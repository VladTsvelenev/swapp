
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .boot.text:

0000000002000000 <_head64>:

.text
.globl _head64
_head64:
    # Disable interrupts.
    cli
 2000000:	fa                   	cli

    # Save Loader_block pointer from Bootloader.c in r12
    movq %rcx, %r12
 2000001:	49 89 cc             	mov    %rcx,%r12

    # Build an early boot pml4 at pml4phys (physical = virtual for it)

    # Initialize the page tables.
    leaq pml4(%rip), %rdi
 2000004:	48 8d 3d f5 0f 00 00 	lea    0xff5(%rip),%rdi        # 2001000 <pml4phys>
    xorl %eax, %eax
 200000b:	31 c0                	xor    %eax,%eax
    movl $PML_SIZE, %ecx  # moving these many words to the 11 pages
 200000d:	b9 00 16 00 00       	mov    $0x1600,%ecx
    rep stosq
 2000012:	f3 48 ab             	rep stos %rax,%es:(%rdi)

    # Creating a 4G boot page table...

    # Setting the 4-level page table with only the second entry needed (PML4)
    leaq pml4(%rip), %rdi
 2000015:	48 8d 3d e4 0f 00 00 	lea    0xfe4(%rip),%rdi        # 2001000 <pml4phys>
    leaq (pdpt1 + (PTE_P | PTE_W))(%rip), %rax
 200001c:	48 8d 05 e0 1f 00 00 	lea    0x1fe0(%rip),%rax        # 2002003 <pdpt1+0x3>
    stosq
 2000023:	48 ab                	stos   %rax,%es:(%rdi)
    movq %rax, (%rdi)
 2000025:	48 89 07             	mov    %rax,(%rdi)
    leaq (pdpt2 + (PTE_P | PTE_W))(%rip), %rax
 2000028:	48 8d 05 d4 2f 00 00 	lea    0x2fd4(%rip),%rax        # 2003003 <pdpt2+0x3>
    stosq
 200002f:	48 ab                	stos   %rax,%es:(%rdi)

    # Setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xA0000--0xD000
    leaq pdpt1(%rip), %rdi
 2000031:	48 8d 3d c8 1f 00 00 	lea    0x1fc8(%rip),%rdi        # 2002000 <pdpt1>
    leaq (pde1 + (PTE_P | PTE_W))(%rip), %rax
 2000038:	48 8d 05 c4 3f 00 00 	lea    0x3fc4(%rip),%rax        # 2004003 <pde1+0x3>
    stosq
 200003f:	48 ab                	stos   %rax,%es:(%rdi)

    leaq (pdpt2 + 8)(%rip), %rdi
 2000041:	48 8d 3d c0 2f 00 00 	lea    0x2fc0(%rip),%rdi        # 2003008 <pdpt2+0x8>
    leaq (pde2 + (PTE_P | PTE_W))(%rip), %rax
 2000048:	48 8d 05 b4 4f 00 00 	lea    0x4fb4(%rip),%rax        # 2005003 <pde2+0x3>
    stosq
 200004f:	48 ab                	stos   %rax,%es:(%rdi)

    # Setting the pgdir so that the LA=PA
    # Mapping first 1024mb of mem at KERN_BASE_ADDR
    movq $-PDP_ENTRY_COUNT, %rcx
 2000051:	48 c7 c1 00 fe ff ff 	mov    $0xfffffffffffffe00,%rcx
    leaq pde1(%rip), %rdi
 2000058:	48 8d 3d a1 3f 00 00 	lea    0x3fa1(%rip),%rdi        # 2004000 <pde1>
    leaq pde2(%rip), %rsi
 200005f:	48 8d 35 9a 4f 00 00 	lea    0x4f9a(%rip),%rsi        # 2005000 <pde2>
    movl $(PTE_P|PTE_W|PTE_MBZ), %eax
 2000066:	b8 83 01 00 00       	mov    $0x183,%eax
1:
    movq %rax, PAGE_SIZE(%rsi,%rcx,8)
 200006b:	48 89 84 ce 00 10 00 	mov    %rax,0x1000(%rsi,%rcx,8)
 2000072:	00 
    movq %rax, PAGE_SIZE(%rdi,%rcx,8)
 2000073:	48 89 84 cf 00 10 00 	mov    %rax,0x1000(%rdi,%rcx,8)
 200007a:	00 
    addq $HUGE_PAGE_SIZE, %rax
 200007b:	48 05 00 00 20 00    	add    $0x200000,%rax
    incq %rcx
 2000081:	48 ff c1             	inc    %rcx
    jnz 1b
 2000084:	75 e5                	jne    200006b <_head64+0x6b>

    # Update CR3 register
    leaq pml4(%rip), %rax
 2000086:	48 8d 05 73 0f 00 00 	lea    0xf73(%rip),%rax        # 2001000 <pml4phys>
    movq %rax, %cr3
 200008d:	0f 22 d8             	mov    %rax,%cr3

    # Transition to high mem entry code and pass LoadParams address
    movabs $entry, %rax
 2000090:	48 b8 00 00 10 42 80 	movabs $0x8042100000,%rax
 2000097:	00 00 00 
    movq %r12, %rcx
 200009a:	4c 89 e1             	mov    %r12,%rcx
    jmpq *%rax
 200009d:	ff e0                	jmp    *%rax

Disassembly of section .text:

0000008042100000 <__text_start>:
.text

.globl entry
entry:
    # Set up kernel stack
    leaq bootstacktop(%rip),%rsp
  8042100000:	48 8d 25 f9 2f 03 00 	lea    0x32ff9(%rip),%rsp        # 8042133000 <bootstacktop>
    xor %ebp, %ebp
  8042100007:	31 ed                	xor    %ebp,%ebp

    # Save LoadParams in uefi_lp.
    movq %rcx, uefi_lp(%rip)
  8042100009:	48 89 0d f0 2f 04 00 	mov    %rcx,0x42ff0(%rip)        # 8042143000 <pfstacktop>

    # Invoke C code
    call i386_init
  8042100010:	e8 6a 04 00 00       	call   804210047f <i386_init>
    # Should never reach this place
    jmp .
  8042100015:	eb fe                	jmp    8042100015 <__text_start+0x15>

0000008042100017 <timers_init>:
#include <kern/kdebug.h>
#include <kern/traceopt.h>
#include <kern/swap.h>

void
timers_init(void) {
  8042100017:	f3 0f 1e fa          	endbr64
  804210001b:	55                   	push   %rbp
  804210001c:	48 89 e5             	mov    %rsp,%rbp
  804210001f:	41 56                	push   %r14
  8042100021:	41 55                	push   %r13
  8042100023:	41 54                	push   %r12
  8042100025:	53                   	push   %rbx
    timertab[0] = timer_rtc;
  8042100026:	48 b8 80 75 00 43 80 	movabs $0x8043007580,%rax
  804210002d:	00 00 00 
  8042100030:	48 ba 20 37 14 42 80 	movabs $0x8042143720,%rdx
  8042100037:	00 00 00 
  804210003a:	48 8b 0a             	mov    (%rdx),%rcx
  804210003d:	48 89 08             	mov    %rcx,(%rax)
  8042100040:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8042100044:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8042100048:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  804210004c:	48 89 48 10          	mov    %rcx,0x10(%rax)
  8042100050:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  8042100054:	48 89 48 18          	mov    %rcx,0x18(%rax)
  8042100058:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  804210005c:	48 89 50 20          	mov    %rdx,0x20(%rax)
    timertab[1] = timer_pit;
  8042100060:	48 ba c0 38 14 42 80 	movabs $0x80421438c0,%rdx
  8042100067:	00 00 00 
  804210006a:	48 8b 0a             	mov    (%rdx),%rcx
  804210006d:	48 89 48 28          	mov    %rcx,0x28(%rax)
  8042100071:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8042100075:	48 89 48 30          	mov    %rcx,0x30(%rax)
  8042100079:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  804210007d:	48 89 48 38          	mov    %rcx,0x38(%rax)
  8042100081:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  8042100085:	48 89 48 40          	mov    %rcx,0x40(%rax)
  8042100089:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  804210008d:	48 89 50 48          	mov    %rdx,0x48(%rax)
    timertab[2] = timer_acpipm;
  8042100091:	48 ba e0 37 14 42 80 	movabs $0x80421437e0,%rdx
  8042100098:	00 00 00 
  804210009b:	48 8b 0a             	mov    (%rdx),%rcx
  804210009e:	48 89 48 50          	mov    %rcx,0x50(%rax)
  80421000a2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80421000a6:	48 89 48 58          	mov    %rcx,0x58(%rax)
  80421000aa:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  80421000ae:	48 89 48 60          	mov    %rcx,0x60(%rax)
  80421000b2:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  80421000b6:	48 89 48 68          	mov    %rcx,0x68(%rax)
  80421000ba:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80421000be:	48 89 50 70          	mov    %rdx,0x70(%rax)
    timertab[3] = timer_hpet0;
  80421000c2:	48 ba 60 38 14 42 80 	movabs $0x8042143860,%rdx
  80421000c9:	00 00 00 
  80421000cc:	48 8b 0a             	mov    (%rdx),%rcx
  80421000cf:	48 89 48 78          	mov    %rcx,0x78(%rax)
  80421000d3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80421000d7:	48 89 88 80 00 00 00 	mov    %rcx,0x80(%rax)
  80421000de:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  80421000e2:	48 89 88 88 00 00 00 	mov    %rcx,0x88(%rax)
  80421000e9:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  80421000ed:	48 89 88 90 00 00 00 	mov    %rcx,0x90(%rax)
  80421000f4:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80421000f8:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
    timertab[4] = timer_hpet1;
  80421000ff:	48 ba 20 38 14 42 80 	movabs $0x8042143820,%rdx
  8042100106:	00 00 00 
  8042100109:	48 8b 0a             	mov    (%rdx),%rcx
  804210010c:	48 89 88 a0 00 00 00 	mov    %rcx,0xa0(%rax)
  8042100113:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8042100117:	48 89 88 a8 00 00 00 	mov    %rcx,0xa8(%rax)
  804210011e:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  8042100122:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
  8042100129:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  804210012d:	48 89 88 b8 00 00 00 	mov    %rcx,0xb8(%rax)
  8042100134:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  8042100138:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)

    for (int i = 0; i < MAX_TIMERS; i++) {
  804210013f:	48 89 c3             	mov    %rax,%rbx
  8042100142:	4c 8d a0 c8 00 00 00 	lea    0xc8(%rax),%r12
        if (timertab[i].timer_init) {
            timertab[i].timer_init();
            if (trace_init) cprintf("Initialized timer %s\n", timertab[i].timer_name);
  8042100149:	49 be d0 f3 11 42 80 	movabs $0x804211f3d0,%r14
  8042100150:	00 00 00 
  8042100153:	49 bd 70 cf 10 42 80 	movabs $0x804210cf70,%r13
  804210015a:	00 00 00 
  804210015d:	eb 09                	jmp    8042100168 <timers_init+0x151>
    for (int i = 0; i < MAX_TIMERS; i++) {
  804210015f:	48 83 c3 28          	add    $0x28,%rbx
  8042100163:	4c 39 e3             	cmp    %r12,%rbx
  8042100166:	74 1b                	je     8042100183 <timers_init+0x16c>
        if (timertab[i].timer_init) {
  8042100168:	48 8b 43 08          	mov    0x8(%rbx),%rax
  804210016c:	48 85 c0             	test   %rax,%rax
  804210016f:	74 ee                	je     804210015f <timers_init+0x148>
            timertab[i].timer_init();
  8042100171:	ff d0                	call   *%rax
            if (trace_init) cprintf("Initialized timer %s\n", timertab[i].timer_name);
  8042100173:	48 8b 33             	mov    (%rbx),%rsi
  8042100176:	4c 89 f7             	mov    %r14,%rdi
  8042100179:	b8 00 00 00 00       	mov    $0x0,%eax
  804210017e:	41 ff d5             	call   *%r13
  8042100181:	eb dc                	jmp    804210015f <timers_init+0x148>
        }
    }
}
  8042100183:	5b                   	pop    %rbx
  8042100184:	41 5c                	pop    %r12
  8042100186:	41 5d                	pop    %r13
  8042100188:	41 5e                	pop    %r14
  804210018a:	5d                   	pop    %rbp
  804210018b:	c3                   	ret

000000804210018c <alloc_pd_early_boot>:

    panic("Timer %s does not exist\n", name);
}

pde_t *
alloc_pd_early_boot(void) {
  804210018c:	f3 0f 1e fa          	endbr64
    /* Assume pde1, pde2 is already used */
    extern uintptr_t pdefreestart, pdefreeend;
    static uintptr_t pdefree = (uintptr_t)&pdefreestart;

    if (pdefree >= (uintptr_t)&pdefreeend) return NULL;
  8042100190:	48 a1 08 30 14 42 80 	movabs 0x8042143008,%rax
  8042100197:	00 00 00 
  804210019a:	48 ba 00 c0 00 02 00 	movabs $0x200c000,%rdx
  80421001a1:	00 00 00 
  80421001a4:	48 39 d0             	cmp    %rdx,%rax
  80421001a7:	73 17                	jae    80421001c0 <alloc_pd_early_boot+0x34>

    pde_t *ret = (pde_t *)pdefree;
  80421001a9:	48 89 c2             	mov    %rax,%rdx
    pdefree += PAGE_SIZE;
  80421001ac:	48 05 00 10 00 00    	add    $0x1000,%rax
  80421001b2:	48 a3 08 30 14 42 80 	movabs %rax,0x8042143008
  80421001b9:	00 00 00 
    return ret;
}
  80421001bc:	48 89 d0             	mov    %rdx,%rax
  80421001bf:	c3                   	ret
    if (pdefree >= (uintptr_t)&pdefreeend) return NULL;
  80421001c0:	ba 00 00 00 00       	mov    $0x0,%edx
  80421001c5:	eb f5                	jmp    80421001bc <alloc_pd_early_boot+0x30>

00000080421001c7 <map_addr_early_boot>:

void
map_addr_early_boot(uintptr_t va, uintptr_t pa, size_t sz) {
  80421001c7:	f3 0f 1e fa          	endbr64
  80421001cb:	55                   	push   %rbp
  80421001cc:	48 89 e5             	mov    %rsp,%rbp
  80421001cf:	41 57                	push   %r15
  80421001d1:	41 56                	push   %r14
  80421001d3:	41 55                	push   %r13
  80421001d5:	41 54                	push   %r12
  80421001d7:	53                   	push   %rbx
  80421001d8:	48 83 ec 18          	sub    $0x18,%rsp

    pml4e_t *pml4 = &pml4phys;
    pdpe_t *pdp;
    pde_t *pd;

    uintptr_t vstart = ROUNDDOWN(va, HUGE_PAGE_SIZE);
  80421001dc:	48 89 f8             	mov    %rdi,%rax
  80421001df:	48 25 00 00 e0 ff    	and    $0xffffffffffe00000,%rax
    uintptr_t vend = ROUNDUP(va + sz, HUGE_PAGE_SIZE);
  80421001e5:	4c 8d b4 17 ff ff 1f 	lea    0x1fffff(%rdi,%rdx,1),%r14
  80421001ec:	00 
  80421001ed:	49 81 e6 00 00 e0 ff 	and    $0xffffffffffe00000,%r14
    uintptr_t pstart = ROUNDDOWN(pa, HUGE_PAGE_SIZE);
  80421001f4:	48 81 e6 00 00 e0 ff 	and    $0xffffffffffe00000,%rsi

    pdp = (pdpe_t *)PTE_ADDR(pml4[PML4_INDEX(vstart)]);
  80421001fb:	48 c1 ef 24          	shr    $0x24,%rdi
  80421001ff:	81 e7 f8 0f 00 00    	and    $0xff8,%edi
  8042100205:	48 ba 00 10 00 02 00 	movabs $0x2001000,%rdx
  804210020c:	00 00 00 
  804210020f:	49 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%r15
  8042100216:	ff ff 7f 
  8042100219:	4c 23 3c 3a          	and    (%rdx,%rdi,1),%r15
    for (; vstart < vend; vstart += HUGE_PAGE_SIZE, pstart += HUGE_PAGE_SIZE) {
  804210021d:	4c 39 f0             	cmp    %r14,%rax
  8042100220:	73 6c                	jae    804210028e <map_addr_early_boot+0xc7>
    uintptr_t vstart = ROUNDDOWN(va, HUGE_PAGE_SIZE);
  8042100222:	49 89 c4             	mov    %rax,%r12
  8042100225:	48 29 c6             	sub    %rax,%rsi
  8042100228:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  804210022c:	eb 21                	jmp    804210024f <map_addr_early_boot+0x88>
        pd = (pde_t *)PTE_ADDR(pdp[PDP_INDEX(vstart)]);
        if (!pd) {
            pd = alloc_pd_early_boot();
            pdp[PDP_INDEX(vstart)] = (uintptr_t)pd | PTE_P | PTE_W;
        }
        pd[PD_INDEX(vstart)] = pstart | PTE_P | PTE_W | PTE_PS;
  804210022e:	4c 89 e2             	mov    %r12,%rdx
  8042100231:	48 c1 ea 15          	shr    $0x15,%rdx
  8042100235:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  804210023b:	41 80 cd 83          	or     $0x83,%r13b
  804210023f:	4c 89 2c d0          	mov    %r13,(%rax,%rdx,8)
    for (; vstart < vend; vstart += HUGE_PAGE_SIZE, pstart += HUGE_PAGE_SIZE) {
  8042100243:	49 81 c4 00 00 20 00 	add    $0x200000,%r12
  804210024a:	4d 39 f4             	cmp    %r14,%r12
  804210024d:	73 3f                	jae    804210028e <map_addr_early_boot+0xc7>
  804210024f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042100253:	4e 8d 2c 20          	lea    (%rax,%r12,1),%r13
        pd = (pde_t *)PTE_ADDR(pdp[PDP_INDEX(vstart)]);
  8042100257:	4c 89 e3             	mov    %r12,%rbx
  804210025a:	48 c1 eb 1b          	shr    $0x1b,%rbx
  804210025e:	81 e3 f8 0f 00 00    	and    $0xff8,%ebx
  8042100264:	4c 01 fb             	add    %r15,%rbx
        if (!pd) {
  8042100267:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  804210026e:	ff ff 7f 
  8042100271:	48 23 03             	and    (%rbx),%rax
  8042100274:	75 b8                	jne    804210022e <map_addr_early_boot+0x67>
            pd = alloc_pd_early_boot();
  8042100276:	48 b8 8c 01 10 42 80 	movabs $0x804210018c,%rax
  804210027d:	00 00 00 
  8042100280:	ff d0                	call   *%rax
            pdp[PDP_INDEX(vstart)] = (uintptr_t)pd | PTE_P | PTE_W;
  8042100282:	48 89 c2             	mov    %rax,%rdx
  8042100285:	48 83 ca 03          	or     $0x3,%rdx
  8042100289:	48 89 13             	mov    %rdx,(%rbx)
  804210028c:	eb a0                	jmp    804210022e <map_addr_early_boot+0x67>
    }
}
  804210028e:	48 83 c4 18          	add    $0x18,%rsp
  8042100292:	5b                   	pop    %rbx
  8042100293:	41 5c                	pop    %r12
  8042100295:	41 5d                	pop    %r13
  8042100297:	41 5e                	pop    %r14
  8042100299:	41 5f                	pop    %r15
  804210029b:	5d                   	pop    %rbp
  804210029c:	c3                   	ret

000000804210029d <early_boot_pml4_init>:
extern char end[];

/* Additionally maps pml4 memory so that we dont get memory errors on accessing
 * uefi_lp, MemMap, KASAN functions. */
void
early_boot_pml4_init(void) {
  804210029d:	f3 0f 1e fa          	endbr64
  80421002a1:	55                   	push   %rbp
  80421002a2:	48 89 e5             	mov    %rsp,%rbp
  80421002a5:	41 54                	push   %r12
  80421002a7:	53                   	push   %rbx
    map_addr_early_boot((uintptr_t)uefi_lp, (uintptr_t)uefi_lp, sizeof(LOADER_PARAMS));
  80421002a8:	49 bc 00 30 14 42 80 	movabs $0x8042143000,%r12
  80421002af:	00 00 00 
  80421002b2:	49 8b 3c 24          	mov    (%r12),%rdi
  80421002b6:	ba e8 00 00 00       	mov    $0xe8,%edx
  80421002bb:	48 89 fe             	mov    %rdi,%rsi
  80421002be:	48 bb c7 01 10 42 80 	movabs $0x80421001c7,%rbx
  80421002c5:	00 00 00 
  80421002c8:	ff d3                	call   *%rbx
    map_addr_early_boot((uintptr_t)uefi_lp->MemoryMap, (uintptr_t)uefi_lp->MemoryMap, uefi_lp->MemoryMapSize);
  80421002ca:	49 8b 04 24          	mov    (%r12),%rax
  80421002ce:	48 8b 78 28          	mov    0x28(%rax),%rdi
  80421002d2:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80421002d6:	48 89 fe             	mov    %rdi,%rsi
  80421002d9:	ff d3                	call   *%rbx
#endif

#if LAB <= 6
    map_addr_early_boot(FRAMEBUFFER, uefi_lp->FrameBufferBase, uefi_lp->FrameBufferSize);
#endif
}
  80421002db:	5b                   	pop    %rbx
  80421002dc:	41 5c                	pop    %r12
  80421002de:	5d                   	pop    %rbp
  80421002df:	c3                   	ret

00000080421002e0 <_panic>:
const char *panicstr = NULL;

/* Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor. */
_Noreturn void
_panic(const char *file, int line, const char *fmt, ...) {
  80421002e0:	f3 0f 1e fa          	endbr64
  80421002e4:	55                   	push   %rbp
  80421002e5:	48 89 e5             	mov    %rsp,%rbp
  80421002e8:	41 54                	push   %r12
  80421002ea:	53                   	push   %rbx
  80421002eb:	48 83 ec 50          	sub    $0x50,%rsp
  80421002ef:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  80421002f3:	4c 89 45 e0          	mov    %r8,-0x20(%rbp)
  80421002f7:	4c 89 4d e8          	mov    %r9,-0x18(%rbp)
    va_list ap;

    if (panicstr) goto dead;
  80421002fb:	48 b8 00 00 a0 42 80 	movabs $0x8042a00000,%rax
  8042100302:	00 00 00 
  8042100305:	48 83 38 00          	cmpq   $0x0,(%rax)
  8042100309:	74 13                	je     804210031e <_panic+0x3e>
    cprintf("\n");
    va_end(ap);

dead:
    /* Break into the kernel monitor */
    for (;;) monitor(NULL);
  804210030b:	48 bb 4a 46 10 42 80 	movabs $0x804210464a,%rbx
  8042100312:	00 00 00 
  8042100315:	bf 00 00 00 00       	mov    $0x0,%edi
  804210031a:	ff d3                	call   *%rbx
  804210031c:	eb f7                	jmp    8042100315 <_panic+0x35>
  804210031e:	48 89 d3             	mov    %rdx,%rbx
    panicstr = fmt;
  8042100321:	48 89 d0             	mov    %rdx,%rax
  8042100324:	48 a3 00 00 a0 42 80 	movabs %rax,0x8042a00000
  804210032b:	00 00 00 
    asm volatile("cli; cld");
  804210032e:	fa                   	cli
  804210032f:	fc                   	cld
    va_start(ap, fmt);
  8042100330:	c7 45 a8 18 00 00 00 	movl   $0x18,-0x58(%rbp)
  8042100337:	48 8d 45 10          	lea    0x10(%rbp),%rax
  804210033b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  804210033f:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8042100343:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    cprintf("kernel panic at %s:%d: ", file, line);
  8042100347:	89 f2                	mov    %esi,%edx
  8042100349:	48 89 fe             	mov    %rdi,%rsi
  804210034c:	48 bf e6 f3 11 42 80 	movabs $0x804211f3e6,%rdi
  8042100353:	00 00 00 
  8042100356:	b8 00 00 00 00       	mov    $0x0,%eax
  804210035b:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  8042100362:	00 00 00 
  8042100365:	41 ff d4             	call   *%r12
    vcprintf(fmt, ap);
  8042100368:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  804210036c:	48 89 df             	mov    %rbx,%rdi
  804210036f:	48 b8 38 cf 10 42 80 	movabs $0x804210cf38,%rax
  8042100376:	00 00 00 
  8042100379:	ff d0                	call   *%rax
    cprintf("\n");
  804210037b:	48 bf 8a f4 11 42 80 	movabs $0x804211f48a,%rdi
  8042100382:	00 00 00 
  8042100385:	b8 00 00 00 00       	mov    $0x0,%eax
  804210038a:	41 ff d4             	call   *%r12
    va_end(ap);
  804210038d:	e9 79 ff ff ff       	jmp    804210030b <_panic+0x2b>

0000008042100392 <timers_schedule>:
timers_schedule(const char *name) {
  8042100392:	f3 0f 1e fa          	endbr64
  8042100396:	55                   	push   %rbp
  8042100397:	48 89 e5             	mov    %rsp,%rbp
  804210039a:	41 56                	push   %r14
  804210039c:	41 55                	push   %r13
  804210039e:	41 54                	push   %r12
  80421003a0:	53                   	push   %rbx
  80421003a1:	49 89 fd             	mov    %rdi,%r13
    for (int i = 0; i < MAX_TIMERS; i++) {
  80421003a4:	49 bc 80 75 00 43 80 	movabs $0x8043007580,%r12
  80421003ab:	00 00 00 
  80421003ae:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (timertab[i].timer_name && !strcmp(timertab[i].timer_name, name)) {
  80421003b3:	49 be 90 0b 11 42 80 	movabs $0x8042110b90,%r14
  80421003ba:	00 00 00 
  80421003bd:	eb 3a                	jmp    80421003f9 <timers_schedule+0x67>
                panic("Timer %s does not support interrupts\n", name);
  80421003bf:	4c 89 e9             	mov    %r13,%rcx
  80421003c2:	48 ba 30 04 12 42 80 	movabs $0x8042120430,%rdx
  80421003c9:	00 00 00 
  80421003cc:	be 2c 00 00 00       	mov    $0x2c,%esi
  80421003d1:	48 bf fe f3 11 42 80 	movabs $0x804211f3fe,%rdi
  80421003d8:	00 00 00 
  80421003db:	b8 00 00 00 00       	mov    $0x0,%eax
  80421003e0:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421003e7:	00 00 00 
  80421003ea:	41 ff d0             	call   *%r8
    for (int i = 0; i < MAX_TIMERS; i++) {
  80421003ed:	83 c3 01             	add    $0x1,%ebx
  80421003f0:	49 83 c4 28          	add    $0x28,%r12
  80421003f4:	83 fb 05             	cmp    $0x5,%ebx
  80421003f7:	74 58                	je     8042100451 <timers_schedule+0xbf>
        if (timertab[i].timer_name && !strcmp(timertab[i].timer_name, name)) {
  80421003f9:	49 8b 3c 24          	mov    (%r12),%rdi
  80421003fd:	48 85 ff             	test   %rdi,%rdi
  8042100400:	74 eb                	je     80421003ed <timers_schedule+0x5b>
  8042100402:	4c 89 ee             	mov    %r13,%rsi
  8042100405:	41 ff d6             	call   *%r14
  8042100408:	85 c0                	test   %eax,%eax
  804210040a:	75 e1                	jne    80421003ed <timers_schedule+0x5b>
            if (!timertab[i].enable_interrupts) {
  804210040c:	48 63 c3             	movslq %ebx,%rax
  804210040f:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
  8042100413:	48 b8 80 75 00 43 80 	movabs $0x8043007580,%rax
  804210041a:	00 00 00 
  804210041d:	48 8b 54 d0 18       	mov    0x18(%rax,%rdx,8),%rdx
  8042100422:	48 85 d2             	test   %rdx,%rdx
  8042100425:	74 98                	je     80421003bf <timers_schedule+0x2d>
            timer_for_schedule = &timertab[i];
  8042100427:	48 63 db             	movslq %ebx,%rbx
  804210042a:	48 8d 0c 9b          	lea    (%rbx,%rbx,4),%rcx
  804210042e:	48 b8 80 75 00 43 80 	movabs $0x8043007580,%rax
  8042100435:	00 00 00 
  8042100438:	48 8d 04 c8          	lea    (%rax,%rcx,8),%rax
  804210043c:	48 a3 60 75 00 43 80 	movabs %rax,0x8043007560
  8042100443:	00 00 00 
            timertab[i].enable_interrupts();
  8042100446:	ff d2                	call   *%rdx
}
  8042100448:	5b                   	pop    %rbx
  8042100449:	41 5c                	pop    %r12
  804210044b:	41 5d                	pop    %r13
  804210044d:	41 5e                	pop    %r14
  804210044f:	5d                   	pop    %rbp
  8042100450:	c3                   	ret
    panic("Timer %s does not exist\n", name);
  8042100451:	4c 89 e9             	mov    %r13,%rcx
  8042100454:	48 ba 0a f4 11 42 80 	movabs $0x804211f40a,%rdx
  804210045b:	00 00 00 
  804210045e:	be 35 00 00 00       	mov    $0x35,%esi
  8042100463:	48 bf fe f3 11 42 80 	movabs $0x804211f3fe,%rdi
  804210046a:	00 00 00 
  804210046d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042100472:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042100479:	00 00 00 
  804210047c:	41 ff d0             	call   *%r8

000000804210047f <i386_init>:
i386_init(void) {
  804210047f:	f3 0f 1e fa          	endbr64
  8042100483:	55                   	push   %rbp
  8042100484:	48 89 e5             	mov    %rsp,%rbp
  8042100487:	53                   	push   %rbx
  8042100488:	48 83 ec 08          	sub    $0x8,%rsp
    early_boot_pml4_init();
  804210048c:	48 b8 9d 02 10 42 80 	movabs $0x804210029d,%rax
  8042100493:	00 00 00 
  8042100496:	ff d0                	call   *%rax
    cons_init();
  8042100498:	48 b8 da 0b 10 42 80 	movabs $0x8042100bda,%rax
  804210049f:	00 00 00 
  80421004a2:	ff d0                	call   *%rax
    tsc_calibrate();
  80421004a4:	48 b8 3c 0f 11 42 80 	movabs $0x8042110f3c,%rax
  80421004ab:	00 00 00 
  80421004ae:	ff d0                	call   *%rax
        cprintf("6828 decimal is %o octal!\n", 6828);
  80421004b0:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80421004b5:	48 bf 23 f4 11 42 80 	movabs $0x804211f423,%rdi
  80421004bc:	00 00 00 
  80421004bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80421004c4:	48 bb 70 cf 10 42 80 	movabs $0x804210cf70,%rbx
  80421004cb:	00 00 00 
  80421004ce:	ff d3                	call   *%rbx
        cprintf("END: %p\n", end);
  80421004d0:	48 be 00 80 00 43 80 	movabs $0x8043008000,%rsi
  80421004d7:	00 00 00 
  80421004da:	48 bf 3e f4 11 42 80 	movabs $0x804211f43e,%rdi
  80421004e1:	00 00 00 
  80421004e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80421004e9:	ff d3                	call   *%rbx
    init_memory();
  80421004eb:	48 b8 b6 a1 10 42 80 	movabs $0x804210a1b6,%rax
  80421004f2:	00 00 00 
  80421004f5:	ff d0                	call   *%rax
    pic_init();
  80421004f7:	48 b8 83 cd 10 42 80 	movabs $0x804210cd83,%rax
  80421004fe:	00 00 00 
  8042100501:	ff d0                	call   *%rax
    timers_init();
  8042100503:	48 b8 17 00 10 42 80 	movabs $0x8042100017,%rax
  804210050a:	00 00 00 
  804210050d:	ff d0                	call   *%rax
    fb_init();
  804210050f:	48 b8 ab 0a 10 42 80 	movabs $0x8042100aab,%rax
  8042100516:	00 00 00 
  8042100519:	ff d0                	call   *%rax
    if (trace_init) cprintf("Framebuffer initialised\n");
  804210051b:	48 bf 47 f4 11 42 80 	movabs $0x804211f447,%rdi
  8042100522:	00 00 00 
  8042100525:	b8 00 00 00 00       	mov    $0x0,%eax
  804210052a:	ff d3                	call   *%rbx
    env_init();
  804210052c:	48 b8 26 c3 10 42 80 	movabs $0x804210c326,%rax
  8042100533:	00 00 00 
  8042100536:	ff d0                	call   *%rax
    timers_schedule("hpet0");
  8042100538:	48 bf 60 f4 11 42 80 	movabs $0x804211f460,%rdi
  804210053f:	00 00 00 
  8042100542:	48 b8 92 03 10 42 80 	movabs $0x8042100392,%rax
  8042100549:	00 00 00 
  804210054c:	ff d0                	call   *%rax
    ENV_CREATE(fs_fs, ENV_TYPE_FS);
  804210054e:	48 bf 38 cf 93 42 80 	movabs $0x804293cf38,%rdi
  8042100555:	00 00 00 
  8042100558:	48 be b0 e7 97 42 80 	movabs $0x804297e7b0,%rsi
  804210055f:	00 00 00 
  8042100562:	48 29 fe             	sub    %rdi,%rsi
  8042100565:	ba 03 00 00 00       	mov    $0x3,%edx
  804210056a:	48 bb 5c c5 10 42 80 	movabs $0x804210c55c,%rbx
  8042100571:	00 00 00 
  8042100574:	ff d3                	call   *%rbx
    ENV_CREATE(user_icode, ENV_TYPE_USER);
  8042100576:	48 bf 18 b3 46 42 80 	movabs $0x804246b318,%rdi
  804210057d:	00 00 00 
  8042100580:	48 be 20 fa 48 42 80 	movabs $0x804248fa20,%rsi
  8042100587:	00 00 00 
  804210058a:	48 29 fe             	sub    %rdi,%rsi
  804210058d:	ba 02 00 00 00       	mov    $0x2,%edx
  8042100592:	ff d3                	call   *%rbx
    kbd_intr();
  8042100594:	48 b8 65 0b 10 42 80 	movabs $0x8042100b65,%rax
  804210059b:	00 00 00 
  804210059e:	ff d0                	call   *%rax
    sched_yield();
  80421005a0:	48 b8 a6 f1 10 42 80 	movabs $0x804210f1a6,%rax
  80421005a7:	00 00 00 
  80421005aa:	ff d0                	call   *%rax

00000080421005ac <_warn>:
}

/* Like panic, but don't */
void
_warn(const char *file, int line, const char *fmt, ...) {
  80421005ac:	f3 0f 1e fa          	endbr64
  80421005b0:	55                   	push   %rbp
  80421005b1:	48 89 e5             	mov    %rsp,%rbp
  80421005b4:	41 54                	push   %r12
  80421005b6:	53                   	push   %rbx
  80421005b7:	48 83 ec 50          	sub    $0x50,%rsp
  80421005bb:	48 89 d3             	mov    %rdx,%rbx
  80421005be:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  80421005c2:	4c 89 45 e0          	mov    %r8,-0x20(%rbp)
  80421005c6:	4c 89 4d e8          	mov    %r9,-0x18(%rbp)
    va_list ap;

    va_start(ap, fmt);
  80421005ca:	c7 45 a8 18 00 00 00 	movl   $0x18,-0x58(%rbp)
  80421005d1:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80421005d5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80421005d9:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80421005dd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    cprintf("kernel warning at %s:%d: ", file, line);
  80421005e1:	89 f2                	mov    %esi,%edx
  80421005e3:	48 89 fe             	mov    %rdi,%rsi
  80421005e6:	48 bf 66 f4 11 42 80 	movabs $0x804211f466,%rdi
  80421005ed:	00 00 00 
  80421005f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80421005f5:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  80421005fc:	00 00 00 
  80421005ff:	41 ff d4             	call   *%r12
    vcprintf(fmt, ap);
  8042100602:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8042100606:	48 89 df             	mov    %rbx,%rdi
  8042100609:	48 b8 38 cf 10 42 80 	movabs $0x804210cf38,%rax
  8042100610:	00 00 00 
  8042100613:	ff d0                	call   *%rax
    cprintf("\n");
  8042100615:	48 bf 8a f4 11 42 80 	movabs $0x804211f48a,%rdi
  804210061c:	00 00 00 
  804210061f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042100624:	41 ff d4             	call   *%r12
    va_end(ap);
}
  8042100627:	48 83 c4 50          	add    $0x50,%rsp
  804210062b:	5b                   	pop    %rbx
  804210062c:	41 5c                	pop    %r12
  804210062e:	5d                   	pop    %rbp
  804210062f:	c3                   	ret

0000008042100630 <serial_proc_data>:
    inb(0x84);
    inb(0x84);
}

static int
serial_proc_data(void) {
  8042100630:	f3 0f 1e fa          	endbr64
}

static inline uint8_t __attribute__((always_inline))
inb(int port) {
    uint8_t data;
    asm volatile("inb %w1,%0"
  8042100634:	ba fd 03 00 00       	mov    $0x3fd,%edx
  8042100639:	ec                   	in     (%dx),%al
    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) return -1;
  804210063a:	a8 01                	test   $0x1,%al
  804210063c:	74 0a                	je     8042100648 <serial_proc_data+0x18>
  804210063e:	ba f8 03 00 00       	mov    $0x3f8,%edx
  8042100643:	ec                   	in     (%dx),%al
    return inb(COM1 + COM_RX);
  8042100644:	0f b6 c0             	movzbl %al,%eax
  8042100647:	c3                   	ret
    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) return -1;
  8042100648:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  804210064d:	c3                   	ret

000000804210064e <cons_intr>:
} cons;

/* called by device interrupt routines to feed input characters
 * into the circular console input buffer */
static void
cons_intr(int (*proc)(void)) {
  804210064e:	f3 0f 1e fa          	endbr64
  8042100652:	55                   	push   %rbp
  8042100653:	48 89 e5             	mov    %rsp,%rbp
  8042100656:	41 54                	push   %r12
  8042100658:	53                   	push   %rbx
  8042100659:	49 89 fc             	mov    %rdi,%r12
    int ch;

    while ((ch = (*proc)()) != -1) {
        if (!ch) continue;
        cons.buf[cons.wpos++] = ch;
  804210065c:	48 bb 40 00 a0 42 80 	movabs $0x8042a00040,%rbx
  8042100663:	00 00 00 
    while ((ch = (*proc)()) != -1) {
  8042100666:	eb 22                	jmp    804210068a <cons_intr+0x3c>
        cons.buf[cons.wpos++] = ch;
  8042100668:	8b 8b 04 02 00 00    	mov    0x204(%rbx),%ecx
  804210066e:	8d 51 01             	lea    0x1(%rcx),%edx
  8042100671:	89 c9                	mov    %ecx,%ecx
  8042100673:	88 04 0b             	mov    %al,(%rbx,%rcx,1)
        if (cons.wpos == CONSBUFSIZE) cons.wpos = 0;
  8042100676:	81 fa 00 02 00 00    	cmp    $0x200,%edx
  804210067c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042100681:	0f 44 d0             	cmove  %eax,%edx
  8042100684:	89 93 04 02 00 00    	mov    %edx,0x204(%rbx)
    while ((ch = (*proc)()) != -1) {
  804210068a:	41 ff d4             	call   *%r12
  804210068d:	83 f8 ff             	cmp    $0xffffffff,%eax
  8042100690:	74 06                	je     8042100698 <cons_intr+0x4a>
        if (!ch) continue;
  8042100692:	85 c0                	test   %eax,%eax
  8042100694:	75 d2                	jne    8042100668 <cons_intr+0x1a>
  8042100696:	eb f2                	jmp    804210068a <cons_intr+0x3c>
    }
}
  8042100698:	5b                   	pop    %rbx
  8042100699:	41 5c                	pop    %r12
  804210069b:	5d                   	pop    %rbp
  804210069c:	c3                   	ret

000000804210069d <kbd_proc_data>:
kbd_proc_data(void) {
  804210069d:	f3 0f 1e fa          	endbr64
  80421006a1:	55                   	push   %rbp
  80421006a2:	48 89 e5             	mov    %rsp,%rbp
  80421006a5:	53                   	push   %rbx
  80421006a6:	48 83 ec 08          	sub    $0x8,%rsp
  80421006aa:	ba 64 00 00 00       	mov    $0x64,%edx
  80421006af:	ec                   	in     (%dx),%al
    if (!(inb(KBSTATP) & KBS_DIB)) return -1;
  80421006b0:	a8 01                	test   $0x1,%al
  80421006b2:	0f 84 30 01 00 00    	je     80421007e8 <kbd_proc_data+0x14b>
  80421006b8:	ba 60 00 00 00       	mov    $0x60,%edx
  80421006bd:	ec                   	in     (%dx),%al
  80421006be:	89 c2                	mov    %eax,%edx
  80421006c0:	89 c1                	mov    %eax,%ecx
    if (data == 0xE0) {
  80421006c2:	3c e0                	cmp    $0xe0,%al
  80421006c4:	0f 84 83 00 00 00    	je     804210074d <kbd_proc_data+0xb0>
    } else if (data & 0x80) {
  80421006ca:	84 c0                	test   %al,%al
  80421006cc:	0f 88 95 00 00 00    	js     8042100767 <kbd_proc_data+0xca>
    } else if (shift & E0ESC) {
  80421006d2:	a1 20 00 a0 42 80 00 	movabs 0x8042a00020,%eax
  80421006d9:	00 00 
  80421006db:	a8 40                	test   $0x40,%al
  80421006dd:	74 0f                	je     80421006ee <kbd_proc_data+0x51>
        data |= 0x80;
  80421006df:	83 c9 80             	or     $0xffffff80,%ecx
        shift &= ~E0ESC;
  80421006e2:	83 e0 bf             	and    $0xffffffbf,%eax
  80421006e5:	a3 20 00 a0 42 80 00 	movabs %eax,0x8042a00020
  80421006ec:	00 00 
    shift |= shiftcode[data];
  80421006ee:	0f b6 f1             	movzbl %cl,%esi
  80421006f1:	48 b8 80 18 12 42 80 	movabs $0x8042121880,%rax
  80421006f8:	00 00 00 
  80421006fb:	0f b6 04 30          	movzbl (%rax,%rsi,1),%eax
  80421006ff:	48 ba 20 00 a0 42 80 	movabs $0x8042a00020,%rdx
  8042100706:	00 00 00 
  8042100709:	0b 02                	or     (%rdx),%eax
    shift ^= togglecode[data];
  804210070b:	48 bf 80 17 12 42 80 	movabs $0x8042121780,%rdi
  8042100712:	00 00 00 
  8042100715:	0f b6 34 37          	movzbl (%rdi,%rsi,1),%esi
  8042100719:	31 f0                	xor    %esi,%eax
  804210071b:	89 02                	mov    %eax,(%rdx)
    c = charcode[shift & (CTL | SHIFT)][data];
  804210071d:	89 c6                	mov    %eax,%esi
  804210071f:	83 e6 03             	and    $0x3,%esi
  8042100722:	0f b6 c9             	movzbl %cl,%ecx
  8042100725:	48 ba 60 17 12 42 80 	movabs $0x8042121760,%rdx
  804210072c:	00 00 00 
  804210072f:	48 8b 14 f2          	mov    (%rdx,%rsi,8),%rdx
  8042100733:	0f b6 14 0a          	movzbl (%rdx,%rcx,1),%edx
  8042100737:	0f b6 da             	movzbl %dl,%ebx
    if (shift & CAPSLOCK) {
  804210073a:	a8 08                	test   $0x8,%al
  804210073c:	74 71                	je     80421007af <kbd_proc_data+0x112>
        if ('a' <= c && c <= 'z')
  804210073e:	89 da                	mov    %ebx,%edx
  8042100740:	8d 4b 9f             	lea    -0x61(%rbx),%ecx
  8042100743:	83 f9 19             	cmp    $0x19,%ecx
  8042100746:	77 5b                	ja     80421007a3 <kbd_proc_data+0x106>
            c += 'A' - 'a';
  8042100748:	83 eb 20             	sub    $0x20,%ebx
    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  804210074b:	eb 12                	jmp    804210075f <kbd_proc_data+0xc2>
        shift |= E0ESC;
  804210074d:	48 b8 20 00 a0 42 80 	movabs $0x8042a00020,%rax
  8042100754:	00 00 00 
  8042100757:	83 08 40             	orl    $0x40,(%rax)
        return 0;
  804210075a:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  804210075f:	89 d8                	mov    %ebx,%eax
  8042100761:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8042100765:	c9                   	leave
  8042100766:	c3                   	ret
        data = (shift & E0ESC ? data : data & 0x7F);
  8042100767:	a1 20 00 a0 42 80 00 	movabs 0x8042a00020,%eax
  804210076e:	00 00 
  8042100770:	83 e2 7f             	and    $0x7f,%edx
  8042100773:	a8 40                	test   $0x40,%al
  8042100775:	0f 44 ca             	cmove  %edx,%ecx
        shift &= ~(shiftcode[data] | E0ESC);
  8042100778:	0f b6 c9             	movzbl %cl,%ecx
  804210077b:	48 ba 80 18 12 42 80 	movabs $0x8042121880,%rdx
  8042100782:	00 00 00 
  8042100785:	0f b6 14 0a          	movzbl (%rdx,%rcx,1),%edx
  8042100789:	83 ca 40             	or     $0x40,%edx
  804210078c:	0f b6 d2             	movzbl %dl,%edx
  804210078f:	f7 d2                	not    %edx
  8042100791:	21 d0                	and    %edx,%eax
  8042100793:	a3 20 00 a0 42 80 00 	movabs %eax,0x8042a00020
  804210079a:	00 00 
        return 0;
  804210079c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80421007a1:	eb bc                	jmp    804210075f <kbd_proc_data+0xc2>
        else if ('A' <= c && c <= 'Z')
  80421007a3:	83 ea 41             	sub    $0x41,%edx
            c += 'a' - 'A';
  80421007a6:	8d 4b 20             	lea    0x20(%rbx),%ecx
  80421007a9:	83 fa 1a             	cmp    $0x1a,%edx
  80421007ac:	0f 42 d9             	cmovb  %ecx,%ebx
    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  80421007af:	f7 d0                	not    %eax
  80421007b1:	a8 06                	test   $0x6,%al
  80421007b3:	75 aa                	jne    804210075f <kbd_proc_data+0xc2>
  80421007b5:	81 fb e9 00 00 00    	cmp    $0xe9,%ebx
  80421007bb:	75 a2                	jne    804210075f <kbd_proc_data+0xc2>
        cprintf("Rebooting!\n");
  80421007bd:	48 bf 80 f4 11 42 80 	movabs $0x804211f480,%rdi
  80421007c4:	00 00 00 
  80421007c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80421007cc:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421007d3:	00 00 00 
  80421007d6:	ff d2                	call   *%rdx
                 : "memory", "cc");
}

static inline void __attribute__((always_inline))
outb(int port, uint8_t data) {
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  80421007d8:	b8 03 00 00 00       	mov    $0x3,%eax
  80421007dd:	ba 92 00 00 00       	mov    $0x92,%edx
  80421007e2:	ee                   	out    %al,(%dx)
}
  80421007e3:	e9 77 ff ff ff       	jmp    804210075f <kbd_proc_data+0xc2>
    if (!(inb(KBSTATP) & KBS_DIB)) return -1;
  80421007e8:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80421007ed:	e9 6d ff ff ff       	jmp    804210075f <kbd_proc_data+0xc2>

00000080421007f2 <draw_char>:
draw_char(uint32_t *buffer, uint32_t x, uint32_t y, uint32_t color, uint8_t charcode) {
  80421007f2:	f3 0f 1e fa          	endbr64
  80421007f6:	49 89 f9             	mov    %rdi,%r9
  80421007f9:	41 89 d2             	mov    %edx,%r10d
  80421007fc:	89 cf                	mov    %ecx,%edi
    uint32_t *buf = buffer + uefi_stride * SYMBOL_SIZE * y + SYMBOL_SIZE * x;
  80421007fe:	a1 54 02 a0 42 80 00 	movabs 0x8042a00254,%eax
  8042100805:	00 00 
    char *chr = font8x8_basic[(unsigned)charcode];
  8042100807:	45 0f b6 c0          	movzbl %r8b,%r8d
  804210080b:	48 ba 20 33 14 42 80 	movabs $0x8042143320,%rdx
  8042100812:	00 00 00 
  8042100815:	4a 8d 14 c2          	lea    (%rdx,%r8,8),%rdx
  8042100819:	41 89 c0             	mov    %eax,%r8d
  804210081c:	49 c1 e0 02          	shl    $0x2,%r8
    uint32_t *buf = buffer + uefi_stride * SYMBOL_SIZE * y + SYMBOL_SIZE * x;
  8042100820:	41 0f af c2          	imul   %r10d,%eax
  8042100824:	8d 04 c5 00 00 00 00 	lea    0x0(,%rax,8),%eax
  804210082b:	8d 0c f5 00 00 00 00 	lea    0x0(,%rsi,8),%ecx
  8042100832:	48 01 c8             	add    %rcx,%rax
  8042100835:	49 8d 34 81          	lea    (%r9,%rax,4),%rsi
  8042100839:	4c 8d 4a 08          	lea    0x8(%rdx),%r9
        for (size_t width = 0; width < 8; width++) {
  804210083d:	b9 00 00 00 00       	mov    $0x0,%ecx
            buf[uefi_stride * heigth + width] = color * ((chr[heigth] >> width) & 1);
  8042100842:	0f be 02             	movsbl (%rdx),%eax
  8042100845:	d3 f8                	sar    %cl,%eax
  8042100847:	83 e0 01             	and    $0x1,%eax
  804210084a:	f7 d8                	neg    %eax
  804210084c:	21 f8                	and    %edi,%eax
  804210084e:	89 04 8e             	mov    %eax,(%rsi,%rcx,4)
        for (size_t width = 0; width < 8; width++) {
  8042100851:	48 83 c1 01          	add    $0x1,%rcx
  8042100855:	48 83 f9 08          	cmp    $0x8,%rcx
  8042100859:	75 e7                	jne    8042100842 <draw_char+0x50>
    for (size_t heigth = 0; heigth < 8; heigth++) {
  804210085b:	48 83 c2 01          	add    $0x1,%rdx
  804210085f:	4c 01 c6             	add    %r8,%rsi
  8042100862:	4c 39 ca             	cmp    %r9,%rdx
  8042100865:	75 d6                	jne    804210083d <draw_char+0x4b>
}
  8042100867:	c3                   	ret

0000008042100868 <fb_putc>:
fb_putc(int c) {
  8042100868:	f3 0f 1e fa          	endbr64
    if (!graphics_exists) return;
  804210086c:	48 b8 5c 02 a0 42 80 	movabs $0x8042a0025c,%rax
  8042100873:	00 00 00 
  8042100876:	80 38 00             	cmpb   $0x0,(%rax)
  8042100879:	0f 84 2b 02 00 00    	je     8042100aaa <fb_putc+0x242>
fb_putc(int c) {
  804210087f:	55                   	push   %rbp
  8042100880:	48 89 e5             	mov    %rsp,%rbp
  8042100883:	41 55                	push   %r13
  8042100885:	41 54                	push   %r12
  8042100887:	53                   	push   %rbx
  8042100888:	48 83 ec 08          	sub    $0x8,%rsp
    if (!(c & ~0xFF)) c |= 0x0700;
  804210088c:	89 f8                	mov    %edi,%eax
  804210088e:	80 cc 07             	or     $0x7,%ah
  8042100891:	81 ff 00 01 00 00    	cmp    $0x100,%edi
  8042100897:	0f 42 f8             	cmovb  %eax,%edi
    switch (c & 0xFF) {
  804210089a:	44 0f b6 c7          	movzbl %dil,%r8d
  804210089e:	40 80 ff 0a          	cmp    $0xa,%dil
  80421008a2:	0f 84 04 01 00 00    	je     80421009ac <fb_putc+0x144>
  80421008a8:	41 83 f8 0a          	cmp    $0xa,%r8d
  80421008ac:	7f 42                	jg     80421008f0 <fb_putc+0x88>
  80421008ae:	41 83 f8 08          	cmp    $0x8,%r8d
  80421008b2:	0f 84 95 00 00 00    	je     804210094d <fb_putc+0xe5>
  80421008b8:	41 83 f8 09          	cmp    $0x9,%r8d
  80421008bc:	75 3c                	jne    80421008fa <fb_putc+0x92>
            fb_putc(' ');
  80421008be:	bf 20 00 00 00       	mov    $0x20,%edi
  80421008c3:	48 bb 68 08 10 42 80 	movabs $0x8042100868,%rbx
  80421008ca:	00 00 00 
  80421008cd:	ff d3                	call   *%rbx
  80421008cf:	bf 20 00 00 00       	mov    $0x20,%edi
  80421008d4:	ff d3                	call   *%rbx
  80421008d6:	bf 20 00 00 00       	mov    $0x20,%edi
  80421008db:	ff d3                	call   *%rbx
  80421008dd:	bf 20 00 00 00       	mov    $0x20,%edi
  80421008e2:	ff d3                	call   *%rbx
  80421008e4:	bf 20 00 00 00       	mov    $0x20,%edi
  80421008e9:	ff d3                	call   *%rbx
        for (size_t i = 0; i < TABW; i++)
  80421008eb:	e9 f8 00 00 00       	jmp    80421009e8 <fb_putc+0x180>
    switch (c & 0xFF) {
  80421008f0:	41 83 f8 0d          	cmp    $0xd,%r8d
  80421008f4:	0f 84 c8 00 00 00    	je     80421009c2 <fb_putc+0x15a>
        draw_char(crt_buf, crt_pos % crt_cols, crt_pos / crt_cols, 0xFFFFFFFF, (uint8_t)c);
  80421008fa:	49 bc 4a 02 a0 42 80 	movabs $0x8042a0024a,%r12
  8042100901:	00 00 00 
  8042100904:	41 0f b7 1c 24       	movzwl (%r12),%ebx
  8042100909:	0f b7 d3             	movzwl %bx,%edx
  804210090c:	48 b8 50 02 a0 42 80 	movabs $0x8042a00250,%rax
  8042100913:	00 00 00 
  8042100916:	8b 08                	mov    (%rax),%ecx
  8042100918:	89 d0                	mov    %edx,%eax
  804210091a:	ba 00 00 00 00       	mov    $0x0,%edx
  804210091f:	f7 f1                	div    %ecx
  8042100921:	89 d6                	mov    %edx,%esi
  8042100923:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  8042100928:	89 c2                	mov    %eax,%edx
  804210092a:	48 bf 00 00 e0 1f 80 	movabs $0x801fe00000,%rdi
  8042100931:	00 00 00 
  8042100934:	48 b8 f2 07 10 42 80 	movabs $0x80421007f2,%rax
  804210093b:	00 00 00 
  804210093e:	ff d0                	call   *%rax
        crt_pos++;
  8042100940:	83 c3 01             	add    $0x1,%ebx
  8042100943:	66 41 89 1c 24       	mov    %bx,(%r12)
  8042100948:	e9 9b 00 00 00       	jmp    80421009e8 <fb_putc+0x180>
        if (crt_pos > 0) {
  804210094d:	66 a1 4a 02 a0 42 80 	movabs 0x8042a0024a,%ax
  8042100954:	00 00 00 
  8042100957:	66 85 c0             	test   %ax,%ax
  804210095a:	0f 84 88 00 00 00    	je     80421009e8 <fb_putc+0x180>
            crt_pos--;
  8042100960:	83 e8 01             	sub    $0x1,%eax
  8042100963:	66 a3 4a 02 a0 42 80 	movabs %ax,0x8042a0024a
  804210096a:	00 00 00 
            draw_char(crt_buf, crt_pos % crt_cols, crt_pos / crt_cols, 0x0, 0x8);
  804210096d:	0f b7 d0             	movzwl %ax,%edx
  8042100970:	48 b8 50 02 a0 42 80 	movabs $0x8042a00250,%rax
  8042100977:	00 00 00 
  804210097a:	8b 08                	mov    (%rax),%ecx
  804210097c:	89 d0                	mov    %edx,%eax
  804210097e:	ba 00 00 00 00       	mov    $0x0,%edx
  8042100983:	f7 f1                	div    %ecx
  8042100985:	89 d6                	mov    %edx,%esi
  8042100987:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804210098d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042100992:	89 c2                	mov    %eax,%edx
  8042100994:	48 bf 00 00 e0 1f 80 	movabs $0x801fe00000,%rdi
  804210099b:	00 00 00 
  804210099e:	48 b8 f2 07 10 42 80 	movabs $0x80421007f2,%rax
  80421009a5:	00 00 00 
  80421009a8:	ff d0                	call   *%rax
  80421009aa:	eb 3c                	jmp    80421009e8 <fb_putc+0x180>
        crt_pos += crt_cols;
  80421009ac:	48 ba 4a 02 a0 42 80 	movabs $0x8042a0024a,%rdx
  80421009b3:	00 00 00 
  80421009b6:	a1 50 02 a0 42 80 00 	movabs 0x8042a00250,%eax
  80421009bd:	00 00 
  80421009bf:	66 01 02             	add    %ax,(%rdx)
        crt_pos -= (crt_pos % crt_cols);
  80421009c2:	48 be 4a 02 a0 42 80 	movabs $0x8042a0024a,%rsi
  80421009c9:	00 00 00 
  80421009cc:	0f b7 0e             	movzwl (%rsi),%ecx
  80421009cf:	0f b7 c1             	movzwl %cx,%eax
  80421009d2:	48 bb 50 02 a0 42 80 	movabs $0x8042a00250,%rbx
  80421009d9:	00 00 00 
  80421009dc:	ba 00 00 00 00       	mov    $0x0,%edx
  80421009e1:	f7 33                	divl   (%rbx)
  80421009e3:	29 d1                	sub    %edx,%ecx
  80421009e5:	66 89 0e             	mov    %cx,(%rsi)
    if (crt_pos >= crt_size) {
  80421009e8:	48 b8 4a 02 a0 42 80 	movabs $0x8042a0024a,%rax
  80421009ef:	00 00 00 
  80421009f2:	0f b7 10             	movzwl (%rax),%edx
  80421009f5:	48 b8 4c 02 a0 42 80 	movabs $0x8042a0024c,%rax
  80421009fc:	00 00 00 
  80421009ff:	3b 10                	cmp    (%rax),%edx
  8042100a01:	73 0b                	jae    8042100a0e <fb_putc+0x1a6>
}
  8042100a03:	48 83 c4 08          	add    $0x8,%rsp
  8042100a07:	5b                   	pop    %rbx
  8042100a08:	41 5c                	pop    %r12
  8042100a0a:	41 5d                	pop    %r13
  8042100a0c:	5d                   	pop    %rbp
  8042100a0d:	c3                   	ret
                      uefi_stride * (uefi_vres - SYMBOL_SIZE) * sizeof(uint32_t));
  8042100a0e:	49 bc 54 02 a0 42 80 	movabs $0x8042a00254,%r12
  8042100a15:	00 00 00 
  8042100a18:	41 8b 04 24          	mov    (%r12),%eax
  8042100a1c:	49 bd 58 02 a0 42 80 	movabs $0x8042a00258,%r13
  8042100a23:	00 00 00 
  8042100a26:	41 8b 75 00          	mov    0x0(%r13),%esi
  8042100a2a:	8d 56 f8             	lea    -0x8(%rsi),%edx
  8042100a2d:	0f af d0             	imul   %eax,%edx
        nosan_memmove(crt_buf, crt_buf + uefi_stride * SYMBOL_SIZE,
  8042100a30:	48 c1 e2 02          	shl    $0x2,%rdx
  8042100a34:	8d 04 c5 00 00 00 00 	lea    0x0(,%rax,8),%eax
  8042100a3b:	48 bb 00 00 e0 1f 80 	movabs $0x801fe00000,%rbx
  8042100a42:	00 00 00 
  8042100a45:	48 8d 34 83          	lea    (%rbx,%rax,4),%rsi
  8042100a49:	48 89 df             	mov    %rbx,%rdi
  8042100a4c:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  8042100a53:	00 00 00 
  8042100a56:	ff d0                	call   *%rax
        size_t i = (uefi_vres - (uefi_vres % SYMBOL_SIZE) - SYMBOL_SIZE);
  8042100a58:	41 8b 45 00          	mov    0x0(%r13),%eax
  8042100a5c:	89 c1                	mov    %eax,%ecx
  8042100a5e:	83 e1 f8             	and    $0xfffffff8,%ecx
  8042100a61:	83 e9 08             	sub    $0x8,%ecx
  8042100a64:	89 c9                	mov    %ecx,%ecx
        nosan_memset(crt_buf + i * uefi_stride, 0, uefi_stride * (uefi_vres - i) * sizeof(uint32_t));
  8042100a66:	41 8b 3c 24          	mov    (%r12),%edi
  8042100a6a:	48 c1 e7 02          	shl    $0x2,%rdi
  8042100a6e:	89 c2                	mov    %eax,%edx
  8042100a70:	48 29 ca             	sub    %rcx,%rdx
  8042100a73:	48 0f af d7          	imul   %rdi,%rdx
  8042100a77:	48 0f af f9          	imul   %rcx,%rdi
  8042100a7b:	48 01 df             	add    %rbx,%rdi
  8042100a7e:	be 00 00 00 00       	mov    $0x0,%esi
  8042100a83:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042100a8a:	00 00 00 
  8042100a8d:	ff d0                	call   *%rax
        crt_pos -= crt_cols;
  8042100a8f:	48 ba 4a 02 a0 42 80 	movabs $0x8042a0024a,%rdx
  8042100a96:	00 00 00 
  8042100a99:	a1 50 02 a0 42 80 00 	movabs 0x8042a00250,%eax
  8042100aa0:	00 00 
  8042100aa2:	66 29 02             	sub    %ax,(%rdx)
  8042100aa5:	e9 59 ff ff ff       	jmp    8042100a03 <fb_putc+0x19b>
  8042100aaa:	c3                   	ret

0000008042100aab <fb_init>:
fb_init(void) {
  8042100aab:	f3 0f 1e fa          	endbr64
  8042100aaf:	55                   	push   %rbp
  8042100ab0:	48 89 e5             	mov    %rsp,%rbp
    LOADER_PARAMS *lp = (LOADER_PARAMS *)uefi_lp;
  8042100ab3:	48 b8 00 30 14 42 80 	movabs $0x8042143000,%rax
  8042100aba:	00 00 00 
  8042100abd:	48 8b 30             	mov    (%rax),%rsi
    uefi_vres = lp->VerticalResolution;
  8042100ac0:	8b 56 50             	mov    0x50(%rsi),%edx
  8042100ac3:	89 d0                	mov    %edx,%eax
  8042100ac5:	a3 58 02 a0 42 80 00 	movabs %eax,0x8042a00258
  8042100acc:	00 00 
    uefi_stride = lp->PixelsPerScanLine;
  8042100ace:	8b 46 4c             	mov    0x4c(%rsi),%eax
  8042100ad1:	a3 54 02 a0 42 80 00 	movabs %eax,0x8042a00254
  8042100ad8:	00 00 
    crt_cols = uefi_hres / SYMBOL_SIZE;
  8042100ada:	8b 4e 54             	mov    0x54(%rsi),%ecx
  8042100add:	c1 e9 03             	shr    $0x3,%ecx
  8042100ae0:	89 c8                	mov    %ecx,%eax
  8042100ae2:	a3 50 02 a0 42 80 00 	movabs %eax,0x8042a00250
  8042100ae9:	00 00 
    crt_rows = uefi_vres / SYMBOL_SIZE;
  8042100aeb:	89 d0                	mov    %edx,%eax
  8042100aed:	c1 e8 03             	shr    $0x3,%eax
    crt_size = crt_rows * crt_cols;
  8042100af0:	0f af c1             	imul   %ecx,%eax
  8042100af3:	a3 4c 02 a0 42 80 00 	movabs %eax,0x8042a0024c
  8042100afa:	00 00 
    crt_pos = crt_cols;
  8042100afc:	89 c8                	mov    %ecx,%eax
  8042100afe:	66 a3 4a 02 a0 42 80 	movabs %ax,0x8042a0024a
  8042100b05:	00 00 00 
    memset(crt_buf, 0, lp->FrameBufferSize);
  8042100b08:	8b 56 48             	mov    0x48(%rsi),%edx
  8042100b0b:	be 00 00 00 00       	mov    $0x0,%esi
  8042100b10:	48 bf 00 00 e0 1f 80 	movabs $0x801fe00000,%rdi
  8042100b17:	00 00 00 
  8042100b1a:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042100b21:	00 00 00 
  8042100b24:	ff d0                	call   *%rax
    graphics_exists = true;
  8042100b26:	48 b8 5c 02 a0 42 80 	movabs $0x8042a0025c,%rax
  8042100b2d:	00 00 00 
  8042100b30:	c6 00 01             	movb   $0x1,(%rax)
}
  8042100b33:	5d                   	pop    %rbp
  8042100b34:	c3                   	ret

0000008042100b35 <serial_intr>:
serial_intr(void) {
  8042100b35:	f3 0f 1e fa          	endbr64
    if (serial_exists) cons_intr(serial_proc_data);
  8042100b39:	48 b8 48 02 a0 42 80 	movabs $0x8042a00248,%rax
  8042100b40:	00 00 00 
  8042100b43:	80 38 00             	cmpb   $0x0,(%rax)
  8042100b46:	75 01                	jne    8042100b49 <serial_intr+0x14>
  8042100b48:	c3                   	ret
serial_intr(void) {
  8042100b49:	55                   	push   %rbp
  8042100b4a:	48 89 e5             	mov    %rsp,%rbp
    if (serial_exists) cons_intr(serial_proc_data);
  8042100b4d:	48 bf 30 06 10 42 80 	movabs $0x8042100630,%rdi
  8042100b54:	00 00 00 
  8042100b57:	48 b8 4e 06 10 42 80 	movabs $0x804210064e,%rax
  8042100b5e:	00 00 00 
  8042100b61:	ff d0                	call   *%rax
}
  8042100b63:	5d                   	pop    %rbp
  8042100b64:	c3                   	ret

0000008042100b65 <kbd_intr>:
kbd_intr(void) {
  8042100b65:	f3 0f 1e fa          	endbr64
  8042100b69:	55                   	push   %rbp
  8042100b6a:	48 89 e5             	mov    %rsp,%rbp
    cons_intr(kbd_proc_data);
  8042100b6d:	48 bf 9d 06 10 42 80 	movabs $0x804210069d,%rdi
  8042100b74:	00 00 00 
  8042100b77:	48 b8 4e 06 10 42 80 	movabs $0x804210064e,%rax
  8042100b7e:	00 00 00 
  8042100b81:	ff d0                	call   *%rax
}
  8042100b83:	5d                   	pop    %rbp
  8042100b84:	c3                   	ret

0000008042100b85 <cons_getc>:

/* Return the next input character from the console, or 0 if none waiting */
int
cons_getc(void) {
  8042100b85:	f3 0f 1e fa          	endbr64
  8042100b89:	55                   	push   %rbp
  8042100b8a:	48 89 e5             	mov    %rsp,%rbp

    /* Poll for any pending input characters,
     * so that this function works even when interrupts are disabled
     * (e.g., when called from the kernel monitor) */
    serial_intr();
  8042100b8d:	48 b8 35 0b 10 42 80 	movabs $0x8042100b35,%rax
  8042100b94:	00 00 00 
  8042100b97:	ff d0                	call   *%rax
    kbd_intr();
  8042100b99:	48 b8 65 0b 10 42 80 	movabs $0x8042100b65,%rax
  8042100ba0:	00 00 00 
  8042100ba3:	ff d0                	call   *%rax

    /* Grab the next character from the input buffer */
    if (cons.rpos != cons.wpos) {
  8042100ba5:	48 ba 40 00 a0 42 80 	movabs $0x8042a00040,%rdx
  8042100bac:	00 00 00 
  8042100baf:	8b 82 00 02 00 00    	mov    0x200(%rdx),%eax
        uint8_t ch = cons.buf[cons.rpos++];
        cons.rpos %= CONSBUFSIZE;
        return ch;
    }
    return 0;
  8042100bb5:	b9 00 00 00 00       	mov    $0x0,%ecx
    if (cons.rpos != cons.wpos) {
  8042100bba:	3b 82 04 02 00 00    	cmp    0x204(%rdx),%eax
  8042100bc0:	74 14                	je     8042100bd6 <cons_getc+0x51>
        uint8_t ch = cons.buf[cons.rpos++];
  8042100bc2:	89 c1                	mov    %eax,%ecx
  8042100bc4:	83 c0 01             	add    $0x1,%eax
        cons.rpos %= CONSBUFSIZE;
  8042100bc7:	25 ff 01 00 00       	and    $0x1ff,%eax
  8042100bcc:	89 82 00 02 00 00    	mov    %eax,0x200(%rdx)
        return ch;
  8042100bd2:	0f b6 0c 0a          	movzbl (%rdx,%rcx,1),%ecx
}
  8042100bd6:	89 c8                	mov    %ecx,%eax
  8042100bd8:	5d                   	pop    %rbp
  8042100bd9:	c3                   	ret

0000008042100bda <cons_init>:
    fb_putc(c);
}

/* Initialize the console devices */
void
cons_init(void) {
  8042100bda:	f3 0f 1e fa          	endbr64
  8042100bde:	55                   	push   %rbp
  8042100bdf:	48 89 e5             	mov    %rsp,%rbp
    kbd_intr();
  8042100be2:	48 b8 65 0b 10 42 80 	movabs $0x8042100b65,%rax
  8042100be9:	00 00 00 
  8042100bec:	ff d0                	call   *%rax
    pic_irq_unmask(IRQ_KBD);
  8042100bee:	bf 01 00 00 00       	mov    $0x1,%edi
  8042100bf3:	48 b8 a0 ce 10 42 80 	movabs $0x804210cea0,%rax
  8042100bfa:	00 00 00 
  8042100bfd:	ff d0                	call   *%rax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8042100bff:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042100c04:	bf fa 03 00 00       	mov    $0x3fa,%edi
  8042100c09:	89 c8                	mov    %ecx,%eax
  8042100c0b:	89 fa                	mov    %edi,%edx
  8042100c0d:	ee                   	out    %al,(%dx)
  8042100c0e:	41 b9 fb 03 00 00    	mov    $0x3fb,%r9d
  8042100c14:	b8 80 ff ff ff       	mov    $0xffffff80,%eax
  8042100c19:	44 89 ca             	mov    %r9d,%edx
  8042100c1c:	ee                   	out    %al,(%dx)
  8042100c1d:	be f8 03 00 00       	mov    $0x3f8,%esi
  8042100c22:	b8 0c 00 00 00       	mov    $0xc,%eax
  8042100c27:	89 f2                	mov    %esi,%edx
  8042100c29:	ee                   	out    %al,(%dx)
  8042100c2a:	41 b8 f9 03 00 00    	mov    $0x3f9,%r8d
  8042100c30:	89 c8                	mov    %ecx,%eax
  8042100c32:	44 89 c2             	mov    %r8d,%edx
  8042100c35:	ee                   	out    %al,(%dx)
  8042100c36:	b8 03 00 00 00       	mov    $0x3,%eax
  8042100c3b:	44 89 ca             	mov    %r9d,%edx
  8042100c3e:	ee                   	out    %al,(%dx)
  8042100c3f:	ba fc 03 00 00       	mov    $0x3fc,%edx
  8042100c44:	89 c8                	mov    %ecx,%eax
  8042100c46:	ee                   	out    %al,(%dx)
  8042100c47:	b8 01 00 00 00       	mov    $0x1,%eax
  8042100c4c:	44 89 c2             	mov    %r8d,%edx
  8042100c4f:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  8042100c50:	ba fd 03 00 00       	mov    $0x3fd,%edx
  8042100c55:	ec                   	in     (%dx),%al
  8042100c56:	89 c1                	mov    %eax,%ecx
    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
  8042100c58:	3c ff                	cmp    $0xff,%al
  8042100c5a:	0f 95 c0             	setne  %al
  8042100c5d:	a2 48 02 a0 42 80 00 	movabs %al,0x8042a00248
  8042100c64:	00 00 
  8042100c66:	89 fa                	mov    %edi,%edx
  8042100c68:	ec                   	in     (%dx),%al
  8042100c69:	89 f2                	mov    %esi,%edx
  8042100c6b:	ec                   	in     (%dx),%al
    if (serial_exists) pic_irq_unmask(IRQ_SERIAL);
  8042100c6c:	80 f9 ff             	cmp    $0xff,%cl
  8042100c6f:	75 1d                	jne    8042100c8e <cons_init+0xb4>
    kbd_init();
    serial_init();

    if (!serial_exists)
        cprintf("Serial port does not exist!\n");
  8042100c71:	48 bf 8c f4 11 42 80 	movabs $0x804211f48c,%rdi
  8042100c78:	00 00 00 
  8042100c7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042100c80:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042100c87:	00 00 00 
  8042100c8a:	ff d2                	call   *%rdx
}
  8042100c8c:	eb 20                	jmp    8042100cae <cons_init+0xd4>
    if (serial_exists) pic_irq_unmask(IRQ_SERIAL);
  8042100c8e:	bf 04 00 00 00       	mov    $0x4,%edi
  8042100c93:	48 b8 a0 ce 10 42 80 	movabs $0x804210cea0,%rax
  8042100c9a:	00 00 00 
  8042100c9d:	ff d0                	call   *%rax
    if (!serial_exists)
  8042100c9f:	48 b8 48 02 a0 42 80 	movabs $0x8042a00248,%rax
  8042100ca6:	00 00 00 
  8042100ca9:	80 38 00             	cmpb   $0x0,(%rax)
  8042100cac:	74 c3                	je     8042100c71 <cons_init+0x97>
}
  8042100cae:	5d                   	pop    %rbp
  8042100caf:	c3                   	ret

0000008042100cb0 <cputchar>:

/* `High'-level console I/O.  Used by readline and cprintf. */

void
cputchar(int c) {
  8042100cb0:	f3 0f 1e fa          	endbr64
  8042100cb4:	55                   	push   %rbp
  8042100cb5:	48 89 e5             	mov    %rsp,%rbp
    c &= 0x7F;
  8042100cb8:	83 e7 7f             	and    $0x7f,%edi
  8042100cbb:	41 89 f8             	mov    %edi,%r8d
  8042100cbe:	ba fd 03 00 00       	mov    $0x3fd,%edx
  8042100cc3:	ec                   	in     (%dx),%al
        if (inb(COM1 + COM_LSR) & COM_LSR_TXRDY) break;
  8042100cc4:	a8 20                	test   $0x20,%al
  8042100cc6:	75 22                	jne    8042100cea <cputchar+0x3a>
  8042100cc8:	be 00 32 00 00       	mov    $0x3200,%esi
  8042100ccd:	b9 84 00 00 00       	mov    $0x84,%ecx
  8042100cd2:	bf fd 03 00 00       	mov    $0x3fd,%edi
  8042100cd7:	89 ca                	mov    %ecx,%edx
  8042100cd9:	ec                   	in     (%dx),%al
  8042100cda:	ec                   	in     (%dx),%al
  8042100cdb:	ec                   	in     (%dx),%al
  8042100cdc:	ec                   	in     (%dx),%al
    for (size_t i = 0; i < 12800; i++) {
  8042100cdd:	48 83 ee 01          	sub    $0x1,%rsi
  8042100ce1:	74 07                	je     8042100cea <cputchar+0x3a>
  8042100ce3:	89 fa                	mov    %edi,%edx
  8042100ce5:	ec                   	in     (%dx),%al
        if (inb(COM1 + COM_LSR) & COM_LSR_TXRDY) break;
  8042100ce6:	a8 20                	test   $0x20,%al
  8042100ce8:	74 ed                	je     8042100cd7 <cputchar+0x27>
    outb(COM1 + COM_TX, c);
  8042100cea:	45 89 c1             	mov    %r8d,%r9d
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8042100ced:	ba f8 03 00 00       	mov    $0x3f8,%edx
  8042100cf2:	44 89 c0             	mov    %r8d,%eax
  8042100cf5:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  8042100cf6:	ba 79 03 00 00       	mov    $0x379,%edx
  8042100cfb:	ec                   	in     (%dx),%al
        if (inb(0x378 + 1) & 0x80) break;
  8042100cfc:	84 c0                	test   %al,%al
  8042100cfe:	78 22                	js     8042100d22 <cputchar+0x72>
  8042100d00:	be 00 32 00 00       	mov    $0x3200,%esi
  8042100d05:	b9 84 00 00 00       	mov    $0x84,%ecx
  8042100d0a:	bf 79 03 00 00       	mov    $0x379,%edi
  8042100d0f:	89 ca                	mov    %ecx,%edx
  8042100d11:	ec                   	in     (%dx),%al
  8042100d12:	ec                   	in     (%dx),%al
  8042100d13:	ec                   	in     (%dx),%al
  8042100d14:	ec                   	in     (%dx),%al
    for (size_t i = 0; i < 12800; i++) {
  8042100d15:	48 83 ee 01          	sub    $0x1,%rsi
  8042100d19:	74 07                	je     8042100d22 <cputchar+0x72>
  8042100d1b:	89 fa                	mov    %edi,%edx
  8042100d1d:	ec                   	in     (%dx),%al
        if (inb(0x378 + 1) & 0x80) break;
  8042100d1e:	84 c0                	test   %al,%al
  8042100d20:	79 ed                	jns    8042100d0f <cputchar+0x5f>
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8042100d22:	ba 78 03 00 00       	mov    $0x378,%edx
  8042100d27:	44 89 c8             	mov    %r9d,%eax
  8042100d2a:	ee                   	out    %al,(%dx)
  8042100d2b:	ba 7a 03 00 00       	mov    $0x37a,%edx
  8042100d30:	b8 0d 00 00 00       	mov    $0xd,%eax
  8042100d35:	ee                   	out    %al,(%dx)
  8042100d36:	b8 08 00 00 00       	mov    $0x8,%eax
  8042100d3b:	ee                   	out    %al,(%dx)
    fb_putc(c);
  8042100d3c:	44 89 c7             	mov    %r8d,%edi
  8042100d3f:	48 b8 68 08 10 42 80 	movabs $0x8042100868,%rax
  8042100d46:	00 00 00 
  8042100d49:	ff d0                	call   *%rax
    cons_putc(c);
}
  8042100d4b:	5d                   	pop    %rbp
  8042100d4c:	c3                   	ret

0000008042100d4d <getchar>:

int
getchar(void) {
  8042100d4d:	f3 0f 1e fa          	endbr64
  8042100d51:	55                   	push   %rbp
  8042100d52:	48 89 e5             	mov    %rsp,%rbp
  8042100d55:	53                   	push   %rbx
  8042100d56:	48 83 ec 08          	sub    $0x8,%rsp
    int ch;

    while (!(ch = cons_getc()))
  8042100d5a:	48 bb 85 0b 10 42 80 	movabs $0x8042100b85,%rbx
  8042100d61:	00 00 00 
  8042100d64:	ff d3                	call   *%rbx
  8042100d66:	85 c0                	test   %eax,%eax
  8042100d68:	74 fa                	je     8042100d64 <getchar+0x17>
        /* nothing */;

    return ch;
}
  8042100d6a:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8042100d6e:	c9                   	leave
  8042100d6f:	c3                   	ret

0000008042100d70 <iscons>:

int
iscons(int fdnum) {
  8042100d70:	f3 0f 1e fa          	endbr64
    /* Used by readline */

    return 1;
}
  8042100d74:	b8 01 00 00 00       	mov    $0x1,%eax
  8042100d79:	c3                   	ret

0000008042100d7a <dwarf_read_abbrev_entry>:
    return -E_BAD_DWARF;
}

/* Read value from .debug_abbrev table in buf. Returns number of bytes read */
static int
dwarf_read_abbrev_entry(const void *entry, unsigned form, void *buf, int bufsize, size_t address_size) {
  8042100d7a:	f3 0f 1e fa          	endbr64
  8042100d7e:	55                   	push   %rbp
  8042100d7f:	48 89 e5             	mov    %rsp,%rbp
  8042100d82:	41 56                	push   %r14
  8042100d84:	41 55                	push   %r13
  8042100d86:	41 54                	push   %r12
  8042100d88:	53                   	push   %rbx
  8042100d89:	48 83 ec 30          	sub    $0x30,%rsp
  8042100d8d:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    int bytes = 0;
    switch (form) {
  8042100d91:	83 fe 20             	cmp    $0x20,%esi
  8042100d94:	0f 87 5d 0a 00 00    	ja     80421017f7 <dwarf_read_abbrev_entry+0xa7d>
  8042100d9a:	49 89 d4             	mov    %rdx,%r12
  8042100d9d:	41 89 cd             	mov    %ecx,%r13d
  8042100da0:	4c 89 c3             	mov    %r8,%rbx
  8042100da3:	89 f6                	mov    %esi,%esi
  8042100da5:	48 b8 80 19 12 42 80 	movabs $0x8042121980,%rax
  8042100dac:	00 00 00 
  8042100daf:	3e ff 24 f0          	notrack jmp *(%rax,%rsi,8)
    case DW_FORM_addr: {
        uintptr_t data = 0;
  8042100db3:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8042100dba:	00 
        memcpy(&data, entry, address_size);
  8042100dbb:	4c 89 c2             	mov    %r8,%rdx
  8042100dbe:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042100dc2:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042100dc6:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100dcd:	00 00 00 
  8042100dd0:	ff d0                	call   *%rax
        entry += address_size;
  8042100dd2:	48 01 5d b8          	add    %rbx,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uintptr_t))
  8042100dd6:	4d 85 e4             	test   %r12,%r12
  8042100dd9:	74 06                	je     8042100de1 <dwarf_read_abbrev_entry+0x67>
  8042100ddb:	41 83 fd 07          	cmp    $0x7,%r13d
  8042100ddf:	77 07                	ja     8042100de8 <dwarf_read_abbrev_entry+0x6e>
            put_unaligned(data, (uintptr_t *)buf);
        bytes = address_size;
  8042100de1:	89 d8                	mov    %ebx,%eax
    } break;
  8042100de3:	e9 14 0a 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (uintptr_t *)buf);
  8042100de8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042100dec:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8042100df0:	ba 08 00 00 00       	mov    $0x8,%edx
  8042100df5:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8042100df9:	4c 89 e7             	mov    %r12,%rdi
  8042100dfc:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100e03:	00 00 00 
  8042100e06:	ff d0                	call   *%rax
  8042100e08:	eb d7                	jmp    8042100de1 <dwarf_read_abbrev_entry+0x67>
    case DW_FORM_block2: {
        /* Read block of 2-byte length followed by 0 to 65535 contiguous information bytes */
        // LAB 2: Your code here
        uint16_t length = get_unaligned(entry, uint16_t);
  8042100e0a:	ba 02 00 00 00       	mov    $0x2,%edx
  8042100e0f:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042100e13:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042100e17:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100e1e:	00 00 00 
  8042100e21:	ff d0                	call   *%rax
  8042100e23:	0f b7 5d d0          	movzwl -0x30(%rbp),%ebx
        entry += sizeof(uint16_t);
  8042100e27:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042100e2b:	48 83 c0 02          	add    $0x2,%rax
  8042100e2f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        struct Slice slice = {
  8042100e33:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8042100e37:	0f b7 c3             	movzwl %bx,%eax
  8042100e3a:	89 45 d8             	mov    %eax,-0x28(%rbp)
            .mem = entry,
            .len = length,
        };
        if (buf) memcpy(buf, &slice, sizeof(struct Slice));
  8042100e3d:	4d 85 e4             	test   %r12,%r12
  8042100e40:	74 18                	je     8042100e5a <dwarf_read_abbrev_entry+0xe0>
  8042100e42:	ba 10 00 00 00       	mov    $0x10,%edx
  8042100e47:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8042100e4b:	4c 89 e7             	mov    %r12,%rdi
  8042100e4e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100e55:	00 00 00 
  8042100e58:	ff d0                	call   *%rax
        entry += length;
        bytes = sizeof(uint16_t) + length;
  8042100e5a:	0f b7 db             	movzwl %bx,%ebx
  8042100e5d:	8d 43 02             	lea    0x2(%rbx),%eax
    } break;
  8042100e60:	e9 97 09 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    case DW_FORM_block4: {
        uint32_t length = get_unaligned(entry, uint32_t);
  8042100e65:	ba 04 00 00 00       	mov    $0x4,%edx
  8042100e6a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042100e6e:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042100e72:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100e79:	00 00 00 
  8042100e7c:	ff d0                	call   *%rax
  8042100e7e:	8b 5d d0             	mov    -0x30(%rbp),%ebx
        entry += sizeof(uint32_t);
  8042100e81:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042100e85:	48 83 c0 04          	add    $0x4,%rax
  8042100e89:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        struct Slice slice = {
  8042100e8d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8042100e91:	89 5d d8             	mov    %ebx,-0x28(%rbp)
                .mem = entry,
                .len = length,
        };
        if (buf) memcpy(buf, &slice, sizeof(struct Slice));
  8042100e94:	4d 85 e4             	test   %r12,%r12
  8042100e97:	74 18                	je     8042100eb1 <dwarf_read_abbrev_entry+0x137>
  8042100e99:	ba 10 00 00 00       	mov    $0x10,%edx
  8042100e9e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8042100ea2:	4c 89 e7             	mov    %r12,%rdi
  8042100ea5:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100eac:	00 00 00 
  8042100eaf:	ff d0                	call   *%rax
        entry += length;
        bytes = sizeof(uint32_t) + length;
  8042100eb1:	8d 43 04             	lea    0x4(%rbx),%eax
    } break;
  8042100eb4:	e9 43 09 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    case DW_FORM_data2: {
        Dwarf_Half data = get_unaligned(entry, Dwarf_Half);
  8042100eb9:	ba 02 00 00 00       	mov    $0x2,%edx
  8042100ebe:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042100ec2:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042100ec6:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100ecd:	00 00 00 
  8042100ed0:	ff d0                	call   *%rax
        entry += sizeof(Dwarf_Half);
  8042100ed2:	48 83 45 b8 02       	addq   $0x2,-0x48(%rbp)
        if (buf && bufsize >= sizeof(Dwarf_Half))
  8042100ed7:	4d 85 e4             	test   %r12,%r12
  8042100eda:	74 06                	je     8042100ee2 <dwarf_read_abbrev_entry+0x168>
  8042100edc:	41 83 fd 01          	cmp    $0x1,%r13d
  8042100ee0:	77 0a                	ja     8042100eec <dwarf_read_abbrev_entry+0x172>
            put_unaligned(data, (Dwarf_Half *)buf);
        bytes = sizeof(Dwarf_Half);
  8042100ee2:	b8 02 00 00 00       	mov    $0x2,%eax
  8042100ee7:	e9 10 09 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (Dwarf_Half *)buf);
  8042100eec:	ba 02 00 00 00       	mov    $0x2,%edx
  8042100ef1:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8042100ef5:	4c 89 e7             	mov    %r12,%rdi
  8042100ef8:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100eff:	00 00 00 
  8042100f02:	ff d0                	call   *%rax
        bytes = sizeof(Dwarf_Half);
  8042100f04:	b8 02 00 00 00       	mov    $0x2,%eax
            put_unaligned(data, (Dwarf_Half *)buf);
  8042100f09:	e9 ee 08 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_data4: {
        uint32_t data = get_unaligned(entry, uint32_t);
  8042100f0e:	ba 04 00 00 00       	mov    $0x4,%edx
  8042100f13:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042100f17:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042100f1b:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100f22:	00 00 00 
  8042100f25:	ff d0                	call   *%rax
        entry += sizeof(uint32_t);
  8042100f27:	48 83 45 b8 04       	addq   $0x4,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint32_t))
  8042100f2c:	4d 85 e4             	test   %r12,%r12
  8042100f2f:	74 06                	je     8042100f37 <dwarf_read_abbrev_entry+0x1bd>
  8042100f31:	41 83 fd 03          	cmp    $0x3,%r13d
  8042100f35:	77 0a                	ja     8042100f41 <dwarf_read_abbrev_entry+0x1c7>
            put_unaligned(data, (uint32_t *)buf);
        bytes = sizeof(uint32_t);
  8042100f37:	b8 04 00 00 00       	mov    $0x4,%eax
  8042100f3c:	e9 bb 08 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (uint32_t *)buf);
  8042100f41:	ba 04 00 00 00       	mov    $0x4,%edx
  8042100f46:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8042100f4a:	4c 89 e7             	mov    %r12,%rdi
  8042100f4d:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100f54:	00 00 00 
  8042100f57:	ff d0                	call   *%rax
        bytes = sizeof(uint32_t);
  8042100f59:	b8 04 00 00 00       	mov    $0x4,%eax
            put_unaligned(data, (uint32_t *)buf);
  8042100f5e:	e9 99 08 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_data8: {
        uint64_t data = get_unaligned(entry, uint64_t);
  8042100f63:	ba 08 00 00 00       	mov    $0x8,%edx
  8042100f68:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042100f6c:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042100f70:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100f77:	00 00 00 
  8042100f7a:	ff d0                	call   *%rax
        entry += sizeof(uint64_t);
  8042100f7c:	48 83 45 b8 08       	addq   $0x8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  8042100f81:	4d 85 e4             	test   %r12,%r12
  8042100f84:	74 06                	je     8042100f8c <dwarf_read_abbrev_entry+0x212>
  8042100f86:	41 83 fd 07          	cmp    $0x7,%r13d
  8042100f8a:	77 0a                	ja     8042100f96 <dwarf_read_abbrev_entry+0x21c>
            put_unaligned(data, (uint64_t *)buf);
        bytes = sizeof(uint64_t);
  8042100f8c:	b8 08 00 00 00       	mov    $0x8,%eax
  8042100f91:	e9 66 08 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (uint64_t *)buf);
  8042100f96:	ba 08 00 00 00       	mov    $0x8,%edx
  8042100f9b:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8042100f9f:	4c 89 e7             	mov    %r12,%rdi
  8042100fa2:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100fa9:	00 00 00 
  8042100fac:	ff d0                	call   *%rax
        bytes = sizeof(uint64_t);
  8042100fae:	b8 08 00 00 00       	mov    $0x8,%eax
            put_unaligned(data, (uint64_t *)buf);
  8042100fb3:	e9 44 08 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_string: {
        if (buf && bufsize >= sizeof(char *))
  8042100fb8:	48 85 d2             	test   %rdx,%rdx
  8042100fbb:	74 05                	je     8042100fc2 <dwarf_read_abbrev_entry+0x248>
  8042100fbd:	83 f9 07             	cmp    $0x7,%ecx
  8042100fc0:	77 18                	ja     8042100fda <dwarf_read_abbrev_entry+0x260>
            memcpy(buf, &entry, sizeof(char *));
        bytes = strlen(entry) + 1;
  8042100fc2:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042100fc6:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  8042100fcd:	00 00 00 
  8042100fd0:	ff d0                	call   *%rax
  8042100fd2:	83 c0 01             	add    $0x1,%eax
    } break;
  8042100fd5:	e9 22 08 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            memcpy(buf, &entry, sizeof(char *));
  8042100fda:	ba 08 00 00 00       	mov    $0x8,%edx
  8042100fdf:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
  8042100fe3:	4c 89 e7             	mov    %r12,%rdi
  8042100fe6:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042100fed:	00 00 00 
  8042100ff0:	ff d0                	call   *%rax
  8042100ff2:	eb ce                	jmp    8042100fc2 <dwarf_read_abbrev_entry+0x248>
    case DW_FORM_block: {
        uint64_t length = 0;
        uint32_t count = dwarf_read_uleb128(entry, &length);
  8042100ff4:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8042100ff8:	4c 89 c2             	mov    %r8,%rdx
/* Decode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C
 * of the DWARF 4 spec. Return the number of bytes read */
static inline uint64_t
dwarf_read_uleb128(const uint8_t *addr, uint64_t *ret) {
    uint64_t result = 0;
    size_t shift = 0, count = 0;
  8042100ffb:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101000:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101005:	41 bd 00 00 00 00    	mov    $0x0,%r13d
    uint8_t byte;

    do {
        byte = *addr++;
  804210100b:	48 83 c2 01          	add    $0x1,%rdx
  804210100f:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042101013:	48 89 fe             	mov    %rdi,%rsi
  8042101016:	83 e6 7f             	and    $0x7f,%esi
  8042101019:	48 d3 e6             	shl    %cl,%rsi
  804210101c:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  804210101f:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101023:	48 89 c6             	mov    %rax,%rsi
  8042101026:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  804210102a:	40 84 ff             	test   %dil,%dil
  804210102d:	79 06                	jns    8042101035 <dwarf_read_abbrev_entry+0x2bb>
  804210102f:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101033:	76 d6                	jbe    804210100b <dwarf_read_abbrev_entry+0x291>

    while (byte & 0x80) {
  8042101035:	40 84 ff             	test   %dil,%dil
  8042101038:	79 12                	jns    804210104c <dwarf_read_abbrev_entry+0x2d2>
        byte = *addr++;
  804210103a:	48 f7 d6             	not    %rsi
  804210103d:	48 01 f2             	add    %rsi,%rdx
  8042101040:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042101044:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042101048:	84 c9                	test   %cl,%cl
  804210104a:	78 f4                	js     8042101040 <dwarf_read_abbrev_entry+0x2c6>
  804210104c:	89 c3                	mov    %eax,%ebx
        entry += count;
  804210104e:	89 c0                	mov    %eax,%eax
  8042101050:	49 01 c0             	add    %rax,%r8
  8042101053:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        struct Slice slice = {
  8042101057:	4c 89 45 d0          	mov    %r8,-0x30(%rbp)
  804210105b:	44 89 6d d8          	mov    %r13d,-0x28(%rbp)
                .mem = entry,
                .len = length,
        };
        if (buf) memcpy(buf, &slice, sizeof(struct Slice));
  804210105f:	4d 85 e4             	test   %r12,%r12
  8042101062:	74 18                	je     804210107c <dwarf_read_abbrev_entry+0x302>
  8042101064:	ba 10 00 00 00       	mov    $0x10,%edx
  8042101069:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  804210106d:	4c 89 e7             	mov    %r12,%rdi
  8042101070:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101077:	00 00 00 
  804210107a:	ff d0                	call   *%rax
        entry += length;
        bytes = count + length;
  804210107c:	42 8d 04 2b          	lea    (%rbx,%r13,1),%eax
    } break;
  8042101080:	e9 77 07 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    case DW_FORM_block1: {
        uint32_t length = get_unaligned(entry, Dwarf_Small);
  8042101085:	ba 01 00 00 00       	mov    $0x1,%edx
  804210108a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804210108e:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042101092:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101099:	00 00 00 
  804210109c:	ff d0                	call   *%rax
  804210109e:	0f b6 5d d0          	movzbl -0x30(%rbp),%ebx
        entry += sizeof(Dwarf_Small);
  80421010a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80421010a6:	48 83 c0 01          	add    $0x1,%rax
  80421010aa:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        struct Slice slice = {
  80421010ae:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80421010b2:	89 5d d8             	mov    %ebx,-0x28(%rbp)
                .mem = entry,
                .len = length,
        };
        if (buf) memcpy(buf, &slice, sizeof(struct Slice));
  80421010b5:	4d 85 e4             	test   %r12,%r12
  80421010b8:	74 18                	je     80421010d2 <dwarf_read_abbrev_entry+0x358>
  80421010ba:	ba 10 00 00 00       	mov    $0x10,%edx
  80421010bf:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80421010c3:	4c 89 e7             	mov    %r12,%rdi
  80421010c6:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421010cd:	00 00 00 
  80421010d0:	ff d0                	call   *%rax
        entry += length;
        bytes = length + sizeof(Dwarf_Small);
  80421010d2:	8d 43 01             	lea    0x1(%rbx),%eax
    } break;
  80421010d5:	e9 22 07 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    case DW_FORM_data1: {
        Dwarf_Small data = get_unaligned(entry, Dwarf_Small);
  80421010da:	ba 01 00 00 00       	mov    $0x1,%edx
  80421010df:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80421010e3:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80421010e7:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421010ee:	00 00 00 
  80421010f1:	ff d0                	call   *%rax
  80421010f3:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
        entry += sizeof(Dwarf_Small);
        if (buf && bufsize >= sizeof(Dwarf_Small)) {
  80421010f7:	4d 85 e4             	test   %r12,%r12
  80421010fa:	0f 84 09 07 00 00    	je     8042101809 <dwarf_read_abbrev_entry+0xa8f>
  8042101100:	45 85 ed             	test   %r13d,%r13d
  8042101103:	0f 84 00 07 00 00    	je     8042101809 <dwarf_read_abbrev_entry+0xa8f>
            put_unaligned(data, (Dwarf_Small *)buf);
  8042101109:	41 88 04 24          	mov    %al,(%r12)
        }
        bytes = sizeof(Dwarf_Small);
  804210110d:	b8 01 00 00 00       	mov    $0x1,%eax
            put_unaligned(data, (Dwarf_Small *)buf);
  8042101112:	e9 e5 06 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_flag: {
        bool data = get_unaligned(entry, Dwarf_Small);
  8042101117:	ba 01 00 00 00       	mov    $0x1,%edx
  804210111c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042101120:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042101124:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210112b:	00 00 00 
  804210112e:	ff d0                	call   *%rax
  8042101130:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
        entry += sizeof(Dwarf_Small);
        if (buf && bufsize >= sizeof(bool)) {
  8042101134:	4d 85 e4             	test   %r12,%r12
  8042101137:	0f 84 d3 06 00 00    	je     8042101810 <dwarf_read_abbrev_entry+0xa96>
  804210113d:	45 85 ed             	test   %r13d,%r13d
  8042101140:	0f 84 ca 06 00 00    	je     8042101810 <dwarf_read_abbrev_entry+0xa96>
        bool data = get_unaligned(entry, Dwarf_Small);
  8042101146:	84 c0                	test   %al,%al
            put_unaligned(data, (bool *)buf);
  8042101148:	41 0f 95 04 24       	setne  (%r12)
        }
        bytes = sizeof(Dwarf_Small);
  804210114d:	b8 01 00 00 00       	mov    $0x1,%eax
            put_unaligned(data, (bool *)buf);
  8042101152:	e9 a5 06 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_sdata: {
        int64_t data = 0;
        uint32_t count = dwarf_read_leb128(entry, &data);
  8042101157:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  804210115b:	4c 89 c0             	mov    %r8,%rax
/* Decode signed LEB128 data. The Algorithm is taken from Appendix C
 * of the DWARF 4 spec. Return the number of bytes read */
static inline uint64_t
dwarf_read_leb128(const char *addr, int64_t *ret) {
    size_t shift = 0, count = 0;
    uint64_t result = 0;
  804210115e:	bf 00 00 00 00       	mov    $0x0,%edi
    size_t shift = 0, count = 0;
  8042101163:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042101168:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint8_t byte;

    do {
        byte = *addr++;
  804210116d:	48 83 c0 01          	add    $0x1,%rax
  8042101171:	0f b6 70 ff          	movzbl -0x1(%rax),%esi
        result |= (byte & 0x7FULL) << shift;
  8042101175:	48 89 f2             	mov    %rsi,%rdx
  8042101178:	83 e2 7f             	and    $0x7f,%edx
  804210117b:	48 d3 e2             	shl    %cl,%rdx
  804210117e:	48 09 d7             	or     %rdx,%rdi
        shift += 7;
  8042101181:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101185:	48 89 da             	mov    %rbx,%rdx
  8042101188:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  804210118c:	40 84 f6             	test   %sil,%sil
  804210118f:	79 06                	jns    8042101197 <dwarf_read_abbrev_entry+0x41d>
  8042101191:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101195:	76 d6                	jbe    804210116d <dwarf_read_abbrev_entry+0x3f3>

    while (byte & 0x80) {
  8042101197:	40 84 f6             	test   %sil,%sil
  804210119a:	79 2d                	jns    80421011c9 <dwarf_read_abbrev_entry+0x44f>
        byte = *addr++;
  804210119c:	48 f7 d2             	not    %rdx
  804210119f:	48 01 d0             	add    %rdx,%rax
  80421011a2:	0f b6 14 18          	movzbl (%rax,%rbx,1),%edx
        count++;
  80421011a6:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  80421011aa:	84 d2                	test   %dl,%dl
  80421011ac:	78 f4                	js     80421011a2 <dwarf_read_abbrev_entry+0x428>
        entry += count;
  80421011ae:	89 d8                	mov    %ebx,%eax
  80421011b0:	49 01 c0             	add    %rax,%r8
  80421011b3:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(int32_t))
  80421011b7:	4d 85 e4             	test   %r12,%r12
  80421011ba:	74 06                	je     80421011c2 <dwarf_read_abbrev_entry+0x448>
  80421011bc:	41 83 fd 03          	cmp    $0x3,%r13d
  80421011c0:	77 1f                	ja     80421011e1 <dwarf_read_abbrev_entry+0x467>
            put_unaligned(data, (int32_t *)buf);
        bytes = count;
  80421011c2:	89 d8                	mov    %ebx,%eax
    } break;
  80421011c4:	e9 33 06 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    }

    /* The number of bits in a signed integer. */
    if (shift < 8 * sizeof(result) && byte & 0x40)
  80421011c9:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421011cd:	77 df                	ja     80421011ae <dwarf_read_abbrev_entry+0x434>
  80421011cf:	40 f6 c6 40          	test   $0x40,%sil
  80421011d3:	74 d9                	je     80421011ae <dwarf_read_abbrev_entry+0x434>
        result |= (-1U << shift);
  80421011d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80421011da:	d3 e0                	shl    %cl,%eax
  80421011dc:	48 09 c7             	or     %rax,%rdi
  80421011df:	eb cd                	jmp    80421011ae <dwarf_read_abbrev_entry+0x434>
            put_unaligned(data, (int32_t *)buf);
  80421011e1:	89 7d d0             	mov    %edi,-0x30(%rbp)
  80421011e4:	ba 04 00 00 00       	mov    $0x4,%edx
  80421011e9:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80421011ed:	4c 89 e7             	mov    %r12,%rdi
  80421011f0:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421011f7:	00 00 00 
  80421011fa:	ff d0                	call   *%rax
  80421011fc:	eb c4                	jmp    80421011c2 <dwarf_read_abbrev_entry+0x448>
    case DW_FORM_strp: {
        uint64_t length = 0;
        uint32_t count = dwarf_entry_len(entry, &length);
  80421011fe:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042101202:	ba 04 00 00 00       	mov    $0x4,%edx
  8042101207:	4c 89 f6             	mov    %r14,%rsi
  804210120a:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  804210120e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101215:	00 00 00 
  8042101218:	ff d0                	call   *%rax
  804210121a:	8b 55 d0             	mov    -0x30(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  804210121d:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8042101224:	ff ff ff 
  8042101227:	48 01 d0             	add    %rdx,%rax
    uint64_t count = sizeof(uint32_t);
  804210122a:	bb 04 00 00 00       	mov    $0x4,%ebx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  804210122f:	48 83 f8 0f          	cmp    $0xf,%rax
  8042101233:	77 2f                	ja     8042101264 <dwarf_read_abbrev_entry+0x4ea>
        if (initial_len == DW_EXT_DWARF64) {
  8042101235:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804210123a:	48 39 c2             	cmp    %rax,%rdx
  804210123d:	74 3b                	je     804210127a <dwarf_read_abbrev_entry+0x500>
            cprintf("Unknown DWARF extension\n");
  804210123f:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  8042101246:	00 00 00 
  8042101249:	b8 00 00 00 00       	mov    $0x0,%eax
  804210124e:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042101255:	00 00 00 
  8042101258:	ff d2                	call   *%rdx
        uint64_t length = 0;
  804210125a:	ba 00 00 00 00       	mov    $0x0,%edx
            count = 0;
  804210125f:	bb 00 00 00 00       	mov    $0x0,%ebx
        entry += count;
  8042101264:	48 01 5d b8          	add    %rbx,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  8042101268:	4d 85 e4             	test   %r12,%r12
  804210126b:	74 06                	je     8042101273 <dwarf_read_abbrev_entry+0x4f9>
  804210126d:	41 83 fd 07          	cmp    $0x7,%r13d
  8042101271:	77 2b                	ja     804210129e <dwarf_read_abbrev_entry+0x524>
            put_unaligned(length, (uint64_t *)buf);
        bytes = count;
  8042101273:	89 d8                	mov    %ebx,%eax
    } break;
  8042101275:	e9 82 05 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  804210127a:	49 8d 76 20          	lea    0x20(%r14),%rsi
  804210127e:	ba 08 00 00 00       	mov    $0x8,%edx
  8042101283:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042101287:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210128e:	00 00 00 
  8042101291:	ff d0                	call   *%rax
  8042101293:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
            count += sizeof(uint64_t);
  8042101297:	bb 0c 00 00 00       	mov    $0xc,%ebx
  804210129c:	eb c6                	jmp    8042101264 <dwarf_read_abbrev_entry+0x4ea>
            put_unaligned(length, (uint64_t *)buf);
  804210129e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80421012a2:	ba 08 00 00 00       	mov    $0x8,%edx
  80421012a7:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80421012ab:	4c 89 e7             	mov    %r12,%rdi
  80421012ae:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421012b5:	00 00 00 
  80421012b8:	ff d0                	call   *%rax
  80421012ba:	eb b7                	jmp    8042101273 <dwarf_read_abbrev_entry+0x4f9>
    case DW_FORM_udata: {
        uint64_t data = 0;
        uint32_t count = dwarf_read_uleb128(entry, &data);
  80421012bc:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  80421012c0:	4c 89 c0             	mov    %r8,%rax
    size_t shift = 0, count = 0;
  80421012c3:	bb 00 00 00 00       	mov    $0x0,%ebx
  80421012c8:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421012cd:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  80421012d2:	48 83 c0 01          	add    $0x1,%rax
  80421012d6:	0f b6 70 ff          	movzbl -0x1(%rax),%esi
        result |= (byte & 0x7FULL) << shift;
  80421012da:	48 89 f2             	mov    %rsi,%rdx
  80421012dd:	83 e2 7f             	and    $0x7f,%edx
  80421012e0:	48 d3 e2             	shl    %cl,%rdx
  80421012e3:	48 09 d7             	or     %rdx,%rdi
        shift += 7;
  80421012e6:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80421012ea:	48 89 da             	mov    %rbx,%rdx
  80421012ed:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  80421012f1:	40 84 f6             	test   %sil,%sil
  80421012f4:	79 06                	jns    80421012fc <dwarf_read_abbrev_entry+0x582>
  80421012f6:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421012fa:	76 d6                	jbe    80421012d2 <dwarf_read_abbrev_entry+0x558>
    while (byte & 0x80) {
  80421012fc:	40 84 f6             	test   %sil,%sil
  80421012ff:	79 12                	jns    8042101313 <dwarf_read_abbrev_entry+0x599>
        byte = *addr++;
  8042101301:	48 f7 d2             	not    %rdx
  8042101304:	48 01 d0             	add    %rdx,%rax
  8042101307:	0f b6 14 18          	movzbl (%rax,%rbx,1),%edx
        count++;
  804210130b:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  804210130f:	84 d2                	test   %dl,%dl
  8042101311:	78 f4                	js     8042101307 <dwarf_read_abbrev_entry+0x58d>
        entry += count;
  8042101313:	89 d8                	mov    %ebx,%eax
  8042101315:	49 01 c0             	add    %rax,%r8
  8042101318:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint32_t))
  804210131c:	4d 85 e4             	test   %r12,%r12
  804210131f:	74 06                	je     8042101327 <dwarf_read_abbrev_entry+0x5ad>
  8042101321:	41 83 fd 03          	cmp    $0x3,%r13d
  8042101325:	77 07                	ja     804210132e <dwarf_read_abbrev_entry+0x5b4>
            put_unaligned(data, (uint32_t *)buf);
        bytes = count;
  8042101327:	89 d8                	mov    %ebx,%eax
    } break;
  8042101329:	e9 ce 04 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (uint32_t *)buf);
  804210132e:	89 7d d0             	mov    %edi,-0x30(%rbp)
  8042101331:	ba 04 00 00 00       	mov    $0x4,%edx
  8042101336:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  804210133a:	4c 89 e7             	mov    %r12,%rdi
  804210133d:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101344:	00 00 00 
  8042101347:	ff d0                	call   *%rax
  8042101349:	eb dc                	jmp    8042101327 <dwarf_read_abbrev_entry+0x5ad>
    case DW_FORM_ref_addr: {
        uint64_t length = 0;
        uint32_t count = dwarf_entry_len(entry, &length);
  804210134b:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  804210134f:	ba 04 00 00 00       	mov    $0x4,%edx
  8042101354:	4c 89 f6             	mov    %r14,%rsi
  8042101357:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  804210135b:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101362:	00 00 00 
  8042101365:	ff d0                	call   *%rax
  8042101367:	8b 55 d0             	mov    -0x30(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  804210136a:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8042101371:	ff ff ff 
  8042101374:	48 01 d0             	add    %rdx,%rax
    uint64_t count = sizeof(uint32_t);
  8042101377:	bb 04 00 00 00       	mov    $0x4,%ebx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  804210137c:	48 83 f8 0f          	cmp    $0xf,%rax
  8042101380:	77 2f                	ja     80421013b1 <dwarf_read_abbrev_entry+0x637>
        if (initial_len == DW_EXT_DWARF64) {
  8042101382:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042101387:	48 39 c2             	cmp    %rax,%rdx
  804210138a:	74 3b                	je     80421013c7 <dwarf_read_abbrev_entry+0x64d>
            cprintf("Unknown DWARF extension\n");
  804210138c:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  8042101393:	00 00 00 
  8042101396:	b8 00 00 00 00       	mov    $0x0,%eax
  804210139b:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421013a2:	00 00 00 
  80421013a5:	ff d2                	call   *%rdx
        uint64_t length = 0;
  80421013a7:	ba 00 00 00 00       	mov    $0x0,%edx
            count = 0;
  80421013ac:	bb 00 00 00 00       	mov    $0x0,%ebx
        entry += count;
  80421013b1:	48 01 5d b8          	add    %rbx,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  80421013b5:	4d 85 e4             	test   %r12,%r12
  80421013b8:	74 06                	je     80421013c0 <dwarf_read_abbrev_entry+0x646>
  80421013ba:	41 83 fd 07          	cmp    $0x7,%r13d
  80421013be:	77 2b                	ja     80421013eb <dwarf_read_abbrev_entry+0x671>
            put_unaligned(length, (uint64_t *)buf);
        bytes = count;
  80421013c0:	89 d8                	mov    %ebx,%eax
    } break;
  80421013c2:	e9 35 04 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  80421013c7:	49 8d 76 20          	lea    0x20(%r14),%rsi
  80421013cb:	ba 08 00 00 00       	mov    $0x8,%edx
  80421013d0:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80421013d4:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421013db:	00 00 00 
  80421013de:	ff d0                	call   *%rax
  80421013e0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
            count += sizeof(uint64_t);
  80421013e4:	bb 0c 00 00 00       	mov    $0xc,%ebx
  80421013e9:	eb c6                	jmp    80421013b1 <dwarf_read_abbrev_entry+0x637>
            put_unaligned(length, (uint64_t *)buf);
  80421013eb:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80421013ef:	ba 08 00 00 00       	mov    $0x8,%edx
  80421013f4:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80421013f8:	4c 89 e7             	mov    %r12,%rdi
  80421013fb:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101402:	00 00 00 
  8042101405:	ff d0                	call   *%rax
  8042101407:	eb b7                	jmp    80421013c0 <dwarf_read_abbrev_entry+0x646>
    case DW_FORM_ref1: {
        Dwarf_Small data = get_unaligned(entry, Dwarf_Small);
  8042101409:	ba 01 00 00 00       	mov    $0x1,%edx
  804210140e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042101412:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042101416:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210141d:	00 00 00 
  8042101420:	ff d0                	call   *%rax
  8042101422:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
        entry += sizeof(Dwarf_Small);
        if (buf && bufsize >= sizeof(Dwarf_Small))
  8042101426:	4d 85 e4             	test   %r12,%r12
  8042101429:	0f 84 e8 03 00 00    	je     8042101817 <dwarf_read_abbrev_entry+0xa9d>
  804210142f:	45 85 ed             	test   %r13d,%r13d
  8042101432:	0f 84 df 03 00 00    	je     8042101817 <dwarf_read_abbrev_entry+0xa9d>
            put_unaligned(data, (Dwarf_Small *)buf);
  8042101438:	41 88 04 24          	mov    %al,(%r12)
        bytes = sizeof(Dwarf_Small);
  804210143c:	b8 01 00 00 00       	mov    $0x1,%eax
            put_unaligned(data, (Dwarf_Small *)buf);
  8042101441:	e9 b6 03 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_ref2: {
        Dwarf_Half data = get_unaligned(entry, Dwarf_Half);
  8042101446:	ba 02 00 00 00       	mov    $0x2,%edx
  804210144b:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804210144f:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042101453:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210145a:	00 00 00 
  804210145d:	ff d0                	call   *%rax
        entry += sizeof(Dwarf_Half);
  804210145f:	48 83 45 b8 02       	addq   $0x2,-0x48(%rbp)
        if (buf && bufsize >= sizeof(Dwarf_Half))
  8042101464:	4d 85 e4             	test   %r12,%r12
  8042101467:	74 06                	je     804210146f <dwarf_read_abbrev_entry+0x6f5>
  8042101469:	41 83 fd 01          	cmp    $0x1,%r13d
  804210146d:	77 0a                	ja     8042101479 <dwarf_read_abbrev_entry+0x6ff>
            put_unaligned(data, (Dwarf_Half *)buf);
        bytes = sizeof(Dwarf_Half);
  804210146f:	b8 02 00 00 00       	mov    $0x2,%eax
  8042101474:	e9 83 03 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (Dwarf_Half *)buf);
  8042101479:	ba 02 00 00 00       	mov    $0x2,%edx
  804210147e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8042101482:	4c 89 e7             	mov    %r12,%rdi
  8042101485:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210148c:	00 00 00 
  804210148f:	ff d0                	call   *%rax
        bytes = sizeof(Dwarf_Half);
  8042101491:	b8 02 00 00 00       	mov    $0x2,%eax
            put_unaligned(data, (Dwarf_Half *)buf);
  8042101496:	e9 61 03 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_ref4: {
        uint32_t data = get_unaligned(entry, uint32_t);
  804210149b:	ba 04 00 00 00       	mov    $0x4,%edx
  80421014a0:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80421014a4:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80421014a8:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421014af:	00 00 00 
  80421014b2:	ff d0                	call   *%rax
        entry += sizeof(uint32_t);
  80421014b4:	48 83 45 b8 04       	addq   $0x4,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint32_t))
  80421014b9:	4d 85 e4             	test   %r12,%r12
  80421014bc:	74 06                	je     80421014c4 <dwarf_read_abbrev_entry+0x74a>
  80421014be:	41 83 fd 03          	cmp    $0x3,%r13d
  80421014c2:	77 0a                	ja     80421014ce <dwarf_read_abbrev_entry+0x754>
            put_unaligned(data, (uint32_t *)buf);
        bytes = sizeof(uint32_t);
  80421014c4:	b8 04 00 00 00       	mov    $0x4,%eax
  80421014c9:	e9 2e 03 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (uint32_t *)buf);
  80421014ce:	ba 04 00 00 00       	mov    $0x4,%edx
  80421014d3:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80421014d7:	4c 89 e7             	mov    %r12,%rdi
  80421014da:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421014e1:	00 00 00 
  80421014e4:	ff d0                	call   *%rax
        bytes = sizeof(uint32_t);
  80421014e6:	b8 04 00 00 00       	mov    $0x4,%eax
            put_unaligned(data, (uint32_t *)buf);
  80421014eb:	e9 0c 03 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_ref8: {
        uint64_t data = get_unaligned(entry, uint64_t);
  80421014f0:	ba 08 00 00 00       	mov    $0x8,%edx
  80421014f5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80421014f9:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80421014fd:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101504:	00 00 00 
  8042101507:	ff d0                	call   *%rax
        entry += sizeof(uint64_t);
  8042101509:	48 83 45 b8 08       	addq   $0x8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  804210150e:	4d 85 e4             	test   %r12,%r12
  8042101511:	74 06                	je     8042101519 <dwarf_read_abbrev_entry+0x79f>
  8042101513:	41 83 fd 07          	cmp    $0x7,%r13d
  8042101517:	77 0a                	ja     8042101523 <dwarf_read_abbrev_entry+0x7a9>
            put_unaligned(data, (uint64_t *)buf);
        bytes = sizeof(uint64_t);
  8042101519:	b8 08 00 00 00       	mov    $0x8,%eax
  804210151e:	e9 d9 02 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (uint64_t *)buf);
  8042101523:	ba 08 00 00 00       	mov    $0x8,%edx
  8042101528:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  804210152c:	4c 89 e7             	mov    %r12,%rdi
  804210152f:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101536:	00 00 00 
  8042101539:	ff d0                	call   *%rax
        bytes = sizeof(uint64_t);
  804210153b:	b8 08 00 00 00       	mov    $0x8,%eax
            put_unaligned(data, (uint64_t *)buf);
  8042101540:	e9 b7 02 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    } break;
    case DW_FORM_ref_udata: {
        uint64_t data = 0;
        uint32_t count = dwarf_read_uleb128(entry, &data);
  8042101545:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8042101549:	4c 89 c0             	mov    %r8,%rax
    size_t shift = 0, count = 0;
  804210154c:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042101551:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101556:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  804210155b:	48 83 c0 01          	add    $0x1,%rax
  804210155f:	0f b6 70 ff          	movzbl -0x1(%rax),%esi
        result |= (byte & 0x7FULL) << shift;
  8042101563:	48 89 f2             	mov    %rsi,%rdx
  8042101566:	83 e2 7f             	and    $0x7f,%edx
  8042101569:	48 d3 e2             	shl    %cl,%rdx
  804210156c:	48 09 d7             	or     %rdx,%rdi
        shift += 7;
  804210156f:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101573:	48 89 da             	mov    %rbx,%rdx
  8042101576:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  804210157a:	40 84 f6             	test   %sil,%sil
  804210157d:	79 06                	jns    8042101585 <dwarf_read_abbrev_entry+0x80b>
  804210157f:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101583:	76 d6                	jbe    804210155b <dwarf_read_abbrev_entry+0x7e1>
    while (byte & 0x80) {
  8042101585:	40 84 f6             	test   %sil,%sil
  8042101588:	79 12                	jns    804210159c <dwarf_read_abbrev_entry+0x822>
        byte = *addr++;
  804210158a:	48 f7 d2             	not    %rdx
  804210158d:	48 01 d0             	add    %rdx,%rax
  8042101590:	0f b6 14 18          	movzbl (%rax,%rbx,1),%edx
        count++;
  8042101594:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8042101598:	84 d2                	test   %dl,%dl
  804210159a:	78 f4                	js     8042101590 <dwarf_read_abbrev_entry+0x816>
        entry += count;
  804210159c:	89 d8                	mov    %ebx,%eax
  804210159e:	49 01 c0             	add    %rax,%r8
  80421015a1:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(unsigned int))
  80421015a5:	4d 85 e4             	test   %r12,%r12
  80421015a8:	74 06                	je     80421015b0 <dwarf_read_abbrev_entry+0x836>
  80421015aa:	41 83 fd 03          	cmp    $0x3,%r13d
  80421015ae:	77 07                	ja     80421015b7 <dwarf_read_abbrev_entry+0x83d>
            put_unaligned(data, (unsigned int *)buf);
        bytes = count;
  80421015b0:	89 d8                	mov    %ebx,%eax
    } break;
  80421015b2:	e9 45 02 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (unsigned int *)buf);
  80421015b7:	89 7d d0             	mov    %edi,-0x30(%rbp)
  80421015ba:	ba 04 00 00 00       	mov    $0x4,%edx
  80421015bf:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80421015c3:	4c 89 e7             	mov    %r12,%rdi
  80421015c6:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421015cd:	00 00 00 
  80421015d0:	ff d0                	call   *%rax
  80421015d2:	eb dc                	jmp    80421015b0 <dwarf_read_abbrev_entry+0x836>
    case DW_FORM_indirect: {
        uint64_t form = 0;
        uint32_t count = dwarf_read_uleb128(entry, &form);
  80421015d4:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80421015d8:	48 89 f8             	mov    %rdi,%rax
    size_t shift = 0, count = 0;
  80421015db:	41 be 00 00 00 00    	mov    $0x0,%r14d
  80421015e1:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421015e6:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  80421015eb:	48 83 c0 01          	add    $0x1,%rax
  80421015ef:	44 0f b6 40 ff       	movzbl -0x1(%rax),%r8d
        result |= (byte & 0x7FULL) << shift;
  80421015f4:	4c 89 c2             	mov    %r8,%rdx
  80421015f7:	83 e2 7f             	and    $0x7f,%edx
  80421015fa:	48 d3 e2             	shl    %cl,%rdx
  80421015fd:	48 09 d6             	or     %rdx,%rsi
        shift += 7;
  8042101600:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101604:	4c 89 f2             	mov    %r14,%rdx
  8042101607:	49 83 c6 01          	add    $0x1,%r14
    } while (byte & 0x80 && shift < 64);
  804210160b:	45 84 c0             	test   %r8b,%r8b
  804210160e:	79 06                	jns    8042101616 <dwarf_read_abbrev_entry+0x89c>
  8042101610:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101614:	76 d5                	jbe    80421015eb <dwarf_read_abbrev_entry+0x871>
    while (byte & 0x80) {
  8042101616:	45 84 c0             	test   %r8b,%r8b
  8042101619:	79 13                	jns    804210162e <dwarf_read_abbrev_entry+0x8b4>
        byte = *addr++;
  804210161b:	48 f7 d2             	not    %rdx
  804210161e:	48 01 d0             	add    %rdx,%rax
  8042101621:	42 0f b6 14 30       	movzbl (%rax,%r14,1),%edx
        count++;
  8042101626:	49 83 c6 01          	add    $0x1,%r14
    while (byte & 0x80) {
  804210162a:	84 d2                	test   %dl,%dl
  804210162c:	78 f3                	js     8042101621 <dwarf_read_abbrev_entry+0x8a7>
        entry += count;
  804210162e:	44 89 f0             	mov    %r14d,%eax
  8042101631:	48 01 c7             	add    %rax,%rdi
  8042101634:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
        uint32_t read = dwarf_read_abbrev_entry(entry, form, buf, bufsize, address_size);
  8042101638:	49 89 d8             	mov    %rbx,%r8
  804210163b:	44 89 e9             	mov    %r13d,%ecx
  804210163e:	4c 89 e2             	mov    %r12,%rdx
  8042101641:	48 b8 7a 0d 10 42 80 	movabs $0x8042100d7a,%rax
  8042101648:	00 00 00 
  804210164b:	ff d0                	call   *%rax
        bytes = count + read;
  804210164d:	44 01 f0             	add    %r14d,%eax
    } break;
  8042101650:	e9 a7 01 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    case DW_FORM_sec_offset: {
        uint64_t length = 0;
        uint32_t count = dwarf_entry_len(entry, &length);
  8042101655:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042101659:	ba 04 00 00 00       	mov    $0x4,%edx
  804210165e:	4c 89 f6             	mov    %r14,%rsi
  8042101661:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  8042101665:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210166c:	00 00 00 
  804210166f:	ff d0                	call   *%rax
  8042101671:	8b 55 d0             	mov    -0x30(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042101674:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  804210167b:	ff ff ff 
  804210167e:	48 01 d0             	add    %rdx,%rax
    uint64_t count = sizeof(uint32_t);
  8042101681:	bb 04 00 00 00       	mov    $0x4,%ebx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042101686:	48 83 f8 0f          	cmp    $0xf,%rax
  804210168a:	77 2f                	ja     80421016bb <dwarf_read_abbrev_entry+0x941>
        if (initial_len == DW_EXT_DWARF64) {
  804210168c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042101691:	48 39 c2             	cmp    %rax,%rdx
  8042101694:	74 3b                	je     80421016d1 <dwarf_read_abbrev_entry+0x957>
            cprintf("Unknown DWARF extension\n");
  8042101696:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  804210169d:	00 00 00 
  80421016a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80421016a5:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421016ac:	00 00 00 
  80421016af:	ff d2                	call   *%rdx
        uint64_t length = 0;
  80421016b1:	ba 00 00 00 00       	mov    $0x0,%edx
            count = 0;
  80421016b6:	bb 00 00 00 00       	mov    $0x0,%ebx
        entry += count;
  80421016bb:	48 01 5d b8          	add    %rbx,-0x48(%rbp)
        if (buf && bufsize >= sizeof(unsigned long))
  80421016bf:	4d 85 e4             	test   %r12,%r12
  80421016c2:	74 06                	je     80421016ca <dwarf_read_abbrev_entry+0x950>
  80421016c4:	41 83 fd 07          	cmp    $0x7,%r13d
  80421016c8:	77 2b                	ja     80421016f5 <dwarf_read_abbrev_entry+0x97b>
            put_unaligned(length, (unsigned long *)buf);
        bytes = count;
  80421016ca:	89 d8                	mov    %ebx,%eax
    } break;
  80421016cc:	e9 2b 01 00 00       	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  80421016d1:	49 8d 76 20          	lea    0x20(%r14),%rsi
  80421016d5:	ba 08 00 00 00       	mov    $0x8,%edx
  80421016da:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80421016de:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421016e5:	00 00 00 
  80421016e8:	ff d0                	call   *%rax
  80421016ea:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
            count += sizeof(uint64_t);
  80421016ee:	bb 0c 00 00 00       	mov    $0xc,%ebx
  80421016f3:	eb c6                	jmp    80421016bb <dwarf_read_abbrev_entry+0x941>
            put_unaligned(length, (unsigned long *)buf);
  80421016f5:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80421016f9:	ba 08 00 00 00       	mov    $0x8,%edx
  80421016fe:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8042101702:	4c 89 e7             	mov    %r12,%rdi
  8042101705:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210170c:	00 00 00 
  804210170f:	ff d0                	call   *%rax
  8042101711:	eb b7                	jmp    80421016ca <dwarf_read_abbrev_entry+0x950>
    case DW_FORM_exprloc: {
        uint64_t length = 0;
        uint64_t count = dwarf_read_uleb128(entry, &length);
  8042101713:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042101717:	48 89 f0             	mov    %rsi,%rax
    size_t shift = 0, count = 0;
  804210171a:	bb 00 00 00 00       	mov    $0x0,%ebx
  804210171f:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101724:	41 be 00 00 00 00    	mov    $0x0,%r14d
        byte = *addr++;
  804210172a:	48 83 c0 01          	add    $0x1,%rax
  804210172e:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  8042101732:	48 89 fa             	mov    %rdi,%rdx
  8042101735:	83 e2 7f             	and    $0x7f,%edx
  8042101738:	48 d3 e2             	shl    %cl,%rdx
  804210173b:	49 09 d6             	or     %rdx,%r14
        shift += 7;
  804210173e:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101742:	48 89 da             	mov    %rbx,%rdx
  8042101745:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8042101749:	40 84 ff             	test   %dil,%dil
  804210174c:	79 06                	jns    8042101754 <dwarf_read_abbrev_entry+0x9da>
  804210174e:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101752:	76 d6                	jbe    804210172a <dwarf_read_abbrev_entry+0x9b0>
    while (byte & 0x80) {
  8042101754:	40 84 ff             	test   %dil,%dil
  8042101757:	79 12                	jns    804210176b <dwarf_read_abbrev_entry+0x9f1>
        byte = *addr++;
  8042101759:	48 f7 d2             	not    %rdx
  804210175c:	48 01 d0             	add    %rdx,%rax
  804210175f:	0f b6 14 18          	movzbl (%rax,%rbx,1),%edx
        count++;
  8042101763:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8042101767:	84 d2                	test   %dl,%dl
  8042101769:	78 f4                	js     804210175f <dwarf_read_abbrev_entry+0x9e5>
        entry += count;
  804210176b:	48 01 de             	add    %rbx,%rsi
  804210176e:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
        if (buf) memcpy(buf, entry, MIN(length, bufsize));
  8042101772:	4d 85 e4             	test   %r12,%r12
  8042101775:	74 1c                	je     8042101793 <dwarf_read_abbrev_entry+0xa19>
  8042101777:	4d 63 ed             	movslq %r13d,%r13
  804210177a:	4d 39 f5             	cmp    %r14,%r13
  804210177d:	4c 89 ea             	mov    %r13,%rdx
  8042101780:	49 0f 47 d6          	cmova  %r14,%rdx
  8042101784:	4c 89 e7             	mov    %r12,%rdi
  8042101787:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210178e:	00 00 00 
  8042101791:	ff d0                	call   *%rax
        entry += length;
        bytes = count + length;
  8042101793:	42 8d 04 33          	lea    (%rbx,%r14,1),%eax
    } break;
  8042101797:	eb 63                	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    case DW_FORM_flag_present:
        if (buf && sizeof(buf) >= sizeof(bool)) {
            put_unaligned(true, (bool *)buf);
        }
        bytes = 0;
  8042101799:	b8 00 00 00 00       	mov    $0x0,%eax
        if (buf && sizeof(buf) >= sizeof(bool)) {
  804210179e:	48 85 d2             	test   %rdx,%rdx
  80421017a1:	74 59                	je     80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(true, (bool *)buf);
  80421017a3:	c6 02 01             	movb   $0x1,(%rdx)
  80421017a6:	eb 54                	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
        break;
    case DW_FORM_ref_sig8: {
        uint64_t data = get_unaligned(entry, uint64_t);
  80421017a8:	ba 08 00 00 00       	mov    $0x8,%edx
  80421017ad:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80421017b1:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  80421017b5:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421017bc:	00 00 00 
  80421017bf:	ff d0                	call   *%rax
        entry += sizeof(uint64_t);
  80421017c1:	48 83 45 b8 08       	addq   $0x8,-0x48(%rbp)
        if (buf && bufsize >= sizeof(uint64_t))
  80421017c6:	4d 85 e4             	test   %r12,%r12
  80421017c9:	74 06                	je     80421017d1 <dwarf_read_abbrev_entry+0xa57>
  80421017cb:	41 83 fd 07          	cmp    $0x7,%r13d
  80421017cf:	77 07                	ja     80421017d8 <dwarf_read_abbrev_entry+0xa5e>
            put_unaligned(data, (uint64_t *)buf);
        bytes = sizeof(uint64_t);
  80421017d1:	b8 08 00 00 00       	mov    $0x8,%eax
    } break;
    }
    return bytes;
  80421017d6:	eb 24                	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
            put_unaligned(data, (uint64_t *)buf);
  80421017d8:	ba 08 00 00 00       	mov    $0x8,%edx
  80421017dd:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80421017e1:	4c 89 e7             	mov    %r12,%rdi
  80421017e4:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421017eb:	00 00 00 
  80421017ee:	ff d0                	call   *%rax
        bytes = sizeof(uint64_t);
  80421017f0:	b8 08 00 00 00       	mov    $0x8,%eax
            put_unaligned(data, (uint64_t *)buf);
  80421017f5:	eb 05                	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
    switch (form) {
  80421017f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80421017fc:	48 83 c4 30          	add    $0x30,%rsp
  8042101800:	5b                   	pop    %rbx
  8042101801:	41 5c                	pop    %r12
  8042101803:	41 5d                	pop    %r13
  8042101805:	41 5e                	pop    %r14
  8042101807:	5d                   	pop    %rbp
  8042101808:	c3                   	ret
        bytes = sizeof(Dwarf_Small);
  8042101809:	b8 01 00 00 00       	mov    $0x1,%eax
  804210180e:	eb ec                	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
        bytes = sizeof(Dwarf_Small);
  8042101810:	b8 01 00 00 00       	mov    $0x1,%eax
  8042101815:	eb e5                	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>
        bytes = sizeof(Dwarf_Small);
  8042101817:	b8 01 00 00 00       	mov    $0x1,%eax
  804210181c:	eb de                	jmp    80421017fc <dwarf_read_abbrev_entry+0xa82>

000000804210181e <info_by_address>:
    }
    return -E_NO_ENT;
}

int
info_by_address(const struct Dwarf_Addrs *addrs, uintptr_t addr, Dwarf_Off *store) {
  804210181e:	f3 0f 1e fa          	endbr64
  8042101822:	55                   	push   %rbp
  8042101823:	48 89 e5             	mov    %rsp,%rbp
  8042101826:	41 57                	push   %r15
  8042101828:	41 56                	push   %r14
  804210182a:	41 55                	push   %r13
  804210182c:	41 54                	push   %r12
  804210182e:	53                   	push   %rbx
  804210182f:	48 83 ec 48          	sub    $0x48,%rsp
  8042101833:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8042101837:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  804210183b:	49 89 d4             	mov    %rdx,%r12
    const uint8_t *set = addrs->aranges_begin;
  804210183e:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
    while ((unsigned char *)set < addrs->aranges_end) {
  8042101842:	48 3b 5f 18          	cmp    0x18(%rdi),%rbx
  8042101846:	72 29                	jb     8042101871 <info_by_address+0x53>
    const uint8_t *entry = addrs->info_begin;
  8042101848:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804210184c:	4c 8b 68 20          	mov    0x20(%rax),%r13
    while (entry < addrs->info_end) {
  8042101850:	4c 3b 68 28          	cmp    0x28(%rax),%r13
  8042101854:	0f 83 bd 03 00 00    	jae    8042101c17 <info_by_address+0x3f9>
                entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  804210185a:	49 bf 7a 0d 10 42 80 	movabs $0x8042100d7a,%r15
  8042101861:	00 00 00 
  8042101864:	4c 89 6d b8          	mov    %r13,-0x48(%rbp)
  8042101868:	4c 89 65 98          	mov    %r12,-0x68(%rbp)
  804210186c:	e9 dc 02 00 00       	jmp    8042101b4d <info_by_address+0x32f>
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042101871:	ba 04 00 00 00       	mov    $0x4,%edx
  8042101876:	48 89 de             	mov    %rbx,%rsi
  8042101879:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210187d:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101884:	00 00 00 
  8042101887:	ff d0                	call   *%rax
  8042101889:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  804210188c:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8042101893:	ff ff ff 
  8042101896:	48 01 d0             	add    %rdx,%rax
  8042101899:	48 83 f8 0f          	cmp    $0xf,%rax
  804210189d:	77 a9                	ja     8042101848 <info_by_address+0x2a>
        if (initial_len == DW_EXT_DWARF64) {
  804210189f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80421018a4:	48 39 c2             	cmp    %rax,%rdx
  80421018a7:	74 1d                	je     80421018c6 <info_by_address+0xa8>
            cprintf("Unknown DWARF extension\n");
  80421018a9:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  80421018b0:	00 00 00 
  80421018b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80421018b8:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421018bf:	00 00 00 
  80421018c2:	ff d2                	call   *%rdx
            count = 0;
  80421018c4:	eb 82                	jmp    8042101848 <info_by_address+0x2a>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  80421018c6:	48 8d 73 20          	lea    0x20(%rbx),%rsi
  80421018ca:	ba 08 00 00 00       	mov    $0x8,%edx
  80421018cf:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421018d3:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421018da:	00 00 00 
  80421018dd:	ff d0                	call   *%rax
            count += sizeof(uint64_t);
  80421018df:	e9 64 ff ff ff       	jmp    8042101848 <info_by_address+0x2a>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  80421018e4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80421018e8:	48 8d 70 20          	lea    0x20(%rax),%rsi
  80421018ec:	ba 08 00 00 00       	mov    $0x8,%edx
  80421018f1:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421018f5:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421018fc:	00 00 00 
  80421018ff:	ff d0                	call   *%rax
  8042101901:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            count += sizeof(uint64_t);
  8042101905:	41 bc 0c 00 00 00    	mov    $0xc,%r12d
  804210190b:	e9 14 03 00 00       	jmp    8042101c24 <info_by_address+0x406>
        assert(version == 4 || version == 2);
  8042101910:	48 b9 c2 f4 11 42 80 	movabs $0x804211f4c2,%rcx
  8042101917:	00 00 00 
  804210191a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042101921:	00 00 00 
  8042101924:	be 1e 01 00 00       	mov    $0x11e,%esi
  8042101929:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042101930:	00 00 00 
  8042101933:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101938:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210193f:	00 00 00 
  8042101942:	41 ff d0             	call   *%r8
        assert(address_size == sizeof(uintptr_t));
  8042101945:	48 b9 58 04 12 42 80 	movabs $0x8042120458,%rcx
  804210194c:	00 00 00 
  804210194f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042101956:	00 00 00 
  8042101959:	be 23 01 00 00       	mov    $0x123,%esi
  804210195e:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042101965:	00 00 00 
  8042101968:	b8 00 00 00 00       	mov    $0x0,%eax
  804210196d:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042101974:	00 00 00 
  8042101977:	41 ff d0             	call   *%r8
        assert(abbrev_code);
  804210197a:	48 b9 01 f5 11 42 80 	movabs $0x804211f501,%rcx
  8042101981:	00 00 00 
  8042101984:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210198b:	00 00 00 
  804210198e:	be 28 01 00 00       	mov    $0x128,%esi
  8042101993:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  804210199a:	00 00 00 
  804210199d:	b8 00 00 00 00       	mov    $0x0,%eax
  80421019a2:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421019a9:	00 00 00 
  80421019ac:	41 ff d0             	call   *%r8
        assert(table_abbrev_code == abbrev_code);
  80421019af:	48 b9 80 04 12 42 80 	movabs $0x8042120480,%rcx
  80421019b6:	00 00 00 
  80421019b9:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421019c0:	00 00 00 
  80421019c3:	be 2e 01 00 00       	mov    $0x12e,%esi
  80421019c8:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  80421019cf:	00 00 00 
  80421019d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80421019d7:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421019de:	00 00 00 
  80421019e1:	41 ff d0             	call   *%r8
        assert(tag == DW_TAG_compile_unit);
  80421019e4:	48 b9 0d f5 11 42 80 	movabs $0x804211f50d,%rcx
  80421019eb:	00 00 00 
  80421019ee:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421019f5:	00 00 00 
  80421019f8:	be 31 01 00 00       	mov    $0x131,%esi
  80421019fd:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042101a04:	00 00 00 
  8042101a07:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101a0c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042101a13:	00 00 00 
  8042101a16:	41 ff d0             	call   *%r8
                entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
  8042101a19:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042101a1f:	b9 08 00 00 00       	mov    $0x8,%ecx
  8042101a24:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  8042101a28:	44 89 e6             	mov    %r12d,%esi
  8042101a2b:	4c 89 f7             	mov    %r14,%rdi
  8042101a2e:	41 ff d7             	call   *%r15
  8042101a31:	48 98                	cltq
  8042101a33:	49 01 c6             	add    %rax,%r14
    uint64_t result = 0;
  8042101a36:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8042101a39:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101a3e:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101a43:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8042101a49:	48 83 c2 01          	add    $0x1,%rdx
  8042101a4d:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042101a51:	48 89 fe             	mov    %rdi,%rsi
  8042101a54:	83 e6 7f             	and    $0x7f,%esi
  8042101a57:	48 d3 e6             	shl    %cl,%rsi
  8042101a5a:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8042101a5d:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101a61:	48 89 c6             	mov    %rax,%rsi
  8042101a64:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042101a68:	40 84 ff             	test   %dil,%dil
  8042101a6b:	79 06                	jns    8042101a73 <info_by_address+0x255>
  8042101a6d:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101a71:	76 d6                	jbe    8042101a49 <info_by_address+0x22b>
    while (byte & 0x80) {
  8042101a73:	40 84 ff             	test   %dil,%dil
  8042101a76:	79 12                	jns    8042101a8a <info_by_address+0x26c>
        byte = *addr++;
  8042101a78:	48 f7 d6             	not    %rsi
  8042101a7b:	48 01 f2             	add    %rsi,%rdx
  8042101a7e:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042101a82:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042101a86:	84 c9                	test   %cl,%cl
  8042101a88:	78 f4                	js     8042101a7e <info_by_address+0x260>
            abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8042101a8a:	48 01 d8             	add    %rbx,%rax
  8042101a8d:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8042101a90:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042101a95:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101a9a:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  8042101aa0:	48 83 c2 01          	add    $0x1,%rdx
  8042101aa4:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042101aa8:	48 89 fe             	mov    %rdi,%rsi
  8042101aab:	83 e6 7f             	and    $0x7f,%esi
  8042101aae:	48 d3 e6             	shl    %cl,%rsi
  8042101ab1:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  8042101ab4:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101ab8:	48 89 de             	mov    %rbx,%rsi
  8042101abb:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8042101abf:	40 84 ff             	test   %dil,%dil
  8042101ac2:	79 06                	jns    8042101aca <info_by_address+0x2ac>
  8042101ac4:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101ac8:	76 d6                	jbe    8042101aa0 <info_by_address+0x282>
    while (byte & 0x80) {
  8042101aca:	40 84 ff             	test   %dil,%dil
  8042101acd:	79 12                	jns    8042101ae1 <info_by_address+0x2c3>
        byte = *addr++;
  8042101acf:	48 f7 d6             	not    %rsi
  8042101ad2:	48 01 f2             	add    %rsi,%rdx
  8042101ad5:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8042101ad9:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8042101add:	84 c9                	test   %cl,%cl
  8042101adf:	78 f4                	js     8042101ad5 <info_by_address+0x2b7>
            abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8042101ae1:	48 01 c3             	add    %rax,%rbx
            if (name == DW_AT_low_pc) {
  8042101ae4:	49 83 fd 11          	cmp    $0x11,%r13
  8042101ae8:	0f 84 2b ff ff ff    	je     8042101a19 <info_by_address+0x1fb>
            } else if (name == DW_AT_high_pc) {
  8042101aee:	49 83 fd 12          	cmp    $0x12,%r13
  8042101af2:	0f 84 c6 00 00 00    	je     8042101bbe <info_by_address+0x3a0>
                entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042101af8:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042101afe:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042101b03:	ba 00 00 00 00       	mov    $0x0,%edx
  8042101b08:	44 89 e6             	mov    %r12d,%esi
  8042101b0b:	4c 89 f7             	mov    %r14,%rdi
  8042101b0e:	41 ff d7             	call   *%r15
  8042101b11:	48 98                	cltq
  8042101b13:	49 01 c6             	add    %rax,%r14
        } while (name || form);
  8042101b16:	4d 09 ec             	or     %r13,%r12
  8042101b19:	0f 85 17 ff ff ff    	jne    8042101a36 <info_by_address+0x218>
        if (p >= low_pc && p <= high_pc) {
  8042101b1f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042101b23:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8042101b27:	72 0a                	jb     8042101b33 <info_by_address+0x315>
  8042101b29:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  8042101b2d:	0f 83 bf 00 00 00    	jae    8042101bf2 <info_by_address+0x3d4>
    while (entry < addrs->info_end) {
  8042101b33:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042101b37:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8042101b3b:	48 3b 78 28          	cmp    0x28(%rax),%rdi
  8042101b3f:	0f 83 cb 00 00 00    	jae    8042101c10 <info_by_address+0x3f2>
  8042101b45:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042101b49:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042101b4d:	ba 04 00 00 00       	mov    $0x4,%edx
  8042101b52:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042101b56:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042101b5a:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101b61:	00 00 00 
  8042101b64:	ff d0                	call   *%rax
  8042101b66:	8b 45 c8             	mov    -0x38(%rbp),%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042101b69:	48 bf 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdi
  8042101b70:	ff ff ff 
  8042101b73:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx
  8042101b77:	48 83 fa 0f          	cmp    $0xf,%rdx
  8042101b7b:	0f 87 9d 00 00 00    	ja     8042101c1e <info_by_address+0x400>
        if (initial_len == DW_EXT_DWARF64) {
  8042101b81:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8042101b86:	48 39 d0             	cmp    %rdx,%rax
  8042101b89:	0f 84 55 fd ff ff    	je     80421018e4 <info_by_address+0xc6>
            cprintf("Unknown DWARF extension\n");
  8042101b8f:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  8042101b96:	00 00 00 
  8042101b99:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101b9e:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042101ba5:	00 00 00 
  8042101ba8:	ff d2                	call   *%rdx
        if (!count) return -E_BAD_DWARF;
  8042101baa:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    int res = info_by_address_debug_aranges(addrs, addr, store);
    if (res < 0) res = info_by_address_debug_info(addrs, addr, store);
    return res;
}
  8042101baf:	48 83 c4 48          	add    $0x48,%rsp
  8042101bb3:	5b                   	pop    %rbx
  8042101bb4:	41 5c                	pop    %r12
  8042101bb6:	41 5d                	pop    %r13
  8042101bb8:	41 5e                	pop    %r14
  8042101bba:	41 5f                	pop    %r15
  8042101bbc:	5d                   	pop    %rbp
  8042101bbd:	c3                   	ret
                entry += dwarf_read_abbrev_entry(entry, form, &high_pc, sizeof(high_pc), address_size);
  8042101bbe:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042101bc4:	b9 08 00 00 00       	mov    $0x8,%ecx
  8042101bc9:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  8042101bcd:	44 89 e6             	mov    %r12d,%esi
  8042101bd0:	4c 89 f7             	mov    %r14,%rdi
  8042101bd3:	41 ff d7             	call   *%r15
  8042101bd6:	48 98                	cltq
  8042101bd8:	49 01 c6             	add    %rax,%r14
                if (form != DW_FORM_addr) high_pc += low_pc;
  8042101bdb:	49 83 fc 01          	cmp    $0x1,%r12
  8042101bdf:	0f 84 51 fe ff ff    	je     8042101a36 <info_by_address+0x218>
  8042101be5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042101be9:	48 01 45 c8          	add    %rax,-0x38(%rbp)
  8042101bed:	e9 44 fe ff ff       	jmp    8042101a36 <info_by_address+0x218>
            *store = (const unsigned char *)header - addrs->info_begin;
  8042101bf2:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
  8042101bf6:	4c 8b 65 98          	mov    -0x68(%rbp),%r12
  8042101bfa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042101bfe:	4c 89 ee             	mov    %r13,%rsi
  8042101c01:	48 2b 70 20          	sub    0x20(%rax),%rsi
  8042101c05:	49 89 34 24          	mov    %rsi,(%r12)
            return 0;
  8042101c09:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101c0e:	eb 9f                	jmp    8042101baf <info_by_address+0x391>
    return -E_NO_ENT;
  8042101c10:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8042101c15:	eb 98                	jmp    8042101baf <info_by_address+0x391>
  8042101c17:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    return res;
  8042101c1c:	eb 91                	jmp    8042101baf <info_by_address+0x391>
    uint64_t count = sizeof(uint32_t);
  8042101c1e:	41 bc 04 00 00 00    	mov    $0x4,%r12d
        entry += count = dwarf_entry_len(entry, &len);
  8042101c24:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042101c28:	49 01 fc             	add    %rdi,%r12
        const uint8_t *entry_end = entry + len;
  8042101c2b:	4c 01 e0             	add    %r12,%rax
  8042101c2e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  8042101c32:	ba 02 00 00 00       	mov    $0x2,%edx
  8042101c37:	4c 89 e6             	mov    %r12,%rsi
  8042101c3a:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042101c3e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101c45:	00 00 00 
  8042101c48:	ff d0                	call   *%rax
        entry += sizeof(Dwarf_Half);
  8042101c4a:	49 8d 74 24 02       	lea    0x2(%r12),%rsi
        assert(version == 4 || version == 2);
  8042101c4f:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8042101c53:	83 e8 02             	sub    $0x2,%eax
  8042101c56:	66 a9 fd ff          	test   $0xfffd,%ax
  8042101c5a:	0f 85 b0 fc ff ff    	jne    8042101910 <info_by_address+0xf2>
        Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  8042101c60:	ba 04 00 00 00       	mov    $0x4,%edx
  8042101c65:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042101c69:	49 be 62 0d 11 42 80 	movabs $0x8042110d62,%r14
  8042101c70:	00 00 00 
  8042101c73:	41 ff d6             	call   *%r14
  8042101c76:	8b 5d c8             	mov    -0x38(%rbp),%ebx
        entry += sizeof(uint32_t);
  8042101c79:	49 8d 74 24 06       	lea    0x6(%r12),%rsi
        Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  8042101c7e:	ba 01 00 00 00       	mov    $0x1,%edx
  8042101c83:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042101c87:	41 ff d6             	call   *%r14
        entry += sizeof(Dwarf_Small);
  8042101c8a:	4d 8d 74 24 07       	lea    0x7(%r12),%r14
        assert(address_size == sizeof(uintptr_t));
  8042101c8f:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8042101c93:	0f 85 ac fc ff ff    	jne    8042101945 <info_by_address+0x127>
  8042101c99:	4c 89 f0             	mov    %r14,%rax
    size_t shift = 0, count = 0;
  8042101c9c:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101ca1:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  8042101ca6:	48 83 c0 01          	add    $0x1,%rax
  8042101caa:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  8042101cae:	48 89 fa             	mov    %rdi,%rdx
  8042101cb1:	83 e2 7f             	and    $0x7f,%edx
  8042101cb4:	48 d3 e2             	shl    %cl,%rdx
  8042101cb7:	48 09 d6             	or     %rdx,%rsi
        shift += 7;
  8042101cba:	48 83 c1 07          	add    $0x7,%rcx
    } while (byte & 0x80 && shift < 64);
  8042101cbe:	40 84 ff             	test   %dil,%dil
  8042101cc1:	79 06                	jns    8042101cc9 <info_by_address+0x4ab>
  8042101cc3:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101cc7:	76 dd                	jbe    8042101ca6 <info_by_address+0x488>
  8042101cc9:	48 8d 48 f9          	lea    -0x7(%rax),%rcx
        count++;
  8042101ccd:	48 89 ca             	mov    %rcx,%rdx
  8042101cd0:	4c 29 e2             	sub    %r12,%rdx
    while (byte & 0x80) {
  8042101cd3:	40 84 ff             	test   %dil,%dil
  8042101cd6:	79 12                	jns    8042101cea <info_by_address+0x4cc>
        byte = *addr++;
  8042101cd8:	49 29 cc             	sub    %rcx,%r12
  8042101cdb:	4c 01 e0             	add    %r12,%rax
  8042101cde:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042101ce2:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042101ce6:	84 c9                	test   %cl,%cl
  8042101ce8:	78 f4                	js     8042101cde <info_by_address+0x4c0>
        entry += dwarf_read_uleb128(entry, &abbrev_code);
  8042101cea:	49 01 d6             	add    %rdx,%r14
        assert(abbrev_code);
  8042101ced:	48 85 f6             	test   %rsi,%rsi
  8042101cf0:	0f 84 84 fc ff ff    	je     804210197a <info_by_address+0x15c>
        const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  8042101cf6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042101cfa:	48 03 18             	add    (%rax),%rbx
  8042101cfd:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8042101d00:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101d05:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101d0a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
        byte = *addr++;
  8042101d10:	48 83 c2 01          	add    $0x1,%rdx
  8042101d14:	44 0f b6 42 ff       	movzbl -0x1(%rdx),%r8d
        result |= (byte & 0x7FULL) << shift;
  8042101d19:	4c 89 c7             	mov    %r8,%rdi
  8042101d1c:	83 e7 7f             	and    $0x7f,%edi
  8042101d1f:	48 d3 e7             	shl    %cl,%rdi
  8042101d22:	49 09 f9             	or     %rdi,%r9
        shift += 7;
  8042101d25:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101d29:	48 89 c7             	mov    %rax,%rdi
  8042101d2c:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042101d30:	45 84 c0             	test   %r8b,%r8b
  8042101d33:	79 06                	jns    8042101d3b <info_by_address+0x51d>
  8042101d35:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101d39:	76 d5                	jbe    8042101d10 <info_by_address+0x4f2>
    while (byte & 0x80) {
  8042101d3b:	45 84 c0             	test   %r8b,%r8b
  8042101d3e:	79 12                	jns    8042101d52 <info_by_address+0x534>
        byte = *addr++;
  8042101d40:	48 f7 d7             	not    %rdi
  8042101d43:	48 01 fa             	add    %rdi,%rdx
  8042101d46:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042101d4a:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042101d4e:	84 c9                	test   %cl,%cl
  8042101d50:	78 f4                	js     8042101d46 <info_by_address+0x528>
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &table_abbrev_code);
  8042101d52:	48 01 d8             	add    %rbx,%rax
        assert(table_abbrev_code == abbrev_code);
  8042101d55:	4c 39 ce             	cmp    %r9,%rsi
  8042101d58:	0f 85 51 fc ff ff    	jne    80421019af <info_by_address+0x191>
  8042101d5e:	48 89 c6             	mov    %rax,%rsi
    size_t shift = 0, count = 0;
  8042101d61:	ba 00 00 00 00       	mov    $0x0,%edx
  8042101d66:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101d6b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
        byte = *addr++;
  8042101d71:	48 83 c6 01          	add    $0x1,%rsi
  8042101d75:	44 0f b6 4e ff       	movzbl -0x1(%rsi),%r9d
        result |= (byte & 0x7FULL) << shift;
  8042101d7a:	4c 89 cf             	mov    %r9,%rdi
  8042101d7d:	83 e7 7f             	and    $0x7f,%edi
  8042101d80:	48 d3 e7             	shl    %cl,%rdi
  8042101d83:	49 09 f8             	or     %rdi,%r8
        shift += 7;
  8042101d86:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101d8a:	48 89 d7             	mov    %rdx,%rdi
  8042101d8d:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  8042101d91:	45 84 c9             	test   %r9b,%r9b
  8042101d94:	79 06                	jns    8042101d9c <info_by_address+0x57e>
  8042101d96:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042101d9a:	76 d5                	jbe    8042101d71 <info_by_address+0x553>
    while (byte & 0x80) {
  8042101d9c:	45 84 c9             	test   %r9b,%r9b
  8042101d9f:	79 12                	jns    8042101db3 <info_by_address+0x595>
        byte = *addr++;
  8042101da1:	48 f7 d7             	not    %rdi
  8042101da4:	48 01 fe             	add    %rdi,%rsi
  8042101da7:	0f b6 0c 16          	movzbl (%rsi,%rdx,1),%ecx
        count++;
  8042101dab:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042101daf:	84 c9                	test   %cl,%cl
  8042101db1:	78 f4                	js     8042101da7 <info_by_address+0x589>
        assert(tag == DW_TAG_compile_unit);
  8042101db3:	49 83 f8 11          	cmp    $0x11,%r8
  8042101db7:	0f 85 27 fc ff ff    	jne    80421019e4 <info_by_address+0x1c6>
        abbrev_entry += sizeof(Dwarf_Small);
  8042101dbd:	48 8d 5c 10 01       	lea    0x1(%rax,%rdx,1),%rbx
        uintptr_t low_pc = 0, high_pc = 0;
  8042101dc2:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8042101dc9:	00 
  8042101dca:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8042101dd1:	00 
  8042101dd2:	e9 5f fc ff ff       	jmp    8042101a36 <info_by_address+0x218>

0000008042101dd7 <file_name_by_info>:

int
file_name_by_info(const struct Dwarf_Addrs *addrs, Dwarf_Off offset, char **buf, Dwarf_Off *line_off) {
  8042101dd7:	f3 0f 1e fa          	endbr64
  8042101ddb:	55                   	push   %rbp
  8042101ddc:	48 89 e5             	mov    %rsp,%rbp
  8042101ddf:	41 57                	push   %r15
  8042101de1:	41 56                	push   %r14
  8042101de3:	41 55                	push   %r13
  8042101de5:	41 54                	push   %r12
  8042101de7:	53                   	push   %rbx
  8042101de8:	48 83 ec 38          	sub    $0x38,%rsp
  8042101dec:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8042101df0:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8042101df4:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    if (offset > addrs->info_end - addrs->info_begin) return -E_INVAL;
  8042101df8:	48 8b 5f 20          	mov    0x20(%rdi),%rbx
  8042101dfc:	48 8b 47 28          	mov    0x28(%rdi),%rax
  8042101e00:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8042101e04:	48 29 d8             	sub    %rbx,%rax
  8042101e07:	48 39 f0             	cmp    %rsi,%rax
  8042101e0a:	0f 82 34 03 00 00    	jb     8042102144 <file_name_by_info+0x36d>

    const uint8_t *entry = addrs->info_begin + offset;
  8042101e10:	48 01 f3             	add    %rsi,%rbx
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042101e13:	ba 04 00 00 00       	mov    $0x4,%edx
  8042101e18:	48 89 de             	mov    %rbx,%rsi
  8042101e1b:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042101e1f:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101e26:	00 00 00 
  8042101e29:	ff d0                	call   *%rax
  8042101e2b:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042101e2e:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8042101e35:	ff ff ff 
  8042101e38:	48 01 d0             	add    %rdx,%rax
  8042101e3b:	48 83 f8 0f          	cmp    $0xf,%rax
  8042101e3f:	0f 87 09 03 00 00    	ja     804210214e <file_name_by_info+0x377>
        if (initial_len == DW_EXT_DWARF64) {
  8042101e45:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042101e4a:	48 39 c2             	cmp    %rax,%rdx
  8042101e4d:	74 25                	je     8042101e74 <file_name_by_info+0x9d>
            cprintf("Unknown DWARF extension\n");
  8042101e4f:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  8042101e56:	00 00 00 
  8042101e59:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101e5e:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042101e65:	00 00 00 
  8042101e68:	ff d2                	call   *%rdx
    uint32_t count;
    uint64_t len = 0;
    entry += count = dwarf_entry_len(entry, &len);
    if (!count) return -E_BAD_DWARF;
  8042101e6a:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8042101e6f:	e9 41 02 00 00       	jmp    80421020b5 <file_name_by_info+0x2de>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8042101e74:	48 8d 73 20          	lea    0x20(%rbx),%rsi
  8042101e78:	ba 08 00 00 00       	mov    $0x8,%edx
  8042101e7d:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042101e81:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042101e88:	00 00 00 
  8042101e8b:	ff d0                	call   *%rax
            count += sizeof(uint64_t);
  8042101e8d:	b8 0c 00 00 00       	mov    $0xc,%eax
  8042101e92:	e9 bc 02 00 00       	jmp    8042102153 <file_name_by_info+0x37c>

    /* Parse compilation unit header */
    Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
    entry += sizeof(Dwarf_Half);
    assert(version == 4 || version == 2);
  8042101e97:	48 b9 c2 f4 11 42 80 	movabs $0x804211f4c2,%rcx
  8042101e9e:	00 00 00 
  8042101ea1:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042101ea8:	00 00 00 
  8042101eab:	be 61 01 00 00       	mov    $0x161,%esi
  8042101eb0:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042101eb7:	00 00 00 
  8042101eba:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101ebf:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042101ec6:	00 00 00 
  8042101ec9:	41 ff d0             	call   *%r8
    Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
    entry += sizeof(uint32_t);
    Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
    entry += sizeof(Dwarf_Small);
    assert(address_size == sizeof(uintptr_t));
  8042101ecc:	48 b9 58 04 12 42 80 	movabs $0x8042120458,%rcx
  8042101ed3:	00 00 00 
  8042101ed6:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042101edd:	00 00 00 
  8042101ee0:	be 66 01 00 00       	mov    $0x166,%esi
  8042101ee5:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042101eec:	00 00 00 
  8042101eef:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101ef4:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042101efb:	00 00 00 
  8042101efe:	41 ff d0             	call   *%r8

    /* Read abbreviation code */
    uint64_t abbrev_code = 0;
    entry += dwarf_read_uleb128(entry, &abbrev_code);
    assert(abbrev_code);
  8042101f01:	48 b9 01 f5 11 42 80 	movabs $0x804211f501,%rcx
  8042101f08:	00 00 00 
  8042101f0b:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042101f12:	00 00 00 
  8042101f15:	be 6b 01 00 00       	mov    $0x16b,%esi
  8042101f1a:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042101f21:	00 00 00 
  8042101f24:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101f29:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042101f30:	00 00 00 
  8042101f33:	41 ff d0             	call   *%r8

    /* Read abbreviations table */
    const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
    uint64_t table_abbrev_code = 0;
    abbrev_entry += dwarf_read_uleb128(abbrev_entry, &table_abbrev_code);
    assert(table_abbrev_code == abbrev_code);
  8042101f36:	48 b9 80 04 12 42 80 	movabs $0x8042120480,%rcx
  8042101f3d:	00 00 00 
  8042101f40:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042101f47:	00 00 00 
  8042101f4a:	be 71 01 00 00       	mov    $0x171,%esi
  8042101f4f:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042101f56:	00 00 00 
  8042101f59:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101f5e:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042101f65:	00 00 00 
  8042101f68:	41 ff d0             	call   *%r8
    uint64_t tag = 0;
    abbrev_entry += dwarf_read_uleb128(abbrev_entry, &tag);
    assert(tag == DW_TAG_compile_unit);
  8042101f6b:	48 b9 0d f5 11 42 80 	movabs $0x804211f50d,%rcx
  8042101f72:	00 00 00 
  8042101f75:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042101f7c:	00 00 00 
  8042101f7f:	be 74 01 00 00       	mov    $0x174,%esi
  8042101f84:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042101f8b:	00 00 00 
  8042101f8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101f93:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042101f9a:	00 00 00 
  8042101f9d:	41 ff d0             	call   *%r8
    uint64_t name = 0, form = 0;
    do {
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
        if (name == DW_AT_name) {
            if (form == DW_FORM_strp) {
  8042101fa0:	49 83 fc 0e          	cmp    $0xe,%r12
  8042101fa4:	0f 84 1a 01 00 00    	je     80421020c4 <file_name_by_info+0x2ed>
                uint64_t offset = 0;
                entry += dwarf_read_abbrev_entry(entry, form, &offset, sizeof(uint64_t), address_size);
                if (buf) put_unaligned((const uint8_t *)addrs->str_begin + offset, buf);
            } else {
                entry += dwarf_read_abbrev_entry(entry, form, buf, sizeof(char *), address_size);
  8042101faa:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042101fb0:	b9 08 00 00 00       	mov    $0x8,%ecx
  8042101fb5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8042101fb9:	44 89 e6             	mov    %r12d,%esi
  8042101fbc:	4c 89 f7             	mov    %r14,%rdi
  8042101fbf:	41 ff d7             	call   *%r15
  8042101fc2:	48 98                	cltq
  8042101fc4:	49 01 c6             	add    %rax,%r14
    uint64_t result = 0;
  8042101fc7:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8042101fca:	b8 00 00 00 00       	mov    $0x0,%eax
  8042101fcf:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042101fd4:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8042101fda:	48 83 c2 01          	add    $0x1,%rdx
  8042101fde:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042101fe2:	48 89 fe             	mov    %rdi,%rsi
  8042101fe5:	83 e6 7f             	and    $0x7f,%esi
  8042101fe8:	48 d3 e6             	shl    %cl,%rsi
  8042101feb:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8042101fee:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042101ff2:	48 89 c6             	mov    %rax,%rsi
  8042101ff5:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042101ff9:	40 84 ff             	test   %dil,%dil
  8042101ffc:	79 06                	jns    8042102004 <file_name_by_info+0x22d>
  8042101ffe:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102002:	76 d6                	jbe    8042101fda <file_name_by_info+0x203>
    while (byte & 0x80) {
  8042102004:	40 84 ff             	test   %dil,%dil
  8042102007:	79 12                	jns    804210201b <file_name_by_info+0x244>
        byte = *addr++;
  8042102009:	48 f7 d6             	not    %rsi
  804210200c:	48 01 f2             	add    %rsi,%rdx
  804210200f:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042102013:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042102017:	84 c9                	test   %cl,%cl
  8042102019:	78 f4                	js     804210200f <file_name_by_info+0x238>
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  804210201b:	48 01 d8             	add    %rbx,%rax
  804210201e:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8042102021:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042102026:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804210202b:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  8042102031:	48 83 c2 01          	add    $0x1,%rdx
  8042102035:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042102039:	48 89 fe             	mov    %rdi,%rsi
  804210203c:	83 e6 7f             	and    $0x7f,%esi
  804210203f:	48 d3 e6             	shl    %cl,%rsi
  8042102042:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  8042102045:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102049:	48 89 de             	mov    %rbx,%rsi
  804210204c:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8042102050:	40 84 ff             	test   %dil,%dil
  8042102053:	79 06                	jns    804210205b <file_name_by_info+0x284>
  8042102055:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102059:	76 d6                	jbe    8042102031 <file_name_by_info+0x25a>
    while (byte & 0x80) {
  804210205b:	40 84 ff             	test   %dil,%dil
  804210205e:	79 12                	jns    8042102072 <file_name_by_info+0x29b>
        byte = *addr++;
  8042102060:	48 f7 d6             	not    %rsi
  8042102063:	48 01 f2             	add    %rsi,%rdx
  8042102066:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  804210206a:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  804210206e:	84 c9                	test   %cl,%cl
  8042102070:	78 f4                	js     8042102066 <file_name_by_info+0x28f>
        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8042102072:	48 01 c3             	add    %rax,%rbx
        if (name == DW_AT_name) {
  8042102075:	49 83 fd 03          	cmp    $0x3,%r13
  8042102079:	0f 84 21 ff ff ff    	je     8042101fa0 <file_name_by_info+0x1c9>
            }
        } else if (name == DW_AT_stmt_list) {
  804210207f:	49 83 fd 10          	cmp    $0x10,%r13
  8042102083:	0f 84 99 00 00 00    	je     8042102122 <file_name_by_info+0x34b>
            entry += dwarf_read_abbrev_entry(entry, form, line_off, sizeof(Dwarf_Off), address_size);
        } else {
            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042102089:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804210208f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042102094:	ba 00 00 00 00       	mov    $0x0,%edx
  8042102099:	44 89 e6             	mov    %r12d,%esi
  804210209c:	4c 89 f7             	mov    %r14,%rdi
  804210209f:	41 ff d7             	call   *%r15
  80421020a2:	48 98                	cltq
  80421020a4:	49 01 c6             	add    %rax,%r14
        }
    } while (name || form);
  80421020a7:	4d 09 ec             	or     %r13,%r12
  80421020aa:	0f 85 17 ff ff ff    	jne    8042101fc7 <file_name_by_info+0x1f0>

    return 0;
  80421020b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80421020b5:	48 83 c4 38          	add    $0x38,%rsp
  80421020b9:	5b                   	pop    %rbx
  80421020ba:	41 5c                	pop    %r12
  80421020bc:	41 5d                	pop    %r13
  80421020be:	41 5e                	pop    %r14
  80421020c0:	41 5f                	pop    %r15
  80421020c2:	5d                   	pop    %rbp
  80421020c3:	c3                   	ret
                uint64_t offset = 0;
  80421020c4:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  80421020cb:	00 
                entry += dwarf_read_abbrev_entry(entry, form, &offset, sizeof(uint64_t), address_size);
  80421020cc:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80421020d2:	b9 08 00 00 00       	mov    $0x8,%ecx
  80421020d7:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80421020db:	be 0e 00 00 00       	mov    $0xe,%esi
  80421020e0:	4c 89 f7             	mov    %r14,%rdi
  80421020e3:	41 ff d7             	call   *%r15
  80421020e6:	48 98                	cltq
  80421020e8:	49 01 c6             	add    %rax,%r14
                if (buf) put_unaligned((const uint8_t *)addrs->str_begin + offset, buf);
  80421020eb:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80421020ef:	48 85 ff             	test   %rdi,%rdi
  80421020f2:	0f 84 cf fe ff ff    	je     8042101fc7 <file_name_by_info+0x1f0>
  80421020f8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80421020fc:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8042102100:	48 03 42 40          	add    0x40(%rdx),%rax
  8042102104:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8042102108:	ba 08 00 00 00       	mov    $0x8,%edx
  804210210d:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  8042102111:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102118:	00 00 00 
  804210211b:	ff d0                	call   *%rax
  804210211d:	e9 a5 fe ff ff       	jmp    8042101fc7 <file_name_by_info+0x1f0>
            entry += dwarf_read_abbrev_entry(entry, form, line_off, sizeof(Dwarf_Off), address_size);
  8042102122:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042102128:	b9 08 00 00 00       	mov    $0x8,%ecx
  804210212d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8042102131:	44 89 e6             	mov    %r12d,%esi
  8042102134:	4c 89 f7             	mov    %r14,%rdi
  8042102137:	41 ff d7             	call   *%r15
  804210213a:	48 98                	cltq
  804210213c:	49 01 c6             	add    %rax,%r14
  804210213f:	e9 83 fe ff ff       	jmp    8042101fc7 <file_name_by_info+0x1f0>
    if (offset > addrs->info_end - addrs->info_begin) return -E_INVAL;
  8042102144:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8042102149:	e9 67 ff ff ff       	jmp    80421020b5 <file_name_by_info+0x2de>
    uint64_t count = sizeof(uint32_t);
  804210214e:	b8 04 00 00 00       	mov    $0x4,%eax
    entry += count = dwarf_entry_len(entry, &len);
  8042102153:	48 01 c3             	add    %rax,%rbx
    Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  8042102156:	ba 02 00 00 00       	mov    $0x2,%edx
  804210215b:	48 89 de             	mov    %rbx,%rsi
  804210215e:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042102162:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102169:	00 00 00 
  804210216c:	ff d0                	call   *%rax
    entry += sizeof(Dwarf_Half);
  804210216e:	48 8d 73 02          	lea    0x2(%rbx),%rsi
    assert(version == 4 || version == 2);
  8042102172:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8042102176:	83 e8 02             	sub    $0x2,%eax
  8042102179:	66 a9 fd ff          	test   $0xfffd,%ax
  804210217d:	0f 85 14 fd ff ff    	jne    8042101e97 <file_name_by_info+0xc0>
    Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  8042102183:	ba 04 00 00 00       	mov    $0x4,%edx
  8042102188:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210218c:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  8042102193:	00 00 00 
  8042102196:	41 ff d4             	call   *%r12
  8042102199:	44 8b 6d c8          	mov    -0x38(%rbp),%r13d
    entry += sizeof(uint32_t);
  804210219d:	48 8d 73 06          	lea    0x6(%rbx),%rsi
    Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  80421021a1:	ba 01 00 00 00       	mov    $0x1,%edx
  80421021a6:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421021aa:	41 ff d4             	call   *%r12
    entry += sizeof(Dwarf_Small);
  80421021ad:	4c 8d 73 07          	lea    0x7(%rbx),%r14
    assert(address_size == sizeof(uintptr_t));
  80421021b1:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  80421021b5:	0f 85 11 fd ff ff    	jne    8042101ecc <file_name_by_info+0xf5>
  80421021bb:	4c 89 f0             	mov    %r14,%rax
    size_t shift = 0, count = 0;
  80421021be:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421021c3:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  80421021c8:	48 83 c0 01          	add    $0x1,%rax
  80421021cc:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  80421021d0:	48 89 fa             	mov    %rdi,%rdx
  80421021d3:	83 e2 7f             	and    $0x7f,%edx
  80421021d6:	48 d3 e2             	shl    %cl,%rdx
  80421021d9:	48 09 d6             	or     %rdx,%rsi
        shift += 7;
  80421021dc:	48 83 c1 07          	add    $0x7,%rcx
    } while (byte & 0x80 && shift < 64);
  80421021e0:	40 84 ff             	test   %dil,%dil
  80421021e3:	79 06                	jns    80421021eb <file_name_by_info+0x414>
  80421021e5:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421021e9:	76 dd                	jbe    80421021c8 <file_name_by_info+0x3f1>
  80421021eb:	48 8d 48 f9          	lea    -0x7(%rax),%rcx
        count++;
  80421021ef:	48 89 ca             	mov    %rcx,%rdx
  80421021f2:	48 29 da             	sub    %rbx,%rdx
    while (byte & 0x80) {
  80421021f5:	40 84 ff             	test   %dil,%dil
  80421021f8:	79 12                	jns    804210220c <file_name_by_info+0x435>
        byte = *addr++;
  80421021fa:	48 29 cb             	sub    %rcx,%rbx
  80421021fd:	48 01 d8             	add    %rbx,%rax
  8042102200:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042102204:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042102208:	84 c9                	test   %cl,%cl
  804210220a:	78 f4                	js     8042102200 <file_name_by_info+0x429>
    entry += dwarf_read_uleb128(entry, &abbrev_code);
  804210220c:	49 01 d6             	add    %rdx,%r14
    assert(abbrev_code);
  804210220f:	48 85 f6             	test   %rsi,%rsi
  8042102212:	0f 84 e9 fc ff ff    	je     8042101f01 <file_name_by_info+0x12a>
    const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  8042102218:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804210221c:	4d 89 e8             	mov    %r13,%r8
  804210221f:	4c 03 00             	add    (%rax),%r8
  8042102222:	4c 89 c2             	mov    %r8,%rdx
    size_t shift = 0, count = 0;
  8042102225:	b8 00 00 00 00       	mov    $0x0,%eax
  804210222a:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804210222f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
        byte = *addr++;
  8042102235:	48 83 c2 01          	add    $0x1,%rdx
  8042102239:	44 0f b6 52 ff       	movzbl -0x1(%rdx),%r10d
        result |= (byte & 0x7FULL) << shift;
  804210223e:	4c 89 d7             	mov    %r10,%rdi
  8042102241:	83 e7 7f             	and    $0x7f,%edi
  8042102244:	48 d3 e7             	shl    %cl,%rdi
  8042102247:	49 09 f9             	or     %rdi,%r9
        shift += 7;
  804210224a:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804210224e:	48 89 c7             	mov    %rax,%rdi
  8042102251:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042102255:	45 84 d2             	test   %r10b,%r10b
  8042102258:	79 06                	jns    8042102260 <file_name_by_info+0x489>
  804210225a:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804210225e:	76 d5                	jbe    8042102235 <file_name_by_info+0x45e>
    while (byte & 0x80) {
  8042102260:	45 84 d2             	test   %r10b,%r10b
  8042102263:	79 12                	jns    8042102277 <file_name_by_info+0x4a0>
        byte = *addr++;
  8042102265:	48 f7 d7             	not    %rdi
  8042102268:	48 01 fa             	add    %rdi,%rdx
  804210226b:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  804210226f:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042102273:	84 c9                	test   %cl,%cl
  8042102275:	78 f4                	js     804210226b <file_name_by_info+0x494>
    abbrev_entry += dwarf_read_uleb128(abbrev_entry, &table_abbrev_code);
  8042102277:	49 01 c0             	add    %rax,%r8
    assert(table_abbrev_code == abbrev_code);
  804210227a:	4c 39 ce             	cmp    %r9,%rsi
  804210227d:	0f 85 b3 fc ff ff    	jne    8042101f36 <file_name_by_info+0x15f>
  8042102283:	4c 89 c2             	mov    %r8,%rdx
    size_t shift = 0, count = 0;
  8042102286:	b8 00 00 00 00       	mov    $0x0,%eax
  804210228b:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102290:	41 b9 00 00 00 00    	mov    $0x0,%r9d
        byte = *addr++;
  8042102296:	48 83 c2 01          	add    $0x1,%rdx
  804210229a:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  804210229e:	48 89 fe             	mov    %rdi,%rsi
  80421022a1:	83 e6 7f             	and    $0x7f,%esi
  80421022a4:	48 d3 e6             	shl    %cl,%rsi
  80421022a7:	49 09 f1             	or     %rsi,%r9
        shift += 7;
  80421022aa:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80421022ae:	48 89 c6             	mov    %rax,%rsi
  80421022b1:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80421022b5:	40 84 ff             	test   %dil,%dil
  80421022b8:	79 06                	jns    80421022c0 <file_name_by_info+0x4e9>
  80421022ba:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421022be:	76 d6                	jbe    8042102296 <file_name_by_info+0x4bf>
    while (byte & 0x80) {
  80421022c0:	40 84 ff             	test   %dil,%dil
  80421022c3:	79 12                	jns    80421022d7 <file_name_by_info+0x500>
        byte = *addr++;
  80421022c5:	48 f7 d6             	not    %rsi
  80421022c8:	48 01 f2             	add    %rsi,%rdx
  80421022cb:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  80421022cf:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80421022d3:	84 c9                	test   %cl,%cl
  80421022d5:	78 f4                	js     80421022cb <file_name_by_info+0x4f4>
    assert(tag == DW_TAG_compile_unit);
  80421022d7:	49 83 f9 11          	cmp    $0x11,%r9
  80421022db:	0f 85 8a fc ff ff    	jne    8042101f6b <file_name_by_info+0x194>
    abbrev_entry += sizeof(Dwarf_Small);
  80421022e1:	49 8d 5c 00 01       	lea    0x1(%r8,%rax,1),%rbx
            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  80421022e6:	49 bf 7a 0d 10 42 80 	movabs $0x8042100d7a,%r15
  80421022ed:	00 00 00 
  80421022f0:	e9 d2 fc ff ff       	jmp    8042101fc7 <file_name_by_info+0x1f0>

00000080421022f5 <function_by_info>:

int
function_by_info(const struct Dwarf_Addrs *addrs, uintptr_t p, Dwarf_Off cu_offset, char **buf, uintptr_t *offset) {
  80421022f5:	f3 0f 1e fa          	endbr64
  80421022f9:	55                   	push   %rbp
  80421022fa:	48 89 e5             	mov    %rsp,%rbp
  80421022fd:	41 57                	push   %r15
  80421022ff:	41 56                	push   %r14
  8042102301:	41 55                	push   %r13
  8042102303:	41 54                	push   %r12
  8042102305:	53                   	push   %rbx
  8042102306:	48 83 ec 68          	sub    $0x68,%rsp
  804210230a:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  804210230e:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
  8042102312:	49 89 cd             	mov    %rcx,%r13
  8042102315:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    uint64_t len = 0;
    uint32_t count;

    const void *entry = addrs->info_begin + cu_offset;
  8042102319:	48 03 57 20          	add    0x20(%rdi),%rdx
  804210231d:	49 89 d6             	mov    %rdx,%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042102320:	ba 04 00 00 00       	mov    $0x4,%edx
  8042102325:	4c 89 f6             	mov    %r14,%rsi
  8042102328:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210232c:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102333:	00 00 00 
  8042102336:	ff d0                	call   *%rax
  8042102338:	8b 45 c8             	mov    -0x38(%rbp),%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  804210233b:	48 ba 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdx
  8042102342:	ff ff ff 
  8042102345:	48 01 c2             	add    %rax,%rdx
  8042102348:	48 83 fa 0f          	cmp    $0xf,%rdx
  804210234c:	0f 87 45 06 00 00    	ja     8042102997 <function_by_info+0x6a2>
        if (initial_len == DW_EXT_DWARF64) {
  8042102352:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8042102357:	48 39 d0             	cmp    %rdx,%rax
  804210235a:	74 25                	je     8042102381 <function_by_info+0x8c>
            cprintf("Unknown DWARF extension\n");
  804210235c:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  8042102363:	00 00 00 
  8042102366:	b8 00 00 00 00       	mov    $0x0,%eax
  804210236b:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042102372:	00 00 00 
  8042102375:	ff d2                	call   *%rdx
    entry += count = dwarf_entry_len(entry, &len);
    if (!count) return -E_BAD_DWARF;
  8042102377:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  804210237c:	e9 07 06 00 00       	jmp    8042102988 <function_by_info+0x693>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8042102381:	49 8d 76 20          	lea    0x20(%r14),%rsi
  8042102385:	ba 08 00 00 00       	mov    $0x8,%edx
  804210238a:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210238e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102395:	00 00 00 
  8042102398:	ff d0                	call   *%rax
  804210239a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            count += sizeof(uint64_t);
  804210239e:	ba 0c 00 00 00       	mov    $0xc,%edx
  80421023a3:	e9 f4 05 00 00       	jmp    804210299c <function_by_info+0x6a7>
    const void *entry_end = entry + len;

    /* Parse compilation unit header */
    Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
    entry += sizeof(Dwarf_Half);
    assert(version == 4 || version == 2);
  80421023a8:	48 b9 c2 f4 11 42 80 	movabs $0x804211f4c2,%rcx
  80421023af:	00 00 00 
  80421023b2:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421023b9:	00 00 00 
  80421023bc:	be 9b 01 00 00       	mov    $0x19b,%esi
  80421023c1:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  80421023c8:	00 00 00 
  80421023cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80421023d0:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421023d7:	00 00 00 
  80421023da:	41 ff d0             	call   *%r8
    Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
    entry += sizeof(uint32_t);
    Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
    entry += sizeof(Dwarf_Small);
    assert(address_size == sizeof(uintptr_t));
  80421023dd:	48 b9 58 04 12 42 80 	movabs $0x8042120458,%rcx
  80421023e4:	00 00 00 
  80421023e7:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421023ee:	00 00 00 
  80421023f1:	be a0 01 00 00       	mov    $0x1a0,%esi
  80421023f6:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  80421023fd:	00 00 00 
  8042102400:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102405:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210240c:	00 00 00 
  804210240f:	41 ff d0             	call   *%r8
    while (byte & 0x80) {
  8042102412:	45 84 c0             	test   %r8b,%r8b
  8042102415:	79 12                	jns    8042102429 <function_by_info+0x134>
        byte = *addr++;
  8042102417:	48 f7 d6             	not    %rsi
  804210241a:	48 01 f2             	add    %rsi,%rdx
  804210241d:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042102421:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042102425:	84 c9                	test   %cl,%cl
  8042102427:	78 f4                	js     804210241d <function_by_info+0x128>
    uint64_t table_abbrev_code = 0;
    const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;

    while (entry < entry_end) {
        /* Read info abbreviation code */
        entry += dwarf_read_uleb128(entry, &abbrev_code);
  8042102429:	49 01 c6             	add    %rax,%r14
        if (!abbrev_code) continue;
  804210242c:	48 85 ff             	test   %rdi,%rdi
  804210242f:	75 4c                	jne    804210247d <function_by_info+0x188>
    while (entry < entry_end) {
  8042102431:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8042102435:	49 39 c6             	cmp    %rax,%r14
  8042102438:	0f 83 45 05 00 00    	jae    8042102983 <function_by_info+0x68e>
  804210243e:	4c 89 f2             	mov    %r14,%rdx
    size_t shift = 0, count = 0;
  8042102441:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102446:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804210244b:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  8042102450:	48 83 c2 01          	add    $0x1,%rdx
  8042102454:	44 0f b6 42 ff       	movzbl -0x1(%rdx),%r8d
        result |= (byte & 0x7FULL) << shift;
  8042102459:	4c 89 c6             	mov    %r8,%rsi
  804210245c:	83 e6 7f             	and    $0x7f,%esi
  804210245f:	48 d3 e6             	shl    %cl,%rsi
  8042102462:	48 09 f7             	or     %rsi,%rdi
        shift += 7;
  8042102465:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102469:	48 89 c6             	mov    %rax,%rsi
  804210246c:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042102470:	45 84 c0             	test   %r8b,%r8b
  8042102473:	79 9d                	jns    8042102412 <function_by_info+0x11d>
  8042102475:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102479:	76 d5                	jbe    8042102450 <function_by_info+0x15b>
  804210247b:	eb 95                	jmp    8042102412 <function_by_info+0x11d>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
        uint64_t name = 0, form = 0, tag = 0;

        /* Find abbreviation in abbrev section */
        /* UNSAFE Needs to be replaced */
        while (curr_abbrev_entry < addrs->abbrev_end) {
  804210247d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8042102481:	4c 8b 48 08          	mov    0x8(%rax),%r9
  8042102485:	4d 39 cc             	cmp    %r9,%r12
  8042102488:	0f 83 02 04 00 00    	jae    8042102890 <function_by_info+0x59b>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
  804210248e:	4c 89 e2             	mov    %r12,%rdx
  8042102491:	4d 89 e3             	mov    %r12,%r11
  8042102494:	e9 d2 00 00 00       	jmp    804210256b <function_by_info+0x276>
    while (byte & 0x80) {
  8042102499:	45 84 db             	test   %r11b,%r11b
  804210249c:	79 13                	jns    80421024b1 <function_by_info+0x1bc>
        byte = *addr++;
  804210249e:	49 f7 d2             	not    %r10
  80421024a1:	4d 01 d0             	add    %r10,%r8
  80421024a4:	41 0f b6 0c 10       	movzbl (%r8,%rdx,1),%ecx
        count++;
  80421024a9:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  80421024ad:	84 c9                	test   %cl,%cl
  80421024af:	78 f3                	js     80421024a4 <function_by_info+0x1af>
            if (table_abbrev_code == abbrev_code) break;

            /* Skip attributes */
            do {
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  80421024b1:	48 01 f2             	add    %rsi,%rdx
            } while (name != 0 || form != 0);
  80421024b4:	4c 09 e3             	or     %r12,%rbx
  80421024b7:	0f 84 a1 00 00 00    	je     804210255e <function_by_info+0x269>
    uint64_t result = 0;
  80421024bd:	49 89 d0             	mov    %rdx,%r8
    size_t shift = 0, count = 0;
  80421024c0:	be 00 00 00 00       	mov    $0x0,%esi
  80421024c5:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421024ca:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  80421024d0:	49 83 c0 01          	add    $0x1,%r8
  80421024d4:	45 0f b6 58 ff       	movzbl -0x1(%r8),%r11d
        result |= (byte & 0x7FULL) << shift;
  80421024d9:	4d 89 da             	mov    %r11,%r10
  80421024dc:	41 83 e2 7f          	and    $0x7f,%r10d
  80421024e0:	49 d3 e2             	shl    %cl,%r10
  80421024e3:	4d 09 d4             	or     %r10,%r12
        shift += 7;
  80421024e6:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80421024ea:	49 89 f2             	mov    %rsi,%r10
  80421024ed:	48 83 c6 01          	add    $0x1,%rsi
    } while (byte & 0x80 && shift < 64);
  80421024f1:	45 84 db             	test   %r11b,%r11b
  80421024f4:	79 06                	jns    80421024fc <function_by_info+0x207>
  80421024f6:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421024fa:	76 d4                	jbe    80421024d0 <function_by_info+0x1db>
    while (byte & 0x80) {
  80421024fc:	45 84 db             	test   %r11b,%r11b
  80421024ff:	79 13                	jns    8042102514 <function_by_info+0x21f>
        byte = *addr++;
  8042102501:	49 f7 d2             	not    %r10
  8042102504:	4d 01 d0             	add    %r10,%r8
  8042102507:	41 0f b6 0c 30       	movzbl (%r8,%rsi,1),%ecx
        count++;
  804210250c:	48 83 c6 01          	add    $0x1,%rsi
    while (byte & 0x80) {
  8042102510:	84 c9                	test   %cl,%cl
  8042102512:	78 f3                	js     8042102507 <function_by_info+0x212>
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  8042102514:	48 01 d6             	add    %rdx,%rsi
  8042102517:	49 89 f0             	mov    %rsi,%r8
    size_t shift = 0, count = 0;
  804210251a:	ba 00 00 00 00       	mov    $0x0,%edx
  804210251f:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102524:	bb 00 00 00 00       	mov    $0x0,%ebx
        byte = *addr++;
  8042102529:	49 83 c0 01          	add    $0x1,%r8
  804210252d:	45 0f b6 58 ff       	movzbl -0x1(%r8),%r11d
        result |= (byte & 0x7FULL) << shift;
  8042102532:	4d 89 da             	mov    %r11,%r10
  8042102535:	41 83 e2 7f          	and    $0x7f,%r10d
  8042102539:	49 d3 e2             	shl    %cl,%r10
  804210253c:	4c 09 d3             	or     %r10,%rbx
        shift += 7;
  804210253f:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102543:	49 89 d2             	mov    %rdx,%r10
  8042102546:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  804210254a:	45 84 db             	test   %r11b,%r11b
  804210254d:	0f 89 46 ff ff ff    	jns    8042102499 <function_by_info+0x1a4>
  8042102553:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102557:	76 d0                	jbe    8042102529 <function_by_info+0x234>
  8042102559:	e9 3b ff ff ff       	jmp    8042102499 <function_by_info+0x1a4>
        while (curr_abbrev_entry < addrs->abbrev_end) {
  804210255e:	4c 8b 5d a8          	mov    -0x58(%rbp),%r11
  8042102562:	4c 39 ca             	cmp    %r9,%rdx
  8042102565:	0f 83 bf 00 00 00    	jae    804210262a <function_by_info+0x335>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
  804210256b:	48 89 d6             	mov    %rdx,%rsi
    size_t shift = 0, count = 0;
  804210256e:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102573:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102578:	41 ba 00 00 00 00    	mov    $0x0,%r10d
        byte = *addr++;
  804210257e:	48 83 c6 01          	add    $0x1,%rsi
  8042102582:	0f b6 5e ff          	movzbl -0x1(%rsi),%ebx
        result |= (byte & 0x7FULL) << shift;
  8042102586:	49 89 d8             	mov    %rbx,%r8
  8042102589:	41 83 e0 7f          	and    $0x7f,%r8d
  804210258d:	49 d3 e0             	shl    %cl,%r8
  8042102590:	4d 09 c2             	or     %r8,%r10
        shift += 7;
  8042102593:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102597:	49 89 c0             	mov    %rax,%r8
  804210259a:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  804210259e:	84 db                	test   %bl,%bl
  80421025a0:	79 06                	jns    80421025a8 <function_by_info+0x2b3>
  80421025a2:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421025a6:	76 d6                	jbe    804210257e <function_by_info+0x289>
    while (byte & 0x80) {
  80421025a8:	84 db                	test   %bl,%bl
  80421025aa:	79 12                	jns    80421025be <function_by_info+0x2c9>
        byte = *addr++;
  80421025ac:	49 f7 d0             	not    %r8
  80421025af:	4c 01 c6             	add    %r8,%rsi
  80421025b2:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
        count++;
  80421025b6:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80421025ba:	84 c9                	test   %cl,%cl
  80421025bc:	78 f4                	js     80421025b2 <function_by_info+0x2bd>
            curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &table_abbrev_code);
  80421025be:	48 8d 34 02          	lea    (%rdx,%rax,1),%rsi
  80421025c2:	49 89 f0             	mov    %rsi,%r8
    size_t shift = 0, count = 0;
  80421025c5:	ba 00 00 00 00       	mov    $0x0,%edx
  80421025ca:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421025cf:	b8 00 00 00 00       	mov    $0x0,%eax
        byte = *addr++;
  80421025d4:	49 83 c0 01          	add    $0x1,%r8
  80421025d8:	45 0f b6 60 ff       	movzbl -0x1(%r8),%r12d
        result |= (byte & 0x7FULL) << shift;
  80421025dd:	4c 89 e3             	mov    %r12,%rbx
  80421025e0:	83 e3 7f             	and    $0x7f,%ebx
  80421025e3:	48 d3 e3             	shl    %cl,%rbx
  80421025e6:	48 09 d8             	or     %rbx,%rax
        shift += 7;
  80421025e9:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80421025ed:	48 89 d3             	mov    %rdx,%rbx
  80421025f0:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  80421025f4:	45 84 e4             	test   %r12b,%r12b
  80421025f7:	79 06                	jns    80421025ff <function_by_info+0x30a>
  80421025f9:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421025fd:	76 d5                	jbe    80421025d4 <function_by_info+0x2df>
    while (byte & 0x80) {
  80421025ff:	45 84 e4             	test   %r12b,%r12b
  8042102602:	79 13                	jns    8042102617 <function_by_info+0x322>
        byte = *addr++;
  8042102604:	48 f7 d3             	not    %rbx
  8042102607:	49 01 d8             	add    %rbx,%r8
  804210260a:	41 0f b6 0c 10       	movzbl (%r8,%rdx,1),%ecx
        count++;
  804210260f:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042102613:	84 c9                	test   %cl,%cl
  8042102615:	78 f3                	js     804210260a <function_by_info+0x315>
            curr_abbrev_entry += sizeof(Dwarf_Small);
  8042102617:	48 8d 54 16 01       	lea    0x1(%rsi,%rdx,1),%rdx
            if (table_abbrev_code == abbrev_code) break;
  804210261c:	4c 39 d7             	cmp    %r10,%rdi
  804210261f:	74 09                	je     804210262a <function_by_info+0x335>
  8042102621:	4c 89 5d a8          	mov    %r11,-0x58(%rbp)
  8042102625:	e9 93 fe ff ff       	jmp    80421024bd <function_by_info+0x1c8>
        }
        /* Parse subprogram DIE */
        if (tag == DW_TAG_subprogram) {
  804210262a:	48 89 d3             	mov    %rdx,%rbx
  804210262d:	4d 89 dc             	mov    %r11,%r12
  8042102630:	48 83 f8 2e          	cmp    $0x2e,%rax
  8042102634:	74 0d                	je     8042102643 <function_by_info+0x34e>
  8042102636:	4c 89 65 a8          	mov    %r12,-0x58(%rbp)
  804210263a:	4c 89 6d a0          	mov    %r13,-0x60(%rbp)
  804210263e:	e9 96 02 00 00       	jmp    80421028d9 <function_by_info+0x5e4>
            uintptr_t low_pc = 0, high_pc = 0;
  8042102643:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
  804210264a:	00 
  804210264b:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8042102652:	00 
            const uint8_t *fn_name_entry = 0;
            uint64_t name_form = 0;
  8042102653:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  804210265a:	00 
            const uint8_t *fn_name_entry = 0;
  804210265b:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8042102662:	00 
  8042102663:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
  804210266a:	4c 89 ad 70 ff ff ff 	mov    %r13,-0x90(%rbp)
  8042102671:	eb 71                	jmp    80421026e4 <function_by_info+0x3ef>
  8042102673:	40 84 ff             	test   %dil,%dil
  8042102676:	79 12                	jns    804210268a <function_by_info+0x395>
        byte = *addr++;
  8042102678:	48 f7 d6             	not    %rsi
  804210267b:	48 01 f2             	add    %rsi,%rdx
  804210267e:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8042102682:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8042102686:	84 c9                	test   %cl,%cl
  8042102688:	78 f4                	js     804210267e <function_by_info+0x389>
            do {
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  804210268a:	48 01 c3             	add    %rax,%rbx
                if (name == DW_AT_low_pc) {
  804210268d:	49 83 fc 11          	cmp    $0x11,%r12
  8042102691:	0f 84 ea 00 00 00    	je     8042102781 <function_by_info+0x48c>
                    entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
                } else if (name == DW_AT_high_pc) {
  8042102697:	49 83 fc 12          	cmp    $0x12,%r12
  804210269b:	0f 84 02 01 00 00    	je     80421027a3 <function_by_info+0x4ae>
                    entry += dwarf_read_abbrev_entry(entry, form, &high_pc, sizeof(high_pc), address_size);
                    if (form != DW_FORM_addr) high_pc += low_pc;
                } else {
                    if (name == DW_AT_name) {
                        fn_name_entry = entry;
                        name_form = form;
  80421026a1:	49 83 fc 03          	cmp    $0x3,%r12
  80421026a5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80421026a9:	49 0f 44 c5          	cmove  %r13,%rax
  80421026ad:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80421026b1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80421026b5:	49 0f 44 c6          	cmove  %r14,%rax
  80421026b9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                    }
                    entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  80421026bd:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80421026c3:	b9 00 00 00 00       	mov    $0x0,%ecx
  80421026c8:	ba 00 00 00 00       	mov    $0x0,%edx
  80421026cd:	44 89 ee             	mov    %r13d,%esi
  80421026d0:	4c 89 f7             	mov    %r14,%rdi
  80421026d3:	41 ff d7             	call   *%r15
  80421026d6:	48 98                	cltq
  80421026d8:	49 01 c6             	add    %rax,%r14
                }
            } while (name || form);
  80421026db:	4d 09 e5             	or     %r12,%r13
  80421026de:	0f 84 f3 00 00 00    	je     80421027d7 <function_by_info+0x4e2>
            const uint8_t *fn_name_entry = 0;
  80421026e4:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  80421026e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80421026ec:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421026f1:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  80421026f7:	48 83 c2 01          	add    $0x1,%rdx
  80421026fb:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  80421026ff:	48 89 fe             	mov    %rdi,%rsi
  8042102702:	83 e6 7f             	and    $0x7f,%esi
  8042102705:	48 d3 e6             	shl    %cl,%rsi
  8042102708:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  804210270b:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804210270f:	48 89 c6             	mov    %rax,%rsi
  8042102712:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042102716:	40 84 ff             	test   %dil,%dil
  8042102719:	79 06                	jns    8042102721 <function_by_info+0x42c>
  804210271b:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804210271f:	76 d6                	jbe    80421026f7 <function_by_info+0x402>
    while (byte & 0x80) {
  8042102721:	40 84 ff             	test   %dil,%dil
  8042102724:	79 12                	jns    8042102738 <function_by_info+0x443>
        byte = *addr++;
  8042102726:	48 f7 d6             	not    %rsi
  8042102729:	48 01 f2             	add    %rsi,%rdx
  804210272c:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042102730:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042102734:	84 c9                	test   %cl,%cl
  8042102736:	78 f4                	js     804210272c <function_by_info+0x437>
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  8042102738:	48 01 d8             	add    %rbx,%rax
  804210273b:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  804210273e:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042102743:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102748:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  804210274e:	48 83 c2 01          	add    $0x1,%rdx
  8042102752:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042102756:	48 89 fe             	mov    %rdi,%rsi
  8042102759:	83 e6 7f             	and    $0x7f,%esi
  804210275c:	48 d3 e6             	shl    %cl,%rsi
  804210275f:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8042102762:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102766:	48 89 de             	mov    %rbx,%rsi
  8042102769:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  804210276d:	40 84 ff             	test   %dil,%dil
  8042102770:	0f 89 fd fe ff ff    	jns    8042102673 <function_by_info+0x37e>
  8042102776:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804210277a:	76 d2                	jbe    804210274e <function_by_info+0x459>
  804210277c:	e9 f2 fe ff ff       	jmp    8042102673 <function_by_info+0x37e>
                    entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
  8042102781:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042102787:	b9 08 00 00 00       	mov    $0x8,%ecx
  804210278c:	48 8d 55 b0          	lea    -0x50(%rbp),%rdx
  8042102790:	44 89 ee             	mov    %r13d,%esi
  8042102793:	4c 89 f7             	mov    %r14,%rdi
  8042102796:	41 ff d7             	call   *%r15
  8042102799:	48 98                	cltq
  804210279b:	49 01 c6             	add    %rax,%r14
  804210279e:	e9 41 ff ff ff       	jmp    80421026e4 <function_by_info+0x3ef>
                    entry += dwarf_read_abbrev_entry(entry, form, &high_pc, sizeof(high_pc), address_size);
  80421027a3:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80421027a9:	b9 08 00 00 00       	mov    $0x8,%ecx
  80421027ae:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  80421027b2:	44 89 ee             	mov    %r13d,%esi
  80421027b5:	4c 89 f7             	mov    %r14,%rdi
  80421027b8:	41 ff d7             	call   *%r15
  80421027bb:	48 98                	cltq
  80421027bd:	49 01 c6             	add    %rax,%r14
                    if (form != DW_FORM_addr) high_pc += low_pc;
  80421027c0:	49 83 fd 01          	cmp    $0x1,%r13
  80421027c4:	0f 84 1a ff ff ff    	je     80421026e4 <function_by_info+0x3ef>
  80421027ca:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80421027ce:	48 01 45 b8          	add    %rax,-0x48(%rbp)
  80421027d2:	e9 0d ff ff ff       	jmp    80421026e4 <function_by_info+0x3ef>

            /* Load info and finish if address is inside of the function */
            if (p >= low_pc && p <= high_pc) {
  80421027d7:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  80421027de:	4c 8b ad 70 ff ff ff 	mov    -0x90(%rbp),%r13
  80421027e5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80421027e9:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  80421027ed:	48 39 c7             	cmp    %rax,%rdi
  80421027f0:	0f 82 3b fc ff ff    	jb     8042102431 <function_by_info+0x13c>
  80421027f6:	48 39 7d b8          	cmp    %rdi,-0x48(%rbp)
  80421027fa:	0f 82 31 fc ff ff    	jb     8042102431 <function_by_info+0x13c>
                *offset = low_pc;
  8042102800:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8042102804:	48 8b 5d 80          	mov    -0x80(%rbp),%rbx
  8042102808:	48 89 03             	mov    %rax,(%rbx)
                if (name_form == DW_FORM_strp) {
  804210280b:	48 83 7d a8 0e       	cmpq   $0xe,-0x58(%rbp)
  8042102810:	74 27                	je     8042102839 <function_by_info+0x544>
                    uintptr_t str_offset = 0;
                    entry += dwarf_read_abbrev_entry(fn_name_entry, name_form, &str_offset, sizeof(uintptr_t), address_size);
                    (void)entry;
                    if (buf) put_unaligned((const uint8_t *)addrs->str_begin + str_offset, buf);
                } else {
                    entry += dwarf_read_abbrev_entry(fn_name_entry, name_form, buf, sizeof(uint8_t *), address_size);
  8042102812:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042102818:	b9 08 00 00 00       	mov    $0x8,%ecx
  804210281d:	4c 89 ea             	mov    %r13,%rdx
  8042102820:	8b 75 a8             	mov    -0x58(%rbp),%esi
  8042102823:	48 b8 7a 0d 10 42 80 	movabs $0x8042100d7a,%rax
  804210282a:	00 00 00 
  804210282d:	ff d0                	call   *%rax
                    (void)entry;
                }
                return 0;
  804210282f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102834:	e9 4f 01 00 00       	jmp    8042102988 <function_by_info+0x693>
                    uintptr_t str_offset = 0;
  8042102839:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8042102840:	00 
                    entry += dwarf_read_abbrev_entry(fn_name_entry, name_form, &str_offset, sizeof(uintptr_t), address_size);
  8042102841:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042102847:	b9 08 00 00 00       	mov    $0x8,%ecx
  804210284c:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  8042102850:	be 0e 00 00 00       	mov    $0xe,%esi
  8042102855:	48 b8 7a 0d 10 42 80 	movabs $0x8042100d7a,%rax
  804210285c:	00 00 00 
  804210285f:	ff d0                	call   *%rax
                    if (buf) put_unaligned((const uint8_t *)addrs->str_begin + str_offset, buf);
  8042102861:	4d 85 ed             	test   %r13,%r13
  8042102864:	74 c9                	je     804210282f <function_by_info+0x53a>
  8042102866:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804210286a:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  804210286e:	48 03 47 40          	add    0x40(%rdi),%rax
  8042102872:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8042102876:	ba 08 00 00 00       	mov    $0x8,%edx
  804210287b:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210287f:	4c 89 ef             	mov    %r13,%rdi
  8042102882:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102889:	00 00 00 
  804210288c:	ff d0                	call   *%rax
  804210288e:	eb 9f                	jmp    804210282f <function_by_info+0x53a>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
  8042102890:	4c 89 e3             	mov    %r12,%rbx
  8042102893:	e9 9e fd ff ff       	jmp    8042102636 <function_by_info+0x341>
    while (byte & 0x80) {
  8042102898:	40 84 ff             	test   %dil,%dil
  804210289b:	79 12                	jns    80421028af <function_by_info+0x5ba>
        byte = *addr++;
  804210289d:	48 f7 d6             	not    %rsi
  80421028a0:	48 01 f2             	add    %rsi,%rdx
  80421028a3:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  80421028a7:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  80421028ab:	84 c9                	test   %cl,%cl
  80421028ad:	78 f4                	js     80421028a3 <function_by_info+0x5ae>
            }
        } else {
            /* Skip if not a subprogram */
            do {
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  80421028af:	48 01 c3             	add    %rax,%rbx
                entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  80421028b2:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80421028b8:	b9 00 00 00 00       	mov    $0x0,%ecx
  80421028bd:	ba 00 00 00 00       	mov    $0x0,%edx
  80421028c2:	44 89 e6             	mov    %r12d,%esi
  80421028c5:	4c 89 f7             	mov    %r14,%rdi
  80421028c8:	41 ff d7             	call   *%r15
  80421028cb:	48 98                	cltq
  80421028cd:	49 01 c6             	add    %rax,%r14
            } while (name || form);
  80421028d0:	4d 09 ec             	or     %r13,%r12
  80421028d3:	0f 84 9d 00 00 00    	je     8042102976 <function_by_info+0x681>
        const uint8_t *curr_abbrev_entry = abbrev_entry;
  80421028d9:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  80421028dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80421028e1:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421028e6:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  80421028ec:	48 83 c2 01          	add    $0x1,%rdx
  80421028f0:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  80421028f4:	48 89 fe             	mov    %rdi,%rsi
  80421028f7:	83 e6 7f             	and    $0x7f,%esi
  80421028fa:	48 d3 e6             	shl    %cl,%rsi
  80421028fd:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8042102900:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102904:	48 89 c6             	mov    %rax,%rsi
  8042102907:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  804210290b:	40 84 ff             	test   %dil,%dil
  804210290e:	79 06                	jns    8042102916 <function_by_info+0x621>
  8042102910:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102914:	76 d6                	jbe    80421028ec <function_by_info+0x5f7>
    while (byte & 0x80) {
  8042102916:	40 84 ff             	test   %dil,%dil
  8042102919:	79 12                	jns    804210292d <function_by_info+0x638>
        byte = *addr++;
  804210291b:	48 f7 d6             	not    %rsi
  804210291e:	48 01 f2             	add    %rsi,%rdx
  8042102921:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042102925:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042102929:	84 c9                	test   %cl,%cl
  804210292b:	78 f4                	js     8042102921 <function_by_info+0x62c>
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  804210292d:	48 01 d8             	add    %rbx,%rax
  8042102930:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8042102933:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042102938:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804210293d:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  8042102943:	48 83 c2 01          	add    $0x1,%rdx
  8042102947:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  804210294b:	48 89 fe             	mov    %rdi,%rsi
  804210294e:	83 e6 7f             	and    $0x7f,%esi
  8042102951:	48 d3 e6             	shl    %cl,%rsi
  8042102954:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  8042102957:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804210295b:	48 89 de             	mov    %rbx,%rsi
  804210295e:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8042102962:	40 84 ff             	test   %dil,%dil
  8042102965:	0f 89 2d ff ff ff    	jns    8042102898 <function_by_info+0x5a3>
  804210296b:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804210296f:	76 d2                	jbe    8042102943 <function_by_info+0x64e>
  8042102971:	e9 22 ff ff ff       	jmp    8042102898 <function_by_info+0x5a3>
  8042102976:	4c 8b 65 a8          	mov    -0x58(%rbp),%r12
  804210297a:	4c 8b 6d a0          	mov    -0x60(%rbp),%r13
  804210297e:	e9 ae fa ff ff       	jmp    8042102431 <function_by_info+0x13c>
        }
    }
    return -E_NO_ENT;
  8042102983:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  8042102988:	48 83 c4 68          	add    $0x68,%rsp
  804210298c:	5b                   	pop    %rbx
  804210298d:	41 5c                	pop    %r12
  804210298f:	41 5d                	pop    %r13
  8042102991:	41 5e                	pop    %r14
  8042102993:	41 5f                	pop    %r15
  8042102995:	5d                   	pop    %rbp
  8042102996:	c3                   	ret
    uint64_t count = sizeof(uint32_t);
  8042102997:	ba 04 00 00 00       	mov    $0x4,%edx
    entry += count = dwarf_entry_len(entry, &len);
  804210299c:	49 01 d6             	add    %rdx,%r14
    const void *entry_end = entry + len;
  804210299f:	4c 01 f0             	add    %r14,%rax
  80421029a2:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  80421029a6:	ba 02 00 00 00       	mov    $0x2,%edx
  80421029ab:	4c 89 f6             	mov    %r14,%rsi
  80421029ae:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421029b2:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421029b9:	00 00 00 
  80421029bc:	ff d0                	call   *%rax
    entry += sizeof(Dwarf_Half);
  80421029be:	49 8d 76 02          	lea    0x2(%r14),%rsi
    assert(version == 4 || version == 2);
  80421029c2:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  80421029c6:	83 e8 02             	sub    $0x2,%eax
  80421029c9:	66 a9 fd ff          	test   $0xfffd,%ax
  80421029cd:	0f 85 d5 f9 ff ff    	jne    80421023a8 <function_by_info+0xb3>
    Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  80421029d3:	ba 04 00 00 00       	mov    $0x4,%edx
  80421029d8:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421029dc:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  80421029e3:	00 00 00 
  80421029e6:	41 ff d4             	call   *%r12
  80421029e9:	8b 5d c8             	mov    -0x38(%rbp),%ebx
    entry += sizeof(uint32_t);
  80421029ec:	49 8d 76 06          	lea    0x6(%r14),%rsi
    Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  80421029f0:	ba 01 00 00 00       	mov    $0x1,%edx
  80421029f5:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421029f9:	41 ff d4             	call   *%r12
    entry += sizeof(Dwarf_Small);
  80421029fc:	49 83 c6 07          	add    $0x7,%r14
    assert(address_size == sizeof(uintptr_t));
  8042102a00:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8042102a04:	0f 85 d3 f9 ff ff    	jne    80421023dd <function_by_info+0xe8>
    const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  8042102a0a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8042102a0e:	48 03 18             	add    (%rax),%rbx
  8042102a11:	49 89 dc             	mov    %rbx,%r12
                entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042102a14:	49 bf 7a 0d 10 42 80 	movabs $0x8042100d7a,%r15
  8042102a1b:	00 00 00 
    while (entry < entry_end) {
  8042102a1e:	e9 0e fa ff ff       	jmp    8042102431 <function_by_info+0x13c>

0000008042102a23 <address_by_fname>:

int
address_by_fname(const struct Dwarf_Addrs *addrs, const char *fname, uintptr_t *offset) {
  8042102a23:	f3 0f 1e fa          	endbr64
  8042102a27:	55                   	push   %rbp
  8042102a28:	48 89 e5             	mov    %rsp,%rbp
  8042102a2b:	41 57                	push   %r15
  8042102a2d:	41 56                	push   %r14
  8042102a2f:	41 55                	push   %r13
  8042102a31:	41 54                	push   %r12
  8042102a33:	53                   	push   %rbx
  8042102a34:	48 83 ec 58          	sub    $0x58,%rsp
  8042102a38:	49 89 ff             	mov    %rdi,%r15
  8042102a3b:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
  8042102a3f:	48 89 f7             	mov    %rsi,%rdi
  8042102a42:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
  8042102a46:	48 89 d3             	mov    %rdx,%rbx
    const int flen = strlen(fname);
  8042102a49:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  8042102a50:	00 00 00 
  8042102a53:	ff d0                	call   *%rax
    if (!flen) return -E_INVAL;
  8042102a55:	85 c0                	test   %eax,%eax
  8042102a57:	0f 84 4c 06 00 00    	je     80421030a9 <address_by_fname+0x686>

    const uint8_t *pubnames_entry = addrs->pubnames_begin;
  8042102a5d:	4d 8b 6f 50          	mov    0x50(%r15),%r13
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
                        if (name == DW_AT_low_pc) {
                            entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
                        } else {
                            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042102a61:	49 bf 7a 0d 10 42 80 	movabs $0x8042100d7a,%r15
  8042102a68:	00 00 00 
  8042102a6b:	49 89 de             	mov    %rbx,%r14
    while (pubnames_entry < addrs->pubnames_end) {
  8042102a6e:	e9 b9 05 00 00       	jmp    804210302c <address_by_fname+0x609>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8042102a73:	49 8d 75 20          	lea    0x20(%r13),%rsi
  8042102a77:	ba 08 00 00 00       	mov    $0x8,%edx
  8042102a7c:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042102a80:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102a87:	00 00 00 
  8042102a8a:	ff d0                	call   *%rax
  8042102a8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            count += sizeof(uint64_t);
  8042102a90:	bb 0c 00 00 00       	mov    $0xc,%ebx
  8042102a95:	e9 09 07 00 00       	jmp    80421031a3 <address_by_fname+0x780>
        assert(version == 2);
  8042102a9a:	48 b9 d2 f4 11 42 80 	movabs $0x804211f4d2,%rcx
  8042102aa1:	00 00 00 
  8042102aa4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042102aab:	00 00 00 
  8042102aae:	be 00 02 00 00       	mov    $0x200,%esi
  8042102ab3:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042102aba:	00 00 00 
  8042102abd:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102ac2:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042102ac9:	00 00 00 
  8042102acc:	41 ff d0             	call   *%r8
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8042102acf:	48 8d 73 26          	lea    0x26(%rbx),%rsi
  8042102ad3:	ba 08 00 00 00       	mov    $0x8,%edx
  8042102ad8:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042102adc:	4c 89 e0             	mov    %r12,%rax
  8042102adf:	ff d0                	call   *%rax
            count += sizeof(uint64_t);
  8042102ae1:	b8 0c 00 00 00       	mov    $0xc,%eax
  8042102ae6:	e9 62 07 00 00       	jmp    804210324d <address_by_fname+0x82a>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8042102aeb:	49 8d 74 24 20       	lea    0x20(%r12),%rsi
  8042102af0:	ba 08 00 00 00       	mov    $0x8,%edx
  8042102af5:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042102af9:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102b00:	00 00 00 
  8042102b03:	ff d0                	call   *%rax
            count += sizeof(uint64_t);
  8042102b05:	b8 0c 00 00 00       	mov    $0xc,%eax
  8042102b0a:	e9 ab 05 00 00       	jmp    80421030ba <address_by_fname+0x697>
                assert(version == 4 || version == 2);
  8042102b0f:	48 b9 c2 f4 11 42 80 	movabs $0x804211f4c2,%rcx
  8042102b16:	00 00 00 
  8042102b19:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042102b20:	00 00 00 
  8042102b23:	be 15 02 00 00       	mov    $0x215,%esi
  8042102b28:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042102b2f:	00 00 00 
  8042102b32:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102b37:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042102b3e:	00 00 00 
  8042102b41:	41 ff d0             	call   *%r8
                assert(address_size == sizeof(uintptr_t));
  8042102b44:	48 b9 58 04 12 42 80 	movabs $0x8042120458,%rcx
  8042102b4b:	00 00 00 
  8042102b4e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042102b55:	00 00 00 
  8042102b58:	be 1b 02 00 00       	mov    $0x21b,%esi
  8042102b5d:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042102b64:	00 00 00 
  8042102b67:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102b6c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042102b73:	00 00 00 
  8042102b76:	41 ff d0             	call   *%r8
    while (byte & 0x80) {
  8042102b79:	45 84 e4             	test   %r12b,%r12b
  8042102b7c:	79 13                	jns    8042102b91 <address_by_fname+0x16e>
        byte = *addr++;
  8042102b7e:	49 f7 d3             	not    %r11
  8042102b81:	4d 01 d8             	add    %r11,%r8
  8042102b84:	41 0f b6 0c 10       	movzbl (%r8,%rdx,1),%ecx
        count++;
  8042102b89:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042102b8d:	84 c9                	test   %cl,%cl
  8042102b8f:	78 f3                	js     8042102b84 <address_by_fname+0x161>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8042102b91:	48 01 f2             	add    %rsi,%rdx
                    } while (name || form);
  8042102b94:	4c 09 d3             	or     %r10,%rbx
  8042102b97:	0f 84 9f 00 00 00    	je     8042102c3c <address_by_fname+0x219>
    uint64_t result = 0;
  8042102b9d:	49 89 d0             	mov    %rdx,%r8
    size_t shift = 0, count = 0;
  8042102ba0:	be 00 00 00 00       	mov    $0x0,%esi
  8042102ba5:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102baa:	41 ba 00 00 00 00    	mov    $0x0,%r10d
        byte = *addr++;
  8042102bb0:	49 83 c0 01          	add    $0x1,%r8
  8042102bb4:	41 0f b6 58 ff       	movzbl -0x1(%r8),%ebx
        result |= (byte & 0x7FULL) << shift;
  8042102bb9:	49 89 db             	mov    %rbx,%r11
  8042102bbc:	41 83 e3 7f          	and    $0x7f,%r11d
  8042102bc0:	49 d3 e3             	shl    %cl,%r11
  8042102bc3:	4d 09 da             	or     %r11,%r10
        shift += 7;
  8042102bc6:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102bca:	49 89 f3             	mov    %rsi,%r11
  8042102bcd:	48 83 c6 01          	add    $0x1,%rsi
    } while (byte & 0x80 && shift < 64);
  8042102bd1:	84 db                	test   %bl,%bl
  8042102bd3:	79 06                	jns    8042102bdb <address_by_fname+0x1b8>
  8042102bd5:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102bd9:	76 d5                	jbe    8042102bb0 <address_by_fname+0x18d>
    while (byte & 0x80) {
  8042102bdb:	84 db                	test   %bl,%bl
  8042102bdd:	79 13                	jns    8042102bf2 <address_by_fname+0x1cf>
        byte = *addr++;
  8042102bdf:	49 f7 d3             	not    %r11
  8042102be2:	4d 01 d8             	add    %r11,%r8
  8042102be5:	41 0f b6 0c 30       	movzbl (%r8,%rsi,1),%ecx
        count++;
  8042102bea:	48 83 c6 01          	add    $0x1,%rsi
    while (byte & 0x80) {
  8042102bee:	84 c9                	test   %cl,%cl
  8042102bf0:	78 f3                	js     8042102be5 <address_by_fname+0x1c2>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8042102bf2:	48 01 d6             	add    %rdx,%rsi
  8042102bf5:	49 89 f0             	mov    %rsi,%r8
    size_t shift = 0, count = 0;
  8042102bf8:	ba 00 00 00 00       	mov    $0x0,%edx
  8042102bfd:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102c02:	bb 00 00 00 00       	mov    $0x0,%ebx
        byte = *addr++;
  8042102c07:	49 83 c0 01          	add    $0x1,%r8
  8042102c0b:	45 0f b6 60 ff       	movzbl -0x1(%r8),%r12d
        result |= (byte & 0x7FULL) << shift;
  8042102c10:	4d 89 e3             	mov    %r12,%r11
  8042102c13:	41 83 e3 7f          	and    $0x7f,%r11d
  8042102c17:	49 d3 e3             	shl    %cl,%r11
  8042102c1a:	4c 09 db             	or     %r11,%rbx
        shift += 7;
  8042102c1d:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102c21:	49 89 d3             	mov    %rdx,%r11
  8042102c24:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  8042102c28:	45 84 e4             	test   %r12b,%r12b
  8042102c2b:	0f 89 48 ff ff ff    	jns    8042102b79 <address_by_fname+0x156>
  8042102c31:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102c35:	76 d0                	jbe    8042102c07 <address_by_fname+0x1e4>
  8042102c37:	e9 3d ff ff ff       	jmp    8042102b79 <address_by_fname+0x156>
                while (abbrev_entry < addrs->abbrev_end) {
  8042102c3c:	4c 39 ca             	cmp    %r9,%rdx
  8042102c3f:	0f 83 bc 00 00 00    	jae    8042102d01 <address_by_fname+0x2de>
    uint64_t result = 0;
  8042102c45:	48 89 d6             	mov    %rdx,%rsi
    size_t shift = 0, count = 0;
  8042102c48:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102c4d:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102c52:	41 ba 00 00 00 00    	mov    $0x0,%r10d
        byte = *addr++;
  8042102c58:	48 83 c6 01          	add    $0x1,%rsi
  8042102c5c:	44 0f b6 5e ff       	movzbl -0x1(%rsi),%r11d
        result |= (byte & 0x7FULL) << shift;
  8042102c61:	4d 89 d8             	mov    %r11,%r8
  8042102c64:	41 83 e0 7f          	and    $0x7f,%r8d
  8042102c68:	49 d3 e0             	shl    %cl,%r8
  8042102c6b:	4d 09 c2             	or     %r8,%r10
        shift += 7;
  8042102c6e:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102c72:	49 89 c0             	mov    %rax,%r8
  8042102c75:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042102c79:	45 84 db             	test   %r11b,%r11b
  8042102c7c:	79 06                	jns    8042102c84 <address_by_fname+0x261>
  8042102c7e:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102c82:	76 d4                	jbe    8042102c58 <address_by_fname+0x235>
    while (byte & 0x80) {
  8042102c84:	45 84 db             	test   %r11b,%r11b
  8042102c87:	79 12                	jns    8042102c9b <address_by_fname+0x278>
        byte = *addr++;
  8042102c89:	49 f7 d0             	not    %r8
  8042102c8c:	4c 01 c6             	add    %r8,%rsi
  8042102c8f:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
        count++;
  8042102c93:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042102c97:	84 c9                	test   %cl,%cl
  8042102c99:	78 f4                	js     8042102c8f <address_by_fname+0x26c>
                    abbrev_entry += dwarf_read_uleb128(abbrev_entry, &table_abbrev_code);
  8042102c9b:	48 8d 34 02          	lea    (%rdx,%rax,1),%rsi
  8042102c9f:	49 89 f0             	mov    %rsi,%r8
    size_t shift = 0, count = 0;
  8042102ca2:	ba 00 00 00 00       	mov    $0x0,%edx
  8042102ca7:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102cac:	b8 00 00 00 00       	mov    $0x0,%eax
        byte = *addr++;
  8042102cb1:	49 83 c0 01          	add    $0x1,%r8
  8042102cb5:	41 0f b6 58 ff       	movzbl -0x1(%r8),%ebx
        result |= (byte & 0x7FULL) << shift;
  8042102cba:	49 89 db             	mov    %rbx,%r11
  8042102cbd:	41 83 e3 7f          	and    $0x7f,%r11d
  8042102cc1:	49 d3 e3             	shl    %cl,%r11
  8042102cc4:	4c 09 d8             	or     %r11,%rax
        shift += 7;
  8042102cc7:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102ccb:	49 89 d3             	mov    %rdx,%r11
  8042102cce:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  8042102cd2:	84 db                	test   %bl,%bl
  8042102cd4:	79 06                	jns    8042102cdc <address_by_fname+0x2b9>
  8042102cd6:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102cda:	76 d5                	jbe    8042102cb1 <address_by_fname+0x28e>
    while (byte & 0x80) {
  8042102cdc:	84 db                	test   %bl,%bl
  8042102cde:	79 13                	jns    8042102cf3 <address_by_fname+0x2d0>
        byte = *addr++;
  8042102ce0:	49 f7 d3             	not    %r11
  8042102ce3:	4d 01 d8             	add    %r11,%r8
  8042102ce6:	41 0f b6 0c 10       	movzbl (%r8,%rdx,1),%ecx
        count++;
  8042102ceb:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042102cef:	84 c9                	test   %cl,%cl
  8042102cf1:	78 f3                	js     8042102ce6 <address_by_fname+0x2c3>
                    abbrev_entry += sizeof(Dwarf_Small);
  8042102cf3:	48 8d 54 16 01       	lea    0x1(%rsi,%rdx,1),%rdx
                    if (table_abbrev_code == abbrev_code) break;
  8042102cf8:	4c 39 d7             	cmp    %r10,%rdi
  8042102cfb:	0f 85 9c fe ff ff    	jne    8042102b9d <address_by_fname+0x17a>
                if (tag == DW_TAG_subprogram) {
  8042102d01:	48 89 d3             	mov    %rdx,%rbx
  8042102d04:	48 83 f8 2e          	cmp    $0x2e,%rax
  8042102d08:	74 09                	je     8042102d13 <address_by_fname+0x2f0>
  8042102d0a:	4c 89 6d b8          	mov    %r13,-0x48(%rbp)
  8042102d0e:	e9 76 01 00 00       	jmp    8042102e89 <address_by_fname+0x466>
                    uintptr_t low_pc = 0;
  8042102d13:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8042102d1a:	00 
  8042102d1b:	4c 89 6d 88          	mov    %r13,-0x78(%rbp)
  8042102d1f:	eb 4b                	jmp    8042102d6c <address_by_fname+0x349>
  8042102d21:	40 84 ff             	test   %dil,%dil
  8042102d24:	79 12                	jns    8042102d38 <address_by_fname+0x315>
        byte = *addr++;
  8042102d26:	48 f7 d6             	not    %rsi
  8042102d29:	48 01 f2             	add    %rsi,%rdx
  8042102d2c:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8042102d30:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8042102d34:	84 c9                	test   %cl,%cl
  8042102d36:	78 f4                	js     8042102d2c <address_by_fname+0x309>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8042102d38:	48 01 c3             	add    %rax,%rbx
                        if (name == DW_AT_low_pc) {
  8042102d3b:	49 83 fd 11          	cmp    $0x11,%r13
  8042102d3f:	0f 84 c4 00 00 00    	je     8042102e09 <address_by_fname+0x3e6>
                            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042102d45:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042102d4b:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042102d50:	ba 00 00 00 00       	mov    $0x0,%edx
  8042102d55:	44 89 e6             	mov    %r12d,%esi
  8042102d58:	4c 89 f7             	mov    %r14,%rdi
  8042102d5b:	41 ff d7             	call   *%r15
  8042102d5e:	48 98                	cltq
  8042102d60:	49 01 c6             	add    %rax,%r14
                        }
                    } while (name || form);
  8042102d63:	4d 09 ec             	or     %r13,%r12
  8042102d66:	0f 84 bf 00 00 00    	je     8042102e2b <address_by_fname+0x408>
    uint64_t result = 0;
  8042102d6c:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8042102d6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102d74:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102d79:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8042102d7f:	48 83 c2 01          	add    $0x1,%rdx
  8042102d83:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042102d87:	48 89 fe             	mov    %rdi,%rsi
  8042102d8a:	83 e6 7f             	and    $0x7f,%esi
  8042102d8d:	48 d3 e6             	shl    %cl,%rsi
  8042102d90:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8042102d93:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102d97:	48 89 c6             	mov    %rax,%rsi
  8042102d9a:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042102d9e:	40 84 ff             	test   %dil,%dil
  8042102da1:	79 06                	jns    8042102da9 <address_by_fname+0x386>
  8042102da3:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102da7:	76 d6                	jbe    8042102d7f <address_by_fname+0x35c>
    while (byte & 0x80) {
  8042102da9:	40 84 ff             	test   %dil,%dil
  8042102dac:	79 12                	jns    8042102dc0 <address_by_fname+0x39d>
        byte = *addr++;
  8042102dae:	48 f7 d6             	not    %rsi
  8042102db1:	48 01 f2             	add    %rsi,%rdx
  8042102db4:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042102db8:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042102dbc:	84 c9                	test   %cl,%cl
  8042102dbe:	78 f4                	js     8042102db4 <address_by_fname+0x391>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8042102dc0:	48 01 d8             	add    %rbx,%rax
  8042102dc3:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8042102dc6:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042102dcb:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102dd0:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  8042102dd6:	48 83 c2 01          	add    $0x1,%rdx
  8042102dda:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042102dde:	48 89 fe             	mov    %rdi,%rsi
  8042102de1:	83 e6 7f             	and    $0x7f,%esi
  8042102de4:	48 d3 e6             	shl    %cl,%rsi
  8042102de7:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  8042102dea:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102dee:	48 89 de             	mov    %rbx,%rsi
  8042102df1:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8042102df5:	40 84 ff             	test   %dil,%dil
  8042102df8:	0f 89 23 ff ff ff    	jns    8042102d21 <address_by_fname+0x2fe>
  8042102dfe:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102e02:	76 d2                	jbe    8042102dd6 <address_by_fname+0x3b3>
  8042102e04:	e9 18 ff ff ff       	jmp    8042102d21 <address_by_fname+0x2fe>
                            entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
  8042102e09:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042102e0f:	b9 08 00 00 00       	mov    $0x8,%ecx
  8042102e14:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  8042102e18:	44 89 e6             	mov    %r12d,%esi
  8042102e1b:	4c 89 f7             	mov    %r14,%rdi
  8042102e1e:	41 ff d7             	call   *%r15
  8042102e21:	48 98                	cltq
  8042102e23:	49 01 c6             	add    %rax,%r14
                    } while (name || form);
  8042102e26:	e9 41 ff ff ff       	jmp    8042102d6c <address_by_fname+0x349>
                    
                    if (low_pc) {
  8042102e2b:	4c 8b 6d 88          	mov    -0x78(%rbp),%r13
  8042102e2f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042102e33:	48 85 c0             	test   %rax,%rax
  8042102e36:	0f 84 ee 00 00 00    	je     8042102f2a <address_by_fname+0x507>
                        *offset = low_pc;
  8042102e3c:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
  8042102e40:	48 89 03             	mov    %rax,(%rbx)
                        return 0;
  8042102e43:	e9 b7 01 00 00       	jmp    8042102fff <address_by_fname+0x5dc>
    while (byte & 0x80) {
  8042102e48:	40 84 ff             	test   %dil,%dil
  8042102e4b:	79 12                	jns    8042102e5f <address_by_fname+0x43c>
        byte = *addr++;
  8042102e4d:	48 f7 d6             	not    %rsi
  8042102e50:	48 01 f2             	add    %rsi,%rdx
  8042102e53:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8042102e57:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8042102e5b:	84 c9                	test   %cl,%cl
  8042102e5d:	78 f4                	js     8042102e53 <address_by_fname+0x430>
                    }
                } else {
                    /* Skip if not a subprogram or label */
                    do {
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &form);
  8042102e5f:	48 01 c3             	add    %rax,%rbx
                        entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042102e62:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042102e68:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042102e6d:	ba 00 00 00 00       	mov    $0x0,%edx
  8042102e72:	44 89 e6             	mov    %r12d,%esi
  8042102e75:	4c 89 f7             	mov    %r14,%rdi
  8042102e78:	41 ff d7             	call   *%r15
  8042102e7b:	48 98                	cltq
  8042102e7d:	49 01 c6             	add    %rax,%r14
                    } while (name || form);
  8042102e80:	4d 09 ec             	or     %r13,%r12
  8042102e83:	0f 84 9d 00 00 00    	je     8042102f26 <address_by_fname+0x503>
    uint64_t result = 0;
  8042102e89:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8042102e8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102e91:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102e96:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8042102e9c:	48 83 c2 01          	add    $0x1,%rdx
  8042102ea0:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042102ea4:	48 89 fe             	mov    %rdi,%rsi
  8042102ea7:	83 e6 7f             	and    $0x7f,%esi
  8042102eaa:	48 d3 e6             	shl    %cl,%rsi
  8042102ead:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  8042102eb0:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102eb4:	48 89 c6             	mov    %rax,%rsi
  8042102eb7:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042102ebb:	40 84 ff             	test   %dil,%dil
  8042102ebe:	79 06                	jns    8042102ec6 <address_by_fname+0x4a3>
  8042102ec0:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102ec4:	76 d6                	jbe    8042102e9c <address_by_fname+0x479>
    while (byte & 0x80) {
  8042102ec6:	40 84 ff             	test   %dil,%dil
  8042102ec9:	79 12                	jns    8042102edd <address_by_fname+0x4ba>
        byte = *addr++;
  8042102ecb:	48 f7 d6             	not    %rsi
  8042102ece:	48 01 f2             	add    %rsi,%rdx
  8042102ed1:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042102ed5:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042102ed9:	84 c9                	test   %cl,%cl
  8042102edb:	78 f4                	js     8042102ed1 <address_by_fname+0x4ae>
                        abbrev_entry += dwarf_read_uleb128(abbrev_entry, &name);
  8042102edd:	48 01 d8             	add    %rbx,%rax
  8042102ee0:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8042102ee3:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042102ee8:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042102eed:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  8042102ef3:	48 83 c2 01          	add    $0x1,%rdx
  8042102ef7:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042102efb:	48 89 fe             	mov    %rdi,%rsi
  8042102efe:	83 e6 7f             	and    $0x7f,%esi
  8042102f01:	48 d3 e6             	shl    %cl,%rsi
  8042102f04:	49 09 f4             	or     %rsi,%r12
        shift += 7;
  8042102f07:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042102f0b:	48 89 de             	mov    %rbx,%rsi
  8042102f0e:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8042102f12:	40 84 ff             	test   %dil,%dil
  8042102f15:	0f 89 2d ff ff ff    	jns    8042102e48 <address_by_fname+0x425>
  8042102f1b:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042102f1f:	76 d2                	jbe    8042102ef3 <address_by_fname+0x4d0>
  8042102f21:	e9 22 ff ff ff       	jmp    8042102e48 <address_by_fname+0x425>
  8042102f26:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
                }
            }
            pubnames_entry += strlen((const char *)pubnames_entry) + 1;
  8042102f2a:	4c 89 ef             	mov    %r13,%rdi
  8042102f2d:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  8042102f34:	00 00 00 
  8042102f37:	ff d0                	call   *%rax
  8042102f39:	4d 8d 6c 05 01       	lea    0x1(%r13,%rax,1),%r13
        while (pubnames_entry < pubnames_entry_end) {
  8042102f3e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042102f42:	49 39 c5             	cmp    %rax,%r13
  8042102f45:	0f 83 c6 00 00 00    	jae    8042103011 <address_by_fname+0x5ee>
            func_offset = get_unaligned(pubnames_entry, uint32_t);
  8042102f4b:	ba 04 00 00 00       	mov    $0x4,%edx
  8042102f50:	4c 89 ee             	mov    %r13,%rsi
  8042102f53:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042102f57:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102f5e:	00 00 00 
  8042102f61:	ff d0                	call   *%rax
  8042102f63:	44 8b 75 c8          	mov    -0x38(%rbp),%r14d
            pubnames_entry += sizeof(uint32_t);
  8042102f67:	49 83 c5 04          	add    $0x4,%r13
            if (!func_offset) break;
  8042102f6b:	4d 85 f6             	test   %r14,%r14
  8042102f6e:	0f 84 b4 00 00 00    	je     8042103028 <address_by_fname+0x605>
            if (!strcmp(fname, (const char *)pubnames_entry)) {
  8042102f74:	4c 89 ee             	mov    %r13,%rsi
  8042102f77:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8042102f7b:	48 b8 90 0b 11 42 80 	movabs $0x8042110b90,%rax
  8042102f82:	00 00 00 
  8042102f85:	ff d0                	call   *%rax
  8042102f87:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042102f8a:	85 c0                	test   %eax,%eax
  8042102f8c:	75 9c                	jne    8042102f2a <address_by_fname+0x507>
                const uint8_t *entry = addrs->info_begin + cu_offset;
  8042102f8e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042102f92:	4c 8b 65 90          	mov    -0x70(%rbp),%r12
  8042102f96:	4c 03 60 20          	add    0x20(%rax),%r12
                const uint8_t *func_entry = entry + func_offset;
  8042102f9a:	4d 01 e6             	add    %r12,%r14
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042102f9d:	ba 04 00 00 00       	mov    $0x4,%edx
  8042102fa2:	4c 89 e6             	mov    %r12,%rsi
  8042102fa5:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042102fa9:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042102fb0:	00 00 00 
  8042102fb3:	ff d0                	call   *%rax
  8042102fb5:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042102fb8:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  8042102fbf:	ff ff ff 
  8042102fc2:	48 01 d0             	add    %rdx,%rax
  8042102fc5:	48 83 f8 0f          	cmp    $0xf,%rax
  8042102fc9:	0f 87 e6 00 00 00    	ja     80421030b5 <address_by_fname+0x692>
        if (initial_len == DW_EXT_DWARF64) {
  8042102fcf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042102fd4:	48 39 c2             	cmp    %rax,%rdx
  8042102fd7:	0f 84 0e fb ff ff    	je     8042102aeb <address_by_fname+0xc8>
            cprintf("Unknown DWARF extension\n");
  8042102fdd:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  8042102fe4:	00 00 00 
  8042102fe7:	b8 00 00 00 00       	mov    $0x0,%eax
  8042102fec:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042102ff3:	00 00 00 
  8042102ff6:	ff d2                	call   *%rdx
                if (!count) return -E_BAD_DWARF;
  8042102ff8:	c7 45 b8 fa ff ff ff 	movl   $0xfffffffa,-0x48(%rbp)
        }
    }
    return -E_NO_ENT;
}
  8042102fff:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042103002:	48 83 c4 58          	add    $0x58,%rsp
  8042103006:	5b                   	pop    %rbx
  8042103007:	41 5c                	pop    %r12
  8042103009:	41 5d                	pop    %r13
  804210300b:	41 5e                	pop    %r14
  804210300d:	41 5f                	pop    %r15
  804210300f:	5d                   	pop    %rbp
  8042103010:	c3                   	ret
  8042103011:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
    while (pubnames_entry < addrs->pubnames_end) {
  8042103015:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042103019:	4c 3b 68 58          	cmp    0x58(%rax),%r13
  804210301d:	72 17                	jb     8042103036 <address_by_fname+0x613>
    return -E_NO_ENT;
  804210301f:	c7 45 b8 f6 ff ff ff 	movl   $0xfffffff6,-0x48(%rbp)
  8042103026:	eb d7                	jmp    8042102fff <address_by_fname+0x5dc>
  8042103028:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
    while (pubnames_entry < addrs->pubnames_end) {
  804210302c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042103030:	4c 3b 68 58          	cmp    0x58(%rax),%r13
  8042103034:	73 67                	jae    804210309d <address_by_fname+0x67a>
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042103036:	ba 04 00 00 00       	mov    $0x4,%edx
  804210303b:	4c 89 ee             	mov    %r13,%rsi
  804210303e:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103042:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042103049:	00 00 00 
  804210304c:	ff d0                	call   *%rax
  804210304e:	8b 45 c8             	mov    -0x38(%rbp),%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042103051:	48 ba 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdx
  8042103058:	ff ff ff 
  804210305b:	48 01 c2             	add    %rax,%rdx
  804210305e:	48 83 fa 0f          	cmp    $0xf,%rdx
  8042103062:	0f 87 36 01 00 00    	ja     804210319e <address_by_fname+0x77b>
        if (initial_len == DW_EXT_DWARF64) {
  8042103068:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  804210306d:	48 39 d0             	cmp    %rdx,%rax
  8042103070:	0f 84 fd f9 ff ff    	je     8042102a73 <address_by_fname+0x50>
            cprintf("Unknown DWARF extension\n");
  8042103076:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  804210307d:	00 00 00 
  8042103080:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103085:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210308c:	00 00 00 
  804210308f:	ff d2                	call   *%rdx
        if (!count) return -E_BAD_DWARF;
  8042103091:	c7 45 b8 fa ff ff ff 	movl   $0xfffffffa,-0x48(%rbp)
  8042103098:	e9 62 ff ff ff       	jmp    8042102fff <address_by_fname+0x5dc>
    return -E_NO_ENT;
  804210309d:	c7 45 b8 f6 ff ff ff 	movl   $0xfffffff6,-0x48(%rbp)
  80421030a4:	e9 56 ff ff ff       	jmp    8042102fff <address_by_fname+0x5dc>
    if (!flen) return -E_INVAL;
  80421030a9:	c7 45 b8 fd ff ff ff 	movl   $0xfffffffd,-0x48(%rbp)
  80421030b0:	e9 4a ff ff ff       	jmp    8042102fff <address_by_fname+0x5dc>
    uint64_t count = sizeof(uint32_t);
  80421030b5:	b8 04 00 00 00       	mov    $0x4,%eax
                entry += count = dwarf_entry_len(entry, &len);
  80421030ba:	49 01 c4             	add    %rax,%r12
                Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  80421030bd:	ba 02 00 00 00       	mov    $0x2,%edx
  80421030c2:	4c 89 e6             	mov    %r12,%rsi
  80421030c5:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421030c9:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421030d0:	00 00 00 
  80421030d3:	ff d0                	call   *%rax
                assert(version == 4 || version == 2);
  80421030d5:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  80421030d9:	83 e8 02             	sub    $0x2,%eax
  80421030dc:	66 a9 fd ff          	test   $0xfffd,%ax
  80421030e0:	0f 85 29 fa ff ff    	jne    8042102b0f <address_by_fname+0xec>
                entry += sizeof(Dwarf_Half);
  80421030e6:	49 8d 74 24 02       	lea    0x2(%r12),%rsi
                Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  80421030eb:	ba 04 00 00 00       	mov    $0x4,%edx
  80421030f0:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421030f4:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421030fb:	00 00 00 
  80421030fe:	ff d0                	call   *%rax
  8042103100:	8b 5d c8             	mov    -0x38(%rbp),%ebx
                const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  8042103103:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8042103107:	48 03 1f             	add    (%rdi),%rbx
                entry += sizeof(uint32_t);
  804210310a:	49 8d 74 24 06       	lea    0x6(%r12),%rsi
                Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  804210310f:	ba 01 00 00 00       	mov    $0x1,%edx
  8042103114:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103118:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210311f:	00 00 00 
  8042103122:	ff d0                	call   *%rax
                assert(address_size == sizeof(uintptr_t));
  8042103124:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8042103128:	0f 85 16 fa ff ff    	jne    8042102b44 <address_by_fname+0x121>
  804210312e:	4c 89 f2             	mov    %r14,%rdx
    size_t shift = 0, count = 0;
  8042103131:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103136:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804210313b:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  8042103140:	48 83 c2 01          	add    $0x1,%rdx
  8042103144:	44 0f b6 42 ff       	movzbl -0x1(%rdx),%r8d
        result |= (byte & 0x7FULL) << shift;
  8042103149:	4c 89 c6             	mov    %r8,%rsi
  804210314c:	83 e6 7f             	and    $0x7f,%esi
  804210314f:	48 d3 e6             	shl    %cl,%rsi
  8042103152:	48 09 f7             	or     %rsi,%rdi
        shift += 7;
  8042103155:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042103159:	48 89 c6             	mov    %rax,%rsi
  804210315c:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042103160:	45 84 c0             	test   %r8b,%r8b
  8042103163:	79 06                	jns    804210316b <address_by_fname+0x748>
  8042103165:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103169:	76 d5                	jbe    8042103140 <address_by_fname+0x71d>
    while (byte & 0x80) {
  804210316b:	45 84 c0             	test   %r8b,%r8b
  804210316e:	79 12                	jns    8042103182 <address_by_fname+0x75f>
        byte = *addr++;
  8042103170:	48 f7 d6             	not    %rsi
  8042103173:	48 01 f2             	add    %rsi,%rdx
  8042103176:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  804210317a:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804210317e:	84 c9                	test   %cl,%cl
  8042103180:	78 f4                	js     8042103176 <address_by_fname+0x753>
                entry += dwarf_read_uleb128(entry, &abbrev_code);
  8042103182:	49 01 c6             	add    %rax,%r14
                while (abbrev_entry < addrs->abbrev_end) {
  8042103185:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042103189:	4c 8b 48 08          	mov    0x8(%rax),%r9
  804210318d:	4c 39 cb             	cmp    %r9,%rbx
  8042103190:	0f 83 74 fb ff ff    	jae    8042102d0a <address_by_fname+0x2e7>
  8042103196:	48 89 da             	mov    %rbx,%rdx
  8042103199:	e9 a7 fa ff ff       	jmp    8042102c45 <address_by_fname+0x222>
    uint64_t count = sizeof(uint32_t);
  804210319e:	bb 04 00 00 00       	mov    $0x4,%ebx
        pubnames_entry += count;
  80421031a3:	4c 01 eb             	add    %r13,%rbx
        const uint8_t *pubnames_entry_end = pubnames_entry + len;
  80421031a6:	48 01 d8             	add    %rbx,%rax
  80421031a9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
        Dwarf_Half version = get_unaligned(pubnames_entry, Dwarf_Half);
  80421031ad:	ba 02 00 00 00       	mov    $0x2,%edx
  80421031b2:	48 89 de             	mov    %rbx,%rsi
  80421031b5:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421031b9:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421031c0:	00 00 00 
  80421031c3:	ff d0                	call   *%rax
        assert(version == 2);
  80421031c5:	66 83 7d c8 02       	cmpw   $0x2,-0x38(%rbp)
  80421031ca:	0f 85 ca f8 ff ff    	jne    8042102a9a <address_by_fname+0x77>
        pubnames_entry += sizeof(Dwarf_Half);
  80421031d0:	48 8d 73 02          	lea    0x2(%rbx),%rsi
        cu_offset = get_unaligned(pubnames_entry, uint32_t);
  80421031d4:	ba 04 00 00 00       	mov    $0x4,%edx
  80421031d9:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421031dd:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  80421031e4:	00 00 00 
  80421031e7:	41 ff d4             	call   *%r12
  80421031ea:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80421031ed:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        pubnames_entry += sizeof(uint32_t);
  80421031f1:	4c 8d 6b 06          	lea    0x6(%rbx),%r13
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80421031f5:	ba 04 00 00 00       	mov    $0x4,%edx
  80421031fa:	4c 89 ee             	mov    %r13,%rsi
  80421031fd:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103201:	41 ff d4             	call   *%r12
  8042103204:	8b 4d c8             	mov    -0x38(%rbp),%ecx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042103207:	48 ba 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdx
  804210320e:	ff ff ff 
  8042103211:	48 01 ca             	add    %rcx,%rdx
    uint64_t count = sizeof(uint32_t);
  8042103214:	b8 04 00 00 00       	mov    $0x4,%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042103219:	48 83 fa 0f          	cmp    $0xf,%rdx
  804210321d:	77 2e                	ja     804210324d <address_by_fname+0x82a>
        if (initial_len == DW_EXT_DWARF64) {
  804210321f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042103224:	48 39 c1             	cmp    %rax,%rcx
  8042103227:	0f 84 a2 f8 ff ff    	je     8042102acf <address_by_fname+0xac>
            cprintf("Unknown DWARF extension\n");
  804210322d:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  8042103234:	00 00 00 
  8042103237:	b8 00 00 00 00       	mov    $0x0,%eax
  804210323c:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042103243:	00 00 00 
  8042103246:	ff d2                	call   *%rdx
            count = 0;
  8042103248:	b8 00 00 00 00       	mov    $0x0,%eax
        pubnames_entry += count;
  804210324d:	49 01 c5             	add    %rax,%r13
        while (pubnames_entry < pubnames_entry_end) {
  8042103250:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042103254:	49 39 c5             	cmp    %rax,%r13
  8042103257:	0f 83 b8 fd ff ff    	jae    8042103015 <address_by_fname+0x5f2>
            if (!strcmp(fname, (const char *)pubnames_entry)) {
  804210325d:	4c 89 75 a0          	mov    %r14,-0x60(%rbp)
  8042103261:	e9 e5 fc ff ff       	jmp    8042102f4b <address_by_fname+0x528>

0000008042103266 <naive_address_by_fname>:

int
naive_address_by_fname(const struct Dwarf_Addrs *addrs, const char *fname, uintptr_t *offset) {
  8042103266:	f3 0f 1e fa          	endbr64
  804210326a:	55                   	push   %rbp
  804210326b:	48 89 e5             	mov    %rsp,%rbp
  804210326e:	41 57                	push   %r15
  8042103270:	41 56                	push   %r14
  8042103272:	41 55                	push   %r13
  8042103274:	41 54                	push   %r12
  8042103276:	53                   	push   %rbx
  8042103277:	48 83 ec 58          	sub    $0x58,%rsp
  804210327b:	49 89 ff             	mov    %rdi,%r15
  804210327e:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
  8042103282:	48 89 f7             	mov    %rsi,%rdi
  8042103285:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8042103289:	48 89 d3             	mov    %rdx,%rbx
    const int flen = strlen(fname);
  804210328c:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  8042103293:	00 00 00 
  8042103296:	ff d0                	call   *%rax
    if (!flen) return -E_INVAL;
  8042103298:	85 c0                	test   %eax,%eax
  804210329a:	0f 84 44 06 00 00    	je     80421038e4 <naive_address_by_fname+0x67e>

    for (const uint8_t *entry = addrs->info_begin; (const unsigned char *)entry < addrs->info_end;) {
  80421032a0:	4d 8b 77 20          	mov    0x20(%r15),%r14
  80421032a4:	4d 3b 77 28          	cmp    0x28(%r15),%r14
  80421032a8:	0f 82 c4 05 00 00    	jb     8042103872 <naive_address_by_fname+0x60c>
                } while (name || form);
            }
        }
    }

    return -E_NO_ENT;
  80421032ae:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80421032b3:	e9 16 06 00 00       	jmp    80421038ce <naive_address_by_fname+0x668>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  80421032b8:	49 8d 76 20          	lea    0x20(%r14),%rsi
  80421032bc:	ba 08 00 00 00       	mov    $0x8,%edx
  80421032c1:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421032c5:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421032cc:	00 00 00 
  80421032cf:	ff d0                	call   *%rax
  80421032d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            count += sizeof(uint64_t);
  80421032d5:	41 bc 0c 00 00 00    	mov    $0xc,%r12d
  80421032db:	e9 11 06 00 00       	jmp    80421038f1 <naive_address_by_fname+0x68b>
        assert(version == 4 || version == 2);
  80421032e0:	48 b9 c2 f4 11 42 80 	movabs $0x804211f4c2,%rcx
  80421032e7:	00 00 00 
  80421032ea:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421032f1:	00 00 00 
  80421032f4:	be 6a 02 00 00       	mov    $0x26a,%esi
  80421032f9:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042103300:	00 00 00 
  8042103303:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103308:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210330f:	00 00 00 
  8042103312:	41 ff d0             	call   *%r8
        assert(address_size == sizeof(uintptr_t));
  8042103315:	48 b9 58 04 12 42 80 	movabs $0x8042120458,%rcx
  804210331c:	00 00 00 
  804210331f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042103326:	00 00 00 
  8042103329:	be 6f 02 00 00       	mov    $0x26f,%esi
  804210332e:	48 bf f4 f4 11 42 80 	movabs $0x804211f4f4,%rdi
  8042103335:	00 00 00 
  8042103338:	b8 00 00 00 00       	mov    $0x0,%eax
  804210333d:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042103344:	00 00 00 
  8042103347:	41 ff d0             	call   *%r8
    while (byte & 0x80) {
  804210334a:	45 84 c0             	test   %r8b,%r8b
  804210334d:	79 12                	jns    8042103361 <naive_address_by_fname+0xfb>
        byte = *addr++;
  804210334f:	48 f7 d6             	not    %rsi
  8042103352:	48 01 f2             	add    %rsi,%rdx
  8042103355:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042103359:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804210335d:	84 c9                	test   %cl,%cl
  804210335f:	78 f4                	js     8042103355 <naive_address_by_fname+0xef>
            entry += count;
  8042103361:	89 c0                	mov    %eax,%eax
  8042103363:	49 01 c6             	add    %rax,%r14
            if (!abbrev_code) continue;
  8042103366:	48 85 ff             	test   %rdi,%rdi
  8042103369:	75 4c                	jne    80421033b7 <naive_address_by_fname+0x151>
        while (entry < entry_end) {
  804210336b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804210336f:	49 39 c6             	cmp    %rax,%r14
  8042103372:	0f 83 ec 04 00 00    	jae    8042103864 <naive_address_by_fname+0x5fe>
  8042103378:	4c 89 f2             	mov    %r14,%rdx
    size_t shift = 0, count = 0;
  804210337b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103380:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042103385:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  804210338a:	48 83 c2 01          	add    $0x1,%rdx
  804210338e:	44 0f b6 42 ff       	movzbl -0x1(%rdx),%r8d
        result |= (byte & 0x7FULL) << shift;
  8042103393:	4c 89 c6             	mov    %r8,%rsi
  8042103396:	83 e6 7f             	and    $0x7f,%esi
  8042103399:	48 d3 e6             	shl    %cl,%rsi
  804210339c:	48 09 f7             	or     %rsi,%rdi
        shift += 7;
  804210339f:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80421033a3:	48 89 c6             	mov    %rax,%rsi
  80421033a6:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80421033aa:	45 84 c0             	test   %r8b,%r8b
  80421033ad:	79 9b                	jns    804210334a <naive_address_by_fname+0xe4>
  80421033af:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421033b3:	76 d5                	jbe    804210338a <naive_address_by_fname+0x124>
  80421033b5:	eb 93                	jmp    804210334a <naive_address_by_fname+0xe4>
            while ((const unsigned char *)curr_abbrev_entry < addrs->abbrev_end) {
  80421033b7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80421033bb:	4c 8b 48 08          	mov    0x8(%rax),%r9
  80421033bf:	4d 39 cf             	cmp    %r9,%r15
  80421033c2:	0f 83 ac 03 00 00    	jae    8042103774 <naive_address_by_fname+0x50e>
            const uint8_t *curr_abbrev_entry = abbrev_entry;
  80421033c8:	4c 89 75 b8          	mov    %r14,-0x48(%rbp)
  80421033cc:	4c 89 fa             	mov    %r15,%rdx
  80421033cf:	e9 ce 00 00 00       	jmp    80421034a2 <naive_address_by_fname+0x23c>
    while (byte & 0x80) {
  80421033d4:	45 84 f6             	test   %r14b,%r14b
  80421033d7:	79 13                	jns    80421033ec <naive_address_by_fname+0x186>
        byte = *addr++;
  80421033d9:	48 f7 d3             	not    %rbx
  80421033dc:	49 01 da             	add    %rbx,%r10
  80421033df:	41 0f b6 0c 12       	movzbl (%r10,%rdx,1),%ecx
        count++;
  80421033e4:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  80421033e8:	84 c9                	test   %cl,%cl
  80421033ea:	78 f3                	js     80421033df <naive_address_by_fname+0x179>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  80421033ec:	4c 01 c2             	add    %r8,%rdx
                } while (name || form);
  80421033ef:	4d 09 dd             	or     %r11,%r13
  80421033f2:	0f 84 a1 00 00 00    	je     8042103499 <naive_address_by_fname+0x233>
    uint64_t result = 0;
  80421033f8:	49 89 d2             	mov    %rdx,%r10
    size_t shift = 0, count = 0;
  80421033fb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8042103401:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042103406:	41 bb 00 00 00 00    	mov    $0x0,%r11d
        byte = *addr++;
  804210340c:	49 83 c2 01          	add    $0x1,%r10
  8042103410:	45 0f b6 6a ff       	movzbl -0x1(%r10),%r13d
        result |= (byte & 0x7FULL) << shift;
  8042103415:	4c 89 eb             	mov    %r13,%rbx
  8042103418:	83 e3 7f             	and    $0x7f,%ebx
  804210341b:	48 d3 e3             	shl    %cl,%rbx
  804210341e:	49 09 db             	or     %rbx,%r11
        shift += 7;
  8042103421:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042103425:	4c 89 c3             	mov    %r8,%rbx
  8042103428:	49 83 c0 01          	add    $0x1,%r8
    } while (byte & 0x80 && shift < 64);
  804210342c:	45 84 ed             	test   %r13b,%r13b
  804210342f:	79 06                	jns    8042103437 <naive_address_by_fname+0x1d1>
  8042103431:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103435:	76 d5                	jbe    804210340c <naive_address_by_fname+0x1a6>
    while (byte & 0x80) {
  8042103437:	45 84 ed             	test   %r13b,%r13b
  804210343a:	79 13                	jns    804210344f <naive_address_by_fname+0x1e9>
        byte = *addr++;
  804210343c:	48 f7 d3             	not    %rbx
  804210343f:	49 01 da             	add    %rbx,%r10
  8042103442:	43 0f b6 0c 02       	movzbl (%r10,%r8,1),%ecx
        count++;
  8042103447:	49 83 c0 01          	add    $0x1,%r8
    while (byte & 0x80) {
  804210344b:	84 c9                	test   %cl,%cl
  804210344d:	78 f3                	js     8042103442 <naive_address_by_fname+0x1dc>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  804210344f:	49 01 d0             	add    %rdx,%r8
  8042103452:	4d 89 c2             	mov    %r8,%r10
    size_t shift = 0, count = 0;
  8042103455:	ba 00 00 00 00       	mov    $0x0,%edx
  804210345a:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  804210345f:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8042103465:	49 83 c2 01          	add    $0x1,%r10
  8042103469:	45 0f b6 72 ff       	movzbl -0x1(%r10),%r14d
        result |= (byte & 0x7FULL) << shift;
  804210346e:	4c 89 f3             	mov    %r14,%rbx
  8042103471:	83 e3 7f             	and    $0x7f,%ebx
  8042103474:	48 d3 e3             	shl    %cl,%rbx
  8042103477:	49 09 dd             	or     %rbx,%r13
        shift += 7;
  804210347a:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804210347e:	48 89 d3             	mov    %rdx,%rbx
  8042103481:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  8042103485:	45 84 f6             	test   %r14b,%r14b
  8042103488:	0f 89 46 ff ff ff    	jns    80421033d4 <naive_address_by_fname+0x16e>
  804210348e:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103492:	76 d1                	jbe    8042103465 <naive_address_by_fname+0x1ff>
  8042103494:	e9 3b ff ff ff       	jmp    80421033d4 <naive_address_by_fname+0x16e>
            while ((const unsigned char *)curr_abbrev_entry < addrs->abbrev_end) {
  8042103499:	4c 39 ca             	cmp    %r9,%rdx
  804210349c:	0f 83 c3 00 00 00    	jae    8042103565 <naive_address_by_fname+0x2ff>
            const uint8_t *curr_abbrev_entry = abbrev_entry;
  80421034a2:	48 89 d6             	mov    %rdx,%rsi
    size_t shift = 0, count = 0;
  80421034a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80421034aa:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421034af:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  80421034b5:	48 83 c6 01          	add    $0x1,%rsi
  80421034b9:	44 0f b6 56 ff       	movzbl -0x1(%rsi),%r10d
        result |= (byte & 0x7FULL) << shift;
  80421034be:	4d 89 d0             	mov    %r10,%r8
  80421034c1:	41 83 e0 7f          	and    $0x7f,%r8d
  80421034c5:	49 d3 e0             	shl    %cl,%r8
  80421034c8:	4d 09 c5             	or     %r8,%r13
        shift += 7;
  80421034cb:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80421034cf:	49 89 c0             	mov    %rax,%r8
  80421034d2:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80421034d6:	45 84 d2             	test   %r10b,%r10b
  80421034d9:	79 06                	jns    80421034e1 <naive_address_by_fname+0x27b>
  80421034db:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421034df:	76 d4                	jbe    80421034b5 <naive_address_by_fname+0x24f>
    while (byte & 0x80) {
  80421034e1:	45 84 d2             	test   %r10b,%r10b
  80421034e4:	79 12                	jns    80421034f8 <naive_address_by_fname+0x292>
        byte = *addr++;
  80421034e6:	49 f7 d0             	not    %r8
  80421034e9:	4c 01 c6             	add    %r8,%rsi
  80421034ec:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
        count++;
  80421034f0:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  80421034f4:	84 c9                	test   %cl,%cl
  80421034f6:	78 f4                	js     80421034ec <naive_address_by_fname+0x286>
                curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &table_abbrev_code);
  80421034f8:	48 01 c2             	add    %rax,%rdx
  80421034fb:	49 89 d2             	mov    %rdx,%r10
    size_t shift = 0, count = 0;
  80421034fe:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8042103504:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042103509:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  804210350e:	49 83 c2 01          	add    $0x1,%r10
  8042103512:	45 0f b6 5a ff       	movzbl -0x1(%r10),%r11d
        result |= (byte & 0x7FULL) << shift;
  8042103517:	4c 89 d8             	mov    %r11,%rax
  804210351a:	83 e0 7f             	and    $0x7f,%eax
  804210351d:	48 d3 e0             	shl    %cl,%rax
  8042103520:	48 09 c6             	or     %rax,%rsi
        shift += 7;
  8042103523:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042103527:	4d 89 c6             	mov    %r8,%r14
  804210352a:	49 83 c0 01          	add    $0x1,%r8
    } while (byte & 0x80 && shift < 64);
  804210352e:	44 89 d8             	mov    %r11d,%eax
  8042103531:	c0 e8 07             	shr    $0x7,%al
  8042103534:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103538:	0f 96 c3             	setbe  %bl
  804210353b:	20 d8                	and    %bl,%al
  804210353d:	75 cf                	jne    804210350e <naive_address_by_fname+0x2a8>
    while (byte & 0x80) {
  804210353f:	45 84 db             	test   %r11b,%r11b
  8042103542:	79 13                	jns    8042103557 <naive_address_by_fname+0x2f1>
        byte = *addr++;
  8042103544:	49 f7 d6             	not    %r14
  8042103547:	4d 01 f2             	add    %r14,%r10
  804210354a:	43 0f b6 0c 02       	movzbl (%r10,%r8,1),%ecx
        count++;
  804210354f:	49 83 c0 01          	add    $0x1,%r8
    while (byte & 0x80) {
  8042103553:	84 c9                	test   %cl,%cl
  8042103555:	78 f3                	js     804210354a <naive_address_by_fname+0x2e4>
                curr_abbrev_entry += sizeof(Dwarf_Small);
  8042103557:	4a 8d 54 02 01       	lea    0x1(%rdx,%r8,1),%rdx
                if (table_abbrev_code == abbrev_code) break;
  804210355c:	4c 39 ef             	cmp    %r13,%rdi
  804210355f:	0f 85 93 fe ff ff    	jne    80421033f8 <naive_address_by_fname+0x192>
            if (tag == DW_TAG_subprogram || tag == DW_TAG_label) {
  8042103565:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
  8042103569:	48 89 d3             	mov    %rdx,%rbx
  804210356c:	48 83 fe 2e          	cmp    $0x2e,%rsi
  8042103570:	0f 94 c1             	sete   %cl
  8042103573:	48 83 fe 0a          	cmp    $0xa,%rsi
  8042103577:	0f 94 c2             	sete   %dl
  804210357a:	08 d1                	or     %dl,%cl
  804210357c:	88 4d af             	mov    %cl,-0x51(%rbp)
  804210357f:	0f 84 f2 01 00 00    	je     8042103777 <naive_address_by_fname+0x511>
                uintptr_t low_pc = 0;
  8042103585:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  804210358c:	00 
                        entry += dwarf_read_abbrev_entry(entry, form, &low_pc, sizeof(low_pc), address_size);
  804210358d:	88 45 b8             	mov    %al,-0x48(%rbp)
  8042103590:	4c 89 7d 88          	mov    %r15,-0x78(%rbp)
  8042103594:	e9 9b 00 00 00       	jmp    8042103634 <naive_address_by_fname+0x3ce>
  8042103599:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804210359f:	b9 08 00 00 00       	mov    $0x8,%ecx
  80421035a4:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80421035a8:	44 89 ee             	mov    %r13d,%esi
  80421035ab:	4c 89 f7             	mov    %r14,%rdi
  80421035ae:	41 ff d4             	call   *%r12
  80421035b1:	48 98                	cltq
  80421035b3:	49 01 c6             	add    %rax,%r14
  80421035b6:	eb 7c                	jmp    8042103634 <naive_address_by_fname+0x3ce>
                            uint64_t str_offset = 0;
  80421035b8:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80421035bf:	00 
                            entry += dwarf_read_abbrev_entry(entry, form, &str_offset, sizeof(uint64_t), address_size);
  80421035c0:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  80421035c6:	b9 08 00 00 00       	mov    $0x8,%ecx
  80421035cb:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  80421035cf:	be 0e 00 00 00       	mov    $0xe,%esi
  80421035d4:	4c 89 f7             	mov    %r14,%rdi
  80421035d7:	41 ff d4             	call   *%r12
  80421035da:	48 98                	cltq
  80421035dc:	49 01 c6             	add    %rax,%r14
                            if (!strcmp(fname, (const char *)addrs->str_begin + str_offset)) found = 1;
  80421035df:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80421035e3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80421035e7:	48 03 70 40          	add    0x40(%rax),%rsi
  80421035eb:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  80421035ef:	48 b8 90 0b 11 42 80 	movabs $0x8042110b90,%rax
  80421035f6:	00 00 00 
  80421035f9:	ff d0                	call   *%rax
  80421035fb:	85 c0                	test   %eax,%eax
  80421035fd:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  8042103601:	0f b6 7d af          	movzbl -0x51(%rbp),%edi
  8042103605:	0f 44 c7             	cmove  %edi,%eax
  8042103608:	88 45 b8             	mov    %al,-0x48(%rbp)
  804210360b:	eb 27                	jmp    8042103634 <naive_address_by_fname+0x3ce>
                        entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  804210360d:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042103613:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042103618:	ba 00 00 00 00       	mov    $0x0,%edx
  804210361d:	44 89 ee             	mov    %r13d,%esi
  8042103620:	4c 89 f7             	mov    %r14,%rdi
  8042103623:	41 ff d4             	call   *%r12
  8042103626:	48 98                	cltq
  8042103628:	49 01 c6             	add    %rax,%r14
                } while (name || form);
  804210362b:	4d 09 fd             	or     %r15,%r13
  804210362e:	0f 84 12 01 00 00    	je     8042103746 <naive_address_by_fname+0x4e0>
    uint64_t result = 0;
  8042103634:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8042103637:	b8 00 00 00 00       	mov    $0x0,%eax
  804210363c:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042103641:	41 bf 00 00 00 00    	mov    $0x0,%r15d
        byte = *addr++;
  8042103647:	48 83 c2 01          	add    $0x1,%rdx
  804210364b:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  804210364f:	48 89 fe             	mov    %rdi,%rsi
  8042103652:	83 e6 7f             	and    $0x7f,%esi
  8042103655:	48 d3 e6             	shl    %cl,%rsi
  8042103658:	49 09 f7             	or     %rsi,%r15
        shift += 7;
  804210365b:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  804210365f:	48 89 c6             	mov    %rax,%rsi
  8042103662:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042103666:	40 84 ff             	test   %dil,%dil
  8042103669:	79 06                	jns    8042103671 <naive_address_by_fname+0x40b>
  804210366b:	48 83 f9 3f          	cmp    $0x3f,%rcx
  804210366f:	76 d6                	jbe    8042103647 <naive_address_by_fname+0x3e1>
    while (byte & 0x80) {
  8042103671:	40 84 ff             	test   %dil,%dil
  8042103674:	79 12                	jns    8042103688 <naive_address_by_fname+0x422>
        byte = *addr++;
  8042103676:	48 f7 d6             	not    %rsi
  8042103679:	48 01 f2             	add    %rsi,%rdx
  804210367c:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042103680:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042103684:	84 c9                	test   %cl,%cl
  8042103686:	78 f4                	js     804210367c <naive_address_by_fname+0x416>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  8042103688:	48 01 d8             	add    %rbx,%rax
  804210368b:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  804210368e:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042103693:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042103698:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  804210369e:	48 83 c2 01          	add    $0x1,%rdx
  80421036a2:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  80421036a6:	48 89 fe             	mov    %rdi,%rsi
  80421036a9:	83 e6 7f             	and    $0x7f,%esi
  80421036ac:	48 d3 e6             	shl    %cl,%rsi
  80421036af:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  80421036b2:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80421036b6:	48 89 de             	mov    %rbx,%rsi
  80421036b9:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  80421036bd:	40 84 ff             	test   %dil,%dil
  80421036c0:	79 06                	jns    80421036c8 <naive_address_by_fname+0x462>
  80421036c2:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421036c6:	76 d6                	jbe    804210369e <naive_address_by_fname+0x438>
    while (byte & 0x80) {
  80421036c8:	40 84 ff             	test   %dil,%dil
  80421036cb:	79 12                	jns    80421036df <naive_address_by_fname+0x479>
        byte = *addr++;
  80421036cd:	48 f7 d6             	not    %rsi
  80421036d0:	48 01 f2             	add    %rsi,%rdx
  80421036d3:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  80421036d7:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  80421036db:	84 c9                	test   %cl,%cl
  80421036dd:	78 f4                	js     80421036d3 <naive_address_by_fname+0x46d>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  80421036df:	48 01 c3             	add    %rax,%rbx
                    if (name == DW_AT_low_pc) {
  80421036e2:	49 83 ff 11          	cmp    $0x11,%r15
  80421036e6:	0f 84 ad fe ff ff    	je     8042103599 <naive_address_by_fname+0x333>
                    } else if (name == DW_AT_name) {
  80421036ec:	49 83 ff 03          	cmp    $0x3,%r15
  80421036f0:	0f 85 17 ff ff ff    	jne    804210360d <naive_address_by_fname+0x3a7>
                        if (form == DW_FORM_strp) {
  80421036f6:	49 83 fd 0e          	cmp    $0xe,%r13
  80421036fa:	0f 84 b8 fe ff ff    	je     80421035b8 <naive_address_by_fname+0x352>
                            if (!strcmp(fname, (const char *)entry)) found = 1;
  8042103700:	4c 89 f6             	mov    %r14,%rsi
  8042103703:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8042103707:	48 b8 90 0b 11 42 80 	movabs $0x8042110b90,%rax
  804210370e:	00 00 00 
  8042103711:	ff d0                	call   *%rax
  8042103713:	85 c0                	test   %eax,%eax
  8042103715:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  8042103719:	0f b6 7d af          	movzbl -0x51(%rbp),%edi
  804210371d:	0f 44 c7             	cmove  %edi,%eax
  8042103720:	88 45 b8             	mov    %al,-0x48(%rbp)
                            entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042103723:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  8042103729:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210372e:	ba 00 00 00 00       	mov    $0x0,%edx
  8042103733:	44 89 ee             	mov    %r13d,%esi
  8042103736:	4c 89 f7             	mov    %r14,%rdi
  8042103739:	41 ff d4             	call   *%r12
  804210373c:	48 98                	cltq
  804210373e:	49 01 c6             	add    %rax,%r14
  8042103741:	e9 ee fe ff ff       	jmp    8042103634 <naive_address_by_fname+0x3ce>
                if (found && low_pc) {
  8042103746:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  804210374a:	4c 8b 7d 88          	mov    -0x78(%rbp),%r15
  804210374e:	84 c0                	test   %al,%al
  8042103750:	0f 84 15 fc ff ff    	je     804210336b <naive_address_by_fname+0x105>
  8042103756:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804210375a:	48 85 c0             	test   %rax,%rax
  804210375d:	0f 84 08 fc ff ff    	je     804210336b <naive_address_by_fname+0x105>
                    *offset = low_pc;
  8042103763:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  8042103767:	48 89 03             	mov    %rax,(%rbx)
                    return 0;
  804210376a:	b8 00 00 00 00       	mov    $0x0,%eax
  804210376f:	e9 5a 01 00 00       	jmp    80421038ce <naive_address_by_fname+0x668>
            const uint8_t *curr_abbrev_entry = abbrev_entry;
  8042103774:	4c 89 fb             	mov    %r15,%rbx
  8042103777:	4c 89 7d b8          	mov    %r15,-0x48(%rbp)
  804210377b:	eb 41                	jmp    80421037be <naive_address_by_fname+0x558>
  804210377d:	40 84 ff             	test   %dil,%dil
  8042103780:	79 12                	jns    8042103794 <naive_address_by_fname+0x52e>
        byte = *addr++;
  8042103782:	48 f7 d6             	not    %rsi
  8042103785:	48 01 f2             	add    %rsi,%rdx
  8042103788:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  804210378c:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8042103790:	84 c9                	test   %cl,%cl
  8042103792:	78 f4                	js     8042103788 <naive_address_by_fname+0x522>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &form);
  8042103794:	48 01 c3             	add    %rax,%rbx
                    entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042103797:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  804210379d:	b9 00 00 00 00       	mov    $0x0,%ecx
  80421037a2:	ba 00 00 00 00       	mov    $0x0,%edx
  80421037a7:	44 89 ee             	mov    %r13d,%esi
  80421037aa:	4c 89 f7             	mov    %r14,%rdi
  80421037ad:	41 ff d4             	call   *%r12
  80421037b0:	48 98                	cltq
  80421037b2:	49 01 c6             	add    %rax,%r14
                } while (name || form);
  80421037b5:	4d 09 fd             	or     %r15,%r13
  80421037b8:	0f 84 9d 00 00 00    	je     804210385b <naive_address_by_fname+0x5f5>
            const uint8_t *curr_abbrev_entry = abbrev_entry;
  80421037be:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  80421037c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80421037c6:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  80421037cb:	41 bf 00 00 00 00    	mov    $0x0,%r15d
        byte = *addr++;
  80421037d1:	48 83 c2 01          	add    $0x1,%rdx
  80421037d5:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  80421037d9:	48 89 fe             	mov    %rdi,%rsi
  80421037dc:	83 e6 7f             	and    $0x7f,%esi
  80421037df:	48 d3 e6             	shl    %cl,%rsi
  80421037e2:	49 09 f7             	or     %rsi,%r15
        shift += 7;
  80421037e5:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  80421037e9:	48 89 c6             	mov    %rax,%rsi
  80421037ec:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  80421037f0:	40 84 ff             	test   %dil,%dil
  80421037f3:	79 06                	jns    80421037fb <naive_address_by_fname+0x595>
  80421037f5:	48 83 f9 3f          	cmp    $0x3f,%rcx
  80421037f9:	76 d6                	jbe    80421037d1 <naive_address_by_fname+0x56b>
    while (byte & 0x80) {
  80421037fb:	40 84 ff             	test   %dil,%dil
  80421037fe:	79 12                	jns    8042103812 <naive_address_by_fname+0x5ac>
        byte = *addr++;
  8042103800:	48 f7 d6             	not    %rsi
  8042103803:	48 01 f2             	add    %rsi,%rdx
  8042103806:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  804210380a:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  804210380e:	84 c9                	test   %cl,%cl
  8042103810:	78 f4                	js     8042103806 <naive_address_by_fname+0x5a0>
                    curr_abbrev_entry += dwarf_read_uleb128(curr_abbrev_entry, &name);
  8042103812:	48 01 d8             	add    %rbx,%rax
  8042103815:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8042103818:	bb 00 00 00 00       	mov    $0x0,%ebx
  804210381d:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042103822:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        byte = *addr++;
  8042103828:	48 83 c2 01          	add    $0x1,%rdx
  804210382c:	0f b6 7a ff          	movzbl -0x1(%rdx),%edi
        result |= (byte & 0x7FULL) << shift;
  8042103830:	48 89 fe             	mov    %rdi,%rsi
  8042103833:	83 e6 7f             	and    $0x7f,%esi
  8042103836:	48 d3 e6             	shl    %cl,%rsi
  8042103839:	49 09 f5             	or     %rsi,%r13
        shift += 7;
  804210383c:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042103840:	48 89 de             	mov    %rbx,%rsi
  8042103843:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8042103847:	40 84 ff             	test   %dil,%dil
  804210384a:	0f 89 2d ff ff ff    	jns    804210377d <naive_address_by_fname+0x517>
  8042103850:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103854:	76 d2                	jbe    8042103828 <naive_address_by_fname+0x5c2>
  8042103856:	e9 22 ff ff ff       	jmp    804210377d <naive_address_by_fname+0x517>
  804210385b:	4c 8b 7d b8          	mov    -0x48(%rbp),%r15
  804210385f:	e9 07 fb ff ff       	jmp    804210336b <naive_address_by_fname+0x105>
    for (const uint8_t *entry = addrs->info_begin; (const unsigned char *)entry < addrs->info_end;) {
  8042103864:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  8042103868:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804210386c:	4c 3b 70 28          	cmp    0x28(%rax),%r14
  8042103870:	73 6b                	jae    80421038dd <naive_address_by_fname+0x677>
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  8042103872:	ba 04 00 00 00       	mov    $0x4,%edx
  8042103877:	4c 89 f6             	mov    %r14,%rsi
  804210387a:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210387e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042103885:	00 00 00 
  8042103888:	ff d0                	call   *%rax
  804210388a:	8b 45 c8             	mov    -0x38(%rbp),%eax
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  804210388d:	48 ba 10 00 00 00 ff 	movabs $0xffffffff00000010,%rdx
  8042103894:	ff ff ff 
  8042103897:	48 01 c2             	add    %rax,%rdx
  804210389a:	48 83 fa 0f          	cmp    $0xf,%rdx
  804210389e:	77 4b                	ja     80421038eb <naive_address_by_fname+0x685>
        if (initial_len == DW_EXT_DWARF64) {
  80421038a0:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80421038a5:	48 39 d0             	cmp    %rdx,%rax
  80421038a8:	0f 84 0a fa ff ff    	je     80421032b8 <naive_address_by_fname+0x52>
            cprintf("Unknown DWARF extension\n");
  80421038ae:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  80421038b5:	00 00 00 
  80421038b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80421038bd:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421038c4:	00 00 00 
  80421038c7:	ff d2                	call   *%rdx
        if (!count) return -E_BAD_DWARF;
  80421038c9:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
}
  80421038ce:	48 83 c4 58          	add    $0x58,%rsp
  80421038d2:	5b                   	pop    %rbx
  80421038d3:	41 5c                	pop    %r12
  80421038d5:	41 5d                	pop    %r13
  80421038d7:	41 5e                	pop    %r14
  80421038d9:	41 5f                	pop    %r15
  80421038db:	5d                   	pop    %rbp
  80421038dc:	c3                   	ret
    return -E_NO_ENT;
  80421038dd:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80421038e2:	eb ea                	jmp    80421038ce <naive_address_by_fname+0x668>
    if (!flen) return -E_INVAL;
  80421038e4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80421038e9:	eb e3                	jmp    80421038ce <naive_address_by_fname+0x668>
    uint64_t count = sizeof(uint32_t);
  80421038eb:	41 bc 04 00 00 00    	mov    $0x4,%r12d
        entry += count;
  80421038f1:	4d 01 e6             	add    %r12,%r14
        const uint8_t *entry_end = entry + len;
  80421038f4:	4d 8d 3c 06          	lea    (%r14,%rax,1),%r15
        Dwarf_Half version = get_unaligned(entry, Dwarf_Half);
  80421038f8:	ba 02 00 00 00       	mov    $0x2,%edx
  80421038fd:	4c 89 f6             	mov    %r14,%rsi
  8042103900:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103904:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210390b:	00 00 00 
  804210390e:	ff d0                	call   *%rax
        entry += sizeof(Dwarf_Half);
  8042103910:	49 8d 76 02          	lea    0x2(%r14),%rsi
        assert(version == 4 || version == 2);
  8042103914:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8042103918:	83 e8 02             	sub    $0x2,%eax
  804210391b:	66 a9 fd ff          	test   $0xfffd,%ax
  804210391f:	0f 85 bb f9 ff ff    	jne    80421032e0 <naive_address_by_fname+0x7a>
        Dwarf_Off abbrev_offset = get_unaligned(entry, uint32_t);
  8042103925:	ba 04 00 00 00       	mov    $0x4,%edx
  804210392a:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210392e:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  8042103935:	00 00 00 
  8042103938:	41 ff d4             	call   *%r12
  804210393b:	44 8b 6d c8          	mov    -0x38(%rbp),%r13d
        /**/ entry += sizeof(uint32_t);
  804210393f:	49 8d 76 06          	lea    0x6(%r14),%rsi
        Dwarf_Small address_size = get_unaligned(entry, Dwarf_Small);
  8042103943:	ba 01 00 00 00       	mov    $0x1,%edx
  8042103948:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210394c:	41 ff d4             	call   *%r12
        entry += sizeof(Dwarf_Small);
  804210394f:	49 83 c6 07          	add    $0x7,%r14
        assert(address_size == sizeof(uintptr_t));
  8042103953:	80 7d c8 08          	cmpb   $0x8,-0x38(%rbp)
  8042103957:	0f 85 b8 f9 ff ff    	jne    8042103315 <naive_address_by_fname+0xaf>
        const uint8_t *abbrev_entry = addrs->abbrev_begin + abbrev_offset;
  804210395d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042103961:	4c 03 28             	add    (%rax),%r13
                    entry += dwarf_read_abbrev_entry(entry, form, NULL, 0, address_size);
  8042103964:	49 bc 7a 0d 10 42 80 	movabs $0x8042100d7a,%r12
  804210396b:	00 00 00 
  804210396e:	4c 89 7d 90          	mov    %r15,-0x70(%rbp)
  8042103972:	4d 89 ef             	mov    %r13,%r15
  8042103975:	48 89 5d 98          	mov    %rbx,-0x68(%rbp)
        while (entry < entry_end) {
  8042103979:	e9 ed f9 ff ff       	jmp    804210336b <naive_address_by_fname+0x105>

000000804210397e <line_for_address>:
 * contain an offset in .debug_line of entry associated with compilation unit,
 * in which we search address `p`. This offset can be obtained from .debug_info
 * section, using the `file_name_by_info` function. */
int
line_for_address(const struct Dwarf_Addrs *addrs, uintptr_t p,
                 Dwarf_Off line_offset, int *lineno_store) {
  804210397e:	f3 0f 1e fa          	endbr64
  8042103982:	55                   	push   %rbp
  8042103983:	48 89 e5             	mov    %rsp,%rbp
  8042103986:	41 57                	push   %r15
  8042103988:	41 56                	push   %r14
  804210398a:	41 55                	push   %r13
  804210398c:	41 54                	push   %r12
  804210398e:	53                   	push   %rbx
  804210398f:	48 83 ec 48          	sub    $0x48,%rsp
  8042103993:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8042103997:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
    if (line_offset > addrs->line_end - addrs->line_begin)
  804210399b:	4c 8b 67 30          	mov    0x30(%rdi),%r12
  804210399f:	48 8b 47 38          	mov    0x38(%rdi),%rax
  80421039a3:	4c 29 e0             	sub    %r12,%rax
        return -E_INVAL;
    if (!lineno_store)
  80421039a6:	48 39 d0             	cmp    %rdx,%rax
  80421039a9:	0f 82 34 07 00 00    	jb     80421040e3 <line_for_address+0x765>
  80421039af:	48 85 c9             	test   %rcx,%rcx
  80421039b2:	0f 84 2b 07 00 00    	je     80421040e3 <line_for_address+0x765>
        return -E_INVAL;

    const void *curr_addr = addrs->line_begin + line_offset;
  80421039b8:	49 01 d4             	add    %rdx,%r12
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80421039bb:	ba 04 00 00 00       	mov    $0x4,%edx
  80421039c0:	4c 89 e6             	mov    %r12,%rsi
  80421039c3:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421039c7:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421039ce:	00 00 00 
  80421039d1:	ff d0                	call   *%rax
  80421039d3:	8b 55 c8             	mov    -0x38(%rbp),%edx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  80421039d6:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  80421039dd:	ff ff ff 
  80421039e0:	48 01 d0             	add    %rdx,%rax
  80421039e3:	48 83 f8 0f          	cmp    $0xf,%rax
  80421039e7:	0f 87 cb 07 00 00    	ja     80421041b8 <line_for_address+0x83a>
        if (initial_len == DW_EXT_DWARF64) {
  80421039ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80421039f2:	48 39 c2             	cmp    %rax,%rdx
  80421039f5:	74 25                	je     8042103a1c <line_for_address+0x9e>
            cprintf("Unknown DWARF extension\n");
  80421039f7:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  80421039fe:	00 00 00 
  8042103a01:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103a06:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042103a0d:	00 00 00 
  8042103a10:	ff d2                	call   *%rdx
    uint64_t unit_length = 0;
    uint32_t count;

    curr_addr += count = dwarf_entry_len(curr_addr, &unit_length);
    if (!count)
        return -E_BAD_DWARF;
  8042103a12:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8042103a17:	e9 b8 06 00 00       	jmp    80421040d4 <line_for_address+0x756>
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8042103a1c:	49 8d 74 24 20       	lea    0x20(%r12),%rsi
  8042103a21:	ba 08 00 00 00       	mov    $0x8,%edx
  8042103a26:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103a2a:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042103a31:	00 00 00 
  8042103a34:	ff d0                	call   *%rax
  8042103a36:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
            count += sizeof(uint64_t);
  8042103a3a:	b8 0c 00 00 00       	mov    $0xc,%eax
  8042103a3f:	e9 79 07 00 00       	jmp    80421041bd <line_for_address+0x83f>

    const void *unit_end = curr_addr + unit_length;
    Dwarf_Half version = get_unaligned(curr_addr, Dwarf_Half);
    curr_addr += sizeof(Dwarf_Half);
    assert(version == 4 || version == 3 || version == 2);
  8042103a44:	48 b9 a8 04 12 42 80 	movabs $0x80421204a8,%rcx
  8042103a4b:	00 00 00 
  8042103a4e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042103a55:	00 00 00 
  8042103a58:	be dd 00 00 00       	mov    $0xdd,%esi
  8042103a5d:	48 bf 28 f5 11 42 80 	movabs $0x804211f528,%rdi
  8042103a64:	00 00 00 
  8042103a67:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103a6c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042103a73:	00 00 00 
  8042103a76:	41 ff d0             	call   *%r8
            *len = get_unaligned((uint64_t *)addr + sizeof(uint32_t), uint64_t);
  8042103a79:	49 8d 74 24 22       	lea    0x22(%r12),%rsi
  8042103a7e:	ba 08 00 00 00       	mov    $0x8,%edx
  8042103a83:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103a87:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042103a8e:	00 00 00 
  8042103a91:	ff d0                	call   *%rax
  8042103a93:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
            count += sizeof(uint64_t);
  8042103a97:	b8 0c 00 00 00       	mov    $0xc,%eax
  8042103a9c:	e9 4e 06 00 00       	jmp    80421040ef <line_for_address+0x771>
        return -E_BAD_DWARF;

    const uint8_t *program_addr = curr_addr + header_length;
    Dwarf_Small minimum_instruction_length =
            get_unaligned(curr_addr, Dwarf_Small);
    assert(minimum_instruction_length == 1);
  8042103aa1:	48 b9 d8 04 12 42 80 	movabs $0x80421204d8,%rcx
  8042103aa8:	00 00 00 
  8042103aab:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042103ab2:	00 00 00 
  8042103ab5:	be e7 00 00 00       	mov    $0xe7,%esi
  8042103aba:	48 bf 28 f5 11 42 80 	movabs $0x804211f528,%rdi
  8042103ac1:	00 00 00 
  8042103ac4:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103ac9:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042103ad0:	00 00 00 
  8042103ad3:	41 ff d0             	call   *%r8
    curr_addr += sizeof(Dwarf_Small);

    Dwarf_Small maximum_operations_per_instruction;
    if (version == 4) {
        maximum_operations_per_instruction = get_unaligned(curr_addr, Dwarf_Small);
  8042103ad6:	ba 01 00 00 00       	mov    $0x1,%edx
  8042103adb:	4c 89 e6             	mov    %r12,%rsi
  8042103ade:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103ae2:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042103ae9:	00 00 00 
  8042103aec:	ff d0                	call   *%rax
        curr_addr += sizeof(Dwarf_Small);
  8042103aee:	4d 8d 65 02          	lea    0x2(%r13),%r12
    } else {
        maximum_operations_per_instruction = 1;
    }
    assert(maximum_operations_per_instruction == 1);
  8042103af2:	80 7d c8 01          	cmpb   $0x1,-0x38(%rbp)
  8042103af6:	0f 84 2a 06 00 00    	je     8042104126 <line_for_address+0x7a8>
  8042103afc:	48 b9 f8 04 12 42 80 	movabs $0x80421204f8,%rcx
  8042103b03:	00 00 00 
  8042103b06:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042103b0d:	00 00 00 
  8042103b10:	be f1 00 00 00       	mov    $0xf1,%esi
  8042103b15:	48 bf 28 f5 11 42 80 	movabs $0x804211f528,%rdi
  8042103b1c:	00 00 00 
  8042103b1f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103b24:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042103b2b:	00 00 00 
  8042103b2e:	41 ff d0             	call   *%r8
  8042103b31:	48 89 f0             	mov    %rsi,%rax
    size_t shift = 0, count = 0;
  8042103b34:	b9 00 00 00 00       	mov    $0x0,%ecx
    uint64_t result = 0;
  8042103b39:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        byte = *addr++;
  8042103b3f:	48 83 c0 01          	add    $0x1,%rax
  8042103b43:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  8042103b47:	48 89 fa             	mov    %rdi,%rdx
  8042103b4a:	83 e2 7f             	and    $0x7f,%edx
  8042103b4d:	48 d3 e2             	shl    %cl,%rdx
  8042103b50:	49 09 d4             	or     %rdx,%r12
        shift += 7;
  8042103b53:	48 83 c1 07          	add    $0x7,%rcx
    } while (byte & 0x80 && shift < 64);
  8042103b57:	40 84 ff             	test   %dil,%dil
  8042103b5a:	79 06                	jns    8042103b62 <line_for_address+0x1e4>
  8042103b5c:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103b60:	76 dd                	jbe    8042103b3f <line_for_address+0x1c1>
  8042103b62:	48 89 d9             	mov    %rbx,%rcx
  8042103b65:	4c 8d 40 ff          	lea    -0x1(%rax),%r8
        count++;
  8042103b69:	4c 89 c2             	mov    %r8,%rdx
  8042103b6c:	48 29 da             	sub    %rbx,%rdx
    while (byte & 0x80) {
  8042103b6f:	40 84 ff             	test   %dil,%dil
  8042103b72:	79 12                	jns    8042103b86 <line_for_address+0x208>
        byte = *addr++;
  8042103b74:	4c 29 c1             	sub    %r8,%rcx
  8042103b77:	48 01 c8             	add    %rcx,%rax
  8042103b7a:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042103b7e:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042103b82:	84 c9                	test   %cl,%cl
  8042103b84:	78 f4                	js     8042103b7a <line_for_address+0x1fc>
            program_addr += count;
  8042103b86:	89 d2                	mov    %edx,%edx
  8042103b88:	4c 8d 2c 16          	lea    (%rsi,%rdx,1),%r13
            const uint8_t *opcode_end = program_addr + length;
  8042103b8c:	4d 01 ec             	add    %r13,%r12
            opcode = get_unaligned(program_addr, Dwarf_Small);
  8042103b8f:	ba 01 00 00 00       	mov    $0x1,%edx
  8042103b94:	4c 89 ee             	mov    %r13,%rsi
  8042103b97:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103b9b:	41 ff d7             	call   *%r15
  8042103b9e:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
            program_addr += sizeof(Dwarf_Small);
  8042103ba2:	49 8d 5d 01          	lea    0x1(%r13),%rbx
            switch (opcode) {
  8042103ba6:	3c 03                	cmp    $0x3,%al
  8042103ba8:	0f 84 ed 00 00 00    	je     8042103c9b <line_for_address+0x31d>
  8042103bae:	77 65                	ja     8042103c15 <line_for_address+0x297>
  8042103bb0:	3c 01                	cmp    $0x1,%al
  8042103bb2:	0f 84 ad 00 00 00    	je     8042103c65 <line_for_address+0x2e7>
  8042103bb8:	3c 02                	cmp    $0x2,%al
  8042103bba:	0f 85 ba 01 00 00    	jne    8042103d7a <line_for_address+0x3fc>
                state->address = get_unaligned(program_addr, uintptr_t);
  8042103bc0:	ba 08 00 00 00       	mov    $0x8,%edx
  8042103bc5:	48 89 de             	mov    %rbx,%rsi
  8042103bc8:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103bcc:	41 ff d7             	call   *%r15
  8042103bcf:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
                program_addr += sizeof(uintptr_t);
  8042103bd3:	49 8d 5d 09          	lea    0x9(%r13),%rbx
            assert(program_addr == opcode_end);
  8042103bd7:	49 39 dc             	cmp    %rbx,%r12
  8042103bda:	0f 84 6d 04 00 00    	je     804210404d <line_for_address+0x6cf>
  8042103be0:	48 b9 4e f5 11 42 80 	movabs $0x804211f54e,%rcx
  8042103be7:	00 00 00 
  8042103bea:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042103bf1:	00 00 00 
  8042103bf4:	be 61 00 00 00       	mov    $0x61,%esi
  8042103bf9:	48 bf 28 f5 11 42 80 	movabs $0x804211f528,%rdi
  8042103c00:	00 00 00 
  8042103c03:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103c08:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042103c0f:	00 00 00 
  8042103c12:	41 ff d0             	call   *%r8
            switch (opcode) {
  8042103c15:	3c 04                	cmp    $0x4,%al
  8042103c17:	0f 85 5d 01 00 00    	jne    8042103d7a <line_for_address+0x3fc>
  8042103c1d:	48 89 d8             	mov    %rbx,%rax
  8042103c20:	ba 00 00 00 00       	mov    $0x0,%edx
        byte = *addr++;
  8042103c25:	48 83 c0 01          	add    $0x1,%rax
        shift += 7;
  8042103c29:	48 83 c2 07          	add    $0x7,%rdx
    } while (byte & 0x80 && shift < 64);
  8042103c2d:	0f b6 48 ff          	movzbl -0x1(%rax),%ecx
  8042103c31:	84 c9                	test   %cl,%cl
  8042103c33:	79 06                	jns    8042103c3b <line_for_address+0x2bd>
  8042103c35:	48 83 fa 3f          	cmp    $0x3f,%rdx
  8042103c39:	76 ea                	jbe    8042103c25 <line_for_address+0x2a7>
  8042103c3b:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
        count++;
  8042103c3f:	48 89 f2             	mov    %rsi,%rdx
  8042103c42:	4c 29 ea             	sub    %r13,%rdx
    while (byte & 0x80) {
  8042103c45:	84 c9                	test   %cl,%cl
  8042103c47:	79 12                	jns    8042103c5b <line_for_address+0x2dd>
        byte = *addr++;
  8042103c49:	49 29 f5             	sub    %rsi,%r13
  8042103c4c:	4c 01 e8             	add    %r13,%rax
  8042103c4f:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042103c53:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042103c57:	84 c9                	test   %cl,%cl
  8042103c59:	78 f4                	js     8042103c4f <line_for_address+0x2d1>
                program_addr += count;
  8042103c5b:	89 d2                	mov    %edx,%edx
  8042103c5d:	48 01 d3             	add    %rdx,%rbx
            } break;
  8042103c60:	e9 72 ff ff ff       	jmp    8042103bd7 <line_for_address+0x259>
                if (last_state.address <= destination_addr &&
  8042103c65:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042103c69:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  8042103c6d:	48 39 f0             	cmp    %rsi,%rax
  8042103c70:	0f 82 32 01 00 00    	jb     8042103da8 <line_for_address+0x42a>
  8042103c76:	4c 39 f0             	cmp    %r14,%rax
  8042103c79:	0f 82 31 04 00 00    	jb     80421040b0 <line_for_address+0x732>
                last_state = *state;
  8042103c7f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042103c82:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8042103c85:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
                *state = (struct Line_Number_State){
  8042103c89:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
  8042103c90:	41 be 00 00 00 00    	mov    $0x0,%r14d
  8042103c96:	e9 3c ff ff ff       	jmp    8042103bd7 <line_for_address+0x259>
                while (*program_addr++)
  8042103c9b:	48 83 c3 01          	add    $0x1,%rbx
  8042103c9f:	80 7b ff 00          	cmpb   $0x0,-0x1(%rbx)
  8042103ca3:	75 f6                	jne    8042103c9b <line_for_address+0x31d>
  8042103ca5:	48 89 da             	mov    %rbx,%rdx
    size_t shift = 0, count = 0;
  8042103ca8:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103cad:	b9 00 00 00 00       	mov    $0x0,%ecx
        byte = *addr++;
  8042103cb2:	48 83 c2 01          	add    $0x1,%rdx
        shift += 7;
  8042103cb6:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042103cba:	48 89 c7             	mov    %rax,%rdi
  8042103cbd:	48 83 c0 01          	add    $0x1,%rax
    } while (byte & 0x80 && shift < 64);
  8042103cc1:	0f b6 72 ff          	movzbl -0x1(%rdx),%esi
  8042103cc5:	40 84 f6             	test   %sil,%sil
  8042103cc8:	79 06                	jns    8042103cd0 <line_for_address+0x352>
  8042103cca:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103cce:	76 e2                	jbe    8042103cb2 <line_for_address+0x334>
    while (byte & 0x80) {
  8042103cd0:	40 84 f6             	test   %sil,%sil
  8042103cd3:	79 12                	jns    8042103ce7 <line_for_address+0x369>
        byte = *addr++;
  8042103cd5:	48 f7 d7             	not    %rdi
  8042103cd8:	48 01 fa             	add    %rdi,%rdx
  8042103cdb:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
        count++;
  8042103cdf:	48 83 c0 01          	add    $0x1,%rax
    while (byte & 0x80) {
  8042103ce3:	84 c9                	test   %cl,%cl
  8042103ce5:	78 f4                	js     8042103cdb <line_for_address+0x35d>
                program_addr += dwarf_read_uleb128(program_addr, &dir_index);
  8042103ce7:	48 01 d8             	add    %rbx,%rax
  8042103cea:	48 89 c1             	mov    %rax,%rcx
    size_t shift = 0, count = 0;
  8042103ced:	ba 00 00 00 00       	mov    $0x0,%edx
  8042103cf2:	be 00 00 00 00       	mov    $0x0,%esi
        byte = *addr++;
  8042103cf7:	48 83 c1 01          	add    $0x1,%rcx
        shift += 7;
  8042103cfb:	48 83 c6 07          	add    $0x7,%rsi
        count++;
  8042103cff:	49 89 d0             	mov    %rdx,%r8
  8042103d02:	48 83 c2 01          	add    $0x1,%rdx
    } while (byte & 0x80 && shift < 64);
  8042103d06:	0f b6 79 ff          	movzbl -0x1(%rcx),%edi
  8042103d0a:	40 84 ff             	test   %dil,%dil
  8042103d0d:	79 06                	jns    8042103d15 <line_for_address+0x397>
  8042103d0f:	48 83 fe 3f          	cmp    $0x3f,%rsi
  8042103d13:	76 e2                	jbe    8042103cf7 <line_for_address+0x379>
    while (byte & 0x80) {
  8042103d15:	40 84 ff             	test   %dil,%dil
  8042103d18:	79 13                	jns    8042103d2d <line_for_address+0x3af>
        byte = *addr++;
  8042103d1a:	49 f7 d0             	not    %r8
  8042103d1d:	4c 01 c1             	add    %r8,%rcx
  8042103d20:	0f b6 34 11          	movzbl (%rcx,%rdx,1),%esi
        count++;
  8042103d24:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042103d28:	40 84 f6             	test   %sil,%sil
  8042103d2b:	78 f3                	js     8042103d20 <line_for_address+0x3a2>
                program_addr += dwarf_read_uleb128(program_addr, &last_mod);
  8042103d2d:	48 01 d0             	add    %rdx,%rax
  8042103d30:	48 89 c2             	mov    %rax,%rdx
    size_t shift = 0, count = 0;
  8042103d33:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042103d38:	b9 00 00 00 00       	mov    $0x0,%ecx
        byte = *addr++;
  8042103d3d:	48 83 c2 01          	add    $0x1,%rdx
        shift += 7;
  8042103d41:	48 83 c1 07          	add    $0x7,%rcx
        count++;
  8042103d45:	48 89 df             	mov    %rbx,%rdi
  8042103d48:	48 83 c3 01          	add    $0x1,%rbx
    } while (byte & 0x80 && shift < 64);
  8042103d4c:	0f b6 72 ff          	movzbl -0x1(%rdx),%esi
  8042103d50:	40 84 f6             	test   %sil,%sil
  8042103d53:	79 06                	jns    8042103d5b <line_for_address+0x3dd>
  8042103d55:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103d59:	76 e2                	jbe    8042103d3d <line_for_address+0x3bf>
    while (byte & 0x80) {
  8042103d5b:	40 84 f6             	test   %sil,%sil
  8042103d5e:	79 12                	jns    8042103d72 <line_for_address+0x3f4>
        byte = *addr++;
  8042103d60:	48 f7 d7             	not    %rdi
  8042103d63:	48 01 fa             	add    %rdi,%rdx
  8042103d66:	0f b6 0c 1a          	movzbl (%rdx,%rbx,1),%ecx
        count++;
  8042103d6a:	48 83 c3 01          	add    $0x1,%rbx
    while (byte & 0x80) {
  8042103d6e:	84 c9                	test   %cl,%cl
  8042103d70:	78 f4                	js     8042103d66 <line_for_address+0x3e8>
                program_addr += dwarf_read_uleb128(program_addr, &length);
  8042103d72:	48 01 c3             	add    %rax,%rbx
            } break;
  8042103d75:	e9 5d fe ff ff       	jmp    8042103bd7 <line_for_address+0x259>
                panic("Unknown opcode: %x", opcode);
  8042103d7a:	0f b6 c8             	movzbl %al,%ecx
  8042103d7d:	48 ba 3b f5 11 42 80 	movabs $0x804211f53b,%rdx
  8042103d84:	00 00 00 
  8042103d87:	be 5e 00 00 00       	mov    $0x5e,%esi
  8042103d8c:	48 bf 28 f5 11 42 80 	movabs $0x804211f528,%rdi
  8042103d93:	00 00 00 
  8042103d96:	b8 00 00 00 00       	mov    $0x0,%eax
  8042103d9b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042103da2:	00 00 00 
  8042103da5:	41 ff d0             	call   *%r8
                last_state = *state;
  8042103da8:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042103dab:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8042103dae:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
                *state = (struct Line_Number_State){
  8042103db2:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
  8042103db9:	41 be 00 00 00 00    	mov    $0x0,%r14d
  8042103dbf:	e9 13 fe ff ff       	jmp    8042103bd7 <line_for_address+0x259>
                if (last_state.address <= destination_addr &&
  8042103dc4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042103dc8:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  8042103dcc:	48 39 d8             	cmp    %rbx,%rax
  8042103dcf:	0f 82 c3 02 00 00    	jb     8042104098 <line_for_address+0x71a>
  8042103dd5:	4c 39 f0             	cmp    %r14,%rax
  8042103dd8:	0f 82 da 02 00 00    	jb     80421040b8 <line_for_address+0x73a>
                last_state = *state;
  8042103dde:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042103de1:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8042103de4:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
        program_addr += sizeof(Dwarf_Small);
  8042103de8:	48 89 f3             	mov    %rsi,%rbx
  8042103deb:	e9 5d 02 00 00       	jmp    804210404d <line_for_address+0x6cf>
            switch (opcode) {
  8042103df0:	48 89 f0             	mov    %rsi,%rax
  8042103df3:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042103df8:	bf 00 00 00 00       	mov    $0x0,%edi
        byte = *addr++;
  8042103dfd:	48 83 c0 01          	add    $0x1,%rax
  8042103e01:	44 0f b6 40 ff       	movzbl -0x1(%rax),%r8d
        result |= (byte & 0x7FULL) << shift;
  8042103e06:	4c 89 c2             	mov    %r8,%rdx
  8042103e09:	83 e2 7f             	and    $0x7f,%edx
  8042103e0c:	48 d3 e2             	shl    %cl,%rdx
  8042103e0f:	48 09 d7             	or     %rdx,%rdi
        shift += 7;
  8042103e12:	48 83 c1 07          	add    $0x7,%rcx
    } while (byte & 0x80 && shift < 64);
  8042103e16:	45 84 c0             	test   %r8b,%r8b
  8042103e19:	79 06                	jns    8042103e21 <line_for_address+0x4a3>
  8042103e1b:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103e1f:	76 dc                	jbe    8042103dfd <line_for_address+0x47f>
  8042103e21:	48 89 d9             	mov    %rbx,%rcx
  8042103e24:	4c 8d 48 ff          	lea    -0x1(%rax),%r9
        count++;
  8042103e28:	4c 89 ca             	mov    %r9,%rdx
  8042103e2b:	48 29 da             	sub    %rbx,%rdx
    while (byte & 0x80) {
  8042103e2e:	45 84 c0             	test   %r8b,%r8b
  8042103e31:	79 12                	jns    8042103e45 <line_for_address+0x4c7>
        byte = *addr++;
  8042103e33:	4c 29 c9             	sub    %r9,%rcx
  8042103e36:	48 01 c8             	add    %rcx,%rax
  8042103e39:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042103e3d:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042103e41:	84 c9                	test   %cl,%cl
  8042103e43:	78 f4                	js     8042103e39 <line_for_address+0x4bb>
                state->address += info->minimum_instruction_length *
  8042103e45:	49 01 fe             	add    %rdi,%r14
                program_addr += count;
  8042103e48:	89 d2                	mov    %edx,%edx
  8042103e4a:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8042103e4e:	e9 fa 01 00 00       	jmp    804210404d <line_for_address+0x6cf>
            switch (opcode) {
  8042103e53:	48 89 f0             	mov    %rsi,%rax
  8042103e56:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8042103e5c:	b9 00 00 00 00       	mov    $0x0,%ecx
        byte = *addr++;
  8042103e61:	48 83 c0 01          	add    $0x1,%rax
  8042103e65:	0f b6 78 ff          	movzbl -0x1(%rax),%edi
        result |= (byte & 0x7FULL) << shift;
  8042103e69:	48 89 fa             	mov    %rdi,%rdx
  8042103e6c:	83 e2 7f             	and    $0x7f,%edx
  8042103e6f:	48 d3 e2             	shl    %cl,%rdx
  8042103e72:	49 09 d0             	or     %rdx,%r8
        shift += 7;
  8042103e75:	48 83 c1 07          	add    $0x7,%rcx
    } while (byte & 0x80 && shift < 64);
  8042103e79:	40 84 ff             	test   %dil,%dil
  8042103e7c:	79 06                	jns    8042103e84 <line_for_address+0x506>
  8042103e7e:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103e82:	76 dd                	jbe    8042103e61 <line_for_address+0x4e3>
  8042103e84:	49 89 d9             	mov    %rbx,%r9
  8042103e87:	4c 8d 50 ff          	lea    -0x1(%rax),%r10
        count++;
  8042103e8b:	4c 89 d2             	mov    %r10,%rdx
  8042103e8e:	48 29 da             	sub    %rbx,%rdx
    while (byte & 0x80) {
  8042103e91:	40 84 ff             	test   %dil,%dil
  8042103e94:	79 21                	jns    8042103eb7 <line_for_address+0x539>
        byte = *addr++;
  8042103e96:	4d 29 d1             	sub    %r10,%r9
  8042103e99:	4c 01 c8             	add    %r9,%rax
  8042103e9c:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042103ea0:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042103ea4:	84 c9                	test   %cl,%cl
  8042103ea6:	78 f4                	js     8042103e9c <line_for_address+0x51e>
                state->line += (int)line_incr;
  8042103ea8:	44 01 45 b8          	add    %r8d,-0x48(%rbp)
                program_addr += count;
  8042103eac:	89 d2                	mov    %edx,%edx
  8042103eae:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8042103eb2:	e9 96 01 00 00       	jmp    804210404d <line_for_address+0x6cf>
    if (shift < 8 * sizeof(result) && byte & 0x40)
  8042103eb7:	48 83 f9 3f          	cmp    $0x3f,%rcx
  8042103ebb:	77 eb                	ja     8042103ea8 <line_for_address+0x52a>
  8042103ebd:	40 f6 c7 40          	test   $0x40,%dil
  8042103ec1:	74 e5                	je     8042103ea8 <line_for_address+0x52a>
        result |= (-1U << shift);
  8042103ec3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042103ec8:	d3 e0                	shl    %cl,%eax
  8042103eca:	49 09 c0             	or     %rax,%r8
  8042103ecd:	eb d9                	jmp    8042103ea8 <line_for_address+0x52a>
            switch (opcode) {
  8042103ecf:	48 89 f0             	mov    %rsi,%rax
  8042103ed2:	ba 00 00 00 00       	mov    $0x0,%edx
        byte = *addr++;
  8042103ed7:	48 83 c0 01          	add    $0x1,%rax
        shift += 7;
  8042103edb:	48 83 c2 07          	add    $0x7,%rdx
    } while (byte & 0x80 && shift < 64);
  8042103edf:	0f b6 48 ff          	movzbl -0x1(%rax),%ecx
  8042103ee3:	84 c9                	test   %cl,%cl
  8042103ee5:	79 06                	jns    8042103eed <line_for_address+0x56f>
  8042103ee7:	48 83 fa 3f          	cmp    $0x3f,%rdx
  8042103eeb:	76 ea                	jbe    8042103ed7 <line_for_address+0x559>
  8042103eed:	48 89 df             	mov    %rbx,%rdi
  8042103ef0:	4c 8d 40 ff          	lea    -0x1(%rax),%r8
        count++;
  8042103ef4:	4c 89 c2             	mov    %r8,%rdx
  8042103ef7:	48 29 da             	sub    %rbx,%rdx
    while (byte & 0x80) {
  8042103efa:	84 c9                	test   %cl,%cl
  8042103efc:	79 12                	jns    8042103f10 <line_for_address+0x592>
        byte = *addr++;
  8042103efe:	4c 29 c7             	sub    %r8,%rdi
  8042103f01:	48 01 f8             	add    %rdi,%rax
  8042103f04:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042103f08:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042103f0c:	84 c9                	test   %cl,%cl
  8042103f0e:	78 f4                	js     8042103f04 <line_for_address+0x586>
                program_addr += count;
  8042103f10:	89 d2                	mov    %edx,%edx
  8042103f12:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8042103f16:	e9 32 01 00 00       	jmp    804210404d <line_for_address+0x6cf>
            switch (opcode) {
  8042103f1b:	48 89 f0             	mov    %rsi,%rax
  8042103f1e:	ba 00 00 00 00       	mov    $0x0,%edx
        byte = *addr++;
  8042103f23:	48 83 c0 01          	add    $0x1,%rax
        shift += 7;
  8042103f27:	48 83 c2 07          	add    $0x7,%rdx
    } while (byte & 0x80 && shift < 64);
  8042103f2b:	0f b6 48 ff          	movzbl -0x1(%rax),%ecx
  8042103f2f:	84 c9                	test   %cl,%cl
  8042103f31:	79 06                	jns    8042103f39 <line_for_address+0x5bb>
  8042103f33:	48 83 fa 3f          	cmp    $0x3f,%rdx
  8042103f37:	76 ea                	jbe    8042103f23 <line_for_address+0x5a5>
  8042103f39:	48 89 df             	mov    %rbx,%rdi
  8042103f3c:	4c 8d 40 ff          	lea    -0x1(%rax),%r8
        count++;
  8042103f40:	4c 89 c2             	mov    %r8,%rdx
  8042103f43:	48 29 da             	sub    %rbx,%rdx
    while (byte & 0x80) {
  8042103f46:	84 c9                	test   %cl,%cl
  8042103f48:	79 12                	jns    8042103f5c <line_for_address+0x5de>
        byte = *addr++;
  8042103f4a:	4c 29 c7             	sub    %r8,%rdi
  8042103f4d:	48 01 f8             	add    %rdi,%rax
  8042103f50:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042103f54:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042103f58:	84 c9                	test   %cl,%cl
  8042103f5a:	78 f4                	js     8042103f50 <line_for_address+0x5d2>
                program_addr += count;
  8042103f5c:	89 d2                	mov    %edx,%edx
  8042103f5e:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8042103f62:	e9 e6 00 00 00       	jmp    804210404d <line_for_address+0x6cf>
                int op_advance = adjusted_opcode / info->line_range;
  8042103f67:	0f b7 45 9a          	movzwl -0x66(%rbp),%eax
  8042103f6b:	f6 75 be             	divb   -0x42(%rbp)
                state->address += info->minimum_instruction_length *
  8042103f6e:	0f b6 c0             	movzbl %al,%eax
  8042103f71:	49 01 c6             	add    %rax,%r14
        program_addr += sizeof(Dwarf_Small);
  8042103f74:	48 89 f3             	mov    %rsi,%rbx
            } break;
  8042103f77:	e9 d1 00 00 00       	jmp    804210404d <line_for_address+0x6cf>
                state->address += get_unaligned(program_addr, Dwarf_Half);
  8042103f7c:	ba 02 00 00 00       	mov    $0x2,%edx
  8042103f81:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042103f85:	41 ff d7             	call   *%r15
  8042103f88:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
  8042103f8c:	49 01 c6             	add    %rax,%r14
                program_addr += sizeof(Dwarf_Half);
  8042103f8f:	48 83 c3 03          	add    $0x3,%rbx
            } break;
  8042103f93:	e9 b5 00 00 00       	jmp    804210404d <line_for_address+0x6cf>
            switch (opcode) {
  8042103f98:	48 89 f0             	mov    %rsi,%rax
  8042103f9b:	ba 00 00 00 00       	mov    $0x0,%edx
        byte = *addr++;
  8042103fa0:	48 83 c0 01          	add    $0x1,%rax
        shift += 7;
  8042103fa4:	48 83 c2 07          	add    $0x7,%rdx
    } while (byte & 0x80 && shift < 64);
  8042103fa8:	0f b6 48 ff          	movzbl -0x1(%rax),%ecx
  8042103fac:	84 c9                	test   %cl,%cl
  8042103fae:	79 06                	jns    8042103fb6 <line_for_address+0x638>
  8042103fb0:	48 83 fa 3f          	cmp    $0x3f,%rdx
  8042103fb4:	76 ea                	jbe    8042103fa0 <line_for_address+0x622>
  8042103fb6:	48 89 df             	mov    %rbx,%rdi
  8042103fb9:	4c 8d 40 ff          	lea    -0x1(%rax),%r8
        count++;
  8042103fbd:	4c 89 c2             	mov    %r8,%rdx
  8042103fc0:	48 29 da             	sub    %rbx,%rdx
    while (byte & 0x80) {
  8042103fc3:	84 c9                	test   %cl,%cl
  8042103fc5:	79 12                	jns    8042103fd9 <line_for_address+0x65b>
        byte = *addr++;
  8042103fc7:	4c 29 c7             	sub    %r8,%rdi
  8042103fca:	48 01 f8             	add    %rdi,%rax
  8042103fcd:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
        count++;
  8042103fd1:	48 83 c2 01          	add    $0x1,%rdx
    while (byte & 0x80) {
  8042103fd5:	84 c9                	test   %cl,%cl
  8042103fd7:	78 f4                	js     8042103fcd <line_for_address+0x64f>
                program_addr += count;
  8042103fd9:	89 d2                	mov    %edx,%edx
  8042103fdb:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
            } break;
  8042103fdf:	eb 6c                	jmp    804210404d <line_for_address+0x6cf>
                panic("Unknown opcode: %x", opcode);
  8042103fe1:	0f b6 c8             	movzbl %al,%ecx
  8042103fe4:	48 ba 3b f5 11 42 80 	movabs $0x804211f53b,%rdx
  8042103feb:	00 00 00 
  8042103fee:	be a5 00 00 00       	mov    $0xa5,%esi
  8042103ff3:	48 bf 28 f5 11 42 80 	movabs $0x804211f528,%rdi
  8042103ffa:	00 00 00 
  8042103ffd:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104002:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104009:	00 00 00 
  804210400c:	41 ff d0             	call   *%r8
            Dwarf_Small adjusted_opcode = opcode - info->opcode_base;
  804210400f:	2a 45 bf             	sub    -0x41(%rbp),%al
            state->line += (info->line_base + (adjusted_opcode % info->line_range));
  8042104012:	0f b6 c0             	movzbl %al,%eax
  8042104015:	f6 75 be             	divb   -0x42(%rbp)
  8042104018:	0f b6 d4             	movzbl %ah,%edx
  804210401b:	0f be 4d bd          	movsbl -0x43(%rbp),%ecx
  804210401f:	01 ca                	add    %ecx,%edx
  8042104021:	01 55 b8             	add    %edx,-0x48(%rbp)
            state->address += info->minimum_instruction_length *
  8042104024:	0f b6 c0             	movzbl %al,%eax
  8042104027:	49 01 c6             	add    %rax,%r14
            if (last_state.address <= destination_addr && destination_addr < state->address) {
  804210402a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804210402e:	4c 39 f0             	cmp    %r14,%rax
  8042104031:	73 0d                	jae    8042104040 <line_for_address+0x6c2>
  8042104033:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  8042104037:	48 39 d8             	cmp    %rbx,%rax
  804210403a:	0f 83 80 00 00 00    	jae    80421040c0 <line_for_address+0x742>
            last_state = *state;
  8042104040:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042104043:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8042104046:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
        program_addr += sizeof(Dwarf_Small);
  804210404a:	48 89 f3             	mov    %rsi,%rbx
    while (program_addr < end_addr) {
  804210404d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042104051:	48 39 c3             	cmp    %rax,%rbx
  8042104054:	73 70                	jae    80421040c6 <line_for_address+0x748>
        Dwarf_Small opcode = get_unaligned(program_addr, Dwarf_Small);
  8042104056:	ba 01 00 00 00       	mov    $0x1,%edx
  804210405b:	48 89 de             	mov    %rbx,%rsi
  804210405e:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042104062:	41 ff d7             	call   *%r15
  8042104065:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
        program_addr += sizeof(Dwarf_Small);
  8042104069:	48 8d 73 01          	lea    0x1(%rbx),%rsi
        if (opcode == 0) {
  804210406d:	84 c0                	test   %al,%al
  804210406f:	0f 84 bc fa ff ff    	je     8042103b31 <line_for_address+0x1b3>
        } else if (opcode < info->opcode_base) {
  8042104075:	3a 45 bf             	cmp    -0x41(%rbp),%al
  8042104078:	73 95                	jae    804210400f <line_for_address+0x691>
            switch (opcode) {
  804210407a:	3c 0c                	cmp    $0xc,%al
  804210407c:	0f 87 5f ff ff ff    	ja     8042103fe1 <line_for_address+0x663>
  8042104082:	0f b6 d0             	movzbl %al,%edx
  8042104085:	48 bf 88 1a 12 42 80 	movabs $0x8042121a88,%rdi
  804210408c:	00 00 00 
  804210408f:	3e ff 24 d7          	notrack jmp *(%rdi,%rdx,8)
  8042104093:	48 89 f3             	mov    %rsi,%rbx
  8042104096:	eb b5                	jmp    804210404d <line_for_address+0x6cf>
                last_state = *state;
  8042104098:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804210409b:	89 45 9c             	mov    %eax,-0x64(%rbp)
  804210409e:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
        program_addr += sizeof(Dwarf_Small);
  80421040a2:	48 89 f3             	mov    %rsi,%rbx
  80421040a5:	eb a6                	jmp    804210404d <line_for_address+0x6cf>
    struct Line_Number_State current_state = {
  80421040a7:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
  80421040ae:	eb 16                	jmp    80421040c6 <line_for_address+0x748>
                    *state = last_state;
  80421040b0:	8b 45 9c             	mov    -0x64(%rbp),%eax
  80421040b3:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421040b6:	eb 0e                	jmp    80421040c6 <line_for_address+0x748>
                    *state = last_state;
  80421040b8:	8b 45 9c             	mov    -0x64(%rbp),%eax
  80421040bb:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421040be:	eb 06                	jmp    80421040c6 <line_for_address+0x748>
                *state = last_state;
  80421040c0:	8b 45 9c             	mov    -0x64(%rbp),%eax
  80421040c3:	89 45 b8             	mov    %eax,-0x48(%rbp)
            .standard_opcode_lengths = standard_opcode_lengths,
    };

    run_line_number_program(program_addr, unit_end, &info, &current_state, p);

    *lineno_store = current_state.line;
  80421040c6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80421040ca:	8b 75 b8             	mov    -0x48(%rbp),%esi
  80421040cd:	89 30                	mov    %esi,(%rax)

    return 0;
  80421040cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80421040d4:	48 83 c4 48          	add    $0x48,%rsp
  80421040d8:	5b                   	pop    %rbx
  80421040d9:	41 5c                	pop    %r12
  80421040db:	41 5d                	pop    %r13
  80421040dd:	41 5e                	pop    %r14
  80421040df:	41 5f                	pop    %r15
  80421040e1:	5d                   	pop    %rbp
  80421040e2:	c3                   	ret
        return -E_INVAL;
  80421040e3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80421040e8:	eb ea                	jmp    80421040d4 <line_for_address+0x756>
    uint64_t count = sizeof(uint32_t);
  80421040ea:	b8 04 00 00 00       	mov    $0x4,%eax
    curr_addr += count = dwarf_entry_len(curr_addr, &header_length);
  80421040ef:	49 01 c5             	add    %rax,%r13
    const uint8_t *program_addr = curr_addr + header_length;
  80421040f2:	4c 01 eb             	add    %r13,%rbx
            get_unaligned(curr_addr, Dwarf_Small);
  80421040f5:	ba 01 00 00 00       	mov    $0x1,%edx
  80421040fa:	4c 89 ee             	mov    %r13,%rsi
  80421040fd:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042104101:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042104108:	00 00 00 
  804210410b:	ff d0                	call   *%rax
    assert(minimum_instruction_length == 1);
  804210410d:	80 7d c8 01          	cmpb   $0x1,-0x38(%rbp)
  8042104111:	0f 85 8a f9 ff ff    	jne    8042103aa1 <line_for_address+0x123>
    curr_addr += sizeof(Dwarf_Small);
  8042104117:	4d 8d 65 01          	lea    0x1(%r13),%r12
    if (version == 4) {
  804210411b:	66 41 83 fe 04       	cmp    $0x4,%r14w
  8042104120:	0f 84 b0 f9 ff ff    	je     8042103ad6 <line_for_address+0x158>
    curr_addr += sizeof(Dwarf_Small);
  8042104126:	49 8d 74 24 01       	lea    0x1(%r12),%rsi
    int8_t line_base = get_unaligned(curr_addr, int8_t);
  804210412b:	ba 01 00 00 00       	mov    $0x1,%edx
  8042104130:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042104134:	49 bd 62 0d 11 42 80 	movabs $0x8042110d62,%r13
  804210413b:	00 00 00 
  804210413e:	41 ff d5             	call   *%r13
  8042104141:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  8042104145:	88 45 bd             	mov    %al,-0x43(%rbp)
    curr_addr += sizeof(int8_t);
  8042104148:	49 8d 74 24 02       	lea    0x2(%r12),%rsi
    Dwarf_Small line_range = get_unaligned(curr_addr, Dwarf_Small);
  804210414d:	ba 01 00 00 00       	mov    $0x1,%edx
  8042104152:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042104156:	41 ff d5             	call   *%r13
  8042104159:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  804210415d:	88 45 be             	mov    %al,-0x42(%rbp)
    curr_addr += sizeof(Dwarf_Small);
  8042104160:	49 8d 74 24 03       	lea    0x3(%r12),%rsi
    Dwarf_Small opcode_base = get_unaligned(curr_addr, Dwarf_Small);
  8042104165:	ba 01 00 00 00       	mov    $0x1,%edx
  804210416a:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210416e:	41 ff d5             	call   *%r13
  8042104171:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  8042104175:	88 45 bf             	mov    %al,-0x41(%rbp)
    curr_addr += sizeof(Dwarf_Small);
  8042104178:	49 8d 74 24 04       	lea    0x4(%r12),%rsi
    Dwarf_Small *standard_opcode_lengths = (Dwarf_Small *)get_unaligned(curr_addr, Dwarf_Small *);
  804210417d:	ba 08 00 00 00       	mov    $0x8,%edx
  8042104182:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042104186:	41 ff d5             	call   *%r13
    while (program_addr < end_addr) {
  8042104189:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804210418d:	48 39 f3             	cmp    %rsi,%rbx
  8042104190:	0f 83 11 ff ff ff    	jae    80421040a7 <line_for_address+0x729>
    struct Line_Number_State current_state = {
  8042104196:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
  804210419d:	41 be 00 00 00 00    	mov    $0x0,%r14d
        Dwarf_Small opcode = get_unaligned(program_addr, Dwarf_Small);
  80421041a3:	4d 89 ef             	mov    %r13,%r15
                Dwarf_Small adjusted_opcode = opcode - info->opcode_base;
  80421041a6:	0f b6 45 bf          	movzbl -0x41(%rbp),%eax
  80421041aa:	f7 d0                	not    %eax
                int op_advance = adjusted_opcode / info->line_range;
  80421041ac:	0f b6 c0             	movzbl %al,%eax
  80421041af:	66 89 45 9a          	mov    %ax,-0x66(%rbp)
  80421041b3:	e9 9e fe ff ff       	jmp    8042104056 <line_for_address+0x6d8>
  80421041b8:	b8 04 00 00 00       	mov    $0x4,%eax
    curr_addr += count = dwarf_entry_len(curr_addr, &unit_length);
  80421041bd:	49 01 c4             	add    %rax,%r12
    const void *unit_end = curr_addr + unit_length;
  80421041c0:	49 8d 04 14          	lea    (%r12,%rdx,1),%rax
  80421041c4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    Dwarf_Half version = get_unaligned(curr_addr, Dwarf_Half);
  80421041c8:	ba 02 00 00 00       	mov    $0x2,%edx
  80421041cd:	4c 89 e6             	mov    %r12,%rsi
  80421041d0:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  80421041d4:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421041db:	00 00 00 
  80421041de:	ff d0                	call   *%rax
  80421041e0:	44 0f b7 75 c8       	movzwl -0x38(%rbp),%r14d
    curr_addr += sizeof(Dwarf_Half);
  80421041e5:	4d 8d 6c 24 02       	lea    0x2(%r12),%r13
    assert(version == 4 || version == 3 || version == 2);
  80421041ea:	41 8d 46 fe          	lea    -0x2(%r14),%eax
  80421041ee:	66 83 f8 02          	cmp    $0x2,%ax
  80421041f2:	0f 87 4c f8 ff ff    	ja     8042103a44 <line_for_address+0xc6>
    uint64_t initial_len = get_unaligned(addr, uint32_t);
  80421041f8:	ba 04 00 00 00       	mov    $0x4,%edx
  80421041fd:	4c 89 ee             	mov    %r13,%rsi
  8042104200:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  8042104204:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210420b:	00 00 00 
  804210420e:	ff d0                	call   *%rax
  8042104210:	8b 5d c8             	mov    -0x38(%rbp),%ebx
    if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
  8042104213:	48 b8 10 00 00 00 ff 	movabs $0xffffffff00000010,%rax
  804210421a:	ff ff ff 
  804210421d:	48 01 d8             	add    %rbx,%rax
  8042104220:	48 83 f8 0f          	cmp    $0xf,%rax
  8042104224:	0f 87 c0 fe ff ff    	ja     80421040ea <line_for_address+0x76c>
        if (initial_len == DW_EXT_DWARF64) {
  804210422a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804210422f:	48 39 c3             	cmp    %rax,%rbx
  8042104232:	0f 84 41 f8 ff ff    	je     8042103a79 <line_for_address+0xfb>
            cprintf("Unknown DWARF extension\n");
  8042104238:	48 bf a9 f4 11 42 80 	movabs $0x804211f4a9,%rdi
  804210423f:	00 00 00 
  8042104242:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104247:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210424e:	00 00 00 
  8042104251:	ff d2                	call   *%rdx
        return -E_BAD_DWARF;
  8042104253:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8042104258:	e9 77 fe ff ff       	jmp    80421040d4 <line_for_address+0x756>

000000804210425d <mon_help>:
#define NCOMMANDS (sizeof(commands) / sizeof(commands[0]))

/* Implementations of basic kernel monitor commands */

int
mon_help(int argc, char **argv, struct Trapframe *tf) {
  804210425d:	f3 0f 1e fa          	endbr64
  8042104261:	55                   	push   %rbp
  8042104262:	48 89 e5             	mov    %rsp,%rbp
  8042104265:	41 56                	push   %r14
  8042104267:	41 55                	push   %r13
  8042104269:	41 54                	push   %r12
  804210426b:	53                   	push   %rbx
    for (size_t i = 0; i < NCOMMANDS; i++)
  804210426c:	48 bb 00 1b 12 42 80 	movabs $0x8042121b00,%rbx
  8042104273:	00 00 00 
  8042104276:	4c 8d b3 f0 00 00 00 	lea    0xf0(%rbx),%r14
        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  804210427d:	49 bd 69 f5 11 42 80 	movabs $0x804211f569,%r13
  8042104284:	00 00 00 
  8042104287:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  804210428e:	00 00 00 
  8042104291:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  8042104295:	48 8b 33             	mov    (%rbx),%rsi
  8042104298:	4c 89 ef             	mov    %r13,%rdi
  804210429b:	b8 00 00 00 00       	mov    $0x0,%eax
  80421042a0:	41 ff d4             	call   *%r12
    for (size_t i = 0; i < NCOMMANDS; i++)
  80421042a3:	48 83 c3 18          	add    $0x18,%rbx
  80421042a7:	4c 39 f3             	cmp    %r14,%rbx
  80421042aa:	75 e5                	jne    8042104291 <mon_help+0x34>
    return 0;
}
  80421042ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80421042b1:	5b                   	pop    %rbx
  80421042b2:	41 5c                	pop    %r12
  80421042b4:	41 5d                	pop    %r13
  80421042b6:	41 5e                	pop    %r14
  80421042b8:	5d                   	pop    %rbp
  80421042b9:	c3                   	ret

00000080421042ba <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf) {
  80421042ba:	f3 0f 1e fa          	endbr64
  80421042be:	55                   	push   %rbp
  80421042bf:	48 89 e5             	mov    %rsp,%rbp
  80421042c2:	41 55                	push   %r13
  80421042c4:	41 54                	push   %r12
  80421042c6:	53                   	push   %rbx
  80421042c7:	48 83 ec 08          	sub    $0x8,%rsp
    extern char _head64[], entry[], etext[], edata[], end[];

    cprintf("Special kernel symbols:\n");
  80421042cb:	48 bf 72 f5 11 42 80 	movabs $0x804211f572,%rdi
  80421042d2:	00 00 00 
  80421042d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80421042da:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  80421042e1:	00 00 00 
  80421042e4:	41 ff d4             	call   *%r12
    cprintf("  _head64 %16lx (virt)  %16lx (phys)\n", (unsigned long)_head64, (unsigned long)_head64);
  80421042e7:	48 be 00 00 00 02 00 	movabs $0x2000000,%rsi
  80421042ee:	00 00 00 
  80421042f1:	48 89 f2             	mov    %rsi,%rdx
  80421042f4:	48 bf 20 05 12 42 80 	movabs $0x8042120520,%rdi
  80421042fb:	00 00 00 
  80421042fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104303:	41 ff d4             	call   *%r12
    cprintf("  entry   %16lx (virt)  %16lx (phys)\n", (unsigned long)entry, (unsigned long)entry - KERN_BASE_ADDR);
  8042104306:	49 bd 00 00 10 42 80 	movabs $0x8042100000,%r13
  804210430d:	00 00 00 
  8042104310:	48 ba 00 00 10 02 00 	movabs $0x2100000,%rdx
  8042104317:	00 00 00 
  804210431a:	4c 89 ee             	mov    %r13,%rsi
  804210431d:	48 bf 48 05 12 42 80 	movabs $0x8042120548,%rdi
  8042104324:	00 00 00 
  8042104327:	b8 00 00 00 00       	mov    $0x0,%eax
  804210432c:	41 ff d4             	call   *%r12
    cprintf("  etext   %16lx (virt)  %16lx (phys)\n", (unsigned long)etext, (unsigned long)etext - KERN_BASE_ADDR);
  804210432f:	48 ba d0 f3 11 02 00 	movabs $0x211f3d0,%rdx
  8042104336:	00 00 00 
  8042104339:	48 be d0 f3 11 42 80 	movabs $0x804211f3d0,%rsi
  8042104340:	00 00 00 
  8042104343:	48 bf 70 05 12 42 80 	movabs $0x8042120570,%rdi
  804210434a:	00 00 00 
  804210434d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104352:	41 ff d4             	call   *%r12
    cprintf("  edata   %16lx (virt)  %16lx (phys)\n", (unsigned long)edata, (unsigned long)edata - KERN_BASE_ADDR);
  8042104355:	48 ba 00 f0 97 02 00 	movabs $0x297f000,%rdx
  804210435c:	00 00 00 
  804210435f:	48 be 00 f0 97 42 80 	movabs $0x804297f000,%rsi
  8042104366:	00 00 00 
  8042104369:	48 bf 98 05 12 42 80 	movabs $0x8042120598,%rdi
  8042104370:	00 00 00 
  8042104373:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104378:	41 ff d4             	call   *%r12
    cprintf("  end     %16lx (virt)  %16lx (phys)\n", (unsigned long)end, (unsigned long)end - KERN_BASE_ADDR);
  804210437b:	48 bb 00 80 00 43 80 	movabs $0x8043008000,%rbx
  8042104382:	00 00 00 
  8042104385:	48 ba 00 80 00 03 00 	movabs $0x3008000,%rdx
  804210438c:	00 00 00 
  804210438f:	48 89 de             	mov    %rbx,%rsi
  8042104392:	48 bf c0 05 12 42 80 	movabs $0x80421205c0,%rdi
  8042104399:	00 00 00 
  804210439c:	b8 00 00 00 00       	mov    $0x0,%eax
  80421043a1:	41 ff d4             	call   *%r12
    cprintf("Kernel executable memory footprint: %luKB\n", (unsigned long)ROUNDUP(end - entry, 1024) / 1024);
  80421043a4:	4c 29 eb             	sub    %r13,%rbx
  80421043a7:	48 8d b3 ff 03 00 00 	lea    0x3ff(%rbx),%rsi
  80421043ae:	48 c1 ee 0a          	shr    $0xa,%rsi
  80421043b2:	48 bf e8 05 12 42 80 	movabs $0x80421205e8,%rdi
  80421043b9:	00 00 00 
  80421043bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80421043c1:	41 ff d4             	call   *%r12
    return 0;
}
  80421043c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80421043c9:	48 83 c4 08          	add    $0x8,%rsp
  80421043cd:	5b                   	pop    %rbx
  80421043ce:	41 5c                	pop    %r12
  80421043d0:	41 5d                	pop    %r13
  80421043d2:	5d                   	pop    %rbp
  80421043d3:	c3                   	ret

00000080421043d4 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf) {
  80421043d4:	f3 0f 1e fa          	endbr64
  80421043d8:	55                   	push   %rbp
  80421043d9:	48 89 e5             	mov    %rsp,%rbp
  80421043dc:	41 57                	push   %r15
  80421043de:	41 56                	push   %r14
  80421043e0:	41 55                	push   %r13
  80421043e2:	41 54                	push   %r12
  80421043e4:	53                   	push   %rbx
  80421043e5:	48 81 ec 28 02 00 00 	sub    $0x228,%rsp
    // LAB 2: Your code here
    cprintf("Stack backtrace:\n");
  80421043ec:	48 bf 8b f5 11 42 80 	movabs $0x804211f58b,%rdi
  80421043f3:	00 00 00 
  80421043f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80421043fb:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042104402:	00 00 00 
  8042104405:	ff d2                	call   *%rdx
}

static inline uint64_t __attribute__((always_inline))
read_rbp(void) {
    uint64_t rbp;
    asm volatile("movq %%rbp,%0"
  8042104407:	48 89 e8             	mov    %rbp,%rax
    uint64_t *rbp = (uint64_t *)read_rbp();
    while (rbp) {
  804210440a:	48 85 c0             	test   %rax,%rax
  804210440d:	74 7e                	je     804210448d <mon_backtrace+0xb9>
  804210440f:	48 89 c3             	mov    %rax,%rbx
        uint64_t rip = *(rbp + 1);
        cprintf("  rbp %016lx  rip %016lx\n", (uint64_t)rbp, rip);
  8042104412:	49 bf 9d f5 11 42 80 	movabs $0x804211f59d,%r15
  8042104419:	00 00 00 
  804210441c:	49 bd 70 cf 10 42 80 	movabs $0x804210cf70,%r13
  8042104423:	00 00 00 
        struct Ripdebuginfo info;
        if (debuginfo_rip(rip, &info) == 0) {
  8042104426:	49 be 96 fd 10 42 80 	movabs $0x804210fd96,%r14
  804210442d:	00 00 00 
  8042104430:	eb 08                	jmp    804210443a <mon_backtrace+0x66>
            cprintf("    %s:%d: %.*s+%lx\n", info.rip_file, info.rip_line,
                    info.rip_fn_namelen, info.rip_fn_name, rip - info.rip_fn_addr);
        }
        rbp = (uint64_t *)(*rbp);
  8042104432:	48 8b 1b             	mov    (%rbx),%rbx
    while (rbp) {
  8042104435:	48 85 db             	test   %rbx,%rbx
  8042104438:	74 53                	je     804210448d <mon_backtrace+0xb9>
        uint64_t rip = *(rbp + 1);
  804210443a:	4c 8b 63 08          	mov    0x8(%rbx),%r12
        cprintf("  rbp %016lx  rip %016lx\n", (uint64_t)rbp, rip);
  804210443e:	4c 89 e2             	mov    %r12,%rdx
  8042104441:	48 89 de             	mov    %rbx,%rsi
  8042104444:	4c 89 ff             	mov    %r15,%rdi
  8042104447:	b8 00 00 00 00       	mov    $0x0,%eax
  804210444c:	41 ff d5             	call   *%r13
        if (debuginfo_rip(rip, &info) == 0) {
  804210444f:	48 8d b5 b8 fd ff ff 	lea    -0x248(%rbp),%rsi
  8042104456:	4c 89 e7             	mov    %r12,%rdi
  8042104459:	41 ff d6             	call   *%r14
  804210445c:	85 c0                	test   %eax,%eax
  804210445e:	75 d2                	jne    8042104432 <mon_backtrace+0x5e>
            cprintf("    %s:%d: %.*s+%lx\n", info.rip_file, info.rip_line,
  8042104460:	4d 89 e1             	mov    %r12,%r9
  8042104463:	4c 2b 4d c0          	sub    -0x40(%rbp),%r9
  8042104467:	4c 8d 85 bc fe ff ff 	lea    -0x144(%rbp),%r8
  804210446e:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  8042104471:	8b 95 b8 fe ff ff    	mov    -0x148(%rbp),%edx
  8042104477:	48 8d b5 b8 fd ff ff 	lea    -0x248(%rbp),%rsi
  804210447e:	48 bf b7 f5 11 42 80 	movabs $0x804211f5b7,%rdi
  8042104485:	00 00 00 
  8042104488:	41 ff d5             	call   *%r13
  804210448b:	eb a5                	jmp    8042104432 <mon_backtrace+0x5e>
    }

    return 0;
}
  804210448d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104492:	48 81 c4 28 02 00 00 	add    $0x228,%rsp
  8042104499:	5b                   	pop    %rbx
  804210449a:	41 5c                	pop    %r12
  804210449c:	41 5d                	pop    %r13
  804210449e:	41 5e                	pop    %r14
  80421044a0:	41 5f                	pop    %r15
  80421044a2:	5d                   	pop    %rbp
  80421044a3:	c3                   	ret

00000080421044a4 <mon_start>:
/* Implement timer_start (mon_start), timer_stop (mon_stop), timer_freq (mon_frequency) commands. */
// LAB 5: Your code here:


int
mon_start(int argc, char **argv, struct Trapframe *tf) {
  80421044a4:	f3 0f 1e fa          	endbr64
    if (argc != 2) {
		return 1;
  80421044a8:	b8 01 00 00 00       	mov    $0x1,%eax
    if (argc != 2) {
  80421044ad:	83 ff 02             	cmp    $0x2,%edi
  80421044b0:	74 01                	je     80421044b3 <mon_start+0xf>
	}
	timer_start(argv[1]);
    return 0;
}
  80421044b2:	c3                   	ret
mon_start(int argc, char **argv, struct Trapframe *tf) {
  80421044b3:	55                   	push   %rbp
  80421044b4:	48 89 e5             	mov    %rsp,%rbp
	timer_start(argv[1]);
  80421044b7:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  80421044bb:	48 b8 87 11 11 42 80 	movabs $0x8042111187,%rax
  80421044c2:	00 00 00 
  80421044c5:	ff d0                	call   *%rax
    return 0;
  80421044c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80421044cc:	5d                   	pop    %rbp
  80421044cd:	c3                   	ret

00000080421044ce <mon_stop>:

int
mon_stop(int argc, char **argv, struct Trapframe *tf) {
  80421044ce:	f3 0f 1e fa          	endbr64
  80421044d2:	55                   	push   %rbp
  80421044d3:	48 89 e5             	mov    %rsp,%rbp
    timer_stop();
  80421044d6:	48 b8 28 12 11 42 80 	movabs $0x8042111228,%rax
  80421044dd:	00 00 00 
  80421044e0:	ff d0                	call   *%rax
    return 0;
}
  80421044e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80421044e7:	5d                   	pop    %rbp
  80421044e8:	c3                   	ret

00000080421044e9 <mon_frequency>:

int
mon_frequency(int argc, char **argv, struct Trapframe *tf) {
  80421044e9:	f3 0f 1e fa          	endbr64
    if (argc != 2) {
		return 1;
  80421044ed:	b8 01 00 00 00       	mov    $0x1,%eax
    if (argc != 2) {
  80421044f2:	83 ff 02             	cmp    $0x2,%edi
  80421044f5:	74 01                	je     80421044f8 <mon_frequency+0xf>
	}
	timer_cpu_frequency(argv[1]);
    return 0;
}
  80421044f7:	c3                   	ret
mon_frequency(int argc, char **argv, struct Trapframe *tf) {
  80421044f8:	55                   	push   %rbp
  80421044f9:	48 89 e5             	mov    %rsp,%rbp
	timer_cpu_frequency(argv[1]);
  80421044fc:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  8042104500:	48 b8 c4 12 11 42 80 	movabs $0x80421112c4,%rax
  8042104507:	00 00 00 
  804210450a:	ff d0                	call   *%rax
    return 0;
  804210450c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8042104511:	5d                   	pop    %rbp
  8042104512:	c3                   	ret

0000008042104513 <mon_memory>:

// LAB 6: Your code here
/* Implement memory (mon_memory) commands. */
int
mon_memory(int argc, char **argv, struct Trapframe *tf) {
  8042104513:	f3 0f 1e fa          	endbr64
  8042104517:	55                   	push   %rbp
  8042104518:	48 89 e5             	mov    %rsp,%rbp
    dump_memory_lists();
  804210451b:	48 b8 8c 6c 10 42 80 	movabs $0x8042106c8c,%rax
  8042104522:	00 00 00 
  8042104525:	ff d0                	call   *%rax
    return 0;
}
  8042104527:	b8 00 00 00 00       	mov    $0x0,%eax
  804210452c:	5d                   	pop    %rbp
  804210452d:	c3                   	ret

000000804210452e <mon_pagetable>:

/* Implement mon_pagetable() and mon_virt()
 * (using dump_virtual_tree(), dump_page_table())*/
int
mon_pagetable(int argc, char **argv, struct Trapframe *tf) {
  804210452e:	f3 0f 1e fa          	endbr64
  8042104532:	55                   	push   %rbp
  8042104533:	48 89 e5             	mov    %rsp,%rbp
    // LAB 7: Your code here
    dump_page_table(current_space->pml4);
  8042104536:	48 a1 d0 10 00 43 80 	movabs 0x80430010d0,%rax
  804210453d:	00 00 00 
  8042104540:	48 8b 38             	mov    (%rax),%rdi
  8042104543:	48 b8 c5 57 10 42 80 	movabs $0x80421057c5,%rax
  804210454a:	00 00 00 
  804210454d:	ff d0                	call   *%rax
    return 0;
}
  804210454f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104554:	5d                   	pop    %rbp
  8042104555:	c3                   	ret

0000008042104556 <mon_virt>:

int
mon_virt(int argc, char **argv, struct Trapframe *tf) {
  8042104556:	f3 0f 1e fa          	endbr64
  804210455a:	55                   	push   %rbp
  804210455b:	48 89 e5             	mov    %rsp,%rbp
    // LAB 7: Your code here
    dump_virtual_tree(current_space->root, current_space->root->class);
  804210455e:	48 a1 d0 10 00 43 80 	movabs 0x80430010d0,%rax
  8042104565:	00 00 00 
  8042104568:	48 8b 78 10          	mov    0x10(%rax),%rdi
  804210456c:	0f b7 77 34          	movzwl 0x34(%rdi),%esi
  8042104570:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
  8042104576:	48 b8 2d 57 10 42 80 	movabs $0x804210572d,%rax
  804210457d:	00 00 00 
  8042104580:	ff d0                	call   *%rax
    return 0;
}
  8042104582:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104587:	5d                   	pop    %rbp
  8042104588:	c3                   	ret

0000008042104589 <mon_dumpcmos>:

// LAB 4: Your code here
int
mon_dumpcmos(int argc, char **argv, struct Trapframe *tf) {
  8042104589:	f3 0f 1e fa          	endbr64
  804210458d:	55                   	push   %rbp
  804210458e:	48 89 e5             	mov    %rsp,%rbp
  8042104591:	41 57                	push   %r15
  8042104593:	41 56                	push   %r14
  8042104595:	41 55                	push   %r13
  8042104597:	41 54                	push   %r12
  8042104599:	53                   	push   %rbx
  804210459a:	48 83 ec 08          	sub    $0x8,%rsp
    // 10: 00 ..
    // Make sure you understand the values read.
    // Hint: Use cmos_read8()/cmos_write8() functions.
    // LAB 4: Your code here
    uint8_t i;
    cprintf("00: ");
  804210459e:	48 bf cc f5 11 42 80 	movabs $0x804211f5cc,%rdi
  80421045a5:	00 00 00 
  80421045a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80421045ad:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421045b4:	00 00 00 
  80421045b7:	ff d2                	call   *%rdx
  80421045b9:	bb 00 00 00 00       	mov    $0x0,%ebx
    for (i = 0; i < CMOS_SIZE; i++) {
		if (i % 16 == 0 && i > 0) {
			cprintf("\n%02X: ", i);
  80421045be:	49 bf d1 f5 11 42 80 	movabs $0x804211f5d1,%r15
  80421045c5:	00 00 00 
  80421045c8:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  80421045cf:	00 00 00 
		}
		cprintf("%02X ", cmos_read8(i));
  80421045d2:	49 be 87 c9 10 42 80 	movabs $0x804210c987,%r14
  80421045d9:	00 00 00 
  80421045dc:	49 bd d9 f5 11 42 80 	movabs $0x804211f5d9,%r13
  80421045e3:	00 00 00 
  80421045e6:	eb 28                	jmp    8042104610 <mon_dumpcmos+0x87>
			cprintf("\n%02X: ", i);
  80421045e8:	89 de                	mov    %ebx,%esi
  80421045ea:	4c 89 ff             	mov    %r15,%rdi
  80421045ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80421045f2:	41 ff d4             	call   *%r12
		cprintf("%02X ", cmos_read8(i));
  80421045f5:	89 df                	mov    %ebx,%edi
  80421045f7:	41 ff d6             	call   *%r14
  80421045fa:	0f b6 f0             	movzbl %al,%esi
  80421045fd:	4c 89 ef             	mov    %r13,%rdi
  8042104600:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104605:	41 ff d4             	call   *%r12
    for (i = 0; i < CMOS_SIZE; i++) {
  8042104608:	83 c3 01             	add    $0x1,%ebx
  804210460b:	83 fb 32             	cmp    $0x32,%ebx
  804210460e:	74 0b                	je     804210461b <mon_dumpcmos+0x92>
		if (i % 16 == 0 && i > 0) {
  8042104610:	f6 c3 0f             	test   $0xf,%bl
  8042104613:	75 e0                	jne    80421045f5 <mon_dumpcmos+0x6c>
  8042104615:	84 db                	test   %bl,%bl
  8042104617:	74 dc                	je     80421045f5 <mon_dumpcmos+0x6c>
  8042104619:	eb cd                	jmp    80421045e8 <mon_dumpcmos+0x5f>
	}
	cprintf("\n");
  804210461b:	48 bf 8a f4 11 42 80 	movabs $0x804211f48a,%rdi
  8042104622:	00 00 00 
  8042104625:	b8 00 00 00 00       	mov    $0x0,%eax
  804210462a:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042104631:	00 00 00 
  8042104634:	ff d2                	call   *%rdx
    
    return 0;
}
  8042104636:	b8 00 00 00 00       	mov    $0x0,%eax
  804210463b:	48 83 c4 08          	add    $0x8,%rsp
  804210463f:	5b                   	pop    %rbx
  8042104640:	41 5c                	pop    %r12
  8042104642:	41 5d                	pop    %r13
  8042104644:	41 5e                	pop    %r14
  8042104646:	41 5f                	pop    %r15
  8042104648:	5d                   	pop    %rbp
  8042104649:	c3                   	ret

000000804210464a <monitor>:
    cprintf("Unknown command '%s'\n", argv[0]);
    return 0;
}

void
monitor(struct Trapframe *tf) {
  804210464a:	f3 0f 1e fa          	endbr64
  804210464e:	55                   	push   %rbp
  804210464f:	48 89 e5             	mov    %rsp,%rbp
  8042104652:	41 57                	push   %r15
  8042104654:	41 56                	push   %r14
  8042104656:	41 55                	push   %r13
  8042104658:	41 54                	push   %r12
  804210465a:	53                   	push   %rbx
  804210465b:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8042104662:	49 89 ff             	mov    %rdi,%r15
  8042104665:	48 89 bd 48 ff ff ff 	mov    %rdi,-0xb8(%rbp)

    cprintf("Welcome to the JOS kernel monitor!\n");
  804210466c:	48 bf 18 06 12 42 80 	movabs $0x8042120618,%rdi
  8042104673:	00 00 00 
  8042104676:	b8 00 00 00 00       	mov    $0x0,%eax
  804210467b:	48 bb 70 cf 10 42 80 	movabs $0x804210cf70,%rbx
  8042104682:	00 00 00 
  8042104685:	ff d3                	call   *%rbx
    cprintf("Type 'help' for a list of commands.\n");
  8042104687:	48 bf 40 06 12 42 80 	movabs $0x8042120640,%rdi
  804210468e:	00 00 00 
  8042104691:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104696:	ff d3                	call   *%rbx

    if (tf) print_trapframe(tf);
  8042104698:	4d 85 ff             	test   %r15,%r15
  804210469b:	74 0f                	je     80421046ac <monitor+0x62>
  804210469d:	4c 89 ff             	mov    %r15,%rdi
  80421046a0:	48 b8 ae d8 10 42 80 	movabs $0x804210d8ae,%rax
  80421046a7:	00 00 00 
  80421046aa:	ff d0                	call   *%rax
        while (*buf && strchr(WHITESPACE, *buf)) *buf++ = 0;
  80421046ac:	49 bd e3 f5 11 42 80 	movabs $0x804211f5e3,%r13
  80421046b3:	00 00 00 
  80421046b6:	e9 f7 00 00 00       	jmp    80421047b2 <monitor+0x168>
  80421046bb:	40 0f be f6          	movsbl %sil,%esi
  80421046bf:	4c 89 ef             	mov    %r13,%rdi
  80421046c2:	41 ff d4             	call   *%r12
  80421046c5:	48 85 c0             	test   %rax,%rax
  80421046c8:	74 0c                	je     80421046d6 <monitor+0x8c>
  80421046ca:	c6 03 00             	movb   $0x0,(%rbx)
  80421046cd:	45 89 f7             	mov    %r14d,%r15d
  80421046d0:	48 8d 5b 01          	lea    0x1(%rbx),%rbx
  80421046d4:	eb 41                	jmp    8042104717 <monitor+0xcd>
        if (!*buf) break;
  80421046d6:	80 3b 00             	cmpb   $0x0,(%rbx)
  80421046d9:	74 47                	je     8042104722 <monitor+0xd8>
        if (argc == MAXARGS - 1) {
  80421046db:	41 83 fe 0f          	cmp    $0xf,%r14d
  80421046df:	0f 84 b2 00 00 00    	je     8042104797 <monitor+0x14d>
        argv[argc++] = buf;
  80421046e5:	45 8d 7e 01          	lea    0x1(%r14),%r15d
  80421046e9:	4d 63 f6             	movslq %r14d,%r14
  80421046ec:	4a 89 9c f5 50 ff ff 	mov    %rbx,-0xb0(%rbp,%r14,8)
  80421046f3:	ff 
        while (*buf && !strchr(WHITESPACE, *buf)) buf++;
  80421046f4:	0f b6 33             	movzbl (%rbx),%esi
  80421046f7:	40 84 f6             	test   %sil,%sil
  80421046fa:	74 1b                	je     8042104717 <monitor+0xcd>
  80421046fc:	40 0f be f6          	movsbl %sil,%esi
  8042104700:	4c 89 ef             	mov    %r13,%rdi
  8042104703:	41 ff d4             	call   *%r12
  8042104706:	48 85 c0             	test   %rax,%rax
  8042104709:	75 0c                	jne    8042104717 <monitor+0xcd>
  804210470b:	48 83 c3 01          	add    $0x1,%rbx
  804210470f:	0f b6 33             	movzbl (%rbx),%esi
  8042104712:	40 84 f6             	test   %sil,%sil
  8042104715:	75 e5                	jne    80421046fc <monitor+0xb2>
        while (*buf && strchr(WHITESPACE, *buf)) *buf++ = 0;
  8042104717:	45 89 fe             	mov    %r15d,%r14d
  804210471a:	0f b6 33             	movzbl (%rbx),%esi
  804210471d:	40 84 f6             	test   %sil,%sil
  8042104720:	75 99                	jne    80421046bb <monitor+0x71>
    argv[argc] = NULL;
  8042104722:	49 63 c6             	movslq %r14d,%rax
  8042104725:	48 c7 84 c5 50 ff ff 	movq   $0x0,-0xb0(%rbp,%rax,8)
  804210472c:	ff 00 00 00 00 
    if (!argc) return 0;
  8042104731:	45 85 f6             	test   %r14d,%r14d
  8042104734:	74 7c                	je     80421047b2 <monitor+0x168>
  8042104736:	48 bb 00 1b 12 42 80 	movabs $0x8042121b00,%rbx
  804210473d:	00 00 00 
    for (size_t i = 0; i < NCOMMANDS; i++) {
  8042104740:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        if (strcmp(argv[0], commands[i].name) == 0)
  8042104746:	49 bf 90 0b 11 42 80 	movabs $0x8042110b90,%r15
  804210474d:	00 00 00 
  8042104750:	48 8b 33             	mov    (%rbx),%rsi
  8042104753:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  804210475a:	41 ff d7             	call   *%r15
  804210475d:	85 c0                	test   %eax,%eax
  804210475f:	0f 84 8b 00 00 00    	je     80421047f0 <monitor+0x1a6>
    for (size_t i = 0; i < NCOMMANDS; i++) {
  8042104765:	49 83 c4 01          	add    $0x1,%r12
  8042104769:	48 83 c3 18          	add    $0x18,%rbx
  804210476d:	49 83 fc 0a          	cmp    $0xa,%r12
  8042104771:	75 dd                	jne    8042104750 <monitor+0x106>
    cprintf("Unknown command '%s'\n", argv[0]);
  8042104773:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  804210477a:	48 bf 05 f6 11 42 80 	movabs $0x804211f605,%rdi
  8042104781:	00 00 00 
  8042104784:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104789:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042104790:	00 00 00 
  8042104793:	ff d2                	call   *%rdx
    return 0;
  8042104795:	eb 1b                	jmp    80421047b2 <monitor+0x168>
            cprintf("Too many arguments (max %d)\n", MAXARGS);
  8042104797:	be 10 00 00 00       	mov    $0x10,%esi
  804210479c:	48 bf e8 f5 11 42 80 	movabs $0x804211f5e8,%rdi
  80421047a3:	00 00 00 
  80421047a6:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421047ad:	00 00 00 
  80421047b0:	ff d2                	call   *%rdx

    char *buf;
    do buf = readline("K> ");
  80421047b2:	48 bf df f5 11 42 80 	movabs $0x804211f5df,%rdi
  80421047b9:	00 00 00 
  80421047bc:	48 b8 4e 09 11 42 80 	movabs $0x804211094e,%rax
  80421047c3:	00 00 00 
  80421047c6:	ff d0                	call   *%rax
  80421047c8:	48 89 c3             	mov    %rax,%rbx
    while (!buf || runcmd(buf, tf) >= 0);
  80421047cb:	48 85 c0             	test   %rax,%rax
  80421047ce:	74 e2                	je     80421047b2 <monitor+0x168>
    argv[0] = NULL;
  80421047d0:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  80421047d7:	00 00 00 00 
    int argc = 0;
  80421047db:	41 be 00 00 00 00    	mov    $0x0,%r14d
        while (*buf && strchr(WHITESPACE, *buf)) *buf++ = 0;
  80421047e1:	49 bc ee 0b 11 42 80 	movabs $0x8042110bee,%r12
  80421047e8:	00 00 00 
  80421047eb:	e9 2a ff ff ff       	jmp    804210471a <monitor+0xd0>
            return commands[i].func(argc, argv, tf);
  80421047f0:	4b 8d 0c 64          	lea    (%r12,%r12,2),%rcx
  80421047f4:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  80421047fb:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  8042104802:	44 89 f7             	mov    %r14d,%edi
  8042104805:	48 b8 00 1b 12 42 80 	movabs $0x8042121b00,%rax
  804210480c:	00 00 00 
  804210480f:	ff 54 c8 10          	call   *0x10(%rax,%rcx,8)
    while (!buf || runcmd(buf, tf) >= 0);
  8042104813:	85 c0                	test   %eax,%eax
  8042104815:	79 9b                	jns    80421047b2 <monitor+0x168>
}
  8042104817:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  804210481e:	5b                   	pop    %rbx
  804210481f:	41 5c                	pop    %r12
  8042104821:	41 5d                	pop    %r13
  8042104823:	41 5e                	pop    %r14
  8042104825:	41 5f                	pop    %r15
  8042104827:	5d                   	pop    %rbp
  8042104828:	c3                   	ret

0000008042104829 <free_descriptor>:

    return new;
}

static void
free_descriptor(struct Page *page) {
  8042104829:	f3 0f 1e fa          	endbr64
    if (!list) {
  804210482d:	48 85 ff             	test   %rdi,%rdi
  8042104830:	74 15                	je     8042104847 <free_descriptor+0x1e>
    struct List *list_prev = list->prev;
  8042104832:	48 8b 17             	mov    (%rdi),%rdx
    struct List *list_next = list->next;
  8042104835:	48 8b 47 08          	mov    0x8(%rdi),%rax
    list_prev->next = list_next;
  8042104839:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list_next->prev = list_prev;
  804210483d:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  8042104840:	48 89 3f             	mov    %rdi,(%rdi)
  8042104843:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
    struct List *list_next = list->next;
  8042104847:	48 b8 40 61 00 43 80 	movabs $0x8043006140,%rax
  804210484e:	00 00 00 
  8042104851:	48 8b 50 08          	mov    0x8(%rax),%rdx
    list_prev->next = list_cur;
  8042104855:	48 89 78 08          	mov    %rdi,0x8(%rax)
    list_next->prev = list_cur;
  8042104859:	48 89 3a             	mov    %rdi,(%rdx)
    list_cur->prev = list_prev;
  804210485c:	48 89 07             	mov    %rax,(%rdi)
    list_cur->next = list_next;
  804210485f:	48 89 57 08          	mov    %rdx,0x8(%rdi)
    list_del((struct List *)page);
    list_append(&free_descriptors, (struct List *)page);
    free_desc_count++;
  8042104863:	48 b8 38 61 00 43 80 	movabs $0x8043006138,%rax
  804210486a:	00 00 00 
  804210486d:	48 83 00 01          	addq   $0x1,(%rax)
}
  8042104871:	c3                   	ret

0000008042104872 <page_ref>:

    return node;
}

static void
page_ref(struct Page *node) {
  8042104872:	f3 0f 1e fa          	endbr64
    if (!node) return;
  8042104876:	48 85 ff             	test   %rdi,%rdi
  8042104879:	74 4b                	je     80421048c6 <page_ref+0x54>
page_ref(struct Page *node) {
  804210487b:	55                   	push   %rbp
  804210487c:	48 89 e5             	mov    %rsp,%rbp
  804210487f:	41 54                	push   %r12
  8042104881:	53                   	push   %rbx
  8042104882:	48 89 fb             	mov    %rdi,%rbx

    /* If parent is allocated
     * all of its children are allocated too,
     * so need to reference them recursively
     * when refc transitions from 0 to 1 */
    if (!node->refc++) {
  8042104885:	8b 47 30             	mov    0x30(%rdi),%eax
  8042104888:	8d 50 01             	lea    0x1(%rax),%edx
  804210488b:	89 57 30             	mov    %edx,0x30(%rdi)
  804210488e:	85 c0                	test   %eax,%eax
  8042104890:	74 05                	je     8042104897 <page_ref+0x25>
        list_del((struct List *)node);
        list_init((struct List *)node);
        page_ref(node->left);
        page_ref(node->right);
    }
}
  8042104892:	5b                   	pop    %rbx
  8042104893:	41 5c                	pop    %r12
  8042104895:	5d                   	pop    %rbp
  8042104896:	c3                   	ret
    struct List *list_prev = list->prev;
  8042104897:	48 8b 17             	mov    (%rdi),%rdx
    struct List *list_next = list->next;
  804210489a:	48 8b 47 08          	mov    0x8(%rdi),%rax
    list_prev->next = list_next;
  804210489e:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list_next->prev = list_prev;
  80421048a2:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  80421048a5:	48 89 3f             	mov    %rdi,(%rdi)
  80421048a8:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
        page_ref(node->left);
  80421048ac:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  80421048b0:	49 bc 72 48 10 42 80 	movabs $0x8042104872,%r12
  80421048b7:	00 00 00 
  80421048ba:	41 ff d4             	call   *%r12
        page_ref(node->right);
  80421048bd:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  80421048c1:	41 ff d4             	call   *%r12
  80421048c4:	eb cc                	jmp    8042104892 <page_ref+0x20>
  80421048c6:	c3                   	ret

00000080421048c7 <free_desc_rec>:
free_desc_rec(struct Page *p) {
  80421048c7:	f3 0f 1e fa          	endbr64
    while (p) {
  80421048cb:	48 85 ff             	test   %rdi,%rdi
  80421048ce:	0f 84 81 00 00 00    	je     8042104955 <free_desc_rec+0x8e>
free_desc_rec(struct Page *p) {
  80421048d4:	55                   	push   %rbp
  80421048d5:	48 89 e5             	mov    %rsp,%rbp
  80421048d8:	41 56                	push   %r14
  80421048da:	41 55                	push   %r13
  80421048dc:	41 54                	push   %r12
  80421048de:	53                   	push   %rbx
  80421048df:	48 89 fb             	mov    %rdi,%rbx
        free_desc_rec(p->right);
  80421048e2:	49 be c7 48 10 42 80 	movabs $0x80421048c7,%r14
  80421048e9:	00 00 00 
        free_descriptor(p);
  80421048ec:	49 bd 29 48 10 42 80 	movabs $0x8042104829,%r13
  80421048f3:	00 00 00 
  80421048f6:	eb 03                	jmp    80421048fb <free_desc_rec+0x34>
  80421048f8:	4c 89 e3             	mov    %r12,%rbx
        assert(!p->refc);
  80421048fb:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  80421048ff:	75 1f                	jne    8042104920 <free_desc_rec+0x59>
        free_desc_rec(p->right);
  8042104901:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8042104905:	41 ff d6             	call   *%r14
        struct Page *tmp = p->left;
  8042104908:	4c 8b 63 10          	mov    0x10(%rbx),%r12
        free_descriptor(p);
  804210490c:	48 89 df             	mov    %rbx,%rdi
  804210490f:	41 ff d5             	call   *%r13
    while (p) {
  8042104912:	4d 85 e4             	test   %r12,%r12
  8042104915:	75 e1                	jne    80421048f8 <free_desc_rec+0x31>
}
  8042104917:	5b                   	pop    %rbx
  8042104918:	41 5c                	pop    %r12
  804210491a:	41 5d                	pop    %r13
  804210491c:	41 5e                	pop    %r14
  804210491e:	5d                   	pop    %rbp
  804210491f:	c3                   	ret
        assert(!p->refc);
  8042104920:	48 b9 0f f7 11 42 80 	movabs $0x804211f70f,%rcx
  8042104927:	00 00 00 
  804210492a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104931:	00 00 00 
  8042104934:	be b7 00 00 00       	mov    $0xb7,%esi
  8042104939:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104940:	00 00 00 
  8042104943:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104948:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210494f:	00 00 00 
  8042104952:	41 ff d0             	call   *%r8
  8042104955:	c3                   	ret

0000008042104956 <page_unref>:

static void
page_unref(struct Page *page) {
  8042104956:	f3 0f 1e fa          	endbr64
    if (!page) return;
  804210495a:	48 85 ff             	test   %rdi,%rdi
  804210495d:	0f 84 8e 02 00 00    	je     8042104bf1 <page_unref+0x29b>
page_unref(struct Page *page) {
  8042104963:	55                   	push   %rbp
  8042104964:	48 89 e5             	mov    %rsp,%rbp
  8042104967:	41 56                	push   %r14
  8042104969:	41 55                	push   %r13
  804210496b:	41 54                	push   %r12
  804210496d:	53                   	push   %rbx
  804210496e:	48 89 fb             	mov    %rdi,%rbx
    assert_physical(page);
  8042104971:	8b 47 28             	mov    0x28(%rdi),%eax
  8042104974:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042104979:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  804210497e:	76 2f                	jbe    80421049af <page_unref+0x59>
    assert(page->refc);
  8042104980:	8b 47 30             	mov    0x30(%rdi),%eax
  8042104983:	85 c0                	test   %eax,%eax
  8042104985:	74 5d                	je     80421049e4 <page_unref+0x8e>

    /* NOTE Decrementing refc after
     * this if statement is important
     * to prevent double frees */

    if (page->refc == 1) {
  8042104987:	83 f8 01             	cmp    $0x1,%eax
  804210498a:	0f 84 84 00 00 00    	je     8042104a14 <page_unref+0xbe>
        page_unref(page->left);
        page_unref(page->right);
    }

    page->refc--;
  8042104990:	8b 43 30             	mov    0x30(%rbx),%eax
  8042104993:	83 e8 01             	sub    $0x1,%eax
  8042104996:	89 43 30             	mov    %eax,0x30(%rbx)

    /* Try to merge free page with adjacent */
    if (PAGE_IS_FREE(page)) {
  8042104999:	75 0b                	jne    80421049a6 <page_unref+0x50>
  804210499b:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  80421049a0:	0f 84 8b 00 00 00    	je     8042104a31 <page_unref+0xdb>
        if (current_space) {
            platform_asan_poison(KADDR(page2pa(page)), CLASS_SIZE(page->class));
        }
#endif
    }
}
  80421049a6:	5b                   	pop    %rbx
  80421049a7:	41 5c                	pop    %r12
  80421049a9:	41 5d                	pop    %r13
  80421049ab:	41 5e                	pop    %r14
  80421049ad:	5d                   	pop    %rbp
  80421049ae:	c3                   	ret
    assert_physical(page);
  80421049af:	48 b9 b0 06 12 42 80 	movabs $0x80421206b0,%rcx
  80421049b6:	00 00 00 
  80421049b9:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421049c0:	00 00 00 
  80421049c3:	be 3f 01 00 00       	mov    $0x13f,%esi
  80421049c8:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421049cf:	00 00 00 
  80421049d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80421049d7:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421049de:	00 00 00 
  80421049e1:	41 ff d0             	call   *%r8
    assert(page->refc);
  80421049e4:	48 b9 ed f8 11 42 80 	movabs $0x804211f8ed,%rcx
  80421049eb:	00 00 00 
  80421049ee:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421049f5:	00 00 00 
  80421049f8:	be 40 01 00 00       	mov    $0x140,%esi
  80421049fd:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104a04:	00 00 00 
  8042104a07:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104a0e:	00 00 00 
  8042104a11:	41 ff d0             	call   *%r8
        page_unref(page->left);
  8042104a14:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  8042104a18:	49 bc 56 49 10 42 80 	movabs $0x8042104956,%r12
  8042104a1f:	00 00 00 
  8042104a22:	41 ff d4             	call   *%r12
        page_unref(page->right);
  8042104a25:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8042104a29:	41 ff d4             	call   *%r12
  8042104a2c:	e9 5f ff ff ff       	jmp    8042104990 <page_unref+0x3a>
    if (PAGE_IS_FREE(page)) {
  8042104a31:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8042104a36:	0f 85 6a ff ff ff    	jne    80421049a6 <page_unref+0x50>
        while (page != &root) {
  8042104a3c:	48 b8 80 10 00 43 80 	movabs $0x8043001080,%rax
  8042104a43:	00 00 00 
  8042104a46:	48 39 c3             	cmp    %rax,%rbx
  8042104a49:	0f 84 9d 01 00 00    	je     8042104bec <page_unref+0x296>
                free_descriptor(par->left);
  8042104a4f:	49 bc 29 48 10 42 80 	movabs $0x8042104829,%r12
  8042104a56:	00 00 00 
    struct List *list_next = list->next;
  8042104a59:	49 be 60 61 00 43 80 	movabs $0x8043006160,%r14
  8042104a60:	00 00 00 
        while (page != &root) {
  8042104a63:	49 89 c5             	mov    %rax,%r13
  8042104a66:	eb 73                	jmp    8042104adb <page_unref+0x185>
            assert_physical(par);
  8042104a68:	48 b9 e8 06 12 42 80 	movabs $0x80421206e8,%rcx
  8042104a6f:	00 00 00 
  8042104a72:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104a79:	00 00 00 
  8042104a7c:	be 51 01 00 00       	mov    $0x151,%esi
  8042104a81:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104a88:	00 00 00 
  8042104a8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104a90:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104a97:	00 00 00 
  8042104a9a:	41 ff d0             	call   *%r8
                    assert(list_empty((struct List *)par));
  8042104a9d:	48 b9 18 07 12 42 80 	movabs $0x8042120718,%rcx
  8042104aa4:	00 00 00 
  8042104aa7:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104aae:	00 00 00 
  8042104ab1:	be 5c 01 00 00       	mov    $0x15c,%esi
  8042104ab6:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104abd:	00 00 00 
  8042104ac0:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104ac5:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104acc:	00 00 00 
  8042104acf:	41 ff d0             	call   *%r8
        while (page != &root) {
  8042104ad2:	4c 39 eb             	cmp    %r13,%rbx
  8042104ad5:	0f 84 b7 00 00 00    	je     8042104b92 <page_unref+0x23c>
            struct Page *par = page->parent;
  8042104adb:	48 89 da             	mov    %rbx,%rdx
  8042104ade:	48 8b 5b 20          	mov    0x20(%rbx),%rbx
            assert_physical(par);
  8042104ae2:	8b 43 28             	mov    0x28(%rbx),%eax
  8042104ae5:	89 c1                	mov    %eax,%ecx
  8042104ae7:	81 e1 00 00 f0 00    	and    $0xf00000,%ecx
  8042104aed:	81 f9 ff ff 2f 00    	cmp    $0x2fffff,%ecx
  8042104af3:	0f 86 6f ff ff ff    	jbe    8042104a68 <page_unref+0x112>
            if (par->state == page->state &&
  8042104af9:	3b 42 28             	cmp    0x28(%rdx),%eax
  8042104afc:	0f 85 93 00 00 00    	jne    8042104b95 <page_unref+0x23f>
                PAGE_IS_FREE(par->left) &&
  8042104b02:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
            if (par->state == page->state &&
  8042104b06:	83 7f 30 00          	cmpl   $0x0,0x30(%rdi)
  8042104b0a:	0f 85 85 00 00 00    	jne    8042104b95 <page_unref+0x23f>
                PAGE_IS_FREE(par->left) &&
  8042104b10:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
  8042104b15:	75 7e                	jne    8042104b95 <page_unref+0x23f>
  8042104b17:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
  8042104b1c:	75 77                	jne    8042104b95 <page_unref+0x23f>
                PAGE_IS_FREE(par->right)) {
  8042104b1e:	48 8b 43 18          	mov    0x18(%rbx),%rax
                PAGE_IS_FREE(par->left) &&
  8042104b22:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042104b26:	75 6d                	jne    8042104b95 <page_unref+0x23f>
                PAGE_IS_FREE(par->right)) {
  8042104b28:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  8042104b2d:	75 66                	jne    8042104b95 <page_unref+0x23f>
  8042104b2f:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  8042104b34:	75 5f                	jne    8042104b95 <page_unref+0x23f>
                free_descriptor(par->left);
  8042104b36:	41 ff d4             	call   *%r12
                par->left = NULL;
  8042104b39:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  8042104b40:	00 
                free_descriptor(par->right);
  8042104b41:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8042104b45:	41 ff d4             	call   *%r12
                par->right = NULL;
  8042104b48:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  8042104b4f:	00 
                if (par->state == ALLOCATABLE_NODE) {
  8042104b50:	81 7b 28 00 00 40 00 	cmpl   $0x400000,0x28(%rbx)
  8042104b57:	0f 85 75 ff ff ff    	jne    8042104ad2 <page_unref+0x17c>
                    assert(list_empty((struct List *)par));
  8042104b5d:	48 3b 5b 08          	cmp    0x8(%rbx),%rbx
  8042104b61:	0f 85 36 ff ff ff    	jne    8042104a9d <page_unref+0x147>
                    list_append(&free_classes[par->class], (struct List *)par);
  8042104b67:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
    struct List *list_next = list->next;
  8042104b6b:	48 89 c2             	mov    %rax,%rdx
  8042104b6e:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  8042104b74:	48 c1 e2 04          	shl    $0x4,%rdx
  8042104b78:	4c 01 f2             	add    %r14,%rdx
  8042104b7b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
    list_prev->next = list_cur;
  8042104b7f:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
    list_next->prev = list_cur;
  8042104b83:	48 89 19             	mov    %rbx,(%rcx)
                    list_append(&free_classes[par->class], (struct List *)par);
  8042104b86:	48 89 13             	mov    %rdx,(%rbx)
    list_cur->next = list_next;
  8042104b89:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
}
  8042104b8d:	e9 40 ff ff ff       	jmp    8042104ad2 <page_unref+0x17c>
  8042104b92:	48 89 da             	mov    %rbx,%rdx
    struct List *list_prev = list->prev;
  8042104b95:	48 8b 0a             	mov    (%rdx),%rcx
    struct List *list_next = list->next;
  8042104b98:	48 8b 42 08          	mov    0x8(%rdx),%rax
    list_prev->next = list_next;
  8042104b9c:	48 89 41 08          	mov    %rax,0x8(%rcx)
    list_next->prev = list_prev;
  8042104ba0:	48 89 08             	mov    %rcx,(%rax)
    list->next = list->prev = list;
  8042104ba3:	48 89 12             	mov    %rdx,(%rdx)
  8042104ba6:	48 89 52 08          	mov    %rdx,0x8(%rdx)
        if (page->state == ALLOCATABLE_NODE)
  8042104baa:	81 7a 28 00 00 40 00 	cmpl   $0x400000,0x28(%rdx)
  8042104bb1:	0f 85 ef fd ff ff    	jne    80421049a6 <page_unref+0x50>
            list_append(&free_classes[page->class], (struct List *)page);
  8042104bb7:	0f b7 42 34          	movzwl 0x34(%rdx),%eax
    struct List *list_next = list->next;
  8042104bbb:	48 bf 60 61 00 43 80 	movabs $0x8043006160,%rdi
  8042104bc2:	00 00 00 
  8042104bc5:	48 89 c1             	mov    %rax,%rcx
  8042104bc8:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042104bce:	48 c1 e1 04          	shl    $0x4,%rcx
  8042104bd2:	48 01 f9             	add    %rdi,%rcx
  8042104bd5:	48 8b 71 08          	mov    0x8(%rcx),%rsi
    list_prev->next = list_cur;
  8042104bd9:	48 89 51 08          	mov    %rdx,0x8(%rcx)
    list_next->prev = list_cur;
  8042104bdd:	48 89 16             	mov    %rdx,(%rsi)
            list_append(&free_classes[page->class], (struct List *)page);
  8042104be0:	48 89 0a             	mov    %rcx,(%rdx)
    list_cur->next = list_next;
  8042104be3:	48 89 72 08          	mov    %rsi,0x8(%rdx)
}
  8042104be7:	e9 ba fd ff ff       	jmp    80421049a6 <page_unref+0x50>
        while (page != &root) {
  8042104bec:	48 89 da             	mov    %rbx,%rdx
  8042104bef:	eb a4                	jmp    8042104b95 <page_unref+0x23f>
  8042104bf1:	c3                   	ret

0000008042104bf2 <unmap_page_remove>:
        new_class = 0;
    }
}

static void
unmap_page_remove(struct Page *node) {
  8042104bf2:	f3 0f 1e fa          	endbr64
    if (!node) return;
  8042104bf6:	48 85 ff             	test   %rdi,%rdi
  8042104bf9:	0f 84 82 01 00 00    	je     8042104d81 <unmap_page_remove+0x18f>
unmap_page_remove(struct Page *node) {
  8042104bff:	55                   	push   %rbp
  8042104c00:	48 89 e5             	mov    %rsp,%rbp
  8042104c03:	41 54                	push   %r12
  8042104c05:	53                   	push   %rbx
  8042104c06:	48 89 fb             	mov    %rdi,%rbx
    assert_virtual(node);
  8042104c09:	8b 47 28             	mov    0x28(%rdi),%eax
  8042104c0c:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042104c11:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8042104c16:	77 68                	ja     8042104c80 <unmap_page_remove+0x8e>

    if (node->phy) {
  8042104c18:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
  8042104c1c:	48 85 ff             	test   %rdi,%rdi
  8042104c1f:	0f 84 fa 00 00 00    	je     8042104d1f <unmap_page_remove+0x12d>
        assert(!node->left && !node->right);
  8042104c25:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  8042104c2a:	0f 85 85 00 00 00    	jne    8042104cb5 <unmap_page_remove+0xc3>
  8042104c30:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8042104c35:	75 7e                	jne    8042104cb5 <unmap_page_remove+0xc3>
        assert((node->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8042104c37:	3d 00 00 10 00       	cmp    $0x100000,%eax
  8042104c3c:	0f 85 a8 00 00 00    	jne    8042104cea <unmap_page_remove+0xf8>
        page_unref(node->phy);
  8042104c42:	48 b8 56 49 10 42 80 	movabs $0x8042104956,%rax
  8042104c49:	00 00 00 
  8042104c4c:	ff d0                	call   *%rax
        assert((node->state & NODE_TYPE_MASK) == INTERMEDIATE_NODE);
        unmap_page_remove(node->left);
        unmap_page_remove(node->right);
    }

    if (node->parent) {
  8042104c4e:	48 8b 43 20          	mov    0x20(%rbx),%rax
  8042104c52:	48 85 c0             	test   %rax,%rax
  8042104c55:	74 15                	je     8042104c6c <unmap_page_remove+0x7a>
        *(node->parent->left == node ?
                  &node->parent->left :
  8042104c57:	48 8d 50 18          	lea    0x18(%rax),%rdx
  8042104c5b:	48 39 58 10          	cmp    %rbx,0x10(%rax)
  8042104c5f:	0f 84 13 01 00 00    	je     8042104d78 <unmap_page_remove+0x186>
                  &node->parent->right) = NULL;
  8042104c65:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    }

    free_descriptor(node);
  8042104c6c:	48 89 df             	mov    %rbx,%rdi
  8042104c6f:	48 b8 29 48 10 42 80 	movabs $0x8042104829,%rax
  8042104c76:	00 00 00 
  8042104c79:	ff d0                	call   *%rax
}
  8042104c7b:	5b                   	pop    %rbx
  8042104c7c:	41 5c                	pop    %r12
  8042104c7e:	5d                   	pop    %rbp
  8042104c7f:	c3                   	ret
    assert_virtual(node);
  8042104c80:	48 b9 38 07 12 42 80 	movabs $0x8042120738,%rcx
  8042104c87:	00 00 00 
  8042104c8a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104c91:	00 00 00 
  8042104c94:	be f3 01 00 00       	mov    $0x1f3,%esi
  8042104c99:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104ca0:	00 00 00 
  8042104ca3:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104ca8:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104caf:	00 00 00 
  8042104cb2:	41 ff d0             	call   *%r8
        assert(!node->left && !node->right);
  8042104cb5:	48 b9 24 f7 11 42 80 	movabs $0x804211f724,%rcx
  8042104cbc:	00 00 00 
  8042104cbf:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104cc6:	00 00 00 
  8042104cc9:	be f6 01 00 00       	mov    $0x1f6,%esi
  8042104cce:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104cd5:	00 00 00 
  8042104cd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104cdd:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104ce4:	00 00 00 
  8042104ce7:	41 ff d0             	call   *%r8
        assert((node->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8042104cea:	48 b9 68 07 12 42 80 	movabs $0x8042120768,%rcx
  8042104cf1:	00 00 00 
  8042104cf4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104cfb:	00 00 00 
  8042104cfe:	be f7 01 00 00       	mov    $0x1f7,%esi
  8042104d03:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104d0a:	00 00 00 
  8042104d0d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104d12:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104d19:	00 00 00 
  8042104d1c:	41 ff d0             	call   *%r8
        assert((node->state & NODE_TYPE_MASK) == INTERMEDIATE_NODE);
  8042104d1f:	3d 00 00 20 00       	cmp    $0x200000,%eax
  8042104d24:	75 1d                	jne    8042104d43 <unmap_page_remove+0x151>
        unmap_page_remove(node->left);
  8042104d26:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8042104d2a:	49 bc f2 4b 10 42 80 	movabs $0x8042104bf2,%r12
  8042104d31:	00 00 00 
  8042104d34:	41 ff d4             	call   *%r12
        unmap_page_remove(node->right);
  8042104d37:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8042104d3b:	41 ff d4             	call   *%r12
  8042104d3e:	e9 0b ff ff ff       	jmp    8042104c4e <unmap_page_remove+0x5c>
        assert((node->state & NODE_TYPE_MASK) == INTERMEDIATE_NODE);
  8042104d43:	48 b9 98 07 12 42 80 	movabs $0x8042120798,%rcx
  8042104d4a:	00 00 00 
  8042104d4d:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104d54:	00 00 00 
  8042104d57:	be fa 01 00 00       	mov    $0x1fa,%esi
  8042104d5c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104d63:	00 00 00 
  8042104d66:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104d6b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104d72:	00 00 00 
  8042104d75:	41 ff d0             	call   *%r8
                  &node->parent->left :
  8042104d78:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8042104d7c:	e9 e4 fe ff ff       	jmp    8042104c65 <unmap_page_remove+0x73>
  8042104d81:	c3                   	ret

0000008042104d82 <check_virtual_class>:
check_virtual_class(struct Page *node, int class) {
  8042104d82:	f3 0f 1e fa          	endbr64
    while (node->parent) class ++, node = node->parent;
  8042104d86:	48 8b 47 20          	mov    0x20(%rdi),%rax
  8042104d8a:	48 85 c0             	test   %rax,%rax
  8042104d8d:	74 0c                	je     8042104d9b <check_virtual_class+0x19>
  8042104d8f:	83 c6 01             	add    $0x1,%esi
  8042104d92:	48 8b 40 20          	mov    0x20(%rax),%rax
  8042104d96:	48 85 c0             	test   %rax,%rax
  8042104d99:	75 f4                	jne    8042104d8f <check_virtual_class+0xd>
    assert(class == MAX_CLASS);
  8042104d9b:	83 fe 30             	cmp    $0x30,%esi
  8042104d9e:	75 01                	jne    8042104da1 <check_virtual_class+0x1f>
  8042104da0:	c3                   	ret
check_virtual_class(struct Page *node, int class) {
  8042104da1:	55                   	push   %rbp
  8042104da2:	48 89 e5             	mov    %rsp,%rbp
    assert(class == MAX_CLASS);
  8042104da5:	48 b9 46 f7 11 42 80 	movabs $0x804211f746,%rcx
  8042104dac:	00 00 00 
  8042104daf:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104db6:	00 00 00 
  8042104db9:	be 92 01 00 00       	mov    $0x192,%esi
  8042104dbe:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104dc5:	00 00 00 
  8042104dc8:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104dcd:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104dd4:	00 00 00 
  8042104dd7:	41 ff d0             	call   *%r8

0000008042104dda <check_physical_tree>:
            base & PTE_PS ? 'S' : '-',
            step);
}

static void
check_physical_tree(struct Page *page) {
  8042104dda:	f3 0f 1e fa          	endbr64
  8042104dde:	55                   	push   %rbp
  8042104ddf:	48 89 e5             	mov    %rsp,%rbp
  8042104de2:	41 54                	push   %r12
  8042104de4:	53                   	push   %rbx
    assert_physical(page);
  8042104de5:	44 8b 57 28          	mov    0x28(%rdi),%r10d
  8042104de9:	44 89 d0             	mov    %r10d,%eax
  8042104dec:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042104df1:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8042104df6:	0f 86 99 00 00 00    	jbe    8042104e95 <check_physical_tree+0xbb>
  8042104dfc:	48 89 fb             	mov    %rdi,%rbx
/* Number of PML4 entries taken by userspace */
#define NUSERPML4 1

inline static physaddr_t __attribute__((always_inline))
page2pa(struct Page *page) {
    return page->addr << CLASS_BASE;
  8042104dff:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8042104e06:	ff 0f 00 
  8042104e09:	49 89 c1             	mov    %rax,%r9
  8042104e0c:	4c 23 4f 38          	and    0x38(%rdi),%r9
  8042104e10:	4d 89 c8             	mov    %r9,%r8
  8042104e13:	49 c1 e0 0c          	shl    $0xc,%r8
  8042104e17:	49 21 c0             	and    %rax,%r8
    assert(page->class >= 0);
    assert(!(page2pa(page) & CLASS_MASK(page->class)));
  8042104e1a:	0f b7 47 34          	movzwl 0x34(%rdi),%eax
  8042104e1e:	89 c2                	mov    %eax,%edx
  8042104e20:	66 81 e2 ff 0f       	and    $0xfff,%dx
  8042104e25:	25 ff 0f 00 00       	and    $0xfff,%eax
  8042104e2a:	8d 48 0c             	lea    0xc(%rax),%ecx
  8042104e2d:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
  8042104e34:	48 d3 e6             	shl    %cl,%rsi
  8042104e37:	48 f7 d6             	not    %rsi
  8042104e3a:	4c 85 c6             	test   %r8,%rsi
  8042104e3d:	0f 85 87 00 00 00    	jne    8042104eca <check_physical_tree+0xf0>
    if (page->state == ALLOCATABLE_NODE || page->state == RESERVED_NODE) {
  8042104e43:	44 89 d1             	mov    %r10d,%ecx
  8042104e46:	81 e1 ff ff ef ff    	and    $0xffefffff,%ecx
  8042104e4c:	81 f9 00 00 40 00    	cmp    $0x400000,%ecx
  8042104e52:	0f 85 11 01 00 00    	jne    8042104f69 <check_physical_tree+0x18f>
        if (page->left) assert(page->left->state == page->state);
  8042104e58:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  8042104e5c:	48 85 ff             	test   %rdi,%rdi
  8042104e5f:	0f 84 8e 05 00 00    	je     80421053f3 <check_physical_tree+0x619>
  8042104e65:	44 3b 57 28          	cmp    0x28(%rdi),%r10d
  8042104e69:	0f 85 90 00 00 00    	jne    8042104eff <check_physical_tree+0x125>
        if (page->right) assert(page->right->state == page->state);
  8042104e6f:	4c 8b 63 18          	mov    0x18(%rbx),%r12
  8042104e73:	4d 85 e4             	test   %r12,%r12
  8042104e76:	0f 84 f6 00 00 00    	je     8042104f72 <check_physical_tree+0x198>
  8042104e7c:	45 3b 54 24 28       	cmp    0x28(%r12),%r10d
  8042104e81:	0f 85 ad 00 00 00    	jne    8042104f34 <check_physical_tree+0x15a>
    }
    if (page->left) {
  8042104e87:	48 85 ff             	test   %rdi,%rdi
  8042104e8a:	0f 85 e2 00 00 00    	jne    8042104f72 <check_physical_tree+0x198>
  8042104e90:	e9 1c 01 00 00       	jmp    8042104fb1 <check_physical_tree+0x1d7>
    assert_physical(page);
  8042104e95:	48 b9 b0 06 12 42 80 	movabs $0x80421206b0,%rcx
  8042104e9c:	00 00 00 
  8042104e9f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104ea6:	00 00 00 
  8042104ea9:	be 42 02 00 00       	mov    $0x242,%esi
  8042104eae:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104eb5:	00 00 00 
  8042104eb8:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104ebd:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104ec4:	00 00 00 
  8042104ec7:	41 ff d0             	call   *%r8
    assert(!(page2pa(page) & CLASS_MASK(page->class)));
  8042104eca:	48 b9 d0 07 12 42 80 	movabs $0x80421207d0,%rcx
  8042104ed1:	00 00 00 
  8042104ed4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104edb:	00 00 00 
  8042104ede:	be 44 02 00 00       	mov    $0x244,%esi
  8042104ee3:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104eea:	00 00 00 
  8042104eed:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104ef2:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104ef9:	00 00 00 
  8042104efc:	41 ff d0             	call   *%r8
        if (page->left) assert(page->left->state == page->state);
  8042104eff:	48 b9 00 08 12 42 80 	movabs $0x8042120800,%rcx
  8042104f06:	00 00 00 
  8042104f09:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104f10:	00 00 00 
  8042104f13:	be 46 02 00 00       	mov    $0x246,%esi
  8042104f18:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104f1f:	00 00 00 
  8042104f22:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104f27:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104f2e:	00 00 00 
  8042104f31:	41 ff d0             	call   *%r8
        if (page->right) assert(page->right->state == page->state);
  8042104f34:	48 b9 28 08 12 42 80 	movabs $0x8042120828,%rcx
  8042104f3b:	00 00 00 
  8042104f3e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042104f45:	00 00 00 
  8042104f48:	be 47 02 00 00       	mov    $0x247,%esi
  8042104f4d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042104f54:	00 00 00 
  8042104f57:	b8 00 00 00 00       	mov    $0x0,%eax
  8042104f5c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042104f63:	00 00 00 
  8042104f66:	41 ff d0             	call   *%r8
    if (page->left) {
  8042104f69:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  8042104f6d:	48 85 ff             	test   %rdi,%rdi
  8042104f70:	74 36                	je     8042104fa8 <check_physical_tree+0x1ce>
        assert(page->left->class + 1 == page->class);
  8042104f72:	0f b7 4f 34          	movzwl 0x34(%rdi),%ecx
  8042104f76:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042104f7c:	83 c1 01             	add    $0x1,%ecx
  8042104f7f:	39 c8                	cmp    %ecx,%eax
  8042104f81:	0f 85 32 01 00 00    	jne    80421050b9 <check_physical_tree+0x2df>
  8042104f87:	48 be ff ff ff ff ff 	movabs $0xfffffffffffff,%rsi
  8042104f8e:	ff 0f 00 
  8042104f91:	48 89 f1             	mov    %rsi,%rcx
  8042104f94:	48 23 4f 38          	and    0x38(%rdi),%rcx
  8042104f98:	48 c1 e1 0c          	shl    $0xc,%rcx
  8042104f9c:	48 21 f1             	and    %rsi,%rcx
        assert(page2pa(page) == page2pa(page->left));
  8042104f9f:	49 39 c8             	cmp    %rcx,%r8
  8042104fa2:	0f 85 46 01 00 00    	jne    80421050ee <check_physical_tree+0x314>
    }
    if (page->right) {
  8042104fa8:	4c 8b 63 18          	mov    0x18(%rbx),%r12
  8042104fac:	4d 85 e4             	test   %r12,%r12
  8042104faf:	74 3d                	je     8042104fee <check_physical_tree+0x214>
        assert(page->right->class + 1 == page->class);
  8042104fb1:	41 0f b7 4c 24 34    	movzwl 0x34(%r12),%ecx
  8042104fb7:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042104fbd:	83 c1 01             	add    $0x1,%ecx
  8042104fc0:	39 c8                	cmp    %ecx,%eax
  8042104fc2:	0f 85 5b 01 00 00    	jne    8042105123 <check_physical_tree+0x349>
        assert(page->addr + (1ULL << (page->class - 1)) == page->right->addr);
  8042104fc8:	8d 48 ff             	lea    -0x1(%rax),%ecx
  8042104fcb:	be 01 00 00 00       	mov    $0x1,%esi
  8042104fd0:	48 d3 e6             	shl    %cl,%rsi
  8042104fd3:	4c 01 ce             	add    %r9,%rsi
  8042104fd6:	48 b9 ff ff ff ff ff 	movabs $0xfffffffffffff,%rcx
  8042104fdd:	ff 0f 00 
  8042104fe0:	49 23 4c 24 38       	and    0x38(%r12),%rcx
  8042104fe5:	48 39 ce             	cmp    %rcx,%rsi
  8042104fe8:	0f 85 6a 01 00 00    	jne    8042105158 <check_physical_tree+0x37e>
    }
    if (page->parent) {
  8042104fee:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  8042104ff2:	48 85 f6             	test   %rsi,%rsi
  8042104ff5:	0f 84 fc 01 00 00    	je     80421051f7 <check_physical_tree+0x41d>
        assert(page->parent->class - 1 == page->class);
  8042104ffb:	0f b7 4e 34          	movzwl 0x34(%rsi),%ecx
  8042104fff:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042105005:	83 e9 01             	sub    $0x1,%ecx
  8042105008:	39 c8                	cmp    %ecx,%eax
  804210500a:	0f 85 7d 01 00 00    	jne    804210518d <check_physical_tree+0x3b3>
        assert((page->parent->left == page) ^ (page->parent->right == page));
  8042105010:	48 39 5e 10          	cmp    %rbx,0x10(%rsi)
  8042105014:	0f 95 c1             	setne  %cl
  8042105017:	48 39 5e 18          	cmp    %rbx,0x18(%rsi)
  804210501b:	0f 94 c0             	sete   %al
  804210501e:	38 c1                	cmp    %al,%cl
  8042105020:	0f 85 9c 01 00 00    	jne    80421051c2 <check_physical_tree+0x3e8>
    } else {
        assert(page->class == MAX_CLASS);
        assert(page == &root);
    }
    if (!page->refc) {
  8042105026:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  804210502a:	0f 85 87 02 00 00    	jne    80421052b7 <check_physical_tree+0x4dd>
        assert(page->head.next && page->head.prev);
  8042105030:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8042105034:	48 85 c0             	test   %rax,%rax
  8042105037:	0f 84 45 02 00 00    	je     8042105282 <check_physical_tree+0x4a8>
  804210503d:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  8042105041:	0f 84 3b 02 00 00    	je     8042105282 <check_physical_tree+0x4a8>
        if (!list_empty((struct List *)page)) {
  8042105047:	48 39 d8             	cmp    %rbx,%rax
  804210504a:	0f 84 90 02 00 00    	je     80421052e0 <check_physical_tree+0x506>
            for (struct List *n = page->head.next;
                 n != &free_classes[page->class]; n = n->next) {
  8042105050:	0f b7 d2             	movzwl %dx,%edx
  8042105053:	48 c1 e2 04          	shl    $0x4,%rdx
  8042105057:	48 b9 60 61 00 43 80 	movabs $0x8043006160,%rcx
  804210505e:	00 00 00 
  8042105061:	48 01 ca             	add    %rcx,%rdx
  8042105064:	48 39 d0             	cmp    %rdx,%rax
  8042105067:	0f 84 73 02 00 00    	je     80421052e0 <check_physical_tree+0x506>
                assert(n != &page->head);
  804210506d:	48 39 d8             	cmp    %rbx,%rax
  8042105070:	74 12                	je     8042105084 <check_physical_tree+0x2aa>
                 n != &free_classes[page->class]; n = n->next) {
  8042105072:	48 8b 40 08          	mov    0x8(%rax),%rax
  8042105076:	48 39 c2             	cmp    %rax,%rdx
  8042105079:	0f 84 61 02 00 00    	je     80421052e0 <check_physical_tree+0x506>
                assert(n != &page->head);
  804210507f:	48 39 d8             	cmp    %rbx,%rax
  8042105082:	75 ee                	jne    8042105072 <check_physical_tree+0x298>
  8042105084:	48 b9 67 f7 11 42 80 	movabs $0x804211f767,%rcx
  804210508b:	00 00 00 
  804210508e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105095:	00 00 00 
  8042105098:	be 5d 02 00 00       	mov    $0x25d,%esi
  804210509d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421050a4:	00 00 00 
  80421050a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80421050ac:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421050b3:	00 00 00 
  80421050b6:	41 ff d0             	call   *%r8
        assert(page->left->class + 1 == page->class);
  80421050b9:	48 b9 50 08 12 42 80 	movabs $0x8042120850,%rcx
  80421050c0:	00 00 00 
  80421050c3:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421050ca:	00 00 00 
  80421050cd:	be 4a 02 00 00       	mov    $0x24a,%esi
  80421050d2:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421050d9:	00 00 00 
  80421050dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80421050e1:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421050e8:	00 00 00 
  80421050eb:	41 ff d0             	call   *%r8
        assert(page2pa(page) == page2pa(page->left));
  80421050ee:	48 b9 78 08 12 42 80 	movabs $0x8042120878,%rcx
  80421050f5:	00 00 00 
  80421050f8:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421050ff:	00 00 00 
  8042105102:	be 4b 02 00 00       	mov    $0x24b,%esi
  8042105107:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210510e:	00 00 00 
  8042105111:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105116:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210511d:	00 00 00 
  8042105120:	41 ff d0             	call   *%r8
        assert(page->right->class + 1 == page->class);
  8042105123:	48 b9 a0 08 12 42 80 	movabs $0x80421208a0,%rcx
  804210512a:	00 00 00 
  804210512d:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105134:	00 00 00 
  8042105137:	be 4e 02 00 00       	mov    $0x24e,%esi
  804210513c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105143:	00 00 00 
  8042105146:	b8 00 00 00 00       	mov    $0x0,%eax
  804210514b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105152:	00 00 00 
  8042105155:	41 ff d0             	call   *%r8
        assert(page->addr + (1ULL << (page->class - 1)) == page->right->addr);
  8042105158:	48 b9 c8 08 12 42 80 	movabs $0x80421208c8,%rcx
  804210515f:	00 00 00 
  8042105162:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105169:	00 00 00 
  804210516c:	be 4f 02 00 00       	mov    $0x24f,%esi
  8042105171:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105178:	00 00 00 
  804210517b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105180:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105187:	00 00 00 
  804210518a:	41 ff d0             	call   *%r8
        assert(page->parent->class - 1 == page->class);
  804210518d:	48 b9 08 09 12 42 80 	movabs $0x8042120908,%rcx
  8042105194:	00 00 00 
  8042105197:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210519e:	00 00 00 
  80421051a1:	be 52 02 00 00       	mov    $0x252,%esi
  80421051a6:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421051ad:	00 00 00 
  80421051b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80421051b5:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421051bc:	00 00 00 
  80421051bf:	41 ff d0             	call   *%r8
        assert((page->parent->left == page) ^ (page->parent->right == page));
  80421051c2:	48 b9 30 09 12 42 80 	movabs $0x8042120930,%rcx
  80421051c9:	00 00 00 
  80421051cc:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421051d3:	00 00 00 
  80421051d6:	be 53 02 00 00       	mov    $0x253,%esi
  80421051db:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421051e2:	00 00 00 
  80421051e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80421051ea:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421051f1:	00 00 00 
  80421051f4:	41 ff d0             	call   *%r8
        assert(page->class == MAX_CLASS);
  80421051f7:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
  80421051fb:	66 25 ff 0f          	and    $0xfff,%ax
  80421051ff:	66 83 f8 30          	cmp    $0x30,%ax
  8042105203:	75 48                	jne    804210524d <check_physical_tree+0x473>
        assert(page == &root);
  8042105205:	48 b8 80 10 00 43 80 	movabs $0x8043001080,%rax
  804210520c:	00 00 00 
  804210520f:	48 39 c3             	cmp    %rax,%rbx
  8042105212:	0f 84 0e fe ff ff    	je     8042105026 <check_physical_tree+0x24c>
  8042105218:	48 b9 59 f7 11 42 80 	movabs $0x804211f759,%rcx
  804210521f:	00 00 00 
  8042105222:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105229:	00 00 00 
  804210522c:	be 56 02 00 00       	mov    $0x256,%esi
  8042105231:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105238:	00 00 00 
  804210523b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105240:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105247:	00 00 00 
  804210524a:	41 ff d0             	call   *%r8
        assert(page->class == MAX_CLASS);
  804210524d:	48 b9 40 f7 11 42 80 	movabs $0x804211f740,%rcx
  8042105254:	00 00 00 
  8042105257:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210525e:	00 00 00 
  8042105261:	be 55 02 00 00       	mov    $0x255,%esi
  8042105266:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210526d:	00 00 00 
  8042105270:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105275:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210527c:	00 00 00 
  804210527f:	41 ff d0             	call   *%r8
        assert(page->head.next && page->head.prev);
  8042105282:	48 b9 70 09 12 42 80 	movabs $0x8042120970,%rcx
  8042105289:	00 00 00 
  804210528c:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105293:	00 00 00 
  8042105296:	be 59 02 00 00       	mov    $0x259,%esi
  804210529b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421052a2:	00 00 00 
  80421052a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80421052aa:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421052b1:	00 00 00 
  80421052b4:	41 ff d0             	call   *%r8
            }
        }
    } else {
        for (struct List *n = (struct List *)page->head.next;
  80421052b7:	48 8b 43 08          	mov    0x8(%rbx),%rax
             (struct List *)page != n; n = n->next) {
  80421052bb:	48 39 c3             	cmp    %rax,%rbx
  80421052be:	74 20                	je     80421052e0 <check_physical_tree+0x506>
            struct Page *v = (struct Page *)n;
            assert_virtual(v);
  80421052c0:	8b 50 28             	mov    0x28(%rax),%edx
  80421052c3:	81 e2 00 00 f0 00    	and    $0xf00000,%edx
  80421052c9:	81 fa ff ff 2f 00    	cmp    $0x2fffff,%edx
  80421052cf:	77 4e                	ja     804210531f <check_physical_tree+0x545>
            assert(v->phy == page);
  80421052d1:	48 39 58 30          	cmp    %rbx,0x30(%rax)
  80421052d5:	75 7d                	jne    8042105354 <check_physical_tree+0x57a>
             (struct List *)page != n; n = n->next) {
  80421052d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  80421052db:	48 39 c3             	cmp    %rax,%rbx
  80421052de:	75 e0                	jne    80421052c0 <check_physical_tree+0x4e6>
        }
    }
    if (page->left) {
  80421052e0:	48 85 ff             	test   %rdi,%rdi
  80421052e3:	74 16                	je     80421052fb <check_physical_tree+0x521>
        assert(page->left->parent == page);
  80421052e5:	48 39 5f 20          	cmp    %rbx,0x20(%rdi)
  80421052e9:	0f 85 9a 00 00 00    	jne    8042105389 <check_physical_tree+0x5af>
        check_physical_tree(page->left);
  80421052ef:	48 b8 da 4d 10 42 80 	movabs $0x8042104dda,%rax
  80421052f6:	00 00 00 
  80421052f9:	ff d0                	call   *%rax
    }
    if (page->right) {
  80421052fb:	4d 85 e4             	test   %r12,%r12
  80421052fe:	74 1a                	je     804210531a <check_physical_tree+0x540>
        assert(page->right->parent == page);
  8042105300:	49 39 5c 24 20       	cmp    %rbx,0x20(%r12)
  8042105305:	0f 85 b3 00 00 00    	jne    80421053be <check_physical_tree+0x5e4>
        check_physical_tree(page->right);
  804210530b:	4c 89 e7             	mov    %r12,%rdi
  804210530e:	48 b8 da 4d 10 42 80 	movabs $0x8042104dda,%rax
  8042105315:	00 00 00 
  8042105318:	ff d0                	call   *%rax
    }
}
  804210531a:	5b                   	pop    %rbx
  804210531b:	41 5c                	pop    %r12
  804210531d:	5d                   	pop    %rbp
  804210531e:	c3                   	ret
            assert_virtual(v);
  804210531f:	48 b9 98 09 12 42 80 	movabs $0x8042120998,%rcx
  8042105326:	00 00 00 
  8042105329:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105330:	00 00 00 
  8042105333:	be 64 02 00 00       	mov    $0x264,%esi
  8042105338:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210533f:	00 00 00 
  8042105342:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105347:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210534e:	00 00 00 
  8042105351:	41 ff d0             	call   *%r8
            assert(v->phy == page);
  8042105354:	48 b9 78 f7 11 42 80 	movabs $0x804211f778,%rcx
  804210535b:	00 00 00 
  804210535e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105365:	00 00 00 
  8042105368:	be 65 02 00 00       	mov    $0x265,%esi
  804210536d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105374:	00 00 00 
  8042105377:	b8 00 00 00 00       	mov    $0x0,%eax
  804210537c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105383:	00 00 00 
  8042105386:	41 ff d0             	call   *%r8
        assert(page->left->parent == page);
  8042105389:	48 b9 87 f7 11 42 80 	movabs $0x804211f787,%rcx
  8042105390:	00 00 00 
  8042105393:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210539a:	00 00 00 
  804210539d:	be 69 02 00 00       	mov    $0x269,%esi
  80421053a2:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421053a9:	00 00 00 
  80421053ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80421053b1:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421053b8:	00 00 00 
  80421053bb:	41 ff d0             	call   *%r8
        assert(page->right->parent == page);
  80421053be:	48 b9 a2 f7 11 42 80 	movabs $0x804211f7a2,%rcx
  80421053c5:	00 00 00 
  80421053c8:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421053cf:	00 00 00 
  80421053d2:	be 6d 02 00 00       	mov    $0x26d,%esi
  80421053d7:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421053de:	00 00 00 
  80421053e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80421053e6:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421053ed:	00 00 00 
  80421053f0:	41 ff d0             	call   *%r8
        if (page->right) assert(page->right->state == page->state);
  80421053f3:	4c 8b 63 18          	mov    0x18(%rbx),%r12
  80421053f7:	4d 85 e4             	test   %r12,%r12
  80421053fa:	0f 85 7c fa ff ff    	jne    8042104e7c <check_physical_tree+0xa2>
    if (page->left) {
  8042105400:	4c 89 e7             	mov    %r12,%rdi
  8042105403:	e9 e6 fb ff ff       	jmp    8042104fee <check_physical_tree+0x214>

0000008042105408 <check_virtual_tree>:

static void
check_virtual_tree(struct Page *page, int class) {
  8042105408:	f3 0f 1e fa          	endbr64
  804210540c:	55                   	push   %rbp
  804210540d:	48 89 e5             	mov    %rsp,%rbp
  8042105410:	41 54                	push   %r12
  8042105412:	53                   	push   %rbx
    assert(class >= 0);
  8042105413:	85 f6                	test   %esi,%esi
  8042105415:	0f 88 8c 00 00 00    	js     80421054a7 <check_virtual_tree+0x9f>
  804210541b:	48 89 fb             	mov    %rdi,%rbx
  804210541e:	41 89 f4             	mov    %esi,%r12d
    assert_virtual(page);
  8042105421:	8b 47 28             	mov    0x28(%rdi),%eax
  8042105424:	89 c2                	mov    %eax,%edx
  8042105426:	81 e2 00 00 f0 00    	and    $0xf00000,%edx
  804210542c:	81 fa ff ff 2f 00    	cmp    $0x2fffff,%edx
  8042105432:	0f 87 a4 00 00 00    	ja     80421054dc <check_virtual_tree+0xd4>
    if ((page->state & NODE_TYPE_MASK) == MAPPING_NODE) {
  8042105438:	81 fa 00 00 10 00    	cmp    $0x100000,%edx
  804210543e:	0f 84 cd 00 00 00    	je     8042105511 <check_virtual_tree+0x109>
        assert(!page->left && !page->right);
        assert(page->phy);
        if (!(page->phy->class == class)) cprintf("%d %d\n", page->phy->class, class);
        assert(page->phy->class == class);
    } else {
        assert(!page->phy);
  8042105444:	48 83 7f 30 00       	cmpq   $0x0,0x30(%rdi)
  8042105449:	0f 85 0a 02 00 00    	jne    8042105659 <check_virtual_tree+0x251>
        assert(page->state == INTERMEDIATE_NODE);
  804210544f:	3d 00 00 20 00       	cmp    $0x200000,%eax
  8042105454:	0f 85 34 02 00 00    	jne    804210568e <check_virtual_tree+0x286>
    }
    if (page->left) {
  804210545a:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  804210545e:	48 85 ff             	test   %rdi,%rdi
  8042105461:	74 1b                	je     804210547e <check_virtual_tree+0x76>
        assert(page->left->parent == page);
  8042105463:	48 39 5f 20          	cmp    %rbx,0x20(%rdi)
  8042105467:	0f 85 56 02 00 00    	jne    80421056c3 <check_virtual_tree+0x2bb>
        check_virtual_tree(page->left, class - 1);
  804210546d:	41 8d 74 24 ff       	lea    -0x1(%r12),%esi
  8042105472:	48 b8 08 54 10 42 80 	movabs $0x8042105408,%rax
  8042105479:	00 00 00 
  804210547c:	ff d0                	call   *%rax
    }
    if (page->right) {
  804210547e:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8042105482:	48 85 ff             	test   %rdi,%rdi
  8042105485:	74 1b                	je     80421054a2 <check_virtual_tree+0x9a>
        assert(page->right->parent == page);
  8042105487:	48 39 5f 20          	cmp    %rbx,0x20(%rdi)
  804210548b:	0f 85 67 02 00 00    	jne    80421056f8 <check_virtual_tree+0x2f0>
        check_virtual_tree(page->right, class - 1);
  8042105491:	41 8d 74 24 ff       	lea    -0x1(%r12),%esi
  8042105496:	48 b8 08 54 10 42 80 	movabs $0x8042105408,%rax
  804210549d:	00 00 00 
  80421054a0:	ff d0                	call   *%rax
    }
}
  80421054a2:	5b                   	pop    %rbx
  80421054a3:	41 5c                	pop    %r12
  80421054a5:	5d                   	pop    %rbp
  80421054a6:	c3                   	ret
    assert(class >= 0);
  80421054a7:	48 b9 be f7 11 42 80 	movabs $0x804211f7be,%rcx
  80421054ae:	00 00 00 
  80421054b1:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421054b8:	00 00 00 
  80421054bb:	be 74 02 00 00       	mov    $0x274,%esi
  80421054c0:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421054c7:	00 00 00 
  80421054ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80421054cf:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421054d6:	00 00 00 
  80421054d9:	41 ff d0             	call   *%r8
    assert_virtual(page);
  80421054dc:	48 b9 c8 09 12 42 80 	movabs $0x80421209c8,%rcx
  80421054e3:	00 00 00 
  80421054e6:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421054ed:	00 00 00 
  80421054f0:	be 75 02 00 00       	mov    $0x275,%esi
  80421054f5:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421054fc:	00 00 00 
  80421054ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105504:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210550b:	00 00 00 
  804210550e:	41 ff d0             	call   *%r8
        assert(page->phy);
  8042105511:	48 8b 57 30          	mov    0x30(%rdi),%rdx
  8042105515:	48 85 d2             	test   %rdx,%rdx
  8042105518:	0f 84 9c 00 00 00    	je     80421055ba <check_virtual_tree+0x1b2>
        assert(!(page->state & PROT_LAZY) || !(page->state & PROT_SHARE));
  804210551e:	f7 d0                	not    %eax
  8042105520:	a8 c0                	test   $0xc0,%al
  8042105522:	0f 84 c7 00 00 00    	je     80421055ef <check_virtual_tree+0x1e7>
        assert(!page->left && !page->right);
  8042105528:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
  804210552d:	0f 85 f1 00 00 00    	jne    8042105624 <check_virtual_tree+0x21c>
  8042105533:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
  8042105538:	0f 85 e6 00 00 00    	jne    8042105624 <check_virtual_tree+0x21c>
        if (!(page->phy->class == class)) cprintf("%d %d\n", page->phy->class, class);
  804210553e:	0f b7 72 34          	movzwl 0x34(%rdx),%esi
  8042105542:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
  8042105548:	44 39 e6             	cmp    %r12d,%esi
  804210554b:	0f 84 2d ff ff ff    	je     804210547e <check_virtual_tree+0x76>
  8042105551:	44 89 e2             	mov    %r12d,%edx
  8042105554:	48 bf e5 f7 11 42 80 	movabs $0x804211f7e5,%rdi
  804210555b:	00 00 00 
  804210555e:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105563:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  804210556a:	00 00 00 
  804210556d:	ff d1                	call   *%rcx
        assert(page->phy->class == class);
  804210556f:	48 8b 43 30          	mov    0x30(%rbx),%rax
  8042105573:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  8042105577:	25 ff 0f 00 00       	and    $0xfff,%eax
  804210557c:	44 39 e0             	cmp    %r12d,%eax
  804210557f:	0f 84 d5 fe ff ff    	je     804210545a <check_virtual_tree+0x52>
  8042105585:	48 b9 ec f7 11 42 80 	movabs $0x804211f7ec,%rcx
  804210558c:	00 00 00 
  804210558f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105596:	00 00 00 
  8042105599:	be 7c 02 00 00       	mov    $0x27c,%esi
  804210559e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421055a5:	00 00 00 
  80421055a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80421055ad:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421055b4:	00 00 00 
  80421055b7:	41 ff d0             	call   *%r8
        assert(page->phy);
  80421055ba:	48 b9 07 f8 11 42 80 	movabs $0x804211f807,%rcx
  80421055c1:	00 00 00 
  80421055c4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421055cb:	00 00 00 
  80421055ce:	be 77 02 00 00       	mov    $0x277,%esi
  80421055d3:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421055da:	00 00 00 
  80421055dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80421055e2:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421055e9:	00 00 00 
  80421055ec:	41 ff d0             	call   *%r8
        assert(!(page->state & PROT_LAZY) || !(page->state & PROT_SHARE));
  80421055ef:	48 b9 f8 09 12 42 80 	movabs $0x80421209f8,%rcx
  80421055f6:	00 00 00 
  80421055f9:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105600:	00 00 00 
  8042105603:	be 78 02 00 00       	mov    $0x278,%esi
  8042105608:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210560f:	00 00 00 
  8042105612:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105617:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210561e:	00 00 00 
  8042105621:	41 ff d0             	call   *%r8
        assert(!page->left && !page->right);
  8042105624:	48 b9 c9 f7 11 42 80 	movabs $0x804211f7c9,%rcx
  804210562b:	00 00 00 
  804210562e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105635:	00 00 00 
  8042105638:	be 79 02 00 00       	mov    $0x279,%esi
  804210563d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105644:	00 00 00 
  8042105647:	b8 00 00 00 00       	mov    $0x0,%eax
  804210564c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105653:	00 00 00 
  8042105656:	41 ff d0             	call   *%r8
        assert(!page->phy);
  8042105659:	48 b9 06 f8 11 42 80 	movabs $0x804211f806,%rcx
  8042105660:	00 00 00 
  8042105663:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210566a:	00 00 00 
  804210566d:	be 7e 02 00 00       	mov    $0x27e,%esi
  8042105672:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105679:	00 00 00 
  804210567c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105681:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105688:	00 00 00 
  804210568b:	41 ff d0             	call   *%r8
        assert(page->state == INTERMEDIATE_NODE);
  804210568e:	48 b9 38 0a 12 42 80 	movabs $0x8042120a38,%rcx
  8042105695:	00 00 00 
  8042105698:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210569f:	00 00 00 
  80421056a2:	be 7f 02 00 00       	mov    $0x27f,%esi
  80421056a7:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421056ae:	00 00 00 
  80421056b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80421056b6:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421056bd:	00 00 00 
  80421056c0:	41 ff d0             	call   *%r8
        assert(page->left->parent == page);
  80421056c3:	48 b9 87 f7 11 42 80 	movabs $0x804211f787,%rcx
  80421056ca:	00 00 00 
  80421056cd:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421056d4:	00 00 00 
  80421056d7:	be 82 02 00 00       	mov    $0x282,%esi
  80421056dc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421056e3:	00 00 00 
  80421056e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80421056eb:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421056f2:	00 00 00 
  80421056f5:	41 ff d0             	call   *%r8
        assert(page->right->parent == page);
  80421056f8:	48 b9 a2 f7 11 42 80 	movabs $0x804211f7a2,%rcx
  80421056ff:	00 00 00 
  8042105702:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105709:	00 00 00 
  804210570c:	be 86 02 00 00       	mov    $0x286,%esi
  8042105711:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105718:	00 00 00 
  804210571b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105720:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105727:	00 00 00 
  804210572a:	41 ff d0             	call   *%r8

000000804210572d <dump_virtual_tree>:

/*
 * Pretty-print virtual memory tree
 */
void
dump_virtual_tree(struct Page *node, int class) {
  804210572d:	f3 0f 1e fa          	endbr64
  8042105731:	55                   	push   %rbp
  8042105732:	48 89 e5             	mov    %rsp,%rbp
  8042105735:	41 54                	push   %r12
  8042105737:	53                   	push   %rbx
  8042105738:	48 89 fb             	mov    %rdi,%rbx
  804210573b:	41 89 f4             	mov    %esi,%r12d
    // LAB 7: Your code here
    if ((node->state & NODE_TYPE_MASK) == MAPPING_NODE) {
  804210573e:	8b 47 28             	mov    0x28(%rdi),%eax
  8042105741:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042105746:	3d 00 00 10 00       	cmp    $0x100000,%eax
  804210574b:	74 39                	je     8042105786 <dump_virtual_tree+0x59>
        cprintf("MAPPING_NODE: phy: %p, class: %d\n", (void *)PTE_ADDR(node->phy->addr), class);
    }
    if (node->left) {
  804210574d:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8042105751:	48 85 ff             	test   %rdi,%rdi
  8042105754:	74 11                	je     8042105767 <dump_virtual_tree+0x3a>
        dump_virtual_tree(node->left, class - 1);
  8042105756:	41 8d 74 24 ff       	lea    -0x1(%r12),%esi
  804210575b:	48 b8 2d 57 10 42 80 	movabs $0x804210572d,%rax
  8042105762:	00 00 00 
  8042105765:	ff d0                	call   *%rax
    }
    if (node->right) {
  8042105767:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  804210576b:	48 85 ff             	test   %rdi,%rdi
  804210576e:	74 11                	je     8042105781 <dump_virtual_tree+0x54>
        dump_virtual_tree(node->right, class - 1);
  8042105770:	41 8d 74 24 ff       	lea    -0x1(%r12),%esi
  8042105775:	48 b8 2d 57 10 42 80 	movabs $0x804210572d,%rax
  804210577c:	00 00 00 
  804210577f:	ff d0                	call   *%rax
    }
}
  8042105781:	5b                   	pop    %rbx
  8042105782:	41 5c                	pop    %r12
  8042105784:	5d                   	pop    %rbp
  8042105785:	c3                   	ret
        cprintf("MAPPING_NODE: phy: %p, class: %d\n", (void *)PTE_ADDR(node->phy->addr), class);
  8042105786:	48 8b 47 30          	mov    0x30(%rdi),%rax
  804210578a:	48 be ff ff ff ff ff 	movabs $0xfffffffffffff,%rsi
  8042105791:	ff 0f 00 
  8042105794:	48 23 70 38          	and    0x38(%rax),%rsi
  8042105798:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  804210579f:	ff ff 7f 
  80421057a2:	48 21 c6             	and    %rax,%rsi
  80421057a5:	44 89 e2             	mov    %r12d,%edx
  80421057a8:	48 bf 60 0a 12 42 80 	movabs $0x8042120a60,%rdi
  80421057af:	00 00 00 
  80421057b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80421057b7:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  80421057be:	00 00 00 
  80421057c1:	ff d1                	call   *%rcx
  80421057c3:	eb 88                	jmp    804210574d <dump_virtual_tree+0x20>

00000080421057c5 <dump_page_table>:
 * structure in the LAB 7 description
 * NOTE: Use dump_entry().
 * NOTE: Don't forget about PTE_PS
 */
void
dump_page_table(pte_t *pml4) {
  80421057c5:	f3 0f 1e fa          	endbr64
  80421057c9:	55                   	push   %rbp
  80421057ca:	48 89 e5             	mov    %rsp,%rbp
  80421057cd:	41 57                	push   %r15
  80421057cf:	41 56                	push   %r14
  80421057d1:	41 55                	push   %r13
  80421057d3:	41 54                	push   %r12
  80421057d5:	53                   	push   %rbx
  80421057d6:	48 83 ec 38          	sub    $0x38,%rsp
  80421057da:	49 89 fd             	mov    %rdi,%r13
    uintptr_t addr = 0;
    cprintf("Page table:\n");
  80421057dd:	48 bf 11 f8 11 42 80 	movabs $0x804211f811,%rdi
  80421057e4:	00 00 00 
  80421057e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80421057ec:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421057f3:	00 00 00 
  80421057f6:	ff d2                	call   *%rdx
    // LAB 7: Your code here
    (void)addr;
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  80421057f8:	4d 8d 65 08          	lea    0x8(%r13),%r12
  80421057fc:	49 81 c5 00 10 00 00 	add    $0x1000,%r13
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105803:	49 bf 1e f8 11 42 80 	movabs $0x804211f81e,%r15
  804210580a:	00 00 00 
  804210580d:	4d 89 ee             	mov    %r13,%r14
  8042105810:	e9 3e 03 00 00       	jmp    8042105b53 <dump_page_table+0x38e>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042105815:	49 89 c0             	mov    %rax,%r8
  8042105818:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210581f:	00 00 00 
  8042105822:	be d2 02 00 00       	mov    $0x2d2,%esi
  8042105827:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210582e:	00 00 00 
  8042105831:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105836:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210583d:	00 00 00 
  8042105840:	41 ff d1             	call   *%r9
  8042105843:	48 99                	cqto
  8042105845:	83 e2 d5             	and    $0xffffffd5,%edx
  8042105848:	44 8d 42 58          	lea    0x58(%rdx),%r8d
            base & PTE_W ? 'W' : '-',
  804210584c:	48 89 c2             	mov    %rax,%rdx
  804210584f:	83 e2 02             	and    $0x2,%edx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105852:	48 83 fa 01          	cmp    $0x1,%rdx
  8042105856:	19 c9                	sbb    %ecx,%ecx
  8042105858:	83 e1 d6             	and    $0xffffffd6,%ecx
  804210585b:	83 c1 57             	add    $0x57,%ecx
            base & PTE_U ? 'U' : '-',
  804210585e:	48 89 c2             	mov    %rax,%rdx
  8042105861:	83 e2 04             	and    $0x4,%edx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105864:	48 83 fa 01          	cmp    $0x1,%rdx
  8042105868:	19 ff                	sbb    %edi,%edi
  804210586a:	83 e7 d8             	and    $0xffffffd8,%edi
            base & PTE_P ? 'P' : '-',
  804210586d:	48 89 c2             	mov    %rax,%rdx
  8042105870:	83 e2 01             	and    $0x1,%edx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105873:	48 83 fa 01          	cmp    $0x1,%rdx
  8042105877:	19 f6                	sbb    %esi,%esi
  8042105879:	83 e6 dd             	and    $0xffffffdd,%esi
            PTE_ADDR(base) + (isz ? (step * isz - 1) : 0xFFF),
  804210587c:	48 ba 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdx
  8042105883:	ff ff 7f 
  8042105886:	48 21 c2             	and    %rax,%rdx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105889:	48 8d 82 ff 0f 00 00 	lea    0xfff(%rdx),%rax
  8042105890:	68 00 00 00 40       	push   $0x40000000
  8042105895:	6a 53                	push   $0x53
  8042105897:	41 50                	push   %r8
  8042105899:	51                   	push   %rcx
  804210589a:	44 8d 4f 55          	lea    0x55(%rdi),%r9d
  804210589e:	44 8d 46 50          	lea    0x50(%rsi),%r8d
  80421058a2:	48 89 c1             	mov    %rax,%rcx
  80421058a5:	48 be 28 f8 11 42 80 	movabs $0x804211f828,%rsi
  80421058ac:	00 00 00 
  80421058af:	48 bf c8 0a 12 42 80 	movabs $0x8042120ac8,%rdi
  80421058b6:	00 00 00 
  80421058b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80421058be:	49 ba 70 cf 10 42 80 	movabs $0x804210cf70,%r10
  80421058c5:	00 00 00 
  80421058c8:	41 ff d2             	call   *%r10
        pdpe_t *p = (pdpe_t *) KADDR(PTE_ADDR(pml4[i]));
        for (size_t j = 0; j < PDP_ENTRY_COUNT; j++) {
            if (p[j] & PTE_PS) {
                dump_entry(p[j], 1 * GB, 0);
                continue;
  80421058cb:	48 83 c4 20          	add    $0x20,%rsp
  80421058cf:	e9 07 02 00 00       	jmp    8042105adb <dump_page_table+0x316>
  80421058d4:	49 89 c0             	mov    %rax,%r8
  80421058d7:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421058de:	00 00 00 
  80421058e1:	be db 02 00 00       	mov    $0x2db,%esi
  80421058e6:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421058ed:	00 00 00 
  80421058f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80421058f5:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421058fc:	00 00 00 
  80421058ff:	41 ff d1             	call   *%r9
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105902:	4c 89 e0             	mov    %r12,%rax
  8042105905:	48 c1 f8 3f          	sar    $0x3f,%rax
  8042105909:	83 e0 d5             	and    $0xffffffd5,%eax
  804210590c:	44 8d 40 58          	lea    0x58(%rax),%r8d
            base & PTE_W ? 'W' : '-',
  8042105910:	4c 89 e0             	mov    %r12,%rax
  8042105913:	83 e0 02             	and    $0x2,%eax
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105916:	48 83 f8 01          	cmp    $0x1,%rax
  804210591a:	19 c0                	sbb    %eax,%eax
  804210591c:	83 e0 d6             	and    $0xffffffd6,%eax
  804210591f:	83 c0 57             	add    $0x57,%eax
            base & PTE_U ? 'U' : '-',
  8042105922:	4c 89 e2             	mov    %r12,%rdx
  8042105925:	83 e2 04             	and    $0x4,%edx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105928:	48 83 fa 01          	cmp    $0x1,%rdx
  804210592c:	19 f6                	sbb    %esi,%esi
  804210592e:	83 e6 d8             	and    $0xffffffd8,%esi
            base & PTE_P ? 'P' : '-',
  8042105931:	4c 89 e2             	mov    %r12,%rdx
  8042105934:	83 e2 01             	and    $0x1,%edx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105937:	48 83 fa 01          	cmp    $0x1,%rdx
  804210593b:	19 c9                	sbb    %ecx,%ecx
  804210593d:	83 e1 dd             	and    $0xffffffdd,%ecx
            PTE_ADDR(base) + (isz ? (step * isz - 1) : 0xFFF),
  8042105940:	48 ba 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdx
  8042105947:	ff ff 7f 
  804210594a:	4c 21 e2             	and    %r12,%rdx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  804210594d:	48 8d ba ff 0f 00 00 	lea    0xfff(%rdx),%rdi
  8042105954:	68 00 00 20 00       	push   $0x200000
  8042105959:	6a 53                	push   $0x53
  804210595b:	41 50                	push   %r8
  804210595d:	50                   	push   %rax
  804210595e:	44 8d 4e 55          	lea    0x55(%rsi),%r9d
  8042105962:	44 8d 41 50          	lea    0x50(%rcx),%r8d
  8042105966:	48 89 f9             	mov    %rdi,%rcx
  8042105969:	48 be 23 f8 11 42 80 	movabs $0x804211f823,%rsi
  8042105970:	00 00 00 
  8042105973:	48 bf c8 0a 12 42 80 	movabs $0x8042120ac8,%rdi
  804210597a:	00 00 00 
  804210597d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105982:	49 ba 70 cf 10 42 80 	movabs $0x804210cf70,%r10
  8042105989:	00 00 00 
  804210598c:	41 ff d2             	call   *%r10
			}
            pde_t *pd = (pde_t *) KADDR(PTE_ADDR(p[j]));
            for (size_t k = 0; k < PD_ENTRY_COUNT; k++) {
                if (pd[k] & PTE_PS) {
                    dump_entry(pd[k], 2 * MB, 0);
                    continue;
  804210598f:	48 83 c4 20          	add    $0x20,%rsp
            for (size_t k = 0; k < PD_ENTRY_COUNT; k++) {
  8042105993:	48 83 45 c8 08       	addq   $0x8,-0x38(%rbp)
  8042105998:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210599c:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  80421059a0:	0f 84 2d 01 00 00    	je     8042105ad3 <dump_page_table+0x30e>
                if (pd[k] & PTE_PS) {
  80421059a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421059aa:	4c 8b 20             	mov    (%rax),%r12
  80421059ad:	41 f6 c4 80          	test   $0x80,%r12b
  80421059b1:	0f 85 4b ff ff ff    	jne    8042105902 <dump_page_table+0x13d>
                }
                if (!(pd[k] & PTE_P)) {
  80421059b7:	41 f6 c4 01          	test   $0x1,%r12b
  80421059bb:	74 d6                	je     8042105993 <dump_page_table+0x1ce>
					continue;
				}
                pte_t *pt = (pte_t *) KADDR(PTE_ADDR(pd[k]));
  80421059bd:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  80421059c4:	ff ff 7f 
  80421059c7:	49 21 c4             	and    %rax,%r12
    if (pa > max_memory_map_addr)
  80421059ca:	48 b8 f8 10 00 43 80 	movabs $0x80430010f8,%rax
  80421059d1:	00 00 00 
  80421059d4:	4c 8b 00             	mov    (%rax),%r8
  80421059d7:	4d 39 e0             	cmp    %r12,%r8
  80421059da:	72 30                	jb     8042105a0c <dump_page_table+0x247>
    return (void *)(pa + KERN_BASE_ADDR);
  80421059dc:	48 bb 00 00 00 40 80 	movabs $0x8040000000,%rbx
  80421059e3:	00 00 00 
  80421059e6:	4c 01 e3             	add    %r12,%rbx
                for (size_t m = 0; m < PT_ENTRY_COUNT; m++) {
  80421059e9:	48 b8 00 10 00 40 80 	movabs $0x8040001000,%rax
  80421059f0:	00 00 00 
  80421059f3:	49 01 c4             	add    %rax,%r12
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  80421059f6:	49 be c8 0a 12 42 80 	movabs $0x8042120ac8,%r14
  80421059fd:	00 00 00 
  8042105a00:	49 bd 70 cf 10 42 80 	movabs $0x804210cf70,%r13
  8042105a07:	00 00 00 
  8042105a0a:	eb 3b                	jmp    8042105a47 <dump_page_table+0x282>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042105a0c:	4c 89 e1             	mov    %r12,%rcx
  8042105a0f:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042105a16:	00 00 00 
  8042105a19:	be e4 02 00 00       	mov    $0x2e4,%esi
  8042105a1e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105a25:	00 00 00 
  8042105a28:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105a2d:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042105a34:	00 00 00 
  8042105a37:	41 ff d1             	call   *%r9
                for (size_t m = 0; m < PT_ENTRY_COUNT; m++) {
  8042105a3a:	48 83 c3 08          	add    $0x8,%rbx
  8042105a3e:	49 39 dc             	cmp    %rbx,%r12
  8042105a41:	0f 84 4c ff ff ff    	je     8042105993 <dump_page_table+0x1ce>
                    if (!(pt[m] & PTE_P)) {
  8042105a47:	48 8b 13             	mov    (%rbx),%rdx
  8042105a4a:	f6 c2 01             	test   $0x1,%dl
  8042105a4d:	74 eb                	je     8042105a3a <dump_page_table+0x275>
            base & PTE_PS ? 'S' : '-',
  8042105a4f:	48 89 d0             	mov    %rdx,%rax
  8042105a52:	25 80 00 00 00       	and    $0x80,%eax
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105a57:	48 83 f8 01          	cmp    $0x1,%rax
  8042105a5b:	19 c9                	sbb    %ecx,%ecx
  8042105a5d:	83 e1 da             	and    $0xffffffda,%ecx
  8042105a60:	83 c1 53             	add    $0x53,%ecx
  8042105a63:	48 89 d0             	mov    %rdx,%rax
  8042105a66:	48 c1 f8 3f          	sar    $0x3f,%rax
  8042105a6a:	83 e0 d5             	and    $0xffffffd5,%eax
  8042105a6d:	44 8d 40 58          	lea    0x58(%rax),%r8d
            base & PTE_W ? 'W' : '-',
  8042105a71:	48 89 d0             	mov    %rdx,%rax
  8042105a74:	83 e0 02             	and    $0x2,%eax
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105a77:	48 83 f8 01          	cmp    $0x1,%rax
  8042105a7b:	19 c0                	sbb    %eax,%eax
  8042105a7d:	83 e0 d6             	and    $0xffffffd6,%eax
  8042105a80:	83 c0 57             	add    $0x57,%eax
            base & PTE_U ? 'U' : '-',
  8042105a83:	48 89 d6             	mov    %rdx,%rsi
  8042105a86:	83 e6 04             	and    $0x4,%esi
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105a89:	48 83 fe 01          	cmp    $0x1,%rsi
  8042105a8d:	19 f6                	sbb    %esi,%esi
  8042105a8f:	83 e6 d8             	and    $0xffffffd8,%esi
            PTE_ADDR(base) + (isz ? (step * isz - 1) : 0xFFF),
  8042105a92:	48 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdi
  8042105a99:	ff ff 7f 
  8042105a9c:	48 21 fa             	and    %rdi,%rdx
    cprintf("%s[%08llX, %08llX] %c%c%c%c%c -- step=%zx\n",
  8042105a9f:	48 8d ba ff 0f 00 00 	lea    0xfff(%rdx),%rdi
  8042105aa6:	68 00 10 00 00       	push   $0x1000
  8042105aab:	51                   	push   %rcx
  8042105aac:	41 50                	push   %r8
  8042105aae:	50                   	push   %rax
  8042105aaf:	44 8d 4e 55          	lea    0x55(%rsi),%r9d
  8042105ab3:	41 b8 50 00 00 00    	mov    $0x50,%r8d
  8042105ab9:	48 89 f9             	mov    %rdi,%rcx
  8042105abc:	4c 89 fe             	mov    %r15,%rsi
  8042105abf:	4c 89 f7             	mov    %r14,%rdi
  8042105ac2:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105ac7:	41 ff d5             	call   *%r13
}
  8042105aca:	48 83 c4 20          	add    $0x20,%rsp
  8042105ace:	e9 67 ff ff ff       	jmp    8042105a3a <dump_page_table+0x275>
  8042105ad3:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  8042105ad7:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
        for (size_t j = 0; j < PDP_ENTRY_COUNT; j++) {
  8042105adb:	48 83 c3 08          	add    $0x8,%rbx
  8042105adf:	4c 39 f3             	cmp    %r14,%rbx
  8042105ae2:	74 5e                	je     8042105b42 <dump_page_table+0x37d>
            if (p[j] & PTE_PS) {
  8042105ae4:	48 8b 03             	mov    (%rbx),%rax
  8042105ae7:	a8 80                	test   $0x80,%al
  8042105ae9:	0f 85 54 fd ff ff    	jne    8042105843 <dump_page_table+0x7e>
            if (!(p[j] & PTE_P)) {
  8042105aef:	a8 01                	test   $0x1,%al
  8042105af1:	74 e8                	je     8042105adb <dump_page_table+0x316>
            pde_t *pd = (pde_t *) KADDR(PTE_ADDR(p[j]));
  8042105af3:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042105afa:	ff ff 7f 
  8042105afd:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  8042105b00:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042105b07:	00 00 00 
  8042105b0a:	48 39 c8             	cmp    %rcx,%rax
  8042105b0d:	0f 82 c1 fd ff ff    	jb     80421058d4 <dump_page_table+0x10f>
    return (void *)(pa + KERN_BASE_ADDR);
  8042105b13:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042105b1a:	00 00 00 
  8042105b1d:	48 01 c8             	add    %rcx,%rax
  8042105b20:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            for (size_t k = 0; k < PD_ENTRY_COUNT; k++) {
  8042105b24:	48 b8 00 10 00 40 80 	movabs $0x8040001000,%rax
  8042105b2b:	00 00 00 
  8042105b2e:	48 01 c8             	add    %rcx,%rax
  8042105b31:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    if (pa > max_memory_map_addr)
  8042105b35:	48 89 5d a8          	mov    %rbx,-0x58(%rbp)
  8042105b39:	4c 89 75 a0          	mov    %r14,-0x60(%rbp)
  8042105b3d:	e9 64 fe ff ff       	jmp    80421059a6 <dump_page_table+0x1e1>
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  8042105b42:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  8042105b46:	4c 8b 75 b0          	mov    -0x50(%rbp),%r14
  8042105b4a:	49 83 c4 08          	add    $0x8,%r12
  8042105b4e:	4d 39 f4             	cmp    %r14,%r12
  8042105b51:	74 4a                	je     8042105b9d <dump_page_table+0x3d8>
        pdpe_t *p = (pdpe_t *) KADDR(PTE_ADDR(pml4[i]));
  8042105b53:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042105b5a:	ff ff 7f 
  8042105b5d:	49 23 0c 24          	and    (%r12),%rcx
  8042105b61:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042105b68:	00 00 00 
  8042105b6b:	48 39 c8             	cmp    %rcx,%rax
  8042105b6e:	0f 82 a1 fc ff ff    	jb     8042105815 <dump_page_table+0x50>
    return (void *)(pa + KERN_BASE_ADDR);
  8042105b74:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042105b7b:	00 00 00 
  8042105b7e:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
        for (size_t j = 0; j < PDP_ENTRY_COUNT; j++) {
  8042105b82:	48 8d 80 00 10 00 00 	lea    0x1000(%rax),%rax
  8042105b89:	4c 8d 2c 01          	lea    (%rcx,%rax,1),%r13
            pde_t *pd = (pde_t *) KADDR(PTE_ADDR(p[j]));
  8042105b8d:	4c 89 65 b8          	mov    %r12,-0x48(%rbp)
  8042105b91:	4c 89 75 b0          	mov    %r14,-0x50(%rbp)
  8042105b95:	4d 89 ee             	mov    %r13,%r14
  8042105b98:	e9 47 ff ff ff       	jmp    8042105ae4 <dump_page_table+0x31f>
                    dump_entry(pt[m], 4 * KB, 0);
                }
            }
        }
    }
}
  8042105b9d:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  8042105ba1:	5b                   	pop    %rbx
  8042105ba2:	41 5c                	pop    %r12
  8042105ba4:	41 5d                	pop    %r13
  8042105ba6:	41 5e                	pop    %r14
  8042105ba8:	41 5f                	pop    %r15
  8042105baa:	5d                   	pop    %rbp
  8042105bab:	c3                   	ret

0000008042105bac <switch_address_space>:
 * (Why it might me impactful?)
 *
 * Returns old address space
 */
struct AddressSpace *
switch_address_space(struct AddressSpace *space) {
  8042105bac:	f3 0f 1e fa          	endbr64
    assert(space);
  8042105bb0:	48 85 ff             	test   %rdi,%rdi
  8042105bb3:	74 2a                	je     8042105bdf <switch_address_space+0x33>
    // LAB 7: Your code here
    if (space == current_space) {
  8042105bb5:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  8042105bbc:	00 00 00 
  8042105bbf:	48 8b 10             	mov    (%rax),%rdx
  8042105bc2:	48 39 fa             	cmp    %rdi,%rdx
  8042105bc5:	74 14                	je     8042105bdb <switch_address_space+0x2f>
        return space;
    } else {
        struct AddressSpace *old_current_space = current_space;
        current_space = space;
  8042105bc7:	48 89 f8             	mov    %rdi,%rax
  8042105bca:	48 a3 d0 10 00 43 80 	movabs %rax,0x80430010d0
  8042105bd1:	00 00 00 
    asm volatile("movq %0,%%cr3" ::"r"(val));
  8042105bd4:	48 8b 47 08          	mov    0x8(%rdi),%rax
  8042105bd8:	0f 22 d8             	mov    %rax,%cr3
        lcr3(current_space->cr3);
        return old_current_space;
    }
}
  8042105bdb:	48 89 d0             	mov    %rdx,%rax
  8042105bde:	c3                   	ret
switch_address_space(struct AddressSpace *space) {
  8042105bdf:	55                   	push   %rbp
  8042105be0:	48 89 e5             	mov    %rsp,%rbp
    assert(space);
  8042105be3:	48 b9 9b f9 11 42 80 	movabs $0x804211f99b,%rcx
  8042105bea:	00 00 00 
  8042105bed:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105bf4:	00 00 00 
  8042105bf7:	be 3f 06 00 00       	mov    $0x63f,%esi
  8042105bfc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105c03:	00 00 00 
  8042105c06:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105c0b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105c12:	00 00 00 
  8042105c15:	41 ff d0             	call   *%r8

0000008042105c18 <update_pte>:
    }
}

// Function to update the PTE for a swapped page
void update_pte(struct AddressSpace *as, struct Page *page, int swap_index)
{
  8042105c18:	f3 0f 1e fa          	endbr64
  8042105c1c:	55                   	push   %rbp
  8042105c1d:	48 89 e5             	mov    %rsp,%rbp
  8042105c20:	41 89 d0             	mov    %edx,%r8d
    return page->addr << CLASS_BASE;
  8042105c23:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8042105c2a:	ff 0f 00 
  8042105c2d:	48 89 c2             	mov    %rax,%rdx
  8042105c30:	48 23 56 38          	and    0x38(%rsi),%rdx
  8042105c34:	48 c1 e2 0c          	shl    $0xc,%rdx
  8042105c38:	48 21 c2             	and    %rax,%rdx
    uintptr_t va = page2pa(page);
    pml4e_t *pml4 = as->pml4;
    pdpe_t *pdp = (pdpe_t *)KADDR(PTE_ADDR(pml4[PML4_INDEX(va)]));
  8042105c3b:	48 89 d0             	mov    %rdx,%rax
  8042105c3e:	48 c1 e8 27          	shr    $0x27,%rax
  8042105c42:	25 ff 01 00 00       	and    $0x1ff,%eax
  8042105c47:	48 8b 0f             	mov    (%rdi),%rcx
  8042105c4a:	48 8b 3c c1          	mov    (%rcx,%rax,8),%rdi
  8042105c4e:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042105c55:	ff ff 7f 
  8042105c58:	48 21 f9             	and    %rdi,%rcx
    if (pa > max_memory_map_addr)
  8042105c5b:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042105c62:	00 00 00 
  8042105c65:	48 39 c8             	cmp    %rcx,%rax
  8042105c68:	72 08                	jb     8042105c72 <update_pte+0x5a>
    if (!(pml4[PML4_INDEX(va)] & PTE_P)) return;
  8042105c6a:	40 f6 c7 01          	test   $0x1,%dil
  8042105c6e:	75 30                	jne    8042105ca0 <update_pte+0x88>
    if (!(pd[PD_INDEX(va)] & PTE_P)) return;

    pt[PT_INDEX(va)] = (swap_index << 12) | (pt[PT_INDEX(va)] & 0xFFF);
    pt[PT_INDEX(va)] &= ~PTE_P;
    pt[PT_INDEX(va)] |= PTE_PWT;
}
  8042105c70:	5d                   	pop    %rbp
  8042105c71:	c3                   	ret
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042105c72:	49 89 c0             	mov    %rax,%r8
  8042105c75:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042105c7c:	00 00 00 
  8042105c7f:	be 25 08 00 00       	mov    $0x825,%esi
  8042105c84:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105c8b:	00 00 00 
  8042105c8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105c93:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042105c9a:	00 00 00 
  8042105c9d:	41 ff d1             	call   *%r9
    pde_t *pd = (pde_t *)KADDR(PTE_ADDR(pdp[PDP_INDEX(va)]));
  8042105ca0:	48 89 d7             	mov    %rdx,%rdi
  8042105ca3:	48 c1 ef 1b          	shr    $0x1b,%rdi
  8042105ca7:	81 e7 f8 0f 00 00    	and    $0xff8,%edi
  8042105cad:	48 01 cf             	add    %rcx,%rdi
  8042105cb0:	48 b9 00 00 00 40 80 	movabs $0x8040000000,%rcx
  8042105cb7:	00 00 00 
  8042105cba:	48 8b 3c 0f          	mov    (%rdi,%rcx,1),%rdi
  8042105cbe:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042105cc5:	ff ff 7f 
  8042105cc8:	48 21 f9             	and    %rdi,%rcx
    if (pa > max_memory_map_addr)
  8042105ccb:	48 39 c8             	cmp    %rcx,%rax
  8042105cce:	72 7a                	jb     8042105d4a <update_pte+0x132>
    if (!(pdp[PDP_INDEX(va)] & PTE_P)) return;
  8042105cd0:	40 f6 c7 01          	test   $0x1,%dil
  8042105cd4:	74 9a                	je     8042105c70 <update_pte+0x58>
    pte_t *pt = (pte_t *)KADDR(PTE_ADDR(pd[PD_INDEX(va)]));
  8042105cd6:	48 89 d7             	mov    %rdx,%rdi
  8042105cd9:	48 c1 ef 12          	shr    $0x12,%rdi
  8042105cdd:	81 e7 f8 0f 00 00    	and    $0xff8,%edi
  8042105ce3:	48 01 cf             	add    %rcx,%rdi
  8042105ce6:	48 b9 00 00 00 40 80 	movabs $0x8040000000,%rcx
  8042105ced:	00 00 00 
  8042105cf0:	48 8b 3c 0f          	mov    (%rdi,%rcx,1),%rdi
  8042105cf4:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042105cfb:	ff ff 7f 
  8042105cfe:	48 21 f9             	and    %rdi,%rcx
  8042105d01:	48 39 c8             	cmp    %rcx,%rax
  8042105d04:	72 72                	jb     8042105d78 <update_pte+0x160>
    if (!(pd[PD_INDEX(va)] & PTE_P)) return;
  8042105d06:	40 f6 c7 01          	test   $0x1,%dil
  8042105d0a:	0f 84 60 ff ff ff    	je     8042105c70 <update_pte+0x58>
    return (void *)(pa + KERN_BASE_ADDR);
  8042105d10:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042105d17:	00 00 00 
  8042105d1a:	48 01 c1             	add    %rax,%rcx
    pt[PT_INDEX(va)] = (swap_index << 12) | (pt[PT_INDEX(va)] & 0xFFF);
  8042105d1d:	48 c1 ea 09          	shr    $0x9,%rdx
  8042105d21:	81 e2 f8 0f 00 00    	and    $0xff8,%edx
  8042105d27:	48 01 d1             	add    %rdx,%rcx
  8042105d2a:	44 89 c6             	mov    %r8d,%esi
  8042105d2d:	c1 e6 0c             	shl    $0xc,%esi
  8042105d30:	48 63 f6             	movslq %esi,%rsi
  8042105d33:	48 8b 01             	mov    (%rcx),%rax
  8042105d36:	25 fe 0f 00 00       	and    $0xffe,%eax
    pt[PT_INDEX(va)] &= ~PTE_P;
  8042105d3b:	48 09 f0             	or     %rsi,%rax
    pt[PT_INDEX(va)] |= PTE_PWT;
  8042105d3e:	48 83 c8 08          	or     $0x8,%rax
  8042105d42:	48 89 01             	mov    %rax,(%rcx)
  8042105d45:	e9 26 ff ff ff       	jmp    8042105c70 <update_pte+0x58>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042105d4a:	49 89 c0             	mov    %rax,%r8
  8042105d4d:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042105d54:	00 00 00 
  8042105d57:	be 28 08 00 00       	mov    $0x828,%esi
  8042105d5c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105d63:	00 00 00 
  8042105d66:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105d6b:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042105d72:	00 00 00 
  8042105d75:	41 ff d1             	call   *%r9
  8042105d78:	49 89 c0             	mov    %rax,%r8
  8042105d7b:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042105d82:	00 00 00 
  8042105d85:	be 2b 08 00 00       	mov    $0x82b,%esi
  8042105d8a:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105d91:	00 00 00 
  8042105d94:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105d99:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042105da0:	00 00 00 
  8042105da3:	41 ff d1             	call   *%r9

0000008042105da6 <swap_workout>:
        }
    }
}

void swap_workout()
{
  8042105da6:	f3 0f 1e fa          	endbr64
  8042105daa:	55                   	push   %rbp
  8042105dab:	48 89 e5             	mov    %rsp,%rbp
  8042105dae:	41 57                	push   %r15
  8042105db0:	41 56                	push   %r14
  8042105db2:	41 55                	push   %r13
  8042105db4:	41 54                	push   %r12
  8042105db6:	53                   	push   %rbx
  8042105db7:	48 83 ec 18          	sub    $0x18,%rsp
    cprintf("WORKOUT\n");
  8042105dbb:	48 bf 30 f8 11 42 80 	movabs $0x804211f830,%rdi
  8042105dc2:	00 00 00 
  8042105dc5:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105dca:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042105dd1:	00 00 00 
  8042105dd4:	ff d2                	call   *%rdx
    SwapShift = SwapBuffer;
  8042105dd6:	48 a1 48 10 00 43 80 	movabs 0x8043001048,%rax
  8042105ddd:	00 00 00 
  8042105de0:	48 a3 40 10 00 43 80 	movabs %rax,0x8043001040
  8042105de7:	00 00 00 
    struct Page *tail;
    for (int k = 0; k < SWAP_AMOUNT; k++) {
  8042105dea:	49 bd 60 10 00 43 80 	movabs $0x8043001060,%r13
  8042105df1:	00 00 00 
  8042105df4:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        tail = lru_list->tail;
  8042105dfa:	48 b8 08 00 00 43 80 	movabs $0x8043000008,%rax
  8042105e01:	00 00 00 
  8042105e04:	48 8b 00             	mov    (%rax),%rax
  8042105e07:	4c 8b 70 08          	mov    0x8(%rax),%r14
        cprintf("DEBUG size %d\n", lru_list->size);
  8042105e0b:	8b 70 10             	mov    0x10(%rax),%esi
  8042105e0e:	48 bf 39 f8 11 42 80 	movabs $0x804211f839,%rdi
  8042105e15:	00 00 00 
  8042105e18:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105e1d:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  8042105e24:	00 00 00 
  8042105e27:	ff d1                	call   *%rcx
    return page->addr << CLASS_BASE;
  8042105e29:	48 bf ff ff ff ff ff 	movabs $0xfffffffffffff,%rdi
  8042105e30:	ff 0f 00 
  8042105e33:	49 23 7e 38          	and    0x38(%r14),%rdi
  8042105e37:	48 c1 e7 0c          	shl    $0xc,%rdi
  8042105e3b:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8042105e42:	ff 0f 00 
  8042105e45:	48 21 c7             	and    %rax,%rdi

        int cur_size = LZ4_compress_default((char *)page2pa(tail), CompressionBuffer, PAGE_SIZE, COMP_SIZE);
  8042105e48:	b9 20 10 00 00       	mov    $0x1020,%ecx
  8042105e4d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042105e52:	48 be 20 00 00 43 80 	movabs $0x8043000020,%rsi
  8042105e59:	00 00 00 
  8042105e5c:	48 b8 6d 5d 11 42 80 	movabs $0x8042115d6d,%rax
  8042105e63:	00 00 00 
  8042105e66:	ff d0                	call   *%rax
        memcpy(SwapShift, CompressionBuffer, cur_size);
  8042105e68:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8042105e6b:	4c 63 f8             	movslq %eax,%r15
  8042105e6e:	48 bb 40 10 00 43 80 	movabs $0x8043001040,%rbx
  8042105e75:	00 00 00 
  8042105e78:	48 8b 3b             	mov    (%rbx),%rdi
  8042105e7b:	4c 89 fa             	mov    %r15,%rdx
  8042105e7e:	48 be 20 00 00 43 80 	movabs $0x8043000020,%rsi
  8042105e85:	00 00 00 
  8042105e88:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042105e8f:	00 00 00 
  8042105e92:	ff d0                	call   *%rax
        swap_info[k].buffer = SwapShift;
  8042105e94:	48 8b 03             	mov    (%rbx),%rax
  8042105e97:	49 89 45 00          	mov    %rax,0x0(%r13)
        swap_info[k].size = cur_size;
  8042105e9b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8042105e9e:	41 89 45 08          	mov    %eax,0x8(%r13)
        tail->state = SWAPPED_PAGE;
  8042105ea2:	41 c7 46 28 00 00 00 	movl   $0x1000000,0x28(%r14)
  8042105ea9:	01 

        update_all_pte(tail, k);
  8042105eaa:	44 89 e6             	mov    %r12d,%esi
  8042105ead:	4c 89 f7             	mov    %r14,%rdi
  8042105eb0:	48 b8 9a 78 10 42 80 	movabs $0x804210789a,%rax
  8042105eb7:	00 00 00 
  8042105eba:	ff d0                	call   *%rax

        SwapShift += cur_size;
  8042105ebc:	4c 01 3b             	add    %r15,(%rbx)
    for (int k = 0; k < SWAP_AMOUNT; k++) {
  8042105ebf:	41 83 c4 01          	add    $0x1,%r12d
  8042105ec3:	49 83 c5 10          	add    $0x10,%r13
  8042105ec7:	41 83 fc 02          	cmp    $0x2,%r12d
  8042105ecb:	0f 85 29 ff ff ff    	jne    8042105dfa <swap_workout+0x54>
    }
}
  8042105ed1:	48 83 c4 18          	add    $0x18,%rsp
  8042105ed5:	5b                   	pop    %rbx
  8042105ed6:	41 5c                	pop    %r12
  8042105ed8:	41 5d                	pop    %r13
  8042105eda:	41 5e                	pop    %r14
  8042105edc:	41 5f                	pop    %r15
  8042105ede:	5d                   	pop    %rbp
  8042105edf:	c3                   	ret

0000008042105ee0 <alloc_page>:
alloc_page(int class, int flags) {
  8042105ee0:	f3 0f 1e fa          	endbr64
  8042105ee4:	55                   	push   %rbp
  8042105ee5:	48 89 e5             	mov    %rsp,%rbp
  8042105ee8:	41 56                	push   %r14
  8042105eea:	41 55                	push   %r13
  8042105eec:	41 54                	push   %r12
  8042105eee:	53                   	push   %rbx
  8042105eef:	41 89 fc             	mov    %edi,%r12d
  8042105ef2:	89 f3                	mov    %esi,%ebx
    if (flags & ALLOC_POOL) flags |= ALLOC_BOOTMEM;
  8042105ef4:	89 f0                	mov    %esi,%eax
  8042105ef6:	0d 00 00 04 00       	or     $0x40000,%eax
  8042105efb:	f7 c6 00 00 01 00    	test   $0x10000,%esi
  8042105f01:	0f 45 d8             	cmovne %eax,%ebx
    if (current_space) flags &= ~ALLOC_BOOTMEM;
  8042105f04:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  8042105f0b:	00 00 00 
  8042105f0e:	48 83 38 00          	cmpq   $0x0,(%rax)
  8042105f12:	74 06                	je     8042105f1a <alloc_page+0x3a>
  8042105f14:	81 e3 ff ff fb ff    	and    $0xfffbffff,%ebx
    for (int pclass = class; pclass < MAX_CLASS; pclass++, li = NULL) {
  8042105f1a:	41 83 fc 2f          	cmp    $0x2f,%r12d
  8042105f1e:	0f 8f e1 00 00 00    	jg     8042106005 <alloc_page+0x125>
            if (!(flags & ALLOC_BOOTMEM) || page2pa(peer) + CLASS_SIZE(class) < BOOT_MEM_SIZE) goto found;
  8042105f24:	41 8d 4c 24 0c       	lea    0xc(%r12),%ecx
  8042105f29:	b8 01 00 00 00       	mov    $0x1,%eax
  8042105f2e:	48 d3 e0             	shl    %cl,%rax
  8042105f31:	48 89 c1             	mov    %rax,%rcx
  8042105f34:	49 63 c4             	movslq %r12d,%rax
  8042105f37:	49 89 c2             	mov    %rax,%r10
  8042105f3a:	49 c1 e2 04          	shl    $0x4,%r10
  8042105f3e:	48 ba 60 61 00 43 80 	movabs $0x8043006160,%rdx
  8042105f45:	00 00 00 
  8042105f48:	49 01 d2             	add    %rdx,%r10
  8042105f4b:	41 b9 2f 00 00 00    	mov    $0x2f,%r9d
  8042105f51:	45 29 e1             	sub    %r12d,%r9d
  8042105f54:	49 01 c1             	add    %rax,%r9
  8042105f57:	49 c1 e1 04          	shl    $0x4,%r9
  8042105f5b:	48 8d 42 10          	lea    0x10(%rdx),%rax
  8042105f5f:	49 01 c1             	add    %rax,%r9
    struct Page *peer = NULL;
  8042105f62:	41 bd 00 00 00 00    	mov    $0x0,%r13d
            if (!(flags & ALLOC_BOOTMEM) || page2pa(peer) + CLASS_SIZE(class) < BOOT_MEM_SIZE) goto found;
  8042105f68:	89 de                	mov    %ebx,%esi
  8042105f6a:	81 e6 00 00 04 00    	and    $0x40000,%esi
  8042105f70:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8042105f77:	ff 0f 00 
        for (li = free_classes[pclass].next; li != &free_classes[pclass]; li = li->next) {
  8042105f7a:	4d 89 d0             	mov    %r10,%r8
  8042105f7d:	49 8b 7a 08          	mov    0x8(%r10),%rdi
  8042105f81:	4c 39 d7             	cmp    %r10,%rdi
  8042105f84:	75 05                	jne    8042105f8b <alloc_page+0xab>
  8042105f86:	eb 3d                	jmp    8042105fc5 <alloc_page+0xe5>
  8042105f88:	48 89 c7             	mov    %rax,%rdi
            assert(peer->state == ALLOCATABLE_NODE);
  8042105f8b:	81 7f 28 00 00 40 00 	cmpl   $0x400000,0x28(%rdi)
  8042105f92:	75 3c                	jne    8042105fd0 <alloc_page+0xf0>
            if (!(flags & ALLOC_BOOTMEM) || page2pa(peer) + CLASS_SIZE(class) < BOOT_MEM_SIZE) goto found;
  8042105f94:	85 f6                	test   %esi,%esi
  8042105f96:	0f 84 9f 00 00 00    	je     804210603b <alloc_page+0x15b>
  8042105f9c:	48 89 d0             	mov    %rdx,%rax
  8042105f9f:	48 23 47 38          	and    0x38(%rdi),%rax
  8042105fa3:	48 c1 e0 0c          	shl    $0xc,%rax
  8042105fa7:	48 21 d0             	and    %rdx,%rax
  8042105faa:	48 01 c8             	add    %rcx,%rax
  8042105fad:	48 3d ff ff ff 3f    	cmp    $0x3fffffff,%rax
  8042105fb3:	0f 86 82 00 00 00    	jbe    804210603b <alloc_page+0x15b>
        for (li = free_classes[pclass].next; li != &free_classes[pclass]; li = li->next) {
  8042105fb9:	48 8b 47 08          	mov    0x8(%rdi),%rax
  8042105fbd:	4c 39 c0             	cmp    %r8,%rax
  8042105fc0:	75 c6                	jne    8042105f88 <alloc_page+0xa8>
  8042105fc2:	49 89 fd             	mov    %rdi,%r13
    for (int pclass = class; pclass < MAX_CLASS; pclass++, li = NULL) {
  8042105fc5:	49 83 c2 10          	add    $0x10,%r10
  8042105fc9:	4d 39 ca             	cmp    %r9,%r10
  8042105fcc:	75 ac                	jne    8042105f7a <alloc_page+0x9a>
  8042105fce:	eb 3b                	jmp    804210600b <alloc_page+0x12b>
            assert(peer->state == ALLOCATABLE_NODE);
  8042105fd0:	48 b9 f8 0a 12 42 80 	movabs $0x8042120af8,%rcx
  8042105fd7:	00 00 00 
  8042105fda:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042105fe1:	00 00 00 
  8042105fe4:	be 8c 04 00 00       	mov    $0x48c,%esi
  8042105fe9:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042105ff0:	00 00 00 
  8042105ff3:	b8 00 00 00 00       	mov    $0x0,%eax
  8042105ff8:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042105fff:	00 00 00 
  8042106002:	41 ff d0             	call   *%r8
    struct Page *peer = NULL;
  8042106005:	41 bd 00 00 00 00    	mov    $0x0,%r13d
    return NULL;
  804210600b:	41 be 00 00 00 00    	mov    $0x0,%r14d
    if (!is_swap_full){
  8042106011:	48 b8 00 00 00 43 80 	movabs $0x8043000000,%rax
  8042106018:	00 00 00 
  804210601b:	83 38 00             	cmpl   $0x0,(%rax)
  804210601e:	0f 85 e0 03 00 00    	jne    8042106404 <alloc_page+0x524>
        is_swap_full = 1;
  8042106024:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        swap_workout(); 
  804210602a:	48 b8 a6 5d 10 42 80 	movabs $0x8042105da6,%rax
  8042106031:	00 00 00 
  8042106034:	ff d0                	call   *%rax
  8042106036:	4c 89 ef             	mov    %r13,%rdi
  8042106039:	eb 15                	jmp    8042106050 <alloc_page+0x170>
    struct List *list_prev = list->prev;
  804210603b:	48 8b 17             	mov    (%rdi),%rdx
    struct List *list_next = list->next;
  804210603e:	48 8b 47 08          	mov    0x8(%rdi),%rax
    list_prev->next = list_next;
  8042106042:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list_next->prev = list_prev;
  8042106046:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  8042106049:	48 89 3f             	mov    %rdi,(%rdi)
  804210604c:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
    if (flags & ALLOC_POOL) {
  8042106050:	f7 c3 00 00 01 00    	test   $0x10000,%ebx
  8042106056:	0f 84 ec 02 00 00    	je     8042106348 <alloc_page+0x468>
        assert(!allocating_pool);
  804210605c:	48 b8 00 61 00 43 80 	movabs $0x8043006100,%rax
  8042106063:	00 00 00 
  8042106066:	80 38 00             	cmpb   $0x0,(%rax)
  8042106069:	0f 85 43 01 00 00    	jne    80421061b2 <alloc_page+0x2d2>
        allocating_pool = 1;
  804210606f:	48 b8 00 61 00 43 80 	movabs $0x8043006100,%rax
  8042106076:	00 00 00 
  8042106079:	c6 00 01             	movb   $0x1,(%rax)
  804210607c:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8042106083:	ff 0f 00 
  8042106086:	48 89 d0             	mov    %rdx,%rax
  8042106089:	48 23 47 38          	and    0x38(%rdi),%rax
  804210608d:	48 c1 e0 0c          	shl    $0xc,%rax
  8042106091:	48 89 c6             	mov    %rax,%rsi
  8042106094:	48 21 d6             	and    %rdx,%rsi
    if (pa > max_memory_map_addr)
  8042106097:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210609e:	00 00 00 
  80421060a1:	48 39 f0             	cmp    %rsi,%rax
  80421060a4:	0f 82 3d 01 00 00    	jb     80421061e7 <alloc_page+0x307>
    return (void *)(pa + KERN_BASE_ADDR);
  80421060aa:	49 b9 00 00 00 40 80 	movabs $0x8040000000,%r9
  80421060b1:	00 00 00 
  80421060b4:	49 01 f1             	add    %rsi,%r9
        ndesc = POOL_ENTRIES_FOR_SIZE(CLASS_SIZE(class));
  80421060b7:	41 8d 4c 24 0c       	lea    0xc(%r12),%ecx
  80421060bc:	b8 01 00 00 00       	mov    $0x1,%eax
  80421060c1:	48 d3 e0             	shl    %cl,%rax
  80421060c4:	48 8d 48 f0          	lea    -0x10(%rax),%rcx
  80421060c8:	48 ba cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rdx
  80421060cf:	cc cc cc 
  80421060d2:	48 89 c8             	mov    %rcx,%rax
  80421060d5:	48 f7 e2             	mul    %rdx
  80421060d8:	48 c1 ea 06          	shr    $0x6,%rdx
        for (size_t i = 0; i < ndesc; i++)
  80421060dc:	48 83 f9 4f          	cmp    $0x4f,%rcx
  80421060e0:	76 3b                	jbe    804210611d <alloc_page+0x23d>
  80421060e2:	48 b8 10 00 00 40 80 	movabs $0x8040000010,%rax
  80421060e9:	00 00 00 
  80421060ec:	48 01 f0             	add    %rsi,%rax
  80421060ef:	be 00 00 00 00       	mov    $0x0,%esi
    struct List *list_next = list->next;
  80421060f4:	48 b9 40 61 00 43 80 	movabs $0x8043006140,%rcx
  80421060fb:	00 00 00 
  80421060fe:	4c 8b 41 08          	mov    0x8(%rcx),%r8
    list_prev->next = list_cur;
  8042106102:	48 89 41 08          	mov    %rax,0x8(%rcx)
    list_next->prev = list_cur;
  8042106106:	49 89 00             	mov    %rax,(%r8)
    list_cur->prev = list_prev;
  8042106109:	48 89 08             	mov    %rcx,(%rax)
    list_cur->next = list_next;
  804210610c:	4c 89 40 08          	mov    %r8,0x8(%rax)
        for (size_t i = 0; i < ndesc; i++)
  8042106110:	48 83 c6 01          	add    $0x1,%rsi
  8042106114:	48 83 c0 50          	add    $0x50,%rax
  8042106118:	48 39 d6             	cmp    %rdx,%rsi
  804210611b:	72 e1                	jb     80421060fe <alloc_page+0x21e>
        newpool->next = first_pool;
  804210611d:	48 b8 50 61 00 43 80 	movabs $0x8043006150,%rax
  8042106124:	00 00 00 
  8042106127:	48 8b 08             	mov    (%rax),%rcx
  804210612a:	49 89 49 08          	mov    %rcx,0x8(%r9)
        first_pool = newpool;
  804210612e:	4c 89 08             	mov    %r9,(%rax)
        free_desc_count += ndesc;
  8042106131:	48 b8 38 61 00 43 80 	movabs $0x8043006138,%rax
  8042106138:	00 00 00 
  804210613b:	48 01 10             	add    %rdx,(%rax)
    return page->addr << CLASS_BASE;
  804210613e:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8042106145:	ff 0f 00 
  8042106148:	48 89 c6             	mov    %rax,%rsi
  804210614b:	48 23 77 38          	and    0x38(%rdi),%rsi
  804210614f:	48 c1 e6 0c          	shl    $0xc,%rsi
  8042106153:	48 21 c6             	and    %rax,%rsi
    struct Page *new = page_lookup(peer, page2pa(peer), class, PARTIAL_NODE, 1);
  8042106156:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804210615c:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8042106161:	44 89 e2             	mov    %r12d,%edx
  8042106164:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  804210616b:	00 00 00 
  804210616e:	ff d0                	call   *%rax
  8042106170:	49 89 c6             	mov    %rax,%r14
    assert(!new->refc);
  8042106173:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042106177:	0f 84 9b 00 00 00    	je     8042106218 <alloc_page+0x338>
  804210617d:	48 b9 59 f8 11 42 80 	movabs $0x804211f859,%rcx
  8042106184:	00 00 00 
  8042106187:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210618e:	00 00 00 
  8042106191:	be b1 04 00 00       	mov    $0x4b1,%esi
  8042106196:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210619d:	00 00 00 
  80421061a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80421061a5:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421061ac:	00 00 00 
  80421061af:	41 ff d0             	call   *%r8
        assert(!allocating_pool);
  80421061b2:	48 b9 48 f8 11 42 80 	movabs $0x804211f848,%rcx
  80421061b9:	00 00 00 
  80421061bc:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421061c3:	00 00 00 
  80421061c6:	be 9e 04 00 00       	mov    $0x49e,%esi
  80421061cb:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421061d2:	00 00 00 
  80421061d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80421061da:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421061e1:	00 00 00 
  80421061e4:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  80421061e7:	49 89 c0             	mov    %rax,%r8
  80421061ea:	48 89 f1             	mov    %rsi,%rcx
  80421061ed:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421061f4:	00 00 00 
  80421061f7:	be a1 04 00 00       	mov    $0x4a1,%esi
  80421061fc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106203:	00 00 00 
  8042106206:	b8 00 00 00 00       	mov    $0x0,%eax
  804210620b:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042106212:	00 00 00 
  8042106215:	41 ff d1             	call   *%r9
    return page->addr << CLASS_BASE;
  8042106218:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804210621f:	ff 0f 00 
  8042106222:	48 89 c1             	mov    %rax,%rcx
  8042106225:	49 23 4e 38          	and    0x38(%r14),%rcx
  8042106229:	48 c1 e1 0c          	shl    $0xc,%rcx
  804210622d:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  8042106230:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042106237:	00 00 00 
  804210623a:	48 39 c8             	cmp    %rcx,%rax
  804210623d:	72 43                	jb     8042106282 <alloc_page+0x3a2>
        assert(KADDR(page2pa(new)) == first_pool);
  804210623f:	48 b8 50 61 00 43 80 	movabs $0x8043006150,%rax
  8042106246:	00 00 00 
  8042106249:	48 8b 18             	mov    (%rax),%rbx
    return (void *)(pa + KERN_BASE_ADDR);
  804210624c:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042106253:	00 00 00 
  8042106256:	48 01 c1             	add    %rax,%rcx
  8042106259:	48 39 cb             	cmp    %rcx,%rbx
  804210625c:	75 52                	jne    80421062b0 <alloc_page+0x3d0>
        page_ref(new);
  804210625e:	4c 89 f7             	mov    %r14,%rdi
  8042106261:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  8042106268:	00 00 00 
  804210626b:	ff d0                	call   *%rax
        first_pool->peer = new;
  804210626d:	4c 89 33             	mov    %r14,(%rbx)
        allocating_pool = 0;
  8042106270:	48 b8 00 61 00 43 80 	movabs $0x8043006100,%rax
  8042106277:	00 00 00 
  804210627a:	c6 00 00             	movb   $0x0,(%rax)
  804210627d:	e9 05 01 00 00       	jmp    8042106387 <alloc_page+0x4a7>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042106282:	49 89 c0             	mov    %rax,%r8
  8042106285:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210628c:	00 00 00 
  804210628f:	be b4 04 00 00       	mov    $0x4b4,%esi
  8042106294:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210629b:	00 00 00 
  804210629e:	b8 00 00 00 00       	mov    $0x0,%eax
  80421062a3:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421062aa:	00 00 00 
  80421062ad:	41 ff d1             	call   *%r9
        assert(KADDR(page2pa(new)) == first_pool);
  80421062b0:	48 b9 18 0b 12 42 80 	movabs $0x8042120b18,%rcx
  80421062b7:	00 00 00 
  80421062ba:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421062c1:	00 00 00 
  80421062c4:	be b4 04 00 00       	mov    $0x4b4,%esi
  80421062c9:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421062d0:	00 00 00 
  80421062d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80421062d8:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421062df:	00 00 00 
  80421062e2:	41 ff d0             	call   *%r8
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  80421062e5:	48 89 d1             	mov    %rdx,%rcx
  80421062e8:	48 ba 40 0b 12 42 80 	movabs $0x8042120b40,%rdx
  80421062ef:	00 00 00 
  80421062f2:	be c0 04 00 00       	mov    $0x4c0,%esi
  80421062f7:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421062fe:	00 00 00 
  8042106301:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106306:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210630d:	00 00 00 
  8042106310:	41 ff d0             	call   *%r8
    assert(page2pa(new) >= PADDR(end) || page2pa(new) + CLASS_MASK(new->class) < IOPHYSMEM);
  8042106313:	48 b9 68 0b 12 42 80 	movabs $0x8042120b68,%rcx
  804210631a:	00 00 00 
  804210631d:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106324:	00 00 00 
  8042106327:	be c0 04 00 00       	mov    $0x4c0,%esi
  804210632c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106333:	00 00 00 
  8042106336:	b8 00 00 00 00       	mov    $0x0,%eax
  804210633b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106342:	00 00 00 
  8042106345:	41 ff d0             	call   *%r8
    return page->addr << CLASS_BASE;
  8042106348:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804210634f:	ff 0f 00 
  8042106352:	48 89 c6             	mov    %rax,%rsi
  8042106355:	48 23 77 38          	and    0x38(%rdi),%rsi
  8042106359:	48 c1 e6 0c          	shl    $0xc,%rsi
  804210635d:	48 21 c6             	and    %rax,%rsi
    struct Page *new = page_lookup(peer, page2pa(peer), class, PARTIAL_NODE, 1);
  8042106360:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8042106366:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804210636b:	44 89 e2             	mov    %r12d,%edx
  804210636e:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  8042106375:	00 00 00 
  8042106378:	ff d0                	call   *%rax
  804210637a:	49 89 c6             	mov    %rax,%r14
    assert(!new->refc);
  804210637d:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042106381:	0f 85 f6 fd ff ff    	jne    804210617d <alloc_page+0x29d>
  8042106387:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  804210638e:	ff 0f 00 
  8042106391:	48 89 d0             	mov    %rdx,%rax
  8042106394:	49 23 46 38          	and    0x38(%r14),%rax
  8042106398:	48 c1 e0 0c          	shl    $0xc,%rax
  804210639c:	48 21 d0             	and    %rdx,%rax
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804210639f:	48 ba 00 80 00 43 80 	movabs $0x8043008000,%rdx
  80421063a6:	00 00 00 
  80421063a9:	48 b9 ff ff ff 3f 80 	movabs $0x803fffffff,%rcx
  80421063b0:	00 00 00 
  80421063b3:	48 39 d1             	cmp    %rdx,%rcx
  80421063b6:	0f 83 29 ff ff ff    	jae    80421062e5 <alloc_page+0x405>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  80421063bc:	48 b9 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rcx
  80421063c3:	ff ff ff 
  80421063c6:	48 01 ca             	add    %rcx,%rdx
    assert(page2pa(new) >= PADDR(end) || page2pa(new) + CLASS_MASK(new->class) < IOPHYSMEM);
  80421063c9:	48 39 d0             	cmp    %rdx,%rax
  80421063cc:	73 27                	jae    80421063f5 <alloc_page+0x515>
  80421063ce:	41 0f b7 4e 34       	movzwl 0x34(%r14),%ecx
  80421063d3:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  80421063d9:	83 c1 0c             	add    $0xc,%ecx
  80421063dc:	ba 01 00 00 00       	mov    $0x1,%edx
  80421063e1:	48 d3 e2             	shl    %cl,%rdx
  80421063e4:	48 8d 44 10 ff       	lea    -0x1(%rax,%rdx,1),%rax
  80421063e9:	48 3d ff ff 09 00    	cmp    $0x9ffff,%rax
  80421063ef:	0f 87 1e ff ff ff    	ja     8042106313 <alloc_page+0x433>
        add_to_lru_list(new);
  80421063f5:	4c 89 f7             	mov    %r14,%rdi
  80421063f8:	48 b8 90 16 11 42 80 	movabs $0x8042111690,%rax
  80421063ff:	00 00 00 
  8042106402:	ff d0                	call   *%rax
}
  8042106404:	4c 89 f0             	mov    %r14,%rax
  8042106407:	5b                   	pop    %rbx
  8042106408:	41 5c                	pop    %r12
  804210640a:	41 5d                	pop    %r13
  804210640c:	41 5e                	pop    %r14
  804210640e:	5d                   	pop    %rbp
  804210640f:	c3                   	ret

0000008042106410 <ensure_free_desc>:
ensure_free_desc(size_t count) {
  8042106410:	f3 0f 1e fa          	endbr64
  8042106414:	55                   	push   %rbp
  8042106415:	48 89 e5             	mov    %rsp,%rbp
  8042106418:	53                   	push   %rbx
  8042106419:	48 83 ec 08          	sub    $0x8,%rsp
    if (free_desc_count < count) {
  804210641d:	48 b8 38 61 00 43 80 	movabs $0x8043006138,%rax
  8042106424:	00 00 00 
  8042106427:	48 39 38             	cmp    %rdi,(%rax)
  804210642a:	72 1a                	jb     8042106446 <ensure_free_desc+0x36>
    return list->next == list;
  804210642c:	48 b8 40 61 00 43 80 	movabs $0x8043006140,%rax
  8042106433:	00 00 00 
    assert(!list_empty(&free_descriptors));
  8042106436:	48 39 40 08          	cmp    %rax,0x8(%rax)
  804210643a:	0f 84 8d 00 00 00    	je     80421064cd <ensure_free_desc+0xbd>
}
  8042106440:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8042106444:	c9                   	leave
  8042106445:	c3                   	ret
  8042106446:	48 89 fb             	mov    %rdi,%rbx
        struct Page *res = alloc_page(POOL_CLASS, ALLOC_POOL);
  8042106449:	be 00 00 01 00       	mov    $0x10000,%esi
  804210644e:	bf 01 00 00 00       	mov    $0x1,%edi
  8042106453:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  804210645a:	00 00 00 
  804210645d:	ff d0                	call   *%rax
        if (!res) panic("Out of memory\n");
  804210645f:	48 85 c0             	test   %rax,%rax
  8042106462:	74 44                	je     80421064a8 <ensure_free_desc+0x98>
    assert(free_desc_count >= count);
  8042106464:	48 b8 38 61 00 43 80 	movabs $0x8043006138,%rax
  804210646b:	00 00 00 
  804210646e:	48 39 18             	cmp    %rbx,(%rax)
  8042106471:	73 b9                	jae    804210642c <ensure_free_desc+0x1c>
  8042106473:	48 b9 73 f8 11 42 80 	movabs $0x804211f873,%rcx
  804210647a:	00 00 00 
  804210647d:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106484:	00 00 00 
  8042106487:	be 94 00 00 00       	mov    $0x94,%esi
  804210648c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106493:	00 00 00 
  8042106496:	b8 00 00 00 00       	mov    $0x0,%eax
  804210649b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421064a2:	00 00 00 
  80421064a5:	41 ff d0             	call   *%r8
        if (!res) panic("Out of memory\n");
  80421064a8:	48 ba 64 f8 11 42 80 	movabs $0x804211f864,%rdx
  80421064af:	00 00 00 
  80421064b2:	be 91 00 00 00       	mov    $0x91,%esi
  80421064b7:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421064be:	00 00 00 
  80421064c1:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  80421064c8:	00 00 00 
  80421064cb:	ff d1                	call   *%rcx
    assert(!list_empty(&free_descriptors));
  80421064cd:	48 b9 b8 0b 12 42 80 	movabs $0x8042120bb8,%rcx
  80421064d4:	00 00 00 
  80421064d7:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421064de:	00 00 00 
  80421064e1:	be 95 00 00 00       	mov    $0x95,%esi
  80421064e6:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421064ed:	00 00 00 
  80421064f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80421064f5:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421064fc:	00 00 00 
  80421064ff:	41 ff d0             	call   *%r8

0000008042106502 <alloc_descriptor>:
alloc_descriptor(enum PageState state) {
  8042106502:	f3 0f 1e fa          	endbr64
  8042106506:	55                   	push   %rbp
  8042106507:	48 89 e5             	mov    %rsp,%rbp
  804210650a:	41 54                	push   %r12
  804210650c:	53                   	push   %rbx
  804210650d:	41 89 fc             	mov    %edi,%r12d
    ensure_free_desc(1);
  8042106510:	bf 01 00 00 00       	mov    $0x1,%edi
  8042106515:	48 b8 10 64 10 42 80 	movabs $0x8042106410,%rax
  804210651c:	00 00 00 
  804210651f:	ff d0                	call   *%rax
    struct Page *new = (struct Page *)list_del(free_descriptors.next);
  8042106521:	48 b8 48 61 00 43 80 	movabs $0x8043006148,%rax
  8042106528:	00 00 00 
  804210652b:	48 8b 18             	mov    (%rax),%rbx
    if (!list) {
  804210652e:	48 85 db             	test   %rbx,%rbx
  8042106531:	74 15                	je     8042106548 <alloc_descriptor+0x46>
    struct List *list_prev = list->prev;
  8042106533:	48 8b 13             	mov    (%rbx),%rdx
    struct List *list_next = list->next;
  8042106536:	48 8b 43 08          	mov    0x8(%rbx),%rax
    list_prev->next = list_next;
  804210653a:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list_next->prev = list_prev;
  804210653e:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  8042106541:	48 89 1b             	mov    %rbx,(%rbx)
  8042106544:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
    memset(new, 0, sizeof *new);
  8042106548:	ba 50 00 00 00       	mov    $0x50,%edx
  804210654d:	be 00 00 00 00       	mov    $0x0,%esi
  8042106552:	48 89 df             	mov    %rbx,%rdi
  8042106555:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  804210655c:	00 00 00 
  804210655f:	ff d0                	call   *%rax
    list->next = list->prev = list;
  8042106561:	48 89 1b             	mov    %rbx,(%rbx)
  8042106564:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
    new->state = state;
  8042106568:	44 89 63 28          	mov    %r12d,0x28(%rbx)
    free_desc_count--;
  804210656c:	48 b8 38 61 00 43 80 	movabs $0x8043006138,%rax
  8042106573:	00 00 00 
  8042106576:	48 83 28 01          	subq   $0x1,(%rax)
}
  804210657a:	48 89 d8             	mov    %rbx,%rax
  804210657d:	5b                   	pop    %rbx
  804210657e:	41 5c                	pop    %r12
  8042106580:	5d                   	pop    %rbp
  8042106581:	c3                   	ret

0000008042106582 <alloc_virtual_child>:
alloc_virtual_child(struct Page *parent, struct Page **dst) {
  8042106582:	f3 0f 1e fa          	endbr64
  8042106586:	55                   	push   %rbp
  8042106587:	48 89 e5             	mov    %rsp,%rbp
  804210658a:	41 54                	push   %r12
  804210658c:	53                   	push   %rbx
  804210658d:	48 89 fb             	mov    %rdi,%rbx
    assert_virtual(parent);
  8042106590:	8b 7f 28             	mov    0x28(%rdi),%edi
  8042106593:	89 f8                	mov    %edi,%eax
  8042106595:	25 00 00 f0 00       	and    $0xf00000,%eax
  804210659a:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  804210659f:	0f 87 8f 00 00 00    	ja     8042106634 <alloc_virtual_child+0xb2>
  80421065a5:	49 89 f4             	mov    %rsi,%r12
    assert(parent->phy && parent->phy->left && parent->phy->right);
  80421065a8:	48 8b 43 30          	mov    0x30(%rbx),%rax
  80421065ac:	48 85 c0             	test   %rax,%rax
  80421065af:	0f 84 b4 00 00 00    	je     8042106669 <alloc_virtual_child+0xe7>
  80421065b5:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  80421065ba:	0f 84 a9 00 00 00    	je     8042106669 <alloc_virtual_child+0xe7>
  80421065c0:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  80421065c5:	0f 84 9e 00 00 00    	je     8042106669 <alloc_virtual_child+0xe7>
    if ((*dst = alloc_descriptor(parent->state))) {
  80421065cb:	48 b8 02 65 10 42 80 	movabs $0x8042106502,%rax
  80421065d2:	00 00 00 
  80421065d5:	ff d0                	call   *%rax
  80421065d7:	49 89 04 24          	mov    %rax,(%r12)
  80421065db:	48 85 c0             	test   %rax,%rax
  80421065de:	74 4f                	je     804210662f <alloc_virtual_child+0xad>
        (*dst)->parent = parent;
  80421065e0:	48 89 58 20          	mov    %rbx,0x20(%rax)
        (*dst)->phy = dst == &parent->left ? parent->phy->left : parent->phy->right;
  80421065e4:	48 8d 43 10          	lea    0x10(%rbx),%rax
  80421065e8:	49 39 c4             	cmp    %rax,%r12
  80421065eb:	0f 84 ad 00 00 00    	je     804210669e <alloc_virtual_child+0x11c>
  80421065f1:	48 8b 43 30          	mov    0x30(%rbx),%rax
  80421065f5:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80421065f9:	49 8b 04 24          	mov    (%r12),%rax
  80421065fd:	48 89 50 30          	mov    %rdx,0x30(%rax)
        page_ref((*dst)->phy);
  8042106601:	49 8b 04 24          	mov    (%r12),%rax
  8042106605:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8042106609:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  8042106610:	00 00 00 
  8042106613:	ff d0                	call   *%rax
        list_append((struct List *)(*dst)->phy, (struct List *)(*dst));
  8042106615:	49 8b 04 24          	mov    (%r12),%rax
  8042106619:	48 8b 50 30          	mov    0x30(%rax),%rdx
    struct List *list_next = list->next;
  804210661d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
    list_prev->next = list_cur;
  8042106621:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list_next->prev = list_cur;
  8042106625:	48 89 01             	mov    %rax,(%rcx)
    list_cur->prev = list_prev;
  8042106628:	48 89 10             	mov    %rdx,(%rax)
    list_cur->next = list_next;
  804210662b:	48 89 48 08          	mov    %rcx,0x8(%rax)
}
  804210662f:	5b                   	pop    %rbx
  8042106630:	41 5c                	pop    %r12
  8042106632:	5d                   	pop    %rbp
  8042106633:	c3                   	ret
    assert_virtual(parent);
  8042106634:	48 b9 d8 0b 12 42 80 	movabs $0x8042120bd8,%rcx
  804210663b:	00 00 00 
  804210663e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106645:	00 00 00 
  8042106648:	be 71 01 00 00       	mov    $0x171,%esi
  804210664d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106654:	00 00 00 
  8042106657:	b8 00 00 00 00       	mov    $0x0,%eax
  804210665c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106663:	00 00 00 
  8042106666:	41 ff d0             	call   *%r8
    assert(parent->phy && parent->phy->left && parent->phy->right);
  8042106669:	48 b9 10 0c 12 42 80 	movabs $0x8042120c10,%rcx
  8042106670:	00 00 00 
  8042106673:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210667a:	00 00 00 
  804210667d:	be 72 01 00 00       	mov    $0x172,%esi
  8042106682:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106689:	00 00 00 
  804210668c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106691:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106698:	00 00 00 
  804210669b:	41 ff d0             	call   *%r8
        (*dst)->phy = dst == &parent->left ? parent->phy->left : parent->phy->right;
  804210669e:	48 8b 43 30          	mov    0x30(%rbx),%rax
  80421066a2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80421066a6:	e9 4e ff ff ff       	jmp    80421065f9 <alloc_virtual_child+0x77>

00000080421066ab <alloc_child>:
alloc_child(struct Page *parent, bool right) {
  80421066ab:	f3 0f 1e fa          	endbr64
  80421066af:	55                   	push   %rbp
  80421066b0:	48 89 e5             	mov    %rsp,%rbp
  80421066b3:	41 54                	push   %r12
  80421066b5:	53                   	push   %rbx
  80421066b6:	48 89 fb             	mov    %rdi,%rbx
    assert_physical(parent);
  80421066b9:	8b 7f 28             	mov    0x28(%rdi),%edi
  80421066bc:	89 f8                	mov    %edi,%eax
  80421066be:	25 00 00 f0 00       	and    $0xf00000,%eax
  80421066c3:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  80421066c8:	0f 86 bd 00 00 00    	jbe    804210678b <alloc_child+0xe0>
  80421066ce:	41 89 f4             	mov    %esi,%r12d
    struct Page *new = NULL;
  80421066d1:	b8 00 00 00 00       	mov    $0x0,%eax
	if (parent->class) {
  80421066d6:	66 f7 43 34 ff 0f    	testw  $0xfff,0x34(%rbx)
  80421066dc:	0f 84 a4 00 00 00    	je     8042106786 <alloc_child+0xdb>
		new = alloc_descriptor(parent->state);
  80421066e2:	48 b8 02 65 10 42 80 	movabs $0x8042106502,%rax
  80421066e9:	00 00 00 
  80421066ec:	ff d0                	call   *%rax
		if (right) {
  80421066ee:	45 84 e4             	test   %r12b,%r12b
  80421066f1:	0f 84 c9 00 00 00    	je     80421067c0 <alloc_child+0x115>
			parent->right = new;
  80421066f7:	48 89 43 18          	mov    %rax,0x18(%rbx)
			new->addr = parent->addr + (1ULL << (parent->class - 1));
  80421066fb:	0f b7 4b 34          	movzwl 0x34(%rbx),%ecx
  80421066ff:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042106705:	83 e9 01             	sub    $0x1,%ecx
  8042106708:	ba 01 00 00 00       	mov    $0x1,%edx
  804210670d:	48 d3 e2             	shl    %cl,%rdx
  8042106710:	48 b9 ff ff ff ff ff 	movabs $0xfffffffffffff,%rcx
  8042106717:	ff 0f 00 
  804210671a:	48 89 ce             	mov    %rcx,%rsi
  804210671d:	48 23 73 38          	and    0x38(%rbx),%rsi
  8042106721:	48 01 f2             	add    %rsi,%rdx
  8042106724:	48 21 ca             	and    %rcx,%rdx
  8042106727:	89 50 38             	mov    %edx,0x38(%rax)
  804210672a:	48 89 d1             	mov    %rdx,%rcx
  804210672d:	48 c1 e9 20          	shr    $0x20,%rcx
  8042106731:	66 89 48 3c          	mov    %cx,0x3c(%rax)
  8042106735:	48 c1 ea 30          	shr    $0x30,%rdx
  8042106739:	83 e2 0f             	and    $0xf,%edx
  804210673c:	0f b6 48 3e          	movzbl 0x3e(%rax),%ecx
  8042106740:	83 e1 f0             	and    $0xfffffff0,%ecx
  8042106743:	09 ca                	or     %ecx,%edx
  8042106745:	88 50 3e             	mov    %dl,0x3e(%rax)
		new->left = NULL;
  8042106748:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  804210674f:	00 
		new->right = NULL;
  8042106750:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8042106757:	00 
		new->parent = parent;
  8042106758:	48 89 58 20          	mov    %rbx,0x20(%rax)
		if (parent->refc) {
  804210675c:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  8042106760:	0f 95 c2             	setne  %dl
  8042106763:	0f b6 d2             	movzbl %dl,%edx
  8042106766:	89 50 30             	mov    %edx,0x30(%rax)
		new->class = parent->class - 1;
  8042106769:	0f b7 4b 34          	movzwl 0x34(%rbx),%ecx
  804210676d:	66 81 c1 ff 0f       	add    $0xfff,%cx
  8042106772:	66 81 e1 ff 0f       	and    $0xfff,%cx
  8042106777:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  804210677b:	66 81 e2 00 f0       	and    $0xf000,%dx
  8042106780:	09 ca                	or     %ecx,%edx
  8042106782:	66 89 50 34          	mov    %dx,0x34(%rax)
}
  8042106786:	5b                   	pop    %rbx
  8042106787:	41 5c                	pop    %r12
  8042106789:	5d                   	pop    %rbp
  804210678a:	c3                   	ret
    assert_physical(parent);
  804210678b:	48 b9 48 0c 12 42 80 	movabs $0x8042120c48,%rcx
  8042106792:	00 00 00 
  8042106795:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210679c:	00 00 00 
  804210679f:	be d3 00 00 00       	mov    $0xd3,%esi
  80421067a4:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421067ab:	00 00 00 
  80421067ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80421067b3:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421067ba:	00 00 00 
  80421067bd:	41 ff d0             	call   *%r8
			parent->left = new;
  80421067c0:	48 89 43 10          	mov    %rax,0x10(%rbx)
			new->addr = parent->addr;
  80421067c4:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  80421067cb:	ff 0f 00 
  80421067ce:	48 23 53 38          	and    0x38(%rbx),%rdx
  80421067d2:	e9 50 ff ff ff       	jmp    8042106727 <alloc_child+0x7c>

00000080421067d7 <page_lookup>:
page_lookup(struct Page *hint, uintptr_t addr, int class, enum PageState type, bool alloc) {
  80421067d7:	f3 0f 1e fa          	endbr64
  80421067db:	55                   	push   %rbp
  80421067dc:	48 89 e5             	mov    %rsp,%rbp
  80421067df:	41 57                	push   %r15
  80421067e1:	41 56                	push   %r14
  80421067e3:	41 55                	push   %r13
  80421067e5:	41 54                	push   %r12
  80421067e7:	53                   	push   %rbx
  80421067e8:	48 83 ec 28          	sub    $0x28,%rsp
  80421067ec:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  80421067f0:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
  80421067f3:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
    assert(class >= 0);
  80421067f7:	85 d2                	test   %edx,%edx
  80421067f9:	78 47                	js     8042106842 <page_lookup+0x6b>
  80421067fb:	48 89 fb             	mov    %rdi,%rbx
  80421067fe:	41 89 d5             	mov    %edx,%r13d
  8042106801:	45 89 c6             	mov    %r8d,%r14d
    if (hint) assert_physical(hint);
  8042106804:	48 85 ff             	test   %rdi,%rdi
  8042106807:	0f 84 9f 00 00 00    	je     80421068ac <page_lookup+0xd5>
  804210680d:	8b 47 28             	mov    0x28(%rdi),%eax
  8042106810:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042106815:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  804210681a:	76 5b                	jbe    8042106877 <page_lookup+0xa0>
    assert(!(addr & CLASS_MASK(class)));
  804210681c:	41 8d 4d 0c          	lea    0xc(%r13),%ecx
  8042106820:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8042106827:	48 d3 e0             	shl    %cl,%rax
  804210682a:	48 f7 d0             	not    %rax
  804210682d:	48 85 45 c8          	test   %rax,-0x38(%rbp)
  8042106831:	0f 85 84 00 00 00    	jne    80421068bb <page_lookup+0xe4>
        bool right = addr & CLASS_SIZE(node->class - 1);
  8042106837:	41 bf 01 00 00 00    	mov    $0x1,%r15d
  804210683d:	e9 d0 03 00 00       	jmp    8042106c12 <page_lookup+0x43b>
    assert(class >= 0);
  8042106842:	48 b9 be f7 11 42 80 	movabs $0x804211f7be,%rcx
  8042106849:	00 00 00 
  804210684c:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106853:	00 00 00 
  8042106856:	be f3 00 00 00       	mov    $0xf3,%esi
  804210685b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106862:	00 00 00 
  8042106865:	b8 00 00 00 00       	mov    $0x0,%eax
  804210686a:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106871:	00 00 00 
  8042106874:	41 ff d0             	call   *%r8
    if (hint) assert_physical(hint);
  8042106877:	48 b9 80 0c 12 42 80 	movabs $0x8042120c80,%rcx
  804210687e:	00 00 00 
  8042106881:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106888:	00 00 00 
  804210688b:	be f4 00 00 00       	mov    $0xf4,%esi
  8042106890:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106897:	00 00 00 
  804210689a:	b8 00 00 00 00       	mov    $0x0,%eax
  804210689f:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421068a6:	00 00 00 
  80421068a9:	41 ff d0             	call   *%r8
    struct Page *node = hint ? hint : &root;
  80421068ac:	48 bb 80 10 00 43 80 	movabs $0x8043001080,%rbx
  80421068b3:	00 00 00 
  80421068b6:	e9 61 ff ff ff       	jmp    804210681c <page_lookup+0x45>
    assert(!(addr & CLASS_MASK(class)));
  80421068bb:	48 b9 8c f8 11 42 80 	movabs $0x804211f88c,%rcx
  80421068c2:	00 00 00 
  80421068c5:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421068cc:	00 00 00 
  80421068cf:	be f7 00 00 00       	mov    $0xf7,%esi
  80421068d4:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421068db:	00 00 00 
  80421068de:	b8 00 00 00 00       	mov    $0x0,%eax
  80421068e3:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421068ea:	00 00 00 
  80421068ed:	41 ff d0             	call   *%r8
            ensure_free_desc((node->class - class + 1) * 2);
  80421068f0:	44 29 e8             	sub    %r13d,%eax
  80421068f3:	8d 7c 00 02          	lea    0x2(%rax,%rax,1),%edi
  80421068f7:	48 63 ff             	movslq %edi,%rdi
  80421068fa:	48 b8 10 64 10 42 80 	movabs $0x8042106410,%rax
  8042106901:	00 00 00 
  8042106904:	ff d0                	call   *%rax
            bool was_free = node->state == ALLOCATABLE_NODE && PAGE_IS_FREE(node);
  8042106906:	81 7b 28 00 00 40 00 	cmpl   $0x400000,0x28(%rbx)
  804210690d:	74 51                	je     8042106960 <page_lookup+0x189>
            if (!node->left) alloc_child(node, 0);
  804210690f:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  8042106914:	74 62                	je     8042106978 <page_lookup+0x1a1>
            if (!node->right) alloc_child(node, 1);
  8042106916:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  804210691b:	0f 84 d9 00 00 00    	je     80421069fa <page_lookup+0x223>
            if (type != PARTIAL_NODE && node->state != type)
  8042106921:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8042106924:	3d 00 00 30 00       	cmp    $0x300000,%eax
  8042106929:	74 0c                	je     8042106937 <page_lookup+0x160>
  804210692b:	39 43 28             	cmp    %eax,0x28(%rbx)
  804210692e:	74 07                	je     8042106937 <page_lookup+0x160>
                node->state = PARTIAL_NODE;
  8042106930:	c7 43 28 00 00 30 00 	movl   $0x300000,0x28(%rbx)
        assert((node->left && node->right) || !alloc);
  8042106937:	48 8b 43 10          	mov    0x10(%rbx),%rax
  804210693b:	48 85 c0             	test   %rax,%rax
  804210693e:	0f 84 13 03 00 00    	je     8042106c57 <page_lookup+0x480>
  8042106944:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8042106949:	0f 84 08 03 00 00    	je     8042106c57 <page_lookup+0x480>
        node = right ? node->right : node->left;
  804210694f:	4d 85 e4             	test   %r12,%r12
  8042106952:	0f 85 ad 02 00 00    	jne    8042106c05 <page_lookup+0x42e>
  8042106958:	48 89 c3             	mov    %rax,%rbx
  804210695b:	e9 b2 02 00 00       	jmp    8042106c12 <page_lookup+0x43b>
            bool was_free = node->state == ALLOCATABLE_NODE && PAGE_IS_FREE(node);
  8042106960:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  8042106964:	75 a9                	jne    804210690f <page_lookup+0x138>
  8042106966:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  804210696b:	75 a9                	jne    8042106916 <page_lookup+0x13f>
  804210696d:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8042106972:	0f 94 45 c3          	sete   -0x3d(%rbp)
            if (!node->left) alloc_child(node, 0);
  8042106976:	eb 04                	jmp    804210697c <page_lookup+0x1a5>
  8042106978:	c6 45 c3 00          	movb   $0x0,-0x3d(%rbp)
  804210697c:	be 00 00 00 00       	mov    $0x0,%esi
  8042106981:	48 89 df             	mov    %rbx,%rdi
  8042106984:	48 b8 ab 66 10 42 80 	movabs $0x80421066ab,%rax
  804210698b:	00 00 00 
  804210698e:	ff d0                	call   *%rax
            if (!node->right) alloc_child(node, 1);
  8042106990:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8042106995:	74 67                	je     80421069fe <page_lookup+0x227>
            if (was_free) {
  8042106997:	80 7d c3 00          	cmpb   $0x0,-0x3d(%rbp)
  804210699b:	74 84                	je     8042106921 <page_lookup+0x14a>
                struct Page *other = !right ? node->right : node->left;
  804210699d:	4d 85 e4             	test   %r12,%r12
  80421069a0:	75 72                	jne    8042106a14 <page_lookup+0x23d>
  80421069a2:	48 8b 53 18          	mov    0x18(%rbx),%rdx
                assert(other->state == ALLOCATABLE_NODE);
  80421069a6:	81 7a 28 00 00 40 00 	cmpl   $0x400000,0x28(%rdx)
  80421069ad:	75 6b                	jne    8042106a1a <page_lookup+0x243>
    struct List *list_prev = list->prev;
  80421069af:	48 8b 0b             	mov    (%rbx),%rcx
    struct List *list_next = list->next;
  80421069b2:	48 8b 43 08          	mov    0x8(%rbx),%rax
    list_prev->next = list_next;
  80421069b6:	48 89 41 08          	mov    %rax,0x8(%rcx)
    list_next->prev = list_prev;
  80421069ba:	48 89 08             	mov    %rcx,(%rax)
    list->next = list->prev = list;
  80421069bd:	48 89 1b             	mov    %rbx,(%rbx)
  80421069c0:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
                list_append(&free_classes[node->class - 1], (struct List *)other);
  80421069c4:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
  80421069c8:	25 ff 0f 00 00       	and    $0xfff,%eax
  80421069cd:	83 e8 01             	sub    $0x1,%eax
    struct List *list_next = list->next;
  80421069d0:	48 98                	cltq
  80421069d2:	48 c1 e0 04          	shl    $0x4,%rax
  80421069d6:	48 be 60 61 00 43 80 	movabs $0x8043006160,%rsi
  80421069dd:	00 00 00 
  80421069e0:	48 01 f0             	add    %rsi,%rax
  80421069e3:	48 8b 48 08          	mov    0x8(%rax),%rcx
    list_prev->next = list_cur;
  80421069e7:	48 89 50 08          	mov    %rdx,0x8(%rax)
    list_next->prev = list_cur;
  80421069eb:	48 89 11             	mov    %rdx,(%rcx)
                list_append(&free_classes[node->class - 1], (struct List *)other);
  80421069ee:	48 89 02             	mov    %rax,(%rdx)
    list_cur->next = list_next;
  80421069f1:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
}
  80421069f5:	e9 27 ff ff ff       	jmp    8042106921 <page_lookup+0x14a>
            if (!node->right) alloc_child(node, 1);
  80421069fa:	c6 45 c3 00          	movb   $0x0,-0x3d(%rbp)
  80421069fe:	be 01 00 00 00       	mov    $0x1,%esi
  8042106a03:	48 89 df             	mov    %rbx,%rdi
  8042106a06:	48 b8 ab 66 10 42 80 	movabs $0x80421066ab,%rax
  8042106a0d:	00 00 00 
  8042106a10:	ff d0                	call   *%rax
  8042106a12:	eb 83                	jmp    8042106997 <page_lookup+0x1c0>
                struct Page *other = !right ? node->right : node->left;
  8042106a14:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  8042106a18:	eb 8c                	jmp    80421069a6 <page_lookup+0x1cf>
                assert(other->state == ALLOCATABLE_NODE);
  8042106a1a:	48 b9 b8 0c 12 42 80 	movabs $0x8042120cb8,%rcx
  8042106a21:	00 00 00 
  8042106a24:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106a2b:	00 00 00 
  8042106a2e:	be 07 01 00 00       	mov    $0x107,%esi
  8042106a33:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106a3a:	00 00 00 
  8042106a3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106a42:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106a49:	00 00 00 
  8042106a4c:	41 ff d0             	call   *%r8
    if (alloc) assert(node);
  8042106a4f:	80 7d bc 00          	cmpb   $0x0,-0x44(%rbp)
  8042106a53:	0f 85 b3 00 00 00    	jne    8042106b0c <page_lookup+0x335>
  8042106a59:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (alloc && type != PARTIAL_NODE) /* Attach new memory */ {
  8042106a5e:	81 7d c4 00 00 30 00 	cmpl   $0x300000,-0x3c(%rbp)
  8042106a65:	0f 84 0b 01 00 00    	je     8042106b76 <page_lookup+0x39f>
  8042106a6b:	80 7d bc 00          	cmpb   $0x0,-0x44(%rbp)
  8042106a6f:	0f 84 01 01 00 00    	je     8042106b76 <page_lookup+0x39f>
        assert(!node->refc);
  8042106a75:	83 7b 30 00          	cmpl   $0x0,0x30(%rbx)
  8042106a79:	0f 85 c2 00 00 00    	jne    8042106b41 <page_lookup+0x36a>
        free_desc_rec(node->left);
  8042106a7f:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8042106a83:	49 bc c7 48 10 42 80 	movabs $0x80421048c7,%r12
  8042106a8a:	00 00 00 
  8042106a8d:	41 ff d4             	call   *%r12
        free_desc_rec(node->right);
  8042106a90:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  8042106a94:	41 ff d4             	call   *%r12
        node->left = node->right = NULL;
  8042106a97:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  8042106a9e:	00 
  8042106a9f:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  8042106aa6:	00 
    struct List *list_prev = list->prev;
  8042106aa7:	48 8b 13             	mov    (%rbx),%rdx
    struct List *list_next = list->next;
  8042106aaa:	48 8b 43 08          	mov    0x8(%rbx),%rax
    list_prev->next = list_next;
  8042106aae:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list_next->prev = list_prev;
  8042106ab2:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  8042106ab5:	48 89 1b             	mov    %rbx,(%rbx)
  8042106ab8:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
        if (type != PARTIAL_NODE && node->state != RESERVED_NODE) node->state = type;
  8042106abc:	81 7b 28 00 00 50 00 	cmpl   $0x500000,0x28(%rbx)
  8042106ac3:	0f 84 b2 00 00 00    	je     8042106b7b <page_lookup+0x3a4>
  8042106ac9:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8042106acc:	89 43 28             	mov    %eax,0x28(%rbx)
        if (node->state == ALLOCATABLE_NODE) list_append(&free_classes[node->class], (struct List *)node);
  8042106acf:	3d 00 00 40 00       	cmp    $0x400000,%eax
  8042106ad4:	0f 85 a1 00 00 00    	jne    8042106b7b <page_lookup+0x3a4>
  8042106ada:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
    struct List *list_next = list->next;
  8042106ade:	48 be 60 61 00 43 80 	movabs $0x8043006160,%rsi
  8042106ae5:	00 00 00 
  8042106ae8:	48 89 c2             	mov    %rax,%rdx
  8042106aeb:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  8042106af1:	48 c1 e2 04          	shl    $0x4,%rdx
  8042106af5:	48 01 f2             	add    %rsi,%rdx
  8042106af8:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
    list_prev->next = list_cur;
  8042106afc:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
    list_next->prev = list_cur;
  8042106b00:	48 89 19             	mov    %rbx,(%rcx)
        if (node->state == ALLOCATABLE_NODE) list_append(&free_classes[node->class], (struct List *)node);
  8042106b03:	48 89 13             	mov    %rdx,(%rbx)
    list_cur->next = list_next;
  8042106b06:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
    if (node) assert(!(page2pa(node) & CLASS_MASK(node->class)));
  8042106b0a:	eb 6f                	jmp    8042106b7b <page_lookup+0x3a4>
    if (alloc) assert(node);
  8042106b0c:	48 b9 a8 f8 11 42 80 	movabs $0x804211f8a8,%rcx
  8042106b13:	00 00 00 
  8042106b16:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106b1d:	00 00 00 
  8042106b20:	be 15 01 00 00       	mov    $0x115,%esi
  8042106b25:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106b2c:	00 00 00 
  8042106b2f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106b34:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106b3b:	00 00 00 
  8042106b3e:	41 ff d0             	call   *%r8
        assert(!node->refc);
  8042106b41:	48 b9 ad f8 11 42 80 	movabs $0x804211f8ad,%rcx
  8042106b48:	00 00 00 
  8042106b4b:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106b52:	00 00 00 
  8042106b55:	be 18 01 00 00       	mov    $0x118,%esi
  8042106b5a:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106b61:	00 00 00 
  8042106b64:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106b69:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106b70:	00 00 00 
  8042106b73:	41 ff d0             	call   *%r8
    if (node) assert(!(page2pa(node) & CLASS_MASK(node->class)));
  8042106b76:	48 85 db             	test   %rbx,%rbx
  8042106b79:	74 3a                	je     8042106bb5 <page_lookup+0x3de>
  8042106b7b:	0f b7 4b 34          	movzwl 0x34(%rbx),%ecx
  8042106b7f:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042106b85:	83 c1 0c             	add    $0xc,%ecx
  8042106b88:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8042106b8f:	48 d3 e0             	shl    %cl,%rax
  8042106b92:	48 89 c2             	mov    %rax,%rdx
    return page->addr << CLASS_BASE;
  8042106b95:	48 b9 ff ff ff ff ff 	movabs $0xfffffffffffff,%rcx
  8042106b9c:	ff 0f 00 
  8042106b9f:	48 89 c8             	mov    %rcx,%rax
  8042106ba2:	48 23 43 38          	and    0x38(%rbx),%rax
  8042106ba6:	48 c1 e0 0c          	shl    $0xc,%rax
  8042106baa:	48 21 c8             	and    %rcx,%rax
  8042106bad:	48 f7 d2             	not    %rdx
  8042106bb0:	48 85 c2             	test   %rax,%rdx
  8042106bb3:	75 12                	jne    8042106bc7 <page_lookup+0x3f0>
}
  8042106bb5:	48 89 d8             	mov    %rbx,%rax
  8042106bb8:	48 83 c4 28          	add    $0x28,%rsp
  8042106bbc:	5b                   	pop    %rbx
  8042106bbd:	41 5c                	pop    %r12
  8042106bbf:	41 5d                	pop    %r13
  8042106bc1:	41 5e                	pop    %r14
  8042106bc3:	41 5f                	pop    %r15
  8042106bc5:	5d                   	pop    %rbp
  8042106bc6:	c3                   	ret
    if (node) assert(!(page2pa(node) & CLASS_MASK(node->class)));
  8042106bc7:	48 b9 08 0d 12 42 80 	movabs $0x8042120d08,%rcx
  8042106bce:	00 00 00 
  8042106bd1:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106bd8:	00 00 00 
  8042106bdb:	be 27 01 00 00       	mov    $0x127,%esi
  8042106be0:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106be7:	00 00 00 
  8042106bea:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106bef:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106bf6:	00 00 00 
  8042106bf9:	41 ff d0             	call   *%r8
        node = right ? node->right : node->left;
  8042106bfc:	4d 85 e4             	test   %r12,%r12
  8042106bff:	0f 84 4a fe ff ff    	je     8042106a4f <page_lookup+0x278>
  8042106c05:	48 8b 5b 18          	mov    0x18(%rbx),%rbx
    while (node && node->class > class) {
  8042106c09:	48 85 db             	test   %rbx,%rbx
  8042106c0c:	0f 84 3d fe ff ff    	je     8042106a4f <page_lookup+0x278>
  8042106c12:	0f b7 43 34          	movzwl 0x34(%rbx),%eax
  8042106c16:	25 ff 0f 00 00       	and    $0xfff,%eax
  8042106c1b:	44 39 e8             	cmp    %r13d,%eax
  8042106c1e:	0f 8e 3a fe ff ff    	jle    8042106a5e <page_lookup+0x287>
        bool right = addr & CLASS_SIZE(node->class - 1);
  8042106c24:	8d 48 0b             	lea    0xb(%rax),%ecx
  8042106c27:	4d 89 fc             	mov    %r15,%r12
  8042106c2a:	49 d3 e4             	shl    %cl,%r12
  8042106c2d:	4c 23 65 c8          	and    -0x38(%rbp),%r12
        if (alloc) {
  8042106c31:	45 84 f6             	test   %r14b,%r14b
  8042106c34:	0f 85 b6 fc ff ff    	jne    80421068f0 <page_lookup+0x119>
        assert((node->left && node->right) || !alloc);
  8042106c3a:	48 8b 43 10          	mov    0x10(%rbx),%rax
  8042106c3e:	48 85 c0             	test   %rax,%rax
  8042106c41:	74 b9                	je     8042106bfc <page_lookup+0x425>
  8042106c43:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  8042106c48:	0f 85 01 fd ff ff    	jne    804210694f <page_lookup+0x178>
  8042106c4e:	45 84 f6             	test   %r14b,%r14b
  8042106c51:	0f 84 f8 fc ff ff    	je     804210694f <page_lookup+0x178>
  8042106c57:	48 b9 e0 0c 12 42 80 	movabs $0x8042120ce0,%rcx
  8042106c5e:	00 00 00 
  8042106c61:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106c68:	00 00 00 
  8042106c6b:	be 10 01 00 00       	mov    $0x110,%esi
  8042106c70:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106c77:	00 00 00 
  8042106c7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106c7f:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106c86:	00 00 00 
  8042106c89:	41 ff d0             	call   *%r8

0000008042106c8c <dump_memory_lists>:
dump_memory_lists(void) {
  8042106c8c:	f3 0f 1e fa          	endbr64
  8042106c90:	55                   	push   %rbp
  8042106c91:	48 89 e5             	mov    %rsp,%rbp
  8042106c94:	41 57                	push   %r15
  8042106c96:	41 56                	push   %r14
  8042106c98:	41 55                	push   %r13
  8042106c9a:	41 54                	push   %r12
  8042106c9c:	53                   	push   %rbx
  8042106c9d:	48 83 ec 28          	sub    $0x28,%rsp
    EFI_MEMORY_DESCRIPTOR *start = (void *)uefi_lp->MemoryMap;
  8042106ca1:	48 a1 00 30 14 42 80 	movabs 0x8042143000,%rax
  8042106ca8:	00 00 00 
  8042106cab:	48 8b 48 28          	mov    0x28(%rax),%rcx
    EFI_MEMORY_DESCRIPTOR *end = (void *)(uefi_lp->MemoryMap + uefi_lp->MemoryMapSize);
  8042106caf:	49 89 c8             	mov    %rcx,%r8
  8042106cb2:	4c 03 40 38          	add    0x38(%rax),%r8
    uint64_t minm = start->PhysicalStart;
  8042106cb6:	48 8b 79 08          	mov    0x8(%rcx),%rdi
    while (start < end) {
  8042106cba:	4c 39 c1             	cmp    %r8,%rcx
  8042106cbd:	73 44                	jae    8042106d03 <dump_memory_lists+0x77>
        start = (void *)((uint8_t *)start + uefi_lp->MemoryMapDescriptorSize);
  8042106cbf:	4c 8b 50 20          	mov    0x20(%rax),%r10
    uint64_t minm = start->PhysicalStart;
  8042106cc3:	49 89 ff             	mov    %rdi,%r15
    uint64_t maxm = 0;
  8042106cc6:	b8 00 00 00 00       	mov    $0x0,%eax
        maxm = MAX(start->NumberOfPages * EFI_PAGE_SIZE + start->PhysicalStart, maxm);
  8042106ccb:	48 8b 71 08          	mov    0x8(%rcx),%rsi
  8042106ccf:	48 8b 51 18          	mov    0x18(%rcx),%rdx
  8042106cd3:	48 c1 e2 0c          	shl    $0xc,%rdx
  8042106cd7:	48 01 f2             	add    %rsi,%rdx
  8042106cda:	48 39 d0             	cmp    %rdx,%rax
  8042106cdd:	48 0f 42 c2          	cmovb  %rdx,%rax
        minm = MIN(start->PhysicalStart, minm);
  8042106ce1:	49 39 f7             	cmp    %rsi,%r15
  8042106ce4:	4c 0f 47 fe          	cmova  %rsi,%r15
        start = (void *)((uint8_t *)start + uefi_lp->MemoryMapDescriptorSize);
  8042106ce8:	4c 01 d1             	add    %r10,%rcx
    while (start < end) {
  8042106ceb:	4c 39 c1             	cmp    %r8,%rcx
  8042106cee:	72 db                	jb     8042106ccb <dump_memory_lists+0x3f>
    for (int i = 0; i <= MAX_CLASS; i++) {
  8042106cf0:	41 be 00 00 00 00    	mov    $0x0,%r14d
                    cprintf("Class %d  Page at address: %p, size: %lu bytes\n", i, (void *)(minm + j * cur_size), cur_size);
  8042106cf6:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  8042106cfa:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8042106cfe:	e9 be 00 00 00       	jmp    8042106dc1 <dump_memory_lists+0x135>
    uint64_t minm = start->PhysicalStart;
  8042106d03:	49 89 ff             	mov    %rdi,%r15
    uint64_t maxm = 0;
  8042106d06:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106d0b:	eb e3                	jmp    8042106cf0 <dump_memory_lists+0x64>
            num = 1;
  8042106d0d:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  8042106d13:	bb 00 00 00 00       	mov    $0x0,%ebx
  8042106d18:	89 4d cc             	mov    %ecx,-0x34(%rbp)
  8042106d1b:	eb 2f                	jmp    8042106d4c <dump_memory_lists+0xc0>
                    cprintf("Class %d  Page at address: %p, size: %lu bytes\n", i, (void *)(minm + j * cur_size), cur_size);
  8042106d1d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042106d21:	4c 89 e2             	mov    %r12,%rdx
  8042106d24:	44 89 f6             	mov    %r14d,%esi
  8042106d27:	48 bf 38 0d 12 42 80 	movabs $0x8042120d38,%rdi
  8042106d2e:	00 00 00 
  8042106d31:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106d36:	49 b8 70 cf 10 42 80 	movabs $0x804210cf70,%r8
  8042106d3d:	00 00 00 
  8042106d40:	41 ff d0             	call   *%r8
        for (uint64_t j = 0; j < num; j++) {
  8042106d43:	48 83 c3 01          	add    $0x1,%rbx
  8042106d47:	4c 39 eb             	cmp    %r13,%rbx
  8042106d4a:	74 6b                	je     8042106db7 <dump_memory_lists+0x12b>
            if ((page = page_lookup(NULL, minm + j * cur_size, i, ALLOCATABLE_NODE, 0)) && page->state == ALLOCATABLE_NODE) {
  8042106d4c:	49 89 dc             	mov    %rbx,%r12
  8042106d4f:	0f b6 4d cc          	movzbl -0x34(%rbp),%ecx
  8042106d53:	49 d3 e4             	shl    %cl,%r12
  8042106d56:	4d 01 fc             	add    %r15,%r12
  8042106d59:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8042106d5f:	b9 00 00 40 00       	mov    $0x400000,%ecx
  8042106d64:	44 89 f2             	mov    %r14d,%edx
  8042106d67:	4c 89 e6             	mov    %r12,%rsi
  8042106d6a:	bf 00 00 00 00       	mov    $0x0,%edi
  8042106d6f:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  8042106d76:	00 00 00 
  8042106d79:	ff d0                	call   *%rax
  8042106d7b:	48 85 c0             	test   %rax,%rax
  8042106d7e:	74 c3                	je     8042106d43 <dump_memory_lists+0xb7>
  8042106d80:	81 78 28 00 00 40 00 	cmpl   $0x400000,0x28(%rax)
  8042106d87:	75 ba                	jne    8042106d43 <dump_memory_lists+0xb7>
                if (page->class == 0) {
  8042106d89:	66 f7 40 34 ff 0f    	testw  $0xfff,0x34(%rax)
  8042106d8f:	75 8c                	jne    8042106d1d <dump_memory_lists+0x91>
                    if (((uint64_t)page->addr << CLASS_BASE) > maxn) {
  8042106d91:	48 bf ff ff ff ff ff 	movabs $0xfffffffffffff,%rdi
  8042106d98:	ff 0f 00 
  8042106d9b:	48 23 78 38          	and    0x38(%rax),%rdi
  8042106d9f:	48 89 f8             	mov    %rdi,%rax
  8042106da2:	48 c1 e0 0c          	shl    $0xc,%rax
  8042106da6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042106daa:	48 39 c2             	cmp    %rax,%rdx
  8042106dad:	48 0f 43 c2          	cmovae %rdx,%rax
  8042106db1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042106db5:	eb 8c                	jmp    8042106d43 <dump_memory_lists+0xb7>
    for (int i = 0; i <= MAX_CLASS; i++) {
  8042106db7:	41 83 c6 01          	add    $0x1,%r14d
  8042106dbb:	41 83 fe 31          	cmp    $0x31,%r14d
  8042106dbf:	74 3e                	je     8042106dff <dump_memory_lists+0x173>
        uint64_t cur_size = CLASS_SIZE(i);
  8042106dc1:	41 8d 4e 0c          	lea    0xc(%r14),%ecx
  8042106dc5:	b8 01 00 00 00       	mov    $0x1,%eax
  8042106dca:	48 d3 e0             	shl    %cl,%rax
  8042106dcd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        uint64_t num = (maxm - minm) / CLASS_SIZE(i);
  8042106dd1:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042106dd5:	4c 29 fe             	sub    %r15,%rsi
        if ((maxm - minm) % CLASS_SIZE(i)) {
  8042106dd8:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8042106ddf:	48 d3 e0             	shl    %cl,%rax
  8042106de2:	48 f7 d0             	not    %rax
  8042106de5:	48 85 f0             	test   %rsi,%rax
  8042106de8:	0f 85 1f ff ff ff    	jne    8042106d0d <dump_memory_lists+0x81>
        uint64_t num = (maxm - minm) / CLASS_SIZE(i);
  8042106dee:	48 d3 ee             	shr    %cl,%rsi
  8042106df1:	49 89 f5             	mov    %rsi,%r13
        for (uint64_t j = 0; j < num; j++) {
  8042106df4:	48 85 f6             	test   %rsi,%rsi
  8042106df7:	0f 85 16 ff ff ff    	jne    8042106d13 <dump_memory_lists+0x87>
  8042106dfd:	eb b8                	jmp    8042106db7 <dump_memory_lists+0x12b>
    cprintf("physical page address: %lx - %lx\n", minn, maxn);
  8042106dff:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8042106e03:	48 89 fa             	mov    %rdi,%rdx
  8042106e06:	be 00 00 00 00       	mov    $0x0,%esi
  8042106e0b:	48 bf 68 0d 12 42 80 	movabs $0x8042120d68,%rdi
  8042106e12:	00 00 00 
  8042106e15:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106e1a:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  8042106e21:	00 00 00 
  8042106e24:	ff d1                	call   *%rcx
}
  8042106e26:	48 83 c4 28          	add    $0x28,%rsp
  8042106e2a:	5b                   	pop    %rbx
  8042106e2b:	41 5c                	pop    %r12
  8042106e2d:	41 5d                	pop    %r13
  8042106e2f:	41 5e                	pop    %r14
  8042106e31:	41 5f                	pop    %r15
  8042106e33:	5d                   	pop    %rbp
  8042106e34:	c3                   	ret

0000008042106e35 <remove_pt>:
remove_pt(pte_t *pt, pte_t base, size_t step, uintptr_t i0, uintptr_t i1) {
  8042106e35:	f3 0f 1e fa          	endbr64
  8042106e39:	55                   	push   %rbp
  8042106e3a:	48 89 e5             	mov    %rsp,%rbp
  8042106e3d:	41 57                	push   %r15
  8042106e3f:	41 56                	push   %r14
  8042106e41:	41 55                	push   %r13
  8042106e43:	41 54                	push   %r12
  8042106e45:	53                   	push   %rbx
  8042106e46:	48 83 ec 28          	sub    $0x28,%rsp
  8042106e4a:	49 89 fd             	mov    %rdi,%r13
  8042106e4d:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
  8042106e51:	49 89 d7             	mov    %rdx,%r15
  8042106e54:	48 89 cb             	mov    %rcx,%rbx
  8042106e57:	4d 89 c6             	mov    %r8,%r14
    assert(step == 1 * GB || step == 2 * MB || step == 4 * KB || step == 512 * GB);
  8042106e5a:	48 81 fa 00 00 00 40 	cmp    $0x40000000,%rdx
  8042106e61:	0f 95 c2             	setne  %dl
  8042106e64:	49 81 ff 00 00 20 00 	cmp    $0x200000,%r15
  8042106e6b:	0f 95 c0             	setne  %al
  8042106e6e:	20 c2                	and    %al,%dl
  8042106e70:	88 55 cf             	mov    %dl,-0x31(%rbp)
  8042106e73:	75 23                	jne    8042106e98 <remove_pt+0x63>
            remove_pt(pt2, base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  8042106e75:	4c 89 f8             	mov    %r15,%rax
  8042106e78:	48 c1 e8 09          	shr    $0x9,%rax
  8042106e7c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    for (size_t i = i0; i < i1; i++) {
  8042106e80:	4c 39 f3             	cmp    %r14,%rbx
  8042106e83:	0f 82 d5 00 00 00    	jb     8042106f5e <remove_pt+0x129>
}
  8042106e89:	48 83 c4 28          	add    $0x28,%rsp
  8042106e8d:	5b                   	pop    %rbx
  8042106e8e:	41 5c                	pop    %r12
  8042106e90:	41 5d                	pop    %r13
  8042106e92:	41 5e                	pop    %r14
  8042106e94:	41 5f                	pop    %r15
  8042106e96:	5d                   	pop    %rbp
  8042106e97:	c3                   	ret
    assert(step == 1 * GB || step == 2 * MB || step == 4 * KB || step == 512 * GB);
  8042106e98:	49 81 ff 00 10 00 00 	cmp    $0x1000,%r15
  8042106e9f:	74 d4                	je     8042106e75 <remove_pt+0x40>
  8042106ea1:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  8042106ea8:	00 00 00 
  8042106eab:	49 39 c7             	cmp    %rax,%r15
  8042106eae:	74 c5                	je     8042106e75 <remove_pt+0x40>
  8042106eb0:	48 b9 90 0d 12 42 80 	movabs $0x8042120d90,%rcx
  8042106eb7:	00 00 00 
  8042106eba:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106ec1:	00 00 00 
  8042106ec4:	be 0a 02 00 00       	mov    $0x20a,%esi
  8042106ec9:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106ed0:	00 00 00 
  8042106ed3:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106ed8:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106edf:	00 00 00 
  8042106ee2:	41 ff d0             	call   *%r8
        assert(!(pt[i] & PTE_PS) || (step == 1 * GB || step == 2 * MB));
  8042106ee5:	48 b9 d8 0d 12 42 80 	movabs $0x8042120dd8,%rcx
  8042106eec:	00 00 00 
  8042106eef:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042106ef6:	00 00 00 
  8042106ef9:	be 0d 02 00 00       	mov    $0x20d,%esi
  8042106efe:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106f05:	00 00 00 
  8042106f08:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106f0d:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042106f14:	00 00 00 
  8042106f17:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042106f1a:	4c 89 e1             	mov    %r12,%rcx
  8042106f1d:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042106f24:	00 00 00 
  8042106f27:	be 10 02 00 00       	mov    $0x210,%esi
  8042106f2c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042106f33:	00 00 00 
  8042106f36:	b8 00 00 00 00       	mov    $0x0,%eax
  8042106f3b:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042106f42:	00 00 00 
  8042106f45:	41 ff d1             	call   *%r9
        pt[i] = 0;
  8042106f48:	49 c7 44 dd 00 00 00 	movq   $0x0,0x0(%r13,%rbx,8)
  8042106f4f:	00 00 
    for (size_t i = i0; i < i1; i++) {
  8042106f51:	48 83 c3 01          	add    $0x1,%rbx
  8042106f55:	4c 39 f3             	cmp    %r14,%rbx
  8042106f58:	0f 83 2b ff ff ff    	jae    8042106e89 <remove_pt+0x54>
        if (!(pt[i] & PTE_P)) continue;
  8042106f5e:	4d 8b 64 dd 00       	mov    0x0(%r13,%rbx,8),%r12
  8042106f63:	41 f6 c4 01          	test   $0x1,%r12b
  8042106f67:	74 e8                	je     8042106f51 <remove_pt+0x11c>
        assert(!(pt[i] & PTE_PS) || (step == 1 * GB || step == 2 * MB));
  8042106f69:	4c 89 e0             	mov    %r12,%rax
  8042106f6c:	25 80 00 00 00       	and    $0x80,%eax
  8042106f71:	74 0a                	je     8042106f7d <remove_pt+0x148>
  8042106f73:	80 7d cf 00          	cmpb   $0x0,-0x31(%rbp)
  8042106f77:	0f 85 68 ff ff ff    	jne    8042106ee5 <remove_pt+0xb0>
        if (!(pt[i] & PTE_PS) && step > 4 * KB) {
  8042106f7d:	48 85 c0             	test   %rax,%rax
  8042106f80:	75 c6                	jne    8042106f48 <remove_pt+0x113>
  8042106f82:	49 81 ff 00 10 00 00 	cmp    $0x1000,%r15
  8042106f89:	76 bd                	jbe    8042106f48 <remove_pt+0x113>
            pte_t *pt2 = KADDR(PTE_ADDR(pt[i]));
  8042106f8b:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8042106f92:	ff ff 7f 
  8042106f95:	49 21 c4             	and    %rax,%r12
    if (pa > max_memory_map_addr)
  8042106f98:	48 b8 f8 10 00 43 80 	movabs $0x80430010f8,%rax
  8042106f9f:	00 00 00 
  8042106fa2:	4c 8b 00             	mov    (%rax),%r8
  8042106fa5:	4d 39 e0             	cmp    %r12,%r8
  8042106fa8:	0f 82 6c ff ff ff    	jb     8042106f1a <remove_pt+0xe5>
    return (void *)(pa + KERN_BASE_ADDR);
  8042106fae:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042106fb5:	00 00 00 
  8042106fb8:	49 8d 3c 04          	lea    (%r12,%rax,1),%rdi
            remove_pt(pt2, base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  8042106fbc:	41 b8 00 02 00 00    	mov    $0x200,%r8d
  8042106fc2:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042106fc7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042106fcb:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042106fcf:	48 b8 35 6e 10 42 80 	movabs $0x8042106e35,%rax
  8042106fd6:	00 00 00 
  8042106fd9:	ff d0                	call   *%rax
            page_unref(page_lookup(NULL, (uintptr_t)PADDR(pt2), 0, PARTIAL_NODE, 0));
  8042106fdb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8042106fe1:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8042106fe6:	ba 00 00 00 00       	mov    $0x0,%edx
  8042106feb:	4c 89 e6             	mov    %r12,%rsi
  8042106fee:	bf 00 00 00 00       	mov    $0x0,%edi
  8042106ff3:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  8042106ffa:	00 00 00 
  8042106ffd:	ff d0                	call   *%rax
  8042106fff:	48 89 c7             	mov    %rax,%rdi
  8042107002:	48 b8 56 49 10 42 80 	movabs $0x8042104956,%rax
  8042107009:	00 00 00 
  804210700c:	ff d0                	call   *%rax
  804210700e:	e9 35 ff ff ff       	jmp    8042106f48 <remove_pt+0x113>

0000008042107013 <propagate_one_pml4>:
propagate_one_pml4(struct AddressSpace *dst, struct AddressSpace *src) {
  8042107013:	f3 0f 1e fa          	endbr64
  8042107017:	55                   	push   %rbp
  8042107018:	48 89 e5             	mov    %rsp,%rbp
  804210701b:	41 57                	push   %r15
  804210701d:	41 56                	push   %r14
  804210701f:	41 55                	push   %r13
  8042107021:	41 54                	push   %r12
  8042107023:	53                   	push   %rbx
  8042107024:	48 83 ec 08          	sub    $0x8,%rsp
  8042107028:	49 89 fc             	mov    %rdi,%r12
  804210702b:	49 89 f5             	mov    %rsi,%r13
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  804210702e:	bb 01 00 00 00       	mov    $0x1,%ebx
            page_ref(page_lookup(NULL, PTE_ADDR(src->pml4[i]), 0, PARTIAL_NODE, 0));
  8042107033:	49 bf d7 67 10 42 80 	movabs $0x80421067d7,%r15
  804210703a:	00 00 00 
  804210703d:	49 be 72 48 10 42 80 	movabs $0x8042104872,%r14
  8042107044:	00 00 00 
  8042107047:	eb 38                	jmp    8042107081 <propagate_one_pml4+0x6e>
  8042107049:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8042107050:	ff ff 7f 
  8042107053:	48 21 c6             	and    %rax,%rsi
  8042107056:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  804210705c:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8042107061:	ba 00 00 00 00       	mov    $0x0,%edx
  8042107066:	bf 00 00 00 00       	mov    $0x0,%edi
  804210706b:	41 ff d7             	call   *%r15
  804210706e:	48 89 c7             	mov    %rax,%rdi
  8042107071:	41 ff d6             	call   *%r14
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  8042107074:	48 83 c3 01          	add    $0x1,%rbx
  8042107078:	48 81 fb 00 02 00 00 	cmp    $0x200,%rbx
  804210707f:	74 19                	je     804210709a <propagate_one_pml4+0x87>
        if (src->pml4[i] & PTE_P && i != PML4_INDEX(UVPT))
  8042107081:	49 8b 45 00          	mov    0x0(%r13),%rax
  8042107085:	48 8b 34 d8          	mov    (%rax,%rbx,8),%rsi
  8042107089:	40 f6 c6 01          	test   $0x1,%sil
  804210708d:	74 e5                	je     8042107074 <propagate_one_pml4+0x61>
  804210708f:	48 81 fb ff 00 00 00 	cmp    $0xff,%rbx
  8042107096:	74 dc                	je     8042107074 <propagate_one_pml4+0x61>
  8042107098:	eb af                	jmp    8042107049 <propagate_one_pml4+0x36>
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  804210709a:	bb 01 00 00 00       	mov    $0x1,%ebx
            page_unref(page_lookup(NULL, PTE_ADDR(dst->pml4[i]), 0, PARTIAL_NODE, 0));
  804210709f:	49 bf d7 67 10 42 80 	movabs $0x80421067d7,%r15
  80421070a6:	00 00 00 
  80421070a9:	49 be 56 49 10 42 80 	movabs $0x8042104956,%r14
  80421070b0:	00 00 00 
  80421070b3:	eb 38                	jmp    80421070ed <propagate_one_pml4+0xda>
  80421070b5:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  80421070bc:	ff ff 7f 
  80421070bf:	48 21 c6             	and    %rax,%rsi
  80421070c2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80421070c8:	b9 00 00 30 00       	mov    $0x300000,%ecx
  80421070cd:	ba 00 00 00 00       	mov    $0x0,%edx
  80421070d2:	bf 00 00 00 00       	mov    $0x0,%edi
  80421070d7:	41 ff d7             	call   *%r15
  80421070da:	48 89 c7             	mov    %rax,%rdi
  80421070dd:	41 ff d6             	call   *%r14
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  80421070e0:	48 83 c3 01          	add    $0x1,%rbx
  80421070e4:	48 81 fb 00 02 00 00 	cmp    $0x200,%rbx
  80421070eb:	74 19                	je     8042107106 <propagate_one_pml4+0xf3>
        if (dst->pml4[i] & PTE_P && i != PML4_INDEX(UVPT))
  80421070ed:	49 8b 04 24          	mov    (%r12),%rax
  80421070f1:	48 8b 34 d8          	mov    (%rax,%rbx,8),%rsi
  80421070f5:	40 f6 c6 01          	test   $0x1,%sil
  80421070f9:	74 e5                	je     80421070e0 <propagate_one_pml4+0xcd>
  80421070fb:	48 81 fb ff 00 00 00 	cmp    $0xff,%rbx
  8042107102:	74 dc                	je     80421070e0 <propagate_one_pml4+0xcd>
  8042107104:	eb af                	jmp    80421070b5 <propagate_one_pml4+0xa2>
    pte_t uvpt = dst->pml4[PML4_INDEX(UVPT)];
  8042107106:	49 8b 04 24          	mov    (%r12),%rax
  804210710a:	48 8b 98 f8 07 00 00 	mov    0x7f8(%rax),%rbx
    memcpy(dst->pml4 + NUSERPML4, src->pml4 + NUSERPML4,
  8042107111:	49 8b 75 00          	mov    0x0(%r13),%rsi
  8042107115:	48 83 c6 08          	add    $0x8,%rsi
  8042107119:	48 8d 78 08          	lea    0x8(%rax),%rdi
  804210711d:	ba f8 0f 00 00       	mov    $0xff8,%edx
  8042107122:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042107129:	00 00 00 
  804210712c:	ff d0                	call   *%rax
    dst->pml4[PML4_INDEX(UVPT)] = uvpt;
  804210712e:	49 8b 04 24          	mov    (%r12),%rax
  8042107132:	48 89 98 f8 07 00 00 	mov    %rbx,0x7f8(%rax)
}
  8042107139:	48 83 c4 08          	add    $0x8,%rsp
  804210713d:	5b                   	pop    %rbx
  804210713e:	41 5c                	pop    %r12
  8042107140:	41 5d                	pop    %r13
  8042107142:	41 5e                	pop    %r14
  8042107144:	41 5f                	pop    %r15
  8042107146:	5d                   	pop    %rbp
  8042107147:	c3                   	ret

0000008042107148 <propagate_pml4>:
propagate_pml4(struct AddressSpace *spc) {
  8042107148:	f3 0f 1e fa          	endbr64
    if (!current_space) return;
  804210714c:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  8042107153:	00 00 00 
  8042107156:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210715a:	0f 84 87 00 00 00    	je     80421071e7 <propagate_pml4+0x9f>
propagate_pml4(struct AddressSpace *spc) {
  8042107160:	55                   	push   %rbp
  8042107161:	48 89 e5             	mov    %rsp,%rbp
  8042107164:	41 56                	push   %r14
  8042107166:	41 55                	push   %r13
  8042107168:	41 54                	push   %r12
  804210716a:	53                   	push   %rbx
  804210716b:	49 89 fd             	mov    %rdi,%r13
    if (spc != &kspace) propagate_one_pml4(&kspace, spc);
  804210716e:	48 b8 e0 10 00 43 80 	movabs $0x80430010e0,%rax
  8042107175:	00 00 00 
  8042107178:	48 39 c7             	cmp    %rax,%rdi
  804210717b:	74 12                	je     804210718f <propagate_pml4+0x47>
  804210717d:	48 89 fe             	mov    %rdi,%rsi
  8042107180:	48 89 c7             	mov    %rax,%rdi
  8042107183:	48 b8 13 70 10 42 80 	movabs $0x8042107013,%rax
  804210718a:	00 00 00 
  804210718d:	ff d0                	call   *%rax
propagate_pml4(struct AddressSpace *spc) {
  804210718f:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (envs[i].env_status != ENV_FREE && &envs[i].address_space != spc)
  8042107194:	49 bc 68 64 00 43 80 	movabs $0x8043006468,%r12
  804210719b:	00 00 00 
            propagate_one_pml4(&envs[i].address_space, spc);
  804210719e:	49 be 13 70 10 42 80 	movabs $0x8042107013,%r14
  80421071a5:	00 00 00 
  80421071a8:	eb 10                	jmp    80421071ba <propagate_pml4+0x72>
    for (size_t i = 0; i < NENV; i++) {
  80421071aa:	48 81 c3 30 01 00 00 	add    $0x130,%rbx
  80421071b1:	48 81 fb 00 c0 04 00 	cmp    $0x4c000,%rbx
  80421071b8:	74 24                	je     80421071de <propagate_pml4+0x96>
        if (envs[i].env_status != ENV_FREE && &envs[i].address_space != spc)
  80421071ba:	48 89 df             	mov    %rbx,%rdi
  80421071bd:	49 03 3c 24          	add    (%r12),%rdi
  80421071c1:	83 bf d4 00 00 00 00 	cmpl   $0x0,0xd4(%rdi)
  80421071c8:	74 e0                	je     80421071aa <propagate_pml4+0x62>
  80421071ca:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
  80421071d1:	4c 39 ef             	cmp    %r13,%rdi
  80421071d4:	74 d4                	je     80421071aa <propagate_pml4+0x62>
            propagate_one_pml4(&envs[i].address_space, spc);
  80421071d6:	4c 89 ee             	mov    %r13,%rsi
  80421071d9:	41 ff d6             	call   *%r14
  80421071dc:	eb cc                	jmp    80421071aa <propagate_pml4+0x62>
}
  80421071de:	5b                   	pop    %rbx
  80421071df:	41 5c                	pop    %r12
  80421071e1:	41 5d                	pop    %r13
  80421071e3:	41 5e                	pop    %r14
  80421071e5:	5d                   	pop    %rbp
  80421071e6:	c3                   	ret
  80421071e7:	c3                   	ret

00000080421071e8 <attach_region>:
attach_region(uintptr_t start, uintptr_t end, enum PageState type) {
  80421071e8:	f3 0f 1e fa          	endbr64
  80421071ec:	55                   	push   %rbp
  80421071ed:	48 89 e5             	mov    %rsp,%rbp
  80421071f0:	41 57                	push   %r15
  80421071f2:	41 56                	push   %r14
  80421071f4:	41 55                	push   %r13
  80421071f6:	41 54                	push   %r12
  80421071f8:	53                   	push   %rbx
  80421071f9:	48 83 ec 18          	sub    $0x18,%rsp
  80421071fd:	89 55 cc             	mov    %edx,-0x34(%rbp)
    start = ROUNDDOWN(start, CLASS_SIZE(0));
  8042107200:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
    end = ROUNDUP(end, CLASS_SIZE(0));
  8042107207:	48 81 c6 ff 0f 00 00 	add    $0xfff,%rsi
  804210720e:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
  8042107215:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    while (iter < end) {
  8042107219:	48 39 f7             	cmp    %rsi,%rdi
  804210721c:	0f 83 c9 00 00 00    	jae    80421072eb <attach_region+0x103>
  8042107222:	49 89 fd             	mov    %rdi,%r13
    int i, new_class = -1;
  8042107225:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
        while (!(iter & CLASS_MASK(new_class + 1)) && size >= CLASS_SIZE(new_class + 1)) {
  804210722b:	41 be 01 00 00 00    	mov    $0x1,%r14d
            if (page_lookup(NULL, iter, i, type, 1)) {
  8042107231:	49 bf d7 67 10 42 80 	movabs $0x80421067d7,%r15
  8042107238:	00 00 00 
  804210723b:	eb 24                	jmp    8042107261 <attach_region+0x79>
                new_class = i;
  804210723d:	41 89 dc             	mov    %ebx,%r12d
        iter += CLASS_SIZE(new_class);
  8042107240:	41 8d 4c 24 0c       	lea    0xc(%r12),%ecx
  8042107245:	4c 89 f0             	mov    %r14,%rax
  8042107248:	48 d3 e0             	shl    %cl,%rax
  804210724b:	49 01 c5             	add    %rax,%r13
    while (iter < end) {
  804210724e:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  8042107254:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042107258:	49 39 c5             	cmp    %rax,%r13
  804210725b:	0f 83 8a 00 00 00    	jae    80421072eb <attach_region+0x103>
        uintptr_t size = end - iter;
  8042107261:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042107265:	4c 29 ea             	sub    %r13,%rdx
        while (!(iter & CLASS_MASK(new_class + 1)) && size >= CLASS_SIZE(new_class + 1)) {
  8042107268:	41 8d 4c 24 0d       	lea    0xd(%r12),%ecx
  804210726d:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8042107274:	48 d3 e0             	shl    %cl,%rax
  8042107277:	48 f7 d0             	not    %rax
  804210727a:	4c 85 e8             	test   %r13,%rax
  804210727d:	75 32                	jne    80421072b1 <attach_region+0xc9>
  804210727f:	4c 89 f0             	mov    %r14,%rax
  8042107282:	48 d3 e0             	shl    %cl,%rax
  8042107285:	48 39 c2             	cmp    %rax,%rdx
  8042107288:	72 27                	jb     80421072b1 <attach_region+0xc9>
            new_class++;
  804210728a:	44 89 e1             	mov    %r12d,%ecx
  804210728d:	41 83 c4 01          	add    $0x1,%r12d
        while (!(iter & CLASS_MASK(new_class + 1)) && size >= CLASS_SIZE(new_class + 1)) {
  8042107291:	83 c1 0e             	add    $0xe,%ecx
  8042107294:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  804210729b:	48 d3 e0             	shl    %cl,%rax
  804210729e:	48 f7 d0             	not    %rax
  80421072a1:	4c 85 e8             	test   %r13,%rax
  80421072a4:	75 0b                	jne    80421072b1 <attach_region+0xc9>
  80421072a6:	4c 89 f0             	mov    %r14,%rax
  80421072a9:	48 d3 e0             	shl    %cl,%rax
  80421072ac:	48 39 c2             	cmp    %rax,%rdx
  80421072af:	73 d9                	jae    804210728a <attach_region+0xa2>
        if (new_class == -1) {
  80421072b1:	41 83 fc ff          	cmp    $0xffffffff,%r12d
  80421072b5:	74 34                	je     80421072eb <attach_region+0x103>
        for (i = new_class; i >= 0; i--) {
  80421072b7:	45 85 e4             	test   %r12d,%r12d
  80421072ba:	78 84                	js     8042107240 <attach_region+0x58>
  80421072bc:	44 89 e3             	mov    %r12d,%ebx
            if (page_lookup(NULL, iter, i, type, 1)) {
  80421072bf:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80421072c5:	8b 4d cc             	mov    -0x34(%rbp),%ecx
  80421072c8:	89 da                	mov    %ebx,%edx
  80421072ca:	4c 89 ee             	mov    %r13,%rsi
  80421072cd:	bf 00 00 00 00       	mov    $0x0,%edi
  80421072d2:	41 ff d7             	call   *%r15
  80421072d5:	48 85 c0             	test   %rax,%rax
  80421072d8:	0f 85 5f ff ff ff    	jne    804210723d <attach_region+0x55>
        for (i = new_class; i >= 0; i--) {
  80421072de:	83 eb 01             	sub    $0x1,%ebx
  80421072e1:	83 fb ff             	cmp    $0xffffffff,%ebx
  80421072e4:	75 d9                	jne    80421072bf <attach_region+0xd7>
  80421072e6:	e9 55 ff ff ff       	jmp    8042107240 <attach_region+0x58>
}
  80421072eb:	48 83 c4 18          	add    $0x18,%rsp
  80421072ef:	5b                   	pop    %rbx
  80421072f0:	41 5c                	pop    %r12
  80421072f2:	41 5d                	pop    %r13
  80421072f4:	41 5e                	pop    %r14
  80421072f6:	41 5f                	pop    %r15
  80421072f8:	5d                   	pop    %rbp
  80421072f9:	c3                   	ret

00000080421072fa <page_lookup_virtual>:
page_lookup_virtual(struct Page *node, uintptr_t addr, int class, int alloc) {
  80421072fa:	f3 0f 1e fa          	endbr64
  80421072fe:	55                   	push   %rbp
  80421072ff:	48 89 e5             	mov    %rsp,%rbp
  8042107302:	41 57                	push   %r15
  8042107304:	41 56                	push   %r14
  8042107306:	41 55                	push   %r13
  8042107308:	41 54                	push   %r12
  804210730a:	53                   	push   %rbx
  804210730b:	48 83 ec 18          	sub    $0x18,%rsp
  804210730f:	89 4d cc             	mov    %ecx,-0x34(%rbp)
    assert(class >= 0);
  8042107312:	85 d2                	test   %edx,%edx
  8042107314:	78 31                	js     8042107347 <page_lookup_virtual+0x4d>
  8042107316:	48 89 fb             	mov    %rdi,%rbx
  8042107319:	49 89 f7             	mov    %rsi,%r15
    assert_virtual(node);
  804210731c:	8b 47 28             	mov    0x28(%rdi),%eax
  804210731f:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042107324:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8042107329:	77 59                	ja     8042107384 <page_lookup_virtual+0x8a>
    while (nclass > class) {
  804210732b:	83 fa 2f             	cmp    $0x2f,%edx
  804210732e:	7f 4c                	jg     804210737c <page_lookup_virtual+0x82>
  8042107330:	41 bc 31 00 00 00    	mov    $0x31,%r12d
  8042107336:	41 29 d4             	sub    %edx,%r12d
  8042107339:	45 01 e4             	add    %r12d,%r12d
    int nclass = MAX_CLASS;
  804210733c:	41 bd 30 00 00 00    	mov    $0x30,%r13d
  8042107342:	e9 94 00 00 00       	jmp    80421073db <page_lookup_virtual+0xe1>
    assert(class >= 0);
  8042107347:	48 b9 be f7 11 42 80 	movabs $0x804211f7be,%rcx
  804210734e:	00 00 00 
  8042107351:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107358:	00 00 00 
  804210735b:	be 98 01 00 00       	mov    $0x198,%esi
  8042107360:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107367:	00 00 00 
  804210736a:	b8 00 00 00 00       	mov    $0x0,%eax
  804210736f:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107376:	00 00 00 
  8042107379:	41 ff d0             	call   *%r8
    return node;
  804210737c:	48 89 f8             	mov    %rdi,%rax
  804210737f:	e9 db 02 00 00       	jmp    804210765f <page_lookup_virtual+0x365>
    assert_virtual(node);
  8042107384:	48 b9 38 07 12 42 80 	movabs $0x8042120738,%rcx
  804210738b:	00 00 00 
  804210738e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107395:	00 00 00 
  8042107398:	be 99 01 00 00       	mov    $0x199,%esi
  804210739d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421073a4:	00 00 00 
  80421073a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80421073ac:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421073b3:	00 00 00 
  80421073b6:	41 ff d0             	call   *%r8
        struct Page **next = right ? &node->right : &node->left;
  80421073b9:	4c 8d 73 10          	lea    0x10(%rbx),%r14
  80421073bd:	48 8b 43 10          	mov    0x10(%rbx),%rax
        if (!*next) {
  80421073c1:	48 85 c0             	test   %rax,%rax
  80421073c4:	74 30                	je     80421073f6 <page_lookup_virtual+0xfc>
        node = *next;
  80421073c6:	49 8b 1e             	mov    (%r14),%rbx
        nclass--;
  80421073c9:	41 83 ed 01          	sub    $0x1,%r13d
    while (nclass > class) {
  80421073cd:	41 83 ec 02          	sub    $0x2,%r12d
  80421073d1:	41 83 fc 02          	cmp    $0x2,%r12d
  80421073d5:	0f 84 81 02 00 00    	je     804210765c <page_lookup_virtual+0x362>
        bool right = addr & CLASS_SIZE(nclass - 1);
  80421073db:	41 8d 4d 0b          	lea    0xb(%r13),%ecx
  80421073df:	b8 01 00 00 00       	mov    $0x1,%eax
  80421073e4:	48 d3 e0             	shl    %cl,%rax
        struct Page **next = right ? &node->right : &node->left;
  80421073e7:	4c 85 f8             	test   %r15,%rax
  80421073ea:	74 cd                	je     80421073b9 <page_lookup_virtual+0xbf>
  80421073ec:	4c 8d 73 18          	lea    0x18(%rbx),%r14
  80421073f0:	48 8b 43 18          	mov    0x18(%rbx),%rax
  80421073f4:	eb cb                	jmp    80421073c1 <page_lookup_virtual+0xc7>
            if (!alloc) break;
  80421073f6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80421073f9:	85 c0                	test   %eax,%eax
  80421073fb:	0f 84 6d 02 00 00    	je     804210766e <page_lookup_virtual+0x374>
            if (!node->phy && alloc == LOOKUP_SPLIT) break;
  8042107401:	48 83 7b 30 00       	cmpq   $0x0,0x30(%rbx)
  8042107406:	75 09                	jne    8042107411 <page_lookup_virtual+0x117>
  8042107408:	83 f8 02             	cmp    $0x2,%eax
  804210740b:	0f 84 62 02 00 00    	je     8042107673 <page_lookup_virtual+0x379>
            ensure_free_desc((nclass - class + 1) * 2);
  8042107411:	49 63 fc             	movslq %r12d,%rdi
  8042107414:	48 b8 10 64 10 42 80 	movabs $0x8042106410,%rax
  804210741b:	00 00 00 
  804210741e:	ff d0                	call   *%rax
            if (node->phy) {
  8042107420:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
  8042107424:	48 85 ff             	test   %rdi,%rdi
  8042107427:	0f 84 d4 01 00 00    	je     8042107601 <page_lookup_virtual+0x307>
                assert(nclass == node->phy->class);
  804210742d:	0f b7 57 34          	movzwl 0x34(%rdi),%edx
  8042107431:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  8042107437:	44 39 ea             	cmp    %r13d,%edx
  804210743a:	0f 85 22 01 00 00    	jne    8042107562 <page_lookup_virtual+0x268>
                assert((node->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8042107440:	8b 43 28             	mov    0x28(%rbx),%eax
  8042107443:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042107448:	3d 00 00 10 00       	cmp    $0x100000,%eax
  804210744d:	0f 85 44 01 00 00    	jne    8042107597 <page_lookup_virtual+0x29d>
                struct Page *pleft = page_lookup(node->phy, page2pa(node->phy), node->phy->class - 1, PARTIAL_NODE, 1);
  8042107453:	83 ea 01             	sub    $0x1,%edx
    return page->addr << CLASS_BASE;
  8042107456:	48 be ff ff ff ff ff 	movabs $0xfffffffffffff,%rsi
  804210745d:	ff 0f 00 
  8042107460:	48 23 77 38          	and    0x38(%rdi),%rsi
  8042107464:	48 c1 e6 0c          	shl    $0xc,%rsi
  8042107468:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804210746f:	ff 0f 00 
  8042107472:	48 21 c6             	and    %rax,%rsi
  8042107475:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804210747b:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8042107480:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  8042107487:	00 00 00 
  804210748a:	ff d0                	call   *%rax
                if (!pleft) return NULL;
  804210748c:	48 85 c0             	test   %rax,%rax
  804210748f:	0f 84 ca 01 00 00    	je     804210765f <page_lookup_virtual+0x365>
                assert(node->phy->left && node->phy->right);
  8042107495:	48 8b 43 30          	mov    0x30(%rbx),%rax
  8042107499:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  804210749e:	0f 84 28 01 00 00    	je     80421075cc <page_lookup_virtual+0x2d2>
  80421074a4:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  80421074a9:	0f 84 1d 01 00 00    	je     80421075cc <page_lookup_virtual+0x2d2>
                alloc_virtual_child(node, &node->left);
  80421074af:	48 8d 73 10          	lea    0x10(%rbx),%rsi
  80421074b3:	48 89 df             	mov    %rbx,%rdi
  80421074b6:	48 b8 82 65 10 42 80 	movabs $0x8042106582,%rax
  80421074bd:	00 00 00 
  80421074c0:	ff d0                	call   *%rax
                if (!node->left) return NULL;
  80421074c2:	48 8b 43 10          	mov    0x10(%rbx),%rax
  80421074c6:	48 85 c0             	test   %rax,%rax
  80421074c9:	0f 84 90 01 00 00    	je     804210765f <page_lookup_virtual+0x365>
                alloc_virtual_child(node, &node->right);
  80421074cf:	48 8d 73 18          	lea    0x18(%rbx),%rsi
  80421074d3:	48 89 df             	mov    %rbx,%rdi
  80421074d6:	48 b8 82 65 10 42 80 	movabs $0x8042106582,%rax
  80421074dd:	00 00 00 
  80421074e0:	ff d0                	call   *%rax
                if (!node->right) return NULL;
  80421074e2:	48 8b 43 18          	mov    0x18(%rbx),%rax
  80421074e6:	48 85 c0             	test   %rax,%rax
  80421074e9:	0f 84 70 01 00 00    	je     804210765f <page_lookup_virtual+0x365>
    struct List *list_prev = list->prev;
  80421074ef:	48 8b 13             	mov    (%rbx),%rdx
    struct List *list_next = list->next;
  80421074f2:	48 8b 43 08          	mov    0x8(%rbx),%rax
    list_prev->next = list_next;
  80421074f6:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list_next->prev = list_prev;
  80421074fa:	48 89 10             	mov    %rdx,(%rax)
    list->next = list->prev = list;
  80421074fd:	48 89 1b             	mov    %rbx,(%rbx)
  8042107500:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
                page_unref(node->phy);
  8042107504:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
  8042107508:	48 b8 56 49 10 42 80 	movabs $0x8042104956,%rax
  804210750f:	00 00 00 
  8042107512:	ff d0                	call   *%rax
                node->phy = NULL;
  8042107514:	48 c7 43 30 00 00 00 	movq   $0x0,0x30(%rbx)
  804210751b:	00 
                node->state = INTERMEDIATE_NODE;
  804210751c:	c7 43 28 00 00 20 00 	movl   $0x200000,0x28(%rbx)
            assert(*next);
  8042107523:	49 83 3e 00          	cmpq   $0x0,(%r14)
  8042107527:	0f 85 99 fe ff ff    	jne    80421073c6 <page_lookup_virtual+0xcc>
  804210752d:	48 b9 d4 f8 11 42 80 	movabs $0x804211f8d4,%rcx
  8042107534:	00 00 00 
  8042107537:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210753e:	00 00 00 
  8042107541:	be c1 01 00 00       	mov    $0x1c1,%esi
  8042107546:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210754d:	00 00 00 
  8042107550:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107555:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210755c:	00 00 00 
  804210755f:	41 ff d0             	call   *%r8
                assert(nclass == node->phy->class);
  8042107562:	48 b9 b9 f8 11 42 80 	movabs $0x804211f8b9,%rcx
  8042107569:	00 00 00 
  804210756c:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107573:	00 00 00 
  8042107576:	be ab 01 00 00       	mov    $0x1ab,%esi
  804210757b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107582:	00 00 00 
  8042107585:	b8 00 00 00 00       	mov    $0x0,%eax
  804210758a:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107591:	00 00 00 
  8042107594:	41 ff d0             	call   *%r8
                assert((node->state & NODE_TYPE_MASK) == MAPPING_NODE);
  8042107597:	48 b9 68 07 12 42 80 	movabs $0x8042120768,%rcx
  804210759e:	00 00 00 
  80421075a1:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421075a8:	00 00 00 
  80421075ab:	be ac 01 00 00       	mov    $0x1ac,%esi
  80421075b0:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421075b7:	00 00 00 
  80421075ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80421075bf:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421075c6:	00 00 00 
  80421075c9:	41 ff d0             	call   *%r8
                assert(node->phy->left && node->phy->right);
  80421075cc:	48 b9 10 0e 12 42 80 	movabs $0x8042120e10,%rcx
  80421075d3:	00 00 00 
  80421075d6:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421075dd:	00 00 00 
  80421075e0:	be b1 01 00 00       	mov    $0x1b1,%esi
  80421075e5:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421075ec:	00 00 00 
  80421075ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80421075f4:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421075fb:	00 00 00 
  80421075fe:	41 ff d0             	call   *%r8
                assert(node->state == INTERMEDIATE_NODE);
  8042107601:	81 7b 28 00 00 20 00 	cmpl   $0x200000,0x28(%rbx)
  8042107608:	75 1d                	jne    8042107627 <page_lookup_virtual+0x32d>
                *next = alloc_descriptor(INTERMEDIATE_NODE);
  804210760a:	bf 00 00 20 00       	mov    $0x200000,%edi
  804210760f:	48 b8 02 65 10 42 80 	movabs $0x8042106502,%rax
  8042107616:	00 00 00 
  8042107619:	ff d0                	call   *%rax
  804210761b:	49 89 06             	mov    %rax,(%r14)
                (*next)->parent = node;
  804210761e:	48 89 58 20          	mov    %rbx,0x20(%rax)
  8042107622:	e9 fc fe ff ff       	jmp    8042107523 <page_lookup_virtual+0x229>
                assert(node->state == INTERMEDIATE_NODE);
  8042107627:	48 b9 38 0e 12 42 80 	movabs $0x8042120e38,%rcx
  804210762e:	00 00 00 
  8042107631:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107638:	00 00 00 
  804210763b:	be bd 01 00 00       	mov    $0x1bd,%esi
  8042107640:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107647:	00 00 00 
  804210764a:	b8 00 00 00 00       	mov    $0x0,%eax
  804210764f:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107656:	00 00 00 
  8042107659:	41 ff d0             	call   *%r8
    return node;
  804210765c:	48 89 d8             	mov    %rbx,%rax
}
  804210765f:	48 83 c4 18          	add    $0x18,%rsp
  8042107663:	5b                   	pop    %rbx
  8042107664:	41 5c                	pop    %r12
  8042107666:	41 5d                	pop    %r13
  8042107668:	41 5e                	pop    %r14
  804210766a:	41 5f                	pop    %r15
  804210766c:	5d                   	pop    %rbp
  804210766d:	c3                   	ret
    return node;
  804210766e:	48 89 d8             	mov    %rbx,%rax
  8042107671:	eb ec                	jmp    804210765f <page_lookup_virtual+0x365>
  8042107673:	48 89 d8             	mov    %rbx,%rax
  8042107676:	eb e7                	jmp    804210765f <page_lookup_virtual+0x365>

0000008042107678 <region_maxref>:
region_maxref(struct AddressSpace *spc, uintptr_t addr, size_t size) {
  8042107678:	f3 0f 1e fa          	endbr64
  804210767c:	55                   	push   %rbp
  804210767d:	48 89 e5             	mov    %rsp,%rbp
  8042107680:	41 57                	push   %r15
  8042107682:	41 56                	push   %r14
  8042107684:	41 55                	push   %r13
  8042107686:	41 54                	push   %r12
  8042107688:	53                   	push   %rbx
  8042107689:	48 83 ec 08          	sub    $0x8,%rsp
    uintptr_t start = ROUNDDOWN(addr, PAGE_SIZE);
  804210768d:	48 89 f3             	mov    %rsi,%rbx
  8042107690:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
    uintptr_t end = ROUNDUP(addr + size, PAGE_SIZE);
  8042107697:	4c 8d ac 16 ff 0f 00 	lea    0xfff(%rsi,%rdx,1),%r13
  804210769e:	00 
  804210769f:	49 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%r13
    while (start < end) {
  80421076a6:	4c 39 eb             	cmp    %r13,%rbx
  80421076a9:	0f 83 82 00 00 00    	jae    8042107731 <region_maxref+0xb9>
  80421076af:	49 89 fe             	mov    %rdi,%r14
    int res = 0;
  80421076b2:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        struct Page *page = page_lookup_virtual(spc->root, start, 0, LOOKUP_PRESERVE);
  80421076b8:	49 bf fa 72 10 42 80 	movabs $0x80421072fa,%r15
  80421076bf:	00 00 00 
  80421076c2:	eb 19                	jmp    80421076dd <region_maxref+0x65>
            res = MAX(res, page->phy->refc + (page->phy->left || page->phy->right));
  80421076c4:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
  80421076c9:	0f 95 c2             	setne  %dl
  80421076cc:	0f b6 d2             	movzbl %dl,%edx
  80421076cf:	eb 3d                	jmp    804210770e <region_maxref+0x96>
            start += CLASS_SIZE(0);
  80421076d1:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
    while (start < end) {
  80421076d8:	4c 39 eb             	cmp    %r13,%rbx
  80421076db:	73 5a                	jae    8042107737 <region_maxref+0xbf>
        struct Page *page = page_lookup_virtual(spc->root, start, 0, LOOKUP_PRESERVE);
  80421076dd:	49 8b 7e 10          	mov    0x10(%r14),%rdi
  80421076e1:	b9 00 00 00 00       	mov    $0x0,%ecx
  80421076e6:	ba 00 00 00 00       	mov    $0x0,%edx
  80421076eb:	48 89 de             	mov    %rbx,%rsi
  80421076ee:	41 ff d7             	call   *%r15
        if (page && page->phy) {
  80421076f1:	48 85 c0             	test   %rax,%rax
  80421076f4:	74 db                	je     80421076d1 <region_maxref+0x59>
  80421076f6:	48 8b 40 30          	mov    0x30(%rax),%rax
  80421076fa:	48 85 c0             	test   %rax,%rax
  80421076fd:	74 d2                	je     80421076d1 <region_maxref+0x59>
            res = MAX(res, page->phy->refc + (page->phy->left || page->phy->right));
  80421076ff:	8b 48 30             	mov    0x30(%rax),%ecx
  8042107702:	ba 01 00 00 00       	mov    $0x1,%edx
  8042107707:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  804210770c:	74 b6                	je     80421076c4 <region_maxref+0x4c>
  804210770e:	01 ca                	add    %ecx,%edx
  8042107710:	44 39 e2             	cmp    %r12d,%edx
  8042107713:	44 0f 43 e2          	cmovae %edx,%r12d
            start += CLASS_SIZE(page->phy->class);
  8042107717:	0f b7 48 34          	movzwl 0x34(%rax),%ecx
  804210771b:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042107721:	83 c1 0c             	add    $0xc,%ecx
  8042107724:	b8 01 00 00 00       	mov    $0x1,%eax
  8042107729:	48 d3 e0             	shl    %cl,%rax
  804210772c:	48 01 c3             	add    %rax,%rbx
  804210772f:	eb a7                	jmp    80421076d8 <region_maxref+0x60>
    int res = 0;
  8042107731:	41 bc 00 00 00 00    	mov    $0x0,%r12d
}
  8042107737:	44 89 e0             	mov    %r12d,%eax
  804210773a:	48 83 c4 08          	add    $0x8,%rsp
  804210773e:	5b                   	pop    %rbx
  804210773f:	41 5c                	pop    %r12
  8042107741:	41 5d                	pop    %r13
  8042107743:	41 5e                	pop    %r14
  8042107745:	41 5f                	pop    %r15
  8042107747:	5d                   	pop    %rbp
  8042107748:	c3                   	ret

0000008042107749 <user_mem_check>:
user_mem_check(struct Env *env, const void *va, size_t len, int perm) {
  8042107749:	f3 0f 1e fa          	endbr64
  804210774d:	55                   	push   %rbp
  804210774e:	48 89 e5             	mov    %rsp,%rbp
  8042107751:	41 57                	push   %r15
  8042107753:	41 56                	push   %r14
  8042107755:	41 55                	push   %r13
  8042107757:	41 54                	push   %r12
  8042107759:	53                   	push   %rbx
  804210775a:	48 83 ec 18          	sub    $0x18,%rsp
  804210775e:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    const void *c = (void *)ROUNDDOWN(va, PAGE_SIZE);
  8042107762:	48 89 f3             	mov    %rsi,%rbx
  8042107765:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
    const void *e = va + len;
  804210776c:	4c 8d 24 16          	lea    (%rsi,%rdx,1),%r12
    struct Page *user_root = env->address_space.root;
  8042107770:	4c 8b b7 f8 00 00 00 	mov    0xf8(%rdi),%r14
    while (c < e) {
  8042107777:	4c 39 e3             	cmp    %r12,%rbx
  804210777a:	73 57                	jae    80421077d3 <user_mem_check+0x8a>
  804210777c:	41 89 cd             	mov    %ecx,%r13d
        struct Page *page = page_lookup_virtual(user_root, (uintptr_t)c, 0, 0);
  804210777f:	49 bf fa 72 10 42 80 	movabs $0x80421072fa,%r15
  8042107786:	00 00 00 
  8042107789:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210778e:	ba 00 00 00 00       	mov    $0x0,%edx
  8042107793:	48 89 de             	mov    %rbx,%rsi
  8042107796:	4c 89 f7             	mov    %r14,%rdi
  8042107799:	41 ff d7             	call   *%r15
        if (!page || !page->phy || (page->state & (perm & PROT_RWX)) != (perm & PROT_RWX)) {
  804210779c:	48 85 c0             	test   %rax,%rax
  804210779f:	74 48                	je     80421077e9 <user_mem_check+0xa0>
  80421077a1:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80421077a5:	48 85 d2             	test   %rdx,%rdx
  80421077a8:	74 3f                	je     80421077e9 <user_mem_check+0xa0>
  80421077aa:	8b 40 28             	mov    0x28(%rax),%eax
  80421077ad:	f7 d0                	not    %eax
  80421077af:	44 21 e8             	and    %r13d,%eax
  80421077b2:	a8 07                	test   $0x7,%al
  80421077b4:	75 33                	jne    80421077e9 <user_mem_check+0xa0>
        c += CLASS_SIZE(page->phy->class);
  80421077b6:	0f b7 4a 34          	movzwl 0x34(%rdx),%ecx
  80421077ba:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  80421077c0:	83 c1 0c             	add    $0xc,%ecx
  80421077c3:	b8 01 00 00 00       	mov    $0x1,%eax
  80421077c8:	48 d3 e0             	shl    %cl,%rax
  80421077cb:	48 01 c3             	add    %rax,%rbx
    while (c < e) {
  80421077ce:	4c 39 e3             	cmp    %r12,%rbx
  80421077d1:	72 b6                	jb     8042107789 <user_mem_check+0x40>
    if ((uintptr_t)e > MAX_USER_READABLE) {
  80421077d3:	48 b8 00 00 c0 1f 80 	movabs $0x801fc00000,%rax
  80421077da:	00 00 00 
  80421077dd:	4c 39 e0             	cmp    %r12,%rax
  80421077e0:	72 30                	jb     8042107812 <user_mem_check+0xc9>
    return 0;
  80421077e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80421077e7:	eb 1a                	jmp    8042107803 <user_mem_check+0xba>
            user_mem_check_addr = (uintptr_t)(MAX(va, c));
  80421077e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421077ed:	48 39 d8             	cmp    %rbx,%rax
  80421077f0:	48 0f 42 c3          	cmovb  %rbx,%rax
  80421077f4:	48 a3 08 61 00 43 80 	movabs %rax,0x8043006108
  80421077fb:	00 00 00 
            return -E_FAULT;
  80421077fe:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
}
  8042107803:	48 83 c4 18          	add    $0x18,%rsp
  8042107807:	5b                   	pop    %rbx
  8042107808:	41 5c                	pop    %r12
  804210780a:	41 5d                	pop    %r13
  804210780c:	41 5e                	pop    %r14
  804210780e:	41 5f                	pop    %r15
  8042107810:	5d                   	pop    %rbp
  8042107811:	c3                   	ret
        user_mem_check_addr = MAX(MAX_USER_READABLE, (uintptr_t)c);
  8042107812:	48 39 c3             	cmp    %rax,%rbx
  8042107815:	48 0f 43 c3          	cmovae %rbx,%rax
  8042107819:	48 a3 08 61 00 43 80 	movabs %rax,0x8043006108
  8042107820:	00 00 00 
        return -E_FAULT;
  8042107823:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
  8042107828:	eb d9                	jmp    8042107803 <user_mem_check+0xba>

000000804210782a <user_mem_assert>:
user_mem_assert(struct Env *env, const void *va, size_t len, int perm) {
  804210782a:	f3 0f 1e fa          	endbr64
  804210782e:	55                   	push   %rbp
  804210782f:	48 89 e5             	mov    %rsp,%rbp
  8042107832:	53                   	push   %rbx
  8042107833:	48 83 ec 08          	sub    $0x8,%rsp
  8042107837:	48 89 fb             	mov    %rdi,%rbx
    if (user_mem_check(env, va, len, perm | PROT_USER_) < 0) {
  804210783a:	83 c9 20             	or     $0x20,%ecx
  804210783d:	48 b8 49 77 10 42 80 	movabs $0x8042107749,%rax
  8042107844:	00 00 00 
  8042107847:	ff d0                	call   *%rax
  8042107849:	85 c0                	test   %eax,%eax
  804210784b:	78 06                	js     8042107853 <user_mem_assert+0x29>
}
  804210784d:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8042107851:	c9                   	leave
  8042107852:	c3                   	ret
        cprintf("[%08x] user_mem_check assertion failure for "
  8042107853:	48 8b 8b 98 00 00 00 	mov    0x98(%rbx),%rcx
  804210785a:	8b b3 c8 00 00 00    	mov    0xc8(%rbx),%esi
  8042107860:	48 b8 08 61 00 43 80 	movabs $0x8043006108,%rax
  8042107867:	00 00 00 
  804210786a:	48 8b 10             	mov    (%rax),%rdx
  804210786d:	48 bf 60 0e 12 42 80 	movabs $0x8042120e60,%rdi
  8042107874:	00 00 00 
  8042107877:	b8 00 00 00 00       	mov    $0x0,%eax
  804210787c:	49 b8 70 cf 10 42 80 	movabs $0x804210cf70,%r8
  8042107883:	00 00 00 
  8042107886:	41 ff d0             	call   *%r8
        env_destroy(env); /* may not return */
  8042107889:	48 89 df             	mov    %rbx,%rdi
  804210788c:	48 b8 e4 c7 10 42 80 	movabs $0x804210c7e4,%rax
  8042107893:	00 00 00 
  8042107896:	ff d0                	call   *%rax
}
  8042107898:	eb b3                	jmp    804210784d <user_mem_assert+0x23>

000000804210789a <update_all_pte>:
{
  804210789a:	f3 0f 1e fa          	endbr64
  804210789e:	55                   	push   %rbp
  804210789f:	48 89 e5             	mov    %rsp,%rbp
  80421078a2:	41 57                	push   %r15
  80421078a4:	41 56                	push   %r14
  80421078a6:	41 55                	push   %r13
  80421078a8:	41 54                	push   %r12
  80421078aa:	53                   	push   %rbx
  80421078ab:	48 83 ec 18          	sub    $0x18,%rsp
  80421078af:	49 89 fd             	mov    %rdi,%r13
  80421078b2:	89 75 cc             	mov    %esi,-0x34(%rbp)
  80421078b5:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (envs[j].env_status == ENV_RUNNABLE || envs[j].env_status == ENV_RUNNING) {
  80421078ba:	49 bc 68 64 00 43 80 	movabs $0x8043006468,%r12
  80421078c1:	00 00 00 
  80421078c4:	49 be ff ff ff ff ff 	movabs $0xfffffffffffff,%r14
  80421078cb:	ff 0f 00 
            struct Page *found_page = page_lookup_virtual(envs[j].address_space.root, page2pa(tail), 0, 0);
  80421078ce:	49 bf fa 72 10 42 80 	movabs $0x80421072fa,%r15
  80421078d5:	00 00 00 
  80421078d8:	eb 10                	jmp    80421078ea <update_all_pte+0x50>
    for (int j = 0; j < NENV; j++) {
  80421078da:	48 81 c3 30 01 00 00 	add    $0x130,%rbx
  80421078e1:	48 81 fb 00 c0 04 00 	cmp    $0x4c000,%rbx
  80421078e8:	74 7d                	je     8042107967 <update_all_pte+0xcd>
        if (envs[j].env_status == ENV_RUNNABLE || envs[j].env_status == ENV_RUNNING) {
  80421078ea:	48 89 da             	mov    %rbx,%rdx
  80421078ed:	49 03 14 24          	add    (%r12),%rdx
  80421078f1:	8b 82 d4 00 00 00    	mov    0xd4(%rdx),%eax
  80421078f7:	83 e8 02             	sub    $0x2,%eax
  80421078fa:	83 f8 01             	cmp    $0x1,%eax
  80421078fd:	77 db                	ja     80421078da <update_all_pte+0x40>
  80421078ff:	4c 89 f6             	mov    %r14,%rsi
  8042107902:	49 23 75 38          	and    0x38(%r13),%rsi
  8042107906:	48 c1 e6 0c          	shl    $0xc,%rsi
  804210790a:	4c 21 f6             	and    %r14,%rsi
            struct Page *found_page = page_lookup_virtual(envs[j].address_space.root, page2pa(tail), 0, 0);
  804210790d:	48 8b ba f8 00 00 00 	mov    0xf8(%rdx),%rdi
  8042107914:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042107919:	ba 00 00 00 00       	mov    $0x0,%edx
  804210791e:	41 ff d7             	call   *%r15
            if (found_page) {
  8042107921:	48 85 c0             	test   %rax,%rax
  8042107924:	74 b4                	je     80421078da <update_all_pte+0x40>
                update_pte(&envs[j].address_space, found_page, swap_index);
  8042107926:	48 89 df             	mov    %rbx,%rdi
  8042107929:	49 03 3c 24          	add    (%r12),%rdi
  804210792d:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
  8042107934:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8042107937:	48 89 c6             	mov    %rax,%rsi
  804210793a:	48 b8 18 5c 10 42 80 	movabs $0x8042105c18,%rax
  8042107941:	00 00 00 
  8042107944:	ff d0                	call   *%rax
                tail->refc--;
  8042107946:	41 8b 45 30          	mov    0x30(%r13),%eax
  804210794a:	83 e8 01             	sub    $0x1,%eax
  804210794d:	41 89 45 30          	mov    %eax,0x30(%r13)
                if (tail->refc == 0) {
  8042107951:	75 87                	jne    80421078da <update_all_pte+0x40>
                    unmap_page_remove(tail);
  8042107953:	4c 89 ef             	mov    %r13,%rdi
  8042107956:	48 b8 f2 4b 10 42 80 	movabs $0x8042104bf2,%rax
  804210795d:	00 00 00 
  8042107960:	ff d0                	call   *%rax
  8042107962:	e9 73 ff ff ff       	jmp    80421078da <update_all_pte+0x40>
  8042107967:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804210796e:	ff 0f 00 
  8042107971:	48 89 c6             	mov    %rax,%rsi
  8042107974:	49 23 75 38          	and    0x38(%r13),%rsi
  8042107978:	48 c1 e6 0c          	shl    $0xc,%rsi
  804210797c:	48 21 c6             	and    %rax,%rsi
    struct Page *found_page = page_lookup_virtual(&root, page2pa(tail), 0, 0);
  804210797f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042107984:	ba 00 00 00 00       	mov    $0x0,%edx
  8042107989:	48 bf 80 10 00 43 80 	movabs $0x8043001080,%rdi
  8042107990:	00 00 00 
  8042107993:	48 b8 fa 72 10 42 80 	movabs $0x80421072fa,%rax
  804210799a:	00 00 00 
  804210799d:	ff d0                	call   *%rax
    if (found_page) {
  804210799f:	48 85 c0             	test   %rax,%rax
  80421079a2:	74 29                	je     80421079cd <update_all_pte+0x133>
        update_pte(&kspace, tail, swap_index);
  80421079a4:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80421079a7:	4c 89 ee             	mov    %r13,%rsi
  80421079aa:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  80421079b1:	00 00 00 
  80421079b4:	48 b8 18 5c 10 42 80 	movabs $0x8042105c18,%rax
  80421079bb:	00 00 00 
  80421079be:	ff d0                	call   *%rax
        tail->refc--;
  80421079c0:	41 8b 45 30          	mov    0x30(%r13),%eax
  80421079c4:	83 e8 01             	sub    $0x1,%eax
  80421079c7:	41 89 45 30          	mov    %eax,0x30(%r13)
        if (tail->refc == 0) {
  80421079cb:	74 0f                	je     80421079dc <update_all_pte+0x142>
}
  80421079cd:	48 83 c4 18          	add    $0x18,%rsp
  80421079d1:	5b                   	pop    %rbx
  80421079d2:	41 5c                	pop    %r12
  80421079d4:	41 5d                	pop    %r13
  80421079d6:	41 5e                	pop    %r14
  80421079d8:	41 5f                	pop    %r15
  80421079da:	5d                   	pop    %rbp
  80421079db:	c3                   	ret
            unmap_page_remove(tail);
  80421079dc:	4c 89 ef             	mov    %r13,%rdi
  80421079df:	48 b8 f2 4b 10 42 80 	movabs $0x8042104bf2,%rax
  80421079e6:	00 00 00 
  80421079e9:	ff d0                	call   *%rax
}
  80421079eb:	eb e0                	jmp    80421079cd <update_all_pte+0x133>

00000080421079ed <alloc_fill_pt>:
alloc_fill_pt(pte_t *dst, pte_t base, size_t step, size_t i0, size_t i1) {
  80421079ed:	f3 0f 1e fa          	endbr64
  80421079f1:	55                   	push   %rbp
  80421079f2:	48 89 e5             	mov    %rsp,%rbp
  80421079f5:	41 57                	push   %r15
  80421079f7:	41 56                	push   %r14
  80421079f9:	41 55                	push   %r13
  80421079fb:	41 54                	push   %r12
  80421079fd:	53                   	push   %rbx
  80421079fe:	48 83 ec 28          	sub    $0x28,%rsp
    assert(i0 < i1);
  8042107a02:	4c 39 c1             	cmp    %r8,%rcx
  8042107a05:	73 65                	jae    8042107a6c <alloc_fill_pt+0x7f>
  8042107a07:	49 89 d5             	mov    %rdx,%r13
    assert(i1 <= 512);
  8042107a0a:	49 81 f8 00 02 00 00 	cmp    $0x200,%r8
  8042107a11:	0f 87 8a 00 00 00    	ja     8042107aa1 <alloc_fill_pt+0xb4>
    bool need_recur = step > 1 * GB || (step == 1 * GB && !has_1gb_pages);
  8042107a17:	ba 01 00 00 00       	mov    $0x1,%edx
  8042107a1c:	49 81 fd 00 00 00 40 	cmp    $0x40000000,%r13
  8042107a23:	77 0b                	ja     8042107a30 <alloc_fill_pt+0x43>
  8042107a25:	ba 00 00 00 00       	mov    $0x0,%edx
  8042107a2a:	0f 84 a6 00 00 00    	je     8042107ad6 <alloc_fill_pt+0xe9>
  8042107a30:	41 89 d7             	mov    %edx,%r15d
  8042107a33:	41 83 e7 01          	and    $0x1,%r15d
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  8042107a37:	44 89 f8             	mov    %r15d,%eax
  8042107a3a:	83 f0 01             	xor    $0x1,%eax
  8042107a3d:	49 81 fd 00 10 00 00 	cmp    $0x1000,%r13
  8042107a44:	0f 95 c3             	setne  %bl
  8042107a47:	0f b6 db             	movzbl %bl,%ebx
  8042107a4a:	48 21 c3             	and    %rax,%rbx
  8042107a4d:	48 c1 e3 07          	shl    $0x7,%rbx
  8042107a51:	48 09 f3             	or     %rsi,%rbx
            res = alloc_fill_pt(KADDR(PTE_ADDR(dst[i])), base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  8042107a54:	4c 89 e8             	mov    %r13,%rax
  8042107a57:	48 c1 e8 09          	shr    $0x9,%rax
  8042107a5b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8042107a5f:	4c 8d 24 cf          	lea    (%rdi,%rcx,8),%r12
  8042107a63:	4e 8d 34 c7          	lea    (%rdi,%r8,8),%r14
  8042107a67:	e9 54 02 00 00       	jmp    8042107cc0 <alloc_fill_pt+0x2d3>
    assert(i0 < i1);
  8042107a6c:	48 b9 da f8 11 42 80 	movabs $0x804211f8da,%rcx
  8042107a73:	00 00 00 
  8042107a76:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107a7d:	00 00 00 
  8042107a80:	be 25 03 00 00       	mov    $0x325,%esi
  8042107a85:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107a8c:	00 00 00 
  8042107a8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107a94:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107a9b:	00 00 00 
  8042107a9e:	41 ff d0             	call   *%r8
    assert(i1 <= 512);
  8042107aa1:	48 b9 e2 f8 11 42 80 	movabs $0x804211f8e2,%rcx
  8042107aa8:	00 00 00 
  8042107aab:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107ab2:	00 00 00 
  8042107ab5:	be 26 03 00 00       	mov    $0x326,%esi
  8042107aba:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107ac1:	00 00 00 
  8042107ac4:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107ac9:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107ad0:	00 00 00 
  8042107ad3:	41 ff d0             	call   *%r8
    bool need_recur = step > 1 * GB || (step == 1 * GB && !has_1gb_pages);
  8042107ad6:	a0 28 61 00 43 80 00 	movabs 0x8043006128,%al
  8042107add:	00 00 
  8042107adf:	83 f0 01             	xor    $0x1,%eax
  8042107ae2:	0f b6 d0             	movzbl %al,%edx
  8042107ae5:	e9 46 ff ff ff       	jmp    8042107a30 <alloc_fill_pt+0x43>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8042107aea:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)
  8042107aee:	49 8b 04 24          	mov    (%r12),%rax
  8042107af2:	25 81 00 00 00       	and    $0x81,%eax
  8042107af7:	48 83 f8 01          	cmp    $0x1,%rax
  8042107afb:	75 5f                	jne    8042107b5c <alloc_fill_pt+0x16f>
            res = alloc_fill_pt(KADDR(PTE_ADDR(dst[i])), base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  8042107afd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042107b01:	48 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdi
  8042107b08:	ff ff 7f 
  8042107b0b:	48 23 38             	and    (%rax),%rdi
    if (pa > max_memory_map_addr)
  8042107b0e:	48 b8 f8 10 00 43 80 	movabs $0x80430010f8,%rax
  8042107b15:	00 00 00 
  8042107b18:	4c 8b 00             	mov    (%rax),%r8
  8042107b1b:	49 39 f8             	cmp    %rdi,%r8
  8042107b1e:	0f 82 5e 01 00 00    	jb     8042107c82 <alloc_fill_pt+0x295>
    return (void *)(pa + KERN_BASE_ADDR);
  8042107b24:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042107b2b:	00 00 00 
  8042107b2e:	48 01 c7             	add    %rax,%rdi
  8042107b31:	41 b8 00 02 00 00    	mov    $0x200,%r8d
  8042107b37:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042107b3c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8042107b40:	48 89 de             	mov    %rbx,%rsi
  8042107b43:	48 b8 ed 79 10 42 80 	movabs $0x80421079ed,%rax
  8042107b4a:	00 00 00 
  8042107b4d:	ff d0                	call   *%rax
            if (res < 0)
  8042107b4f:	85 c0                	test   %eax,%eax
  8042107b51:	0f 89 5d 01 00 00    	jns    8042107cb4 <alloc_fill_pt+0x2c7>
  8042107b57:	e9 10 01 00 00       	jmp    8042107c6c <alloc_fill_pt+0x27f>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8042107b5c:	be 00 00 04 00       	mov    $0x40000,%esi
  8042107b61:	bf 00 00 00 00       	mov    $0x0,%edi
  8042107b66:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  8042107b6d:	00 00 00 
  8042107b70:	ff d0                	call   *%rax
  8042107b72:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (!page) return -E_NO_MEM;
  8042107b76:	48 85 c0             	test   %rax,%rax
  8042107b79:	0f 84 fc 00 00 00    	je     8042107c7b <alloc_fill_pt+0x28e>
        assert(!page->refc);
  8042107b7f:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042107b83:	75 7f                	jne    8042107c04 <alloc_fill_pt+0x217>
        page_ref(page);
  8042107b85:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8042107b89:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  8042107b90:	00 00 00 
  8042107b93:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8042107b95:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8042107b9c:	ff 0f 00 
  8042107b9f:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8042107ba3:	48 89 d0             	mov    %rdx,%rax
  8042107ba6:	48 23 41 38          	and    0x38(%rcx),%rax
  8042107baa:	48 c1 e0 0c          	shl    $0xc,%rax
  8042107bae:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8042107bb1:	48 83 c8 07          	or     $0x7,%rax
  8042107bb5:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042107bb9:	48 89 06             	mov    %rax,(%rsi)
  8042107bbc:	48 89 d7             	mov    %rdx,%rdi
  8042107bbf:	48 23 79 38          	and    0x38(%rcx),%rdi
  8042107bc3:	48 c1 e7 0c          	shl    $0xc,%rdi
  8042107bc7:	48 21 d7             	and    %rdx,%rdi
    if (pa > max_memory_map_addr)
  8042107bca:	48 b8 f8 10 00 43 80 	movabs $0x80430010f8,%rax
  8042107bd1:	00 00 00 
  8042107bd4:	4c 8b 00             	mov    (%rax),%r8
  8042107bd7:	49 39 f8             	cmp    %rdi,%r8
  8042107bda:	72 5d                	jb     8042107c39 <alloc_fill_pt+0x24c>
    return (void *)(pa + KERN_BASE_ADDR);
  8042107bdc:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042107be3:	00 00 00 
  8042107be6:	48 01 c7             	add    %rax,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042107be9:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042107bee:	be 00 00 00 00       	mov    $0x0,%esi
  8042107bf3:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042107bfa:	00 00 00 
  8042107bfd:	ff d0                	call   *%rax
  8042107bff:	e9 f9 fe ff ff       	jmp    8042107afd <alloc_fill_pt+0x110>
        assert(!page->refc);
  8042107c04:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042107c0b:	00 00 00 
  8042107c0e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107c15:	00 00 00 
  8042107c18:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042107c1d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107c24:	00 00 00 
  8042107c27:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107c2c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107c33:	00 00 00 
  8042107c36:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042107c39:	48 89 f9             	mov    %rdi,%rcx
  8042107c3c:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042107c43:	00 00 00 
  8042107c46:	be ff 02 00 00       	mov    $0x2ff,%esi
  8042107c4b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107c52:	00 00 00 
  8042107c55:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107c5a:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042107c61:	00 00 00 
  8042107c64:	41 ff d1             	call   *%r9
    return 0;
  8042107c67:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8042107c6c:	48 83 c4 28          	add    $0x28,%rsp
  8042107c70:	5b                   	pop    %rbx
  8042107c71:	41 5c                	pop    %r12
  8042107c73:	41 5d                	pop    %r13
  8042107c75:	41 5e                	pop    %r14
  8042107c77:	41 5f                	pop    %r15
  8042107c79:	5d                   	pop    %rbp
  8042107c7a:	c3                   	ret
        if (!page) return -E_NO_MEM;
  8042107c7b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8042107c80:	eb ea                	jmp    8042107c6c <alloc_fill_pt+0x27f>
  8042107c82:	48 89 f9             	mov    %rdi,%rcx
  8042107c85:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042107c8c:	00 00 00 
  8042107c8f:	be 33 03 00 00       	mov    $0x333,%esi
  8042107c94:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107c9b:	00 00 00 
  8042107c9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107ca3:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042107caa:	00 00 00 
  8042107cad:	41 ff d1             	call   *%r9
            dst[i] = base;
  8042107cb0:	49 89 1c 24          	mov    %rbx,(%r12)
    for (size_t i = i0; i < i1; i++, base += step) {
  8042107cb4:	4c 01 eb             	add    %r13,%rbx
  8042107cb7:	49 83 c4 08          	add    $0x8,%r12
  8042107cbb:	4d 39 f4             	cmp    %r14,%r12
  8042107cbe:	74 a7                	je     8042107c67 <alloc_fill_pt+0x27a>
        if (need_recur) {
  8042107cc0:	45 84 ff             	test   %r15b,%r15b
  8042107cc3:	0f 85 21 fe ff ff    	jne    8042107aea <alloc_fill_pt+0xfd>
            if ((PTE_ADDR(base) & (step - 1)))
  8042107cc9:	49 8d 45 ff          	lea    -0x1(%r13),%rax
  8042107ccd:	48 21 d8             	and    %rbx,%rax
  8042107cd0:	48 be 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rsi
  8042107cd7:	ff ff 7f 
  8042107cda:	48 85 f0             	test   %rsi,%rax
  8042107cdd:	74 d1                	je     8042107cb0 <alloc_fill_pt+0x2c3>
                cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  8042107cdf:	48 89 f0             	mov    %rsi,%rax
  8042107ce2:	48 89 de             	mov    %rbx,%rsi
  8042107ce5:	48 21 c6             	and    %rax,%rsi
  8042107ce8:	4c 89 ea             	mov    %r13,%rdx
  8042107ceb:	48 bf f8 f8 11 42 80 	movabs $0x804211f8f8,%rdi
  8042107cf2:	00 00 00 
  8042107cf5:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107cfa:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  8042107d01:	00 00 00 
  8042107d04:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  8042107d06:	48 b9 a8 0e 12 42 80 	movabs $0x8042120ea8,%rcx
  8042107d0d:	00 00 00 
  8042107d10:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107d17:	00 00 00 
  8042107d1a:	be 3b 03 00 00       	mov    $0x33b,%esi
  8042107d1f:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107d26:	00 00 00 
  8042107d29:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107d2e:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107d35:	00 00 00 
  8042107d38:	41 ff d0             	call   *%r8

0000008042107d3b <init_address_space>:
init_address_space(struct AddressSpace *space) {
  8042107d3b:	f3 0f 1e fa          	endbr64
  8042107d3f:	55                   	push   %rbp
  8042107d40:	48 89 e5             	mov    %rsp,%rbp
  8042107d43:	41 54                	push   %r12
  8042107d45:	53                   	push   %rbx
  8042107d46:	48 89 fb             	mov    %rdi,%rbx
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8042107d49:	48 8b 47 08          	mov    0x8(%rdi),%rax
  8042107d4d:	25 81 00 00 00       	and    $0x81,%eax
  8042107d52:	48 83 f8 01          	cmp    $0x1,%rax
  8042107d56:	75 7f                	jne    8042107dd7 <init_address_space+0x9c>
    space->cr3 = PTE_ADDR(space->cr3);
  8042107d58:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042107d5f:	ff ff 7f 
  8042107d62:	48 23 4b 08          	and    0x8(%rbx),%rcx
  8042107d66:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
    if (pa > max_memory_map_addr)
  8042107d6a:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042107d71:	00 00 00 
  8042107d74:	48 39 c8             	cmp    %rcx,%rax
  8042107d77:	0f 82 5e 01 00 00    	jb     8042107edb <init_address_space+0x1a0>
    return (void *)(pa + KERN_BASE_ADDR);
  8042107d7d:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042107d84:	00 00 00 
  8042107d87:	48 01 c1             	add    %rax,%rcx
  8042107d8a:	48 89 0b             	mov    %rcx,(%rbx)
	space->root = alloc_descriptor(INTERMEDIATE_NODE);
  8042107d8d:	bf 00 00 20 00       	mov    $0x200000,%edi
  8042107d92:	48 b8 02 65 10 42 80 	movabs $0x8042106502,%rax
  8042107d99:	00 00 00 
  8042107d9c:	ff d0                	call   *%rax
  8042107d9e:	48 89 43 10          	mov    %rax,0x10(%rbx)
    space->pml4[PML4_INDEX(UVPT)] = space->cr3 | PTE_P | PTE_U;
  8042107da2:	48 8b 13             	mov    (%rbx),%rdx
  8042107da5:	48 8b 43 08          	mov    0x8(%rbx),%rax
  8042107da9:	48 83 c8 05          	or     $0x5,%rax
  8042107dad:	48 89 82 f8 07 00 00 	mov    %rax,0x7f8(%rdx)
    propagate_one_pml4(space, &kspace);
  8042107db4:	48 be e0 10 00 43 80 	movabs $0x80430010e0,%rsi
  8042107dbb:	00 00 00 
  8042107dbe:	48 89 df             	mov    %rbx,%rdi
  8042107dc1:	48 b8 13 70 10 42 80 	movabs $0x8042107013,%rax
  8042107dc8:	00 00 00 
  8042107dcb:	ff d0                	call   *%rax
    return 0;
  8042107dcd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8042107dd2:	5b                   	pop    %rbx
  8042107dd3:	41 5c                	pop    %r12
  8042107dd5:	5d                   	pop    %rbp
  8042107dd6:	c3                   	ret
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8042107dd7:	be 00 00 04 00       	mov    $0x40000,%esi
  8042107ddc:	bf 00 00 00 00       	mov    $0x0,%edi
  8042107de1:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  8042107de8:	00 00 00 
  8042107deb:	ff d0                	call   *%rax
  8042107ded:	49 89 c4             	mov    %rax,%r12
        if (!page) return -E_NO_MEM;
  8042107df0:	48 85 c0             	test   %rax,%rax
  8042107df3:	0f 84 10 01 00 00    	je     8042107f09 <init_address_space+0x1ce>
        assert(!page->refc);
  8042107df9:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042107dfd:	75 76                	jne    8042107e75 <init_address_space+0x13a>
        page_ref(page);
  8042107dff:	48 89 c7             	mov    %rax,%rdi
  8042107e02:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  8042107e09:	00 00 00 
  8042107e0c:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8042107e0e:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8042107e15:	ff 0f 00 
  8042107e18:	48 89 d0             	mov    %rdx,%rax
  8042107e1b:	49 23 44 24 38       	and    0x38(%r12),%rax
  8042107e20:	48 c1 e0 0c          	shl    $0xc,%rax
  8042107e24:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8042107e27:	48 83 c8 07          	or     $0x7,%rax
  8042107e2b:	48 89 43 08          	mov    %rax,0x8(%rbx)
  8042107e2f:	48 89 d7             	mov    %rdx,%rdi
  8042107e32:	49 23 7c 24 38       	and    0x38(%r12),%rdi
  8042107e37:	48 c1 e7 0c          	shl    $0xc,%rdi
  8042107e3b:	48 21 d7             	and    %rdx,%rdi
    if (pa > max_memory_map_addr)
  8042107e3e:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042107e45:	00 00 00 
  8042107e48:	48 39 f8             	cmp    %rdi,%rax
  8042107e4b:	72 5d                	jb     8042107eaa <init_address_space+0x16f>
    return (void *)(pa + KERN_BASE_ADDR);
  8042107e4d:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042107e54:	00 00 00 
  8042107e57:	48 01 c7             	add    %rax,%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042107e5a:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042107e5f:	be 00 00 00 00       	mov    $0x0,%esi
  8042107e64:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042107e6b:	00 00 00 
  8042107e6e:	ff d0                	call   *%rax
  8042107e70:	e9 e3 fe ff ff       	jmp    8042107d58 <init_address_space+0x1d>
        assert(!page->refc);
  8042107e75:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042107e7c:	00 00 00 
  8042107e7f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107e86:	00 00 00 
  8042107e89:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042107e8e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107e95:	00 00 00 
  8042107e98:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107e9d:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107ea4:	00 00 00 
  8042107ea7:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042107eaa:	49 89 c0             	mov    %rax,%r8
  8042107ead:	48 89 f9             	mov    %rdi,%rcx
  8042107eb0:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042107eb7:	00 00 00 
  8042107eba:	be ff 02 00 00       	mov    $0x2ff,%esi
  8042107ebf:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107ec6:	00 00 00 
  8042107ec9:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107ece:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042107ed5:	00 00 00 
  8042107ed8:	41 ff d1             	call   *%r9
  8042107edb:	49 89 c0             	mov    %rax,%r8
  8042107ede:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042107ee5:	00 00 00 
  8042107ee8:	be 57 06 00 00       	mov    $0x657,%esi
  8042107eed:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107ef4:	00 00 00 
  8042107ef7:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107efc:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042107f03:	00 00 00 
  8042107f06:	41 ff d1             	call   *%r9
        if (!page) return -E_NO_MEM;
  8042107f09:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8042107f0e:	e9 bf fe ff ff       	jmp    8042107dd2 <init_address_space+0x97>

0000008042107f13 <unmap_page>:
unmap_page(struct AddressSpace *spc, uintptr_t addr, int class) {
  8042107f13:	f3 0f 1e fa          	endbr64
  8042107f17:	55                   	push   %rbp
  8042107f18:	48 89 e5             	mov    %rsp,%rbp
  8042107f1b:	41 57                	push   %r15
  8042107f1d:	41 56                	push   %r14
  8042107f1f:	41 55                	push   %r13
  8042107f21:	41 54                	push   %r12
  8042107f23:	53                   	push   %rbx
  8042107f24:	48 83 ec 28          	sub    $0x28,%rsp
    assert(!(addr & CLASS_MASK(class)));
  8042107f28:	44 8d 7a 0c          	lea    0xc(%rdx),%r15d
  8042107f2c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8042107f33:	44 89 f9             	mov    %r15d,%ecx
  8042107f36:	48 d3 e0             	shl    %cl,%rax
  8042107f39:	48 f7 d0             	not    %rax
  8042107f3c:	48 85 f0             	test   %rsi,%rax
  8042107f3f:	75 7c                	jne    8042107fbd <unmap_page+0xaa>
  8042107f41:	49 89 fe             	mov    %rdi,%r14
  8042107f44:	48 89 f3             	mov    %rsi,%rbx
  8042107f47:	41 89 d5             	mov    %edx,%r13d
    struct Page *node = page_lookup_virtual(spc->root, addr, class, LOOKUP_ALLOC);
  8042107f4a:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  8042107f4e:	b9 01 00 00 00       	mov    $0x1,%ecx
  8042107f53:	48 b8 fa 72 10 42 80 	movabs $0x80421072fa,%rax
  8042107f5a:	00 00 00 
  8042107f5d:	ff d0                	call   *%rax
  8042107f5f:	49 89 c4             	mov    %rax,%r12
    if (node) unmap_page_remove(node);
  8042107f62:	48 85 c0             	test   %rax,%rax
  8042107f65:	74 0f                	je     8042107f76 <unmap_page+0x63>
  8042107f67:	48 89 c7             	mov    %rax,%rdi
  8042107f6a:	48 b8 f2 4b 10 42 80 	movabs $0x8042104bf2,%rax
  8042107f71:	00 00 00 
  8042107f74:	ff d0                	call   *%rax
    if (node == spc->root)
  8042107f76:	4d 39 66 10          	cmp    %r12,0x10(%r14)
  8042107f7a:	74 76                	je     8042107ff2 <unmap_page+0xdf>
    uintptr_t end = addr + CLASS_SIZE(class);
  8042107f7c:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  8042107f82:	44 89 f9             	mov    %r15d,%ecx
  8042107f85:	49 d3 e4             	shl    %cl,%r12
  8042107f88:	49 01 dc             	add    %rbx,%r12
    size_t pml4i0 = PML4_INDEX(addr), pml4i1 = PML4_INDEX(end);
  8042107f8b:	48 89 d9             	mov    %rbx,%rcx
  8042107f8e:	48 c1 e9 27          	shr    $0x27,%rcx
  8042107f92:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
    if (class >= 27) {
  8042107f98:	41 83 fd 1a          	cmp    $0x1a,%r13d
  8042107f9c:	7f 6e                	jg     804210800c <unmap_page+0xf9>
    if (!(spc->pml4[pml4i0] & PTE_P)) return;
  8042107f9e:	49 8b 06             	mov    (%r14),%rax
  8042107fa1:	48 8b 0c c8          	mov    (%rax,%rcx,8),%rcx
  8042107fa5:	f6 c1 01             	test   $0x1,%cl
  8042107fa8:	0f 85 a9 00 00 00    	jne    8042108057 <unmap_page+0x144>
}
  8042107fae:	48 83 c4 28          	add    $0x28,%rsp
  8042107fb2:	5b                   	pop    %rbx
  8042107fb3:	41 5c                	pop    %r12
  8042107fb5:	41 5d                	pop    %r13
  8042107fb7:	41 5e                	pop    %r14
  8042107fb9:	41 5f                	pop    %r15
  8042107fbb:	5d                   	pop    %rbp
  8042107fbc:	c3                   	ret
    assert(!(addr & CLASS_MASK(class)));
  8042107fbd:	48 b9 8c f8 11 42 80 	movabs $0x804211f88c,%rcx
  8042107fc4:	00 00 00 
  8042107fc7:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042107fce:	00 00 00 
  8042107fd1:	be 72 03 00 00       	mov    $0x372,%esi
  8042107fd6:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042107fdd:	00 00 00 
  8042107fe0:	b8 00 00 00 00       	mov    $0x0,%eax
  8042107fe5:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042107fec:	00 00 00 
  8042107fef:	41 ff d0             	call   *%r8
        spc->root = alloc_descriptor(INTERMEDIATE_NODE);
  8042107ff2:	bf 00 00 20 00       	mov    $0x200000,%edi
  8042107ff7:	48 b8 02 65 10 42 80 	movabs $0x8042106502,%rax
  8042107ffe:	00 00 00 
  8042108001:	ff d0                	call   *%rax
  8042108003:	49 89 46 10          	mov    %rax,0x10(%r14)
  8042108007:	e9 70 ff ff ff       	jmp    8042107f7c <unmap_page+0x69>
    size_t pml4i0 = PML4_INDEX(addr), pml4i1 = PML4_INDEX(end);
  804210800c:	4d 89 e5             	mov    %r12,%r13
  804210800f:	49 c1 ed 27          	shr    $0x27,%r13
  8042108013:	41 81 e5 ff 01 00 00 	and    $0x1ff,%r13d
        remove_pt(spc->pml4, addr, 512 * GB, pml4i0, pml4i1);
  804210801a:	49 8b 3e             	mov    (%r14),%rdi
  804210801d:	4d 89 e8             	mov    %r13,%r8
  8042108020:	48 ba 00 00 00 00 80 	movabs $0x8000000000,%rdx
  8042108027:	00 00 00 
  804210802a:	48 89 de             	mov    %rbx,%rsi
  804210802d:	48 b8 35 6e 10 42 80 	movabs $0x8042106e35,%rax
  8042108034:	00 00 00 
  8042108037:	ff d0                	call   *%rax
        if (pml4i1 - 1 >= NUSERPML4) propagate_pml4(spc);
  8042108039:	49 83 fd 01          	cmp    $0x1,%r13
  804210803d:	0f 84 e8 03 00 00    	je     804210842b <unmap_page+0x518>
  8042108043:	4c 89 f7             	mov    %r14,%rdi
  8042108046:	48 b8 48 71 10 42 80 	movabs $0x8042107148,%rax
  804210804d:	00 00 00 
  8042108050:	ff d0                	call   *%rax
  8042108052:	e9 d4 03 00 00       	jmp    804210842b <unmap_page+0x518>
    pdpe_t *pdp = KADDR(PTE_ADDR(spc->pml4[pml4i0]));
  8042108057:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  804210805e:	ff ff 7f 
  8042108061:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  8042108064:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210806b:	00 00 00 
  804210806e:	48 39 c8             	cmp    %rcx,%rax
  8042108071:	0f 82 aa 00 00 00    	jb     8042108121 <unmap_page+0x20e>
    return (void *)(pa + KERN_BASE_ADDR);
  8042108077:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804210807e:	00 00 00 
  8042108081:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
    size_t pdpi0 = PDP_INDEX(addr), pdpi1 = PDP_INDEX(end);
  8042108085:	48 89 d9             	mov    %rbx,%rcx
  8042108088:	48 c1 e9 1e          	shr    $0x1e,%rcx
  804210808c:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
  8042108092:	4d 89 e0             	mov    %r12,%r8
  8042108095:	49 c1 e8 1e          	shr    $0x1e,%r8
  8042108099:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
    if (pdpi0 > pdpi1) pdpi1 = PDP_ENTRY_COUNT;
  80421080a0:	49 39 c8             	cmp    %rcx,%r8
  80421080a3:	b8 00 02 00 00       	mov    $0x200,%eax
  80421080a8:	4c 0f 42 c0          	cmovb  %rax,%r8
    if (class >= 18) {
  80421080ac:	41 83 fd 11          	cmp    $0x11,%r13d
  80421080b0:	0f 8f 99 00 00 00    	jg     804210814f <unmap_page+0x23c>
    if (!(pdp[pdpi0] & PTE_P))
  80421080b6:	4c 8d 3c cf          	lea    (%rdi,%rcx,8),%r15
  80421080ba:	49 8b 07             	mov    (%r15),%rax
  80421080bd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80421080c1:	a8 01                	test   $0x1,%al
  80421080c3:	0f 84 e5 fe ff ff    	je     8042107fae <unmap_page+0x9b>
    else if (pdp[pdpi0] & PTE_PS) {
  80421080c9:	a8 80                	test   $0x80,%al
  80421080cb:	0f 84 eb 01 00 00    	je     80421082bc <unmap_page+0x3a9>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  80421080d1:	25 81 00 00 00       	and    $0x81,%eax
  80421080d6:	48 83 f8 01          	cmp    $0x1,%rax
  80421080da:	0f 85 88 00 00 00    	jne    8042108168 <unmap_page+0x255>
        pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi0]));
  80421080e0:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  80421080e7:	ff ff 7f 
  80421080ea:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  80421080ed:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  80421080f4:	00 00 00 
  80421080f7:	48 39 c8             	cmp    %rcx,%rax
  80421080fa:	0f 82 6d 01 00 00    	jb     804210826d <unmap_page+0x35a>
    return (void *)(pa + KERN_BASE_ADDR);
  8042108100:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042108107:	00 00 00 
  804210810a:	48 01 c1             	add    %rax,%rcx
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  804210810d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042108111:	40 80 ce 80          	or     $0x80,%sil
    for (size_t i = i0; i < i1; i++, base += step) {
  8042108115:	48 8d 86 00 00 00 40 	lea    0x40000000(%rsi),%rax
  804210811c:	e9 94 05 00 00       	jmp    80421086b5 <unmap_page+0x7a2>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042108121:	49 89 c0             	mov    %rax,%r8
  8042108124:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210812b:	00 00 00 
  804210812e:	be 85 03 00 00       	mov    $0x385,%esi
  8042108133:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210813a:	00 00 00 
  804210813d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108142:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042108149:	00 00 00 
  804210814c:	41 ff d1             	call   *%r9
        remove_pt(pdp, addr, 1 * GB, pdpi0, pdpi1);
  804210814f:	ba 00 00 00 40       	mov    $0x40000000,%edx
  8042108154:	48 89 de             	mov    %rbx,%rsi
  8042108157:	48 b8 35 6e 10 42 80 	movabs $0x8042106e35,%rax
  804210815e:	00 00 00 
  8042108161:	ff d0                	call   *%rax
        goto finish;
  8042108163:	e9 c3 02 00 00       	jmp    804210842b <unmap_page+0x518>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8042108168:	be 00 00 04 00       	mov    $0x40000,%esi
  804210816d:	bf 00 00 00 00       	mov    $0x0,%edi
  8042108172:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  8042108179:	00 00 00 
  804210817c:	ff d0                	call   *%rax
  804210817e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (!page) return -E_NO_MEM;
  8042108182:	48 85 c0             	test   %rax,%rax
  8042108185:	0f 84 94 05 00 00    	je     804210871f <unmap_page+0x80c>
        assert(!page->refc);
  804210818b:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  804210818f:	75 79                	jne    804210820a <unmap_page+0x2f7>
        page_ref(page);
  8042108191:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8042108195:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  804210819c:	00 00 00 
  804210819f:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  80421081a1:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  80421081a8:	ff 0f 00 
  80421081ab:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80421081af:	48 89 d0             	mov    %rdx,%rax
  80421081b2:	48 23 46 38          	and    0x38(%rsi),%rax
  80421081b6:	48 c1 e0 0c          	shl    $0xc,%rax
  80421081ba:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  80421081bd:	48 83 c8 07          	or     $0x7,%rax
  80421081c1:	49 89 07             	mov    %rax,(%r15)
  80421081c4:	48 89 d1             	mov    %rdx,%rcx
  80421081c7:	48 23 4e 38          	and    0x38(%rsi),%rcx
  80421081cb:	48 c1 e1 0c          	shl    $0xc,%rcx
  80421081cf:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  80421081d2:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  80421081d9:	00 00 00 
  80421081dc:	48 39 c8             	cmp    %rcx,%rax
  80421081df:	72 5e                	jb     804210823f <unmap_page+0x32c>
    return (void *)(pa + KERN_BASE_ADDR);
  80421081e1:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  80421081e8:	00 00 00 
  80421081eb:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  80421081ef:	ba 00 10 00 00       	mov    $0x1000,%edx
  80421081f4:	be 00 00 00 00       	mov    $0x0,%esi
  80421081f9:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042108200:	00 00 00 
  8042108203:	ff d0                	call   *%rax
  8042108205:	e9 d6 fe ff ff       	jmp    80421080e0 <unmap_page+0x1cd>
        assert(!page->refc);
  804210820a:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042108211:	00 00 00 
  8042108214:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210821b:	00 00 00 
  804210821e:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042108223:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210822a:	00 00 00 
  804210822d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108232:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108239:	00 00 00 
  804210823c:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804210823f:	49 89 c0             	mov    %rax,%r8
  8042108242:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042108249:	00 00 00 
  804210824c:	be ff 02 00 00       	mov    $0x2ff,%esi
  8042108251:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108258:	00 00 00 
  804210825b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108260:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042108267:	00 00 00 
  804210826a:	41 ff d1             	call   *%r9
  804210826d:	49 89 c0             	mov    %rax,%r8
  8042108270:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042108277:	00 00 00 
  804210827a:	be 9e 03 00 00       	mov    $0x39e,%esi
  804210827f:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108286:	00 00 00 
  8042108289:	b8 00 00 00 00       	mov    $0x0,%eax
  804210828e:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042108295:	00 00 00 
  8042108298:	41 ff d1             	call   *%r9
        inval_start = ROUNDDOWN(inval_start, 1 * GB);
  804210829b:	48 89 d8             	mov    %rbx,%rax
  804210829e:	48 25 00 00 00 c0    	and    $0xffffffffc0000000,%rax
  80421082a4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        inval_end = ROUNDUP(inval_end, 1 * GB);
  80421082a8:	49 8d 84 24 ff ff ff 	lea    0x3fffffff(%r12),%rax
  80421082af:	3f 
  80421082b0:	48 25 00 00 00 c0    	and    $0xffffffffc0000000,%rax
  80421082b6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        assert(!res);
  80421082ba:	eb 08                	jmp    80421082c4 <unmap_page+0x3b1>
    uintptr_t inval_start = addr, inval_end = end;
  80421082bc:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)
  80421082c0:	48 89 5d c0          	mov    %rbx,-0x40(%rbp)
    pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi0]));
  80421082c4:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  80421082cb:	ff ff 7f 
  80421082ce:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  80421082d1:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  80421082d8:	00 00 00 
  80421082db:	48 39 c8             	cmp    %rcx,%rax
  80421082de:	0f 82 95 01 00 00    	jb     8042108479 <unmap_page+0x566>
    return (void *)(pa + KERN_BASE_ADDR);
  80421082e4:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  80421082eb:	00 00 00 
  80421082ee:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
    size_t pdi0 = PD_INDEX(addr);
  80421082f2:	48 89 d9             	mov    %rbx,%rcx
  80421082f5:	48 c1 e9 15          	shr    $0x15,%rcx
  80421082f9:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
    size_t pdi1 = PD_INDEX(end);
  80421082ff:	4d 89 e0             	mov    %r12,%r8
  8042108302:	49 c1 e8 15          	shr    $0x15,%r8
  8042108306:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
		pdi1 = PD_ENTRY_COUNT;
  804210830d:	49 39 c8             	cmp    %rcx,%r8
  8042108310:	b8 00 02 00 00       	mov    $0x200,%eax
  8042108315:	4c 0f 42 c0          	cmovb  %rax,%r8
    if (class >= 9) {
  8042108319:	41 83 fd 08          	cmp    $0x8,%r13d
  804210831d:	0f 8f 84 01 00 00    	jg     80421084a7 <unmap_page+0x594>
    if (!(pd[pdi0] & PTE_P)) {
  8042108323:	4c 8d 3c cf          	lea    (%rdi,%rcx,8),%r15
  8042108327:	49 8b 07             	mov    (%r15),%rax
  804210832a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  804210832e:	a8 01                	test   $0x1,%al
  8042108330:	0f 84 78 fc ff ff    	je     8042107fae <unmap_page+0x9b>
	} else if (pd[pdi0] & PTE_PS) {
  8042108336:	a8 80                	test   $0x80,%al
  8042108338:	74 77                	je     80421083b1 <unmap_page+0x49e>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  804210833a:	25 81 00 00 00       	and    $0x81,%eax
  804210833f:	48 83 f8 01          	cmp    $0x1,%rax
  8042108343:	0f 85 7f 01 00 00    	jne    80421084c8 <unmap_page+0x5b5>
        pte_t *pt = KADDR(PTE_ADDR(pd[pdi0]));
  8042108349:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042108350:	ff ff 7f 
  8042108353:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8042108356:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210835d:	00 00 00 
  8042108360:	48 39 c8             	cmp    %rcx,%rax
  8042108363:	0f 82 64 02 00 00    	jb     80421085cd <unmap_page+0x6ba>
    return (void *)(pa + KERN_BASE_ADDR);
  8042108369:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042108370:	00 00 00 
  8042108373:	48 01 c1             	add    %rax,%rcx
        res = alloc_fill_pt(pt, old & ~PTE_PS, 4 * KB, 0, PT_ENTRY_COUNT);
  8042108376:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804210837a:	24 7f                	and    $0x7f,%al
    for (size_t i = i0; i < i1; i++, base += step) {
  804210837c:	48 8d 90 00 00 20 00 	lea    0x200000(%rax),%rdx
            dst[i] = base;
  8042108383:	48 89 01             	mov    %rax,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  8042108386:	48 05 00 10 00 00    	add    $0x1000,%rax
  804210838c:	48 83 c1 08          	add    $0x8,%rcx
  8042108390:	48 39 c2             	cmp    %rax,%rdx
  8042108393:	75 ee                	jne    8042108383 <unmap_page+0x470>
        inval_start = ROUNDDOWN(inval_start, 2 * MB);
  8042108395:	48 81 65 c0 00 00 e0 	andq   $0xffffffffffe00000,-0x40(%rbp)
  804210839c:	ff 
        inval_end = ROUNDUP(inval_end, 2 * MB);
  804210839d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421083a1:	48 05 ff ff 1f 00    	add    $0x1fffff,%rax
  80421083a7:	48 25 00 00 e0 ff    	and    $0xffffffffffe00000,%rax
  80421083ad:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    pte_t *pt = KADDR(PTE_ADDR(pd[pdi0]));
  80421083b1:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  80421083b8:	ff ff 7f 
  80421083bb:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  80421083be:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  80421083c5:	00 00 00 
  80421083c8:	48 39 c8             	cmp    %rcx,%rax
  80421083cb:	0f 82 2a 02 00 00    	jb     80421085fb <unmap_page+0x6e8>
    return (void *)(pa + KERN_BASE_ADDR);
  80421083d1:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  80421083d8:	00 00 00 
  80421083db:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
    size_t pti0 = PT_INDEX(addr), pti1 = PT_INDEX(end);
  80421083df:	48 89 d9             	mov    %rbx,%rcx
  80421083e2:	48 c1 e9 0c          	shr    $0xc,%rcx
  80421083e6:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
  80421083ec:	4d 89 e0             	mov    %r12,%r8
  80421083ef:	49 c1 e8 0c          	shr    $0xc,%r8
  80421083f3:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
    if (pti0 > pti1) pti1 = PT_ENTRY_COUNT;
  80421083fa:	49 39 c8             	cmp    %rcx,%r8
  80421083fd:	b8 00 02 00 00       	mov    $0x200,%eax
  8042108402:	4c 0f 42 c0          	cmovb  %rax,%r8
    if (class >= 0) {
  8042108406:	45 85 ed             	test   %r13d,%r13d
  8042108409:	0f 88 1a 02 00 00    	js     8042108629 <unmap_page+0x716>
        remove_pt(pt, addr, 4 * KB, pti0, pti1);
  804210840f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042108414:	48 89 de             	mov    %rbx,%rsi
  8042108417:	48 b8 35 6e 10 42 80 	movabs $0x8042106e35,%rax
  804210841e:	00 00 00 
  8042108421:	ff d0                	call   *%rax
        goto finish;
  8042108423:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  8042108427:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
    if (current_space == spc || !current_space) {
  804210842b:	48 a1 d0 10 00 43 80 	movabs 0x80430010d0,%rax
  8042108432:	00 00 00 
  8042108435:	48 85 c0             	test   %rax,%rax
  8042108438:	74 09                	je     8042108443 <unmap_page+0x530>
  804210843a:	49 39 c6             	cmp    %rax,%r14
  804210843d:	0f 85 6b fb ff ff    	jne    8042107fae <unmap_page+0x9b>
        if (start - end > 512 * GB)
  8042108443:	48 89 d8             	mov    %rbx,%rax
  8042108446:	4c 29 e0             	sub    %r12,%rax
  8042108449:	48 ba 00 00 00 00 80 	movabs $0x8000000000,%rdx
  8042108450:	00 00 00 
  8042108453:	48 39 c2             	cmp    %rax,%rdx
  8042108456:	0f 82 02 02 00 00    	jb     804210865e <unmap_page+0x74b>
            while (start < end) {
  804210845c:	4c 39 e3             	cmp    %r12,%rbx
  804210845f:	0f 83 49 fb ff ff    	jae    8042107fae <unmap_page+0x9b>
    asm volatile("invlpg (%0)" ::"r"(addr)
  8042108465:	0f 01 3b             	invlpg (%rbx)
                start += PAGE_SIZE;
  8042108468:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
            while (start < end) {
  804210846f:	4c 39 e3             	cmp    %r12,%rbx
  8042108472:	72 f1                	jb     8042108465 <unmap_page+0x552>
  8042108474:	e9 35 fb ff ff       	jmp    8042107fae <unmap_page+0x9b>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042108479:	49 89 c0             	mov    %rax,%r8
  804210847c:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042108483:	00 00 00 
  8042108486:	be a4 03 00 00       	mov    $0x3a4,%esi
  804210848b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108492:	00 00 00 
  8042108495:	b8 00 00 00 00       	mov    $0x0,%eax
  804210849a:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421084a1:	00 00 00 
  80421084a4:	41 ff d1             	call   *%r9
        remove_pt(pd, addr, 2 * MB, pdi0, pdi1);
  80421084a7:	ba 00 00 20 00       	mov    $0x200000,%edx
  80421084ac:	48 89 de             	mov    %rbx,%rsi
  80421084af:	48 b8 35 6e 10 42 80 	movabs $0x8042106e35,%rax
  80421084b6:	00 00 00 
  80421084b9:	ff d0                	call   *%rax
        goto finish;
  80421084bb:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  80421084bf:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
  80421084c3:	e9 63 ff ff ff       	jmp    804210842b <unmap_page+0x518>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  80421084c8:	be 00 00 04 00       	mov    $0x40000,%esi
  80421084cd:	bf 00 00 00 00       	mov    $0x0,%edi
  80421084d2:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  80421084d9:	00 00 00 
  80421084dc:	ff d0                	call   *%rax
  80421084de:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        if (!page) return -E_NO_MEM;
  80421084e2:	48 85 c0             	test   %rax,%rax
  80421084e5:	0f 84 7e 01 00 00    	je     8042108669 <unmap_page+0x756>
        assert(!page->refc);
  80421084eb:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  80421084ef:	75 79                	jne    804210856a <unmap_page+0x657>
        page_ref(page);
  80421084f1:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  80421084f5:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  80421084fc:	00 00 00 
  80421084ff:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8042108501:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8042108508:	ff 0f 00 
  804210850b:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804210850f:	48 89 d0             	mov    %rdx,%rax
  8042108512:	48 23 46 38          	and    0x38(%rsi),%rax
  8042108516:	48 c1 e0 0c          	shl    $0xc,%rax
  804210851a:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  804210851d:	48 83 c8 07          	or     $0x7,%rax
  8042108521:	49 89 07             	mov    %rax,(%r15)
  8042108524:	48 89 d1             	mov    %rdx,%rcx
  8042108527:	48 23 4e 38          	and    0x38(%rsi),%rcx
  804210852b:	48 c1 e1 0c          	shl    $0xc,%rcx
  804210852f:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8042108532:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042108539:	00 00 00 
  804210853c:	48 39 c8             	cmp    %rcx,%rax
  804210853f:	72 5e                	jb     804210859f <unmap_page+0x68c>
    return (void *)(pa + KERN_BASE_ADDR);
  8042108541:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042108548:	00 00 00 
  804210854b:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  804210854f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042108554:	be 00 00 00 00       	mov    $0x0,%esi
  8042108559:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042108560:	00 00 00 
  8042108563:	ff d0                	call   *%rax
  8042108565:	e9 df fd ff ff       	jmp    8042108349 <unmap_page+0x436>
        assert(!page->refc);
  804210856a:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042108571:	00 00 00 
  8042108574:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210857b:	00 00 00 
  804210857e:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042108583:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210858a:	00 00 00 
  804210858d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108592:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108599:	00 00 00 
  804210859c:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804210859f:	49 89 c0             	mov    %rax,%r8
  80421085a2:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421085a9:	00 00 00 
  80421085ac:	be ff 02 00 00       	mov    $0x2ff,%esi
  80421085b1:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421085b8:	00 00 00 
  80421085bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80421085c0:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421085c7:	00 00 00 
  80421085ca:	41 ff d1             	call   *%r9
  80421085cd:	49 89 c0             	mov    %rax,%r8
  80421085d0:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421085d7:	00 00 00 
  80421085da:	be c8 03 00 00       	mov    $0x3c8,%esi
  80421085df:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421085e6:	00 00 00 
  80421085e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80421085ee:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421085f5:	00 00 00 
  80421085f8:	41 ff d1             	call   *%r9
  80421085fb:	49 89 c0             	mov    %rax,%r8
  80421085fe:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042108605:	00 00 00 
  8042108608:	be ce 03 00 00       	mov    $0x3ce,%esi
  804210860d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108614:	00 00 00 
  8042108617:	b8 00 00 00 00       	mov    $0x0,%eax
  804210861c:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042108623:	00 00 00 
  8042108626:	41 ff d1             	call   *%r9
    assert(0);
  8042108629:	48 b9 c7 f7 11 42 80 	movabs $0x804211f7c7,%rcx
  8042108630:	00 00 00 
  8042108633:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210863a:	00 00 00 
  804210863d:	be d9 03 00 00       	mov    $0x3d9,%esi
  8042108642:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108649:	00 00 00 
  804210864c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108651:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108658:	00 00 00 
  804210865b:	41 ff d0             	call   *%r8
    asm volatile("movq %%cr3,%0"
  804210865e:	0f 20 d8             	mov    %cr3,%rax
    asm volatile("movq %0,%%cr3" ::"r"(val));
  8042108661:	0f 22 d8             	mov    %rax,%cr3
}
  8042108664:	e9 45 f9 ff ff       	jmp    8042107fae <unmap_page+0x9b>
        assert(!res);
  8042108669:	48 b9 05 f9 11 42 80 	movabs $0x804211f905,%rcx
  8042108670:	00 00 00 
  8042108673:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210867a:	00 00 00 
  804210867d:	be c7 03 00 00       	mov    $0x3c7,%esi
  8042108682:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108689:	00 00 00 
  804210868c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108691:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108698:	00 00 00 
  804210869b:	41 ff d0             	call   *%r8
            dst[i] = base;
  804210869e:	48 89 31             	mov    %rsi,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  80421086a1:	48 81 c6 00 00 20 00 	add    $0x200000,%rsi
  80421086a8:	48 83 c1 08          	add    $0x8,%rcx
  80421086ac:	48 39 f0             	cmp    %rsi,%rax
  80421086af:	0f 84 e6 fb ff ff    	je     804210829b <unmap_page+0x388>
            if ((PTE_ADDR(base) & (step - 1)))
  80421086b5:	f7 c6 00 f0 1f 00    	test   $0x1ff000,%esi
  80421086bb:	74 e1                	je     804210869e <unmap_page+0x78b>
                cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  80421086bd:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  80421086c4:	ff ff 7f 
  80421086c7:	48 21 c6             	and    %rax,%rsi
  80421086ca:	ba 00 00 20 00       	mov    $0x200000,%edx
  80421086cf:	48 bf f8 f8 11 42 80 	movabs $0x804211f8f8,%rdi
  80421086d6:	00 00 00 
  80421086d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80421086de:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  80421086e5:	00 00 00 
  80421086e8:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  80421086ea:	48 b9 a8 0e 12 42 80 	movabs $0x8042120ea8,%rcx
  80421086f1:	00 00 00 
  80421086f4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421086fb:	00 00 00 
  80421086fe:	be 3b 03 00 00       	mov    $0x33b,%esi
  8042108703:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210870a:	00 00 00 
  804210870d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108712:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108719:	00 00 00 
  804210871c:	41 ff d0             	call   *%r8
        assert(!res);
  804210871f:	48 b9 05 f9 11 42 80 	movabs $0x804211f905,%rcx
  8042108726:	00 00 00 
  8042108729:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108730:	00 00 00 
  8042108733:	be 9d 03 00 00       	mov    $0x39d,%esi
  8042108738:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210873f:	00 00 00 
  8042108742:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108747:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210874e:	00 00 00 
  8042108751:	41 ff d0             	call   *%r8

0000008042108754 <unmap_region>:
unmap_region(struct AddressSpace *dspace, uintptr_t dst, uintptr_t size) {
  8042108754:	f3 0f 1e fa          	endbr64
  8042108758:	55                   	push   %rbp
  8042108759:	48 89 e5             	mov    %rsp,%rbp
  804210875c:	41 57                	push   %r15
  804210875e:	41 56                	push   %r14
  8042108760:	41 55                	push   %r13
  8042108762:	41 54                	push   %r12
  8042108764:	53                   	push   %rbx
  8042108765:	48 83 ec 18          	sub    $0x18,%rsp
  8042108769:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  804210876d:	48 89 f0             	mov    %rsi,%rax
    uintptr_t start = ROUNDDOWN(dst, 1ULL << CLASS_BASE);
  8042108770:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
    uintptr_t end = ROUNDUP(dst + size, 1ULL << CLASS_BASE);
  8042108777:	4c 8d b4 10 ff 0f 00 	lea    0xfff(%rax,%rdx,1),%r14
  804210877e:	00 
  804210877f:	49 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%r14
    for (; class < MAX_CLASS && start + CLASS_SIZE(class) <= end; class ++) {
  8042108786:	4c 8d a6 00 10 00 00 	lea    0x1000(%rsi),%r12
  804210878d:	4d 39 e6             	cmp    %r12,%r14
  8042108790:	72 48                	jb     80421087da <unmap_region+0x86>
    int class = 0;
  8042108792:	bb 00 00 00 00       	mov    $0x0,%ebx
            unmap_page(dspace, start, class);
  8042108797:	49 bf 13 7f 10 42 80 	movabs $0x8042107f13,%r15
  804210879e:	00 00 00 
  80421087a1:	eb 20                	jmp    80421087c3 <unmap_region+0x6f>
    for (; class < MAX_CLASS && start + CLASS_SIZE(class) <= end; class ++) {
  80421087a3:	44 8d 6b 01          	lea    0x1(%rbx),%r13d
  80421087a7:	83 fb 2f             	cmp    $0x2f,%ebx
  80421087aa:	74 34                	je     80421087e0 <unmap_region+0x8c>
  80421087ac:	8d 4b 0d             	lea    0xd(%rbx),%ecx
  80421087af:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  80421087b5:	49 d3 e4             	shl    %cl,%r12
  80421087b8:	49 01 f4             	add    %rsi,%r12
  80421087bb:	4d 39 e6             	cmp    %r12,%r14
  80421087be:	72 20                	jb     80421087e0 <unmap_region+0x8c>
  80421087c0:	44 89 eb             	mov    %r13d,%ebx
        if (start & CLASS_SIZE(class)) {
  80421087c3:	8d 43 0c             	lea    0xc(%rbx),%eax
  80421087c6:	48 0f a3 c6          	bt     %rax,%rsi
  80421087ca:	73 d7                	jae    80421087a3 <unmap_region+0x4f>
            unmap_page(dspace, start, class);
  80421087cc:	89 da                	mov    %ebx,%edx
  80421087ce:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  80421087d2:	41 ff d7             	call   *%r15
            start += CLASS_SIZE(class);
  80421087d5:	4c 89 e6             	mov    %r12,%rsi
  80421087d8:	eb c9                	jmp    80421087a3 <unmap_region+0x4f>
    int class = 0;
  80421087da:	41 bd 00 00 00 00    	mov    $0x0,%r13d
    for (; class >= 0 && start < end; class --) {
  80421087e0:	45 85 ed             	test   %r13d,%r13d
  80421087e3:	78 0f                	js     80421087f4 <unmap_region+0xa0>
            unmap_page(dspace, start, class);
  80421087e5:	49 bc 13 7f 10 42 80 	movabs $0x8042107f13,%r12
  80421087ec:	00 00 00 
    for (; class >= 0 && start < end; class --) {
  80421087ef:	4c 39 f6             	cmp    %r14,%rsi
  80421087f2:	72 1a                	jb     804210880e <unmap_region+0xba>
}
  80421087f4:	48 83 c4 18          	add    $0x18,%rsp
  80421087f8:	5b                   	pop    %rbx
  80421087f9:	41 5c                	pop    %r12
  80421087fb:	41 5d                	pop    %r13
  80421087fd:	41 5e                	pop    %r14
  80421087ff:	41 5f                	pop    %r15
  8042108801:	5d                   	pop    %rbp
  8042108802:	c3                   	ret
    for (; class >= 0 && start < end; class --) {
  8042108803:	41 83 ed 01          	sub    $0x1,%r13d
  8042108807:	78 eb                	js     80421087f4 <unmap_region+0xa0>
  8042108809:	4c 39 f6             	cmp    %r14,%rsi
  804210880c:	73 e6                	jae    80421087f4 <unmap_region+0xa0>
        if (start + CLASS_SIZE(class) <= end) {
  804210880e:	41 8d 4d 0c          	lea    0xc(%r13),%ecx
  8042108812:	bb 01 00 00 00       	mov    $0x1,%ebx
  8042108817:	48 d3 e3             	shl    %cl,%rbx
  804210881a:	48 01 f3             	add    %rsi,%rbx
  804210881d:	49 39 de             	cmp    %rbx,%r14
  8042108820:	72 e1                	jb     8042108803 <unmap_region+0xaf>
            unmap_page(dspace, start, class);
  8042108822:	44 89 ea             	mov    %r13d,%edx
  8042108825:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042108829:	41 ff d4             	call   *%r12
            start += CLASS_SIZE(class);
  804210882c:	48 89 de             	mov    %rbx,%rsi
  804210882f:	eb d2                	jmp    8042108803 <unmap_region+0xaf>

0000008042108831 <release_address_space>:
release_address_space(struct AddressSpace *space) {
  8042108831:	f3 0f 1e fa          	endbr64
  8042108835:	55                   	push   %rbp
  8042108836:	48 89 e5             	mov    %rsp,%rbp
  8042108839:	41 57                	push   %r15
  804210883b:	41 56                	push   %r14
  804210883d:	41 55                	push   %r13
  804210883f:	41 54                	push   %r12
  8042108841:	53                   	push   %rbx
  8042108842:	48 83 ec 18          	sub    $0x18,%rsp
  8042108846:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  804210884a:	bb 01 00 00 00       	mov    $0x1,%ebx
        if (kspace.pml4[i] & PTE_P && i != UVPT_INDEX)
  804210884f:	49 bc e0 10 00 43 80 	movabs $0x80430010e0,%r12
  8042108856:	00 00 00 
            page_unref(page_lookup(NULL, PTE_ADDR(kspace.pml4[i]), 0, PARTIAL_NODE, 0));
  8042108859:	49 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%r15
  8042108860:	ff ff 7f 
  8042108863:	49 be d7 67 10 42 80 	movabs $0x80421067d7,%r14
  804210886a:	00 00 00 
  804210886d:	49 bd 56 49 10 42 80 	movabs $0x8042104956,%r13
  8042108874:	00 00 00 
  8042108877:	eb 2e                	jmp    80421088a7 <release_address_space+0x76>
  8042108879:	4c 21 fe             	and    %r15,%rsi
  804210887c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8042108882:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8042108887:	ba 00 00 00 00       	mov    $0x0,%edx
  804210888c:	bf 00 00 00 00       	mov    $0x0,%edi
  8042108891:	41 ff d6             	call   *%r14
  8042108894:	48 89 c7             	mov    %rax,%rdi
  8042108897:	41 ff d5             	call   *%r13
    for (size_t i = NUSERPML4; i < PML4_ENTRY_COUNT; i++) {
  804210889a:	48 83 c3 01          	add    $0x1,%rbx
  804210889e:	48 81 fb 00 02 00 00 	cmp    $0x200,%rbx
  80421088a5:	74 19                	je     80421088c0 <release_address_space+0x8f>
        if (kspace.pml4[i] & PTE_P && i != UVPT_INDEX)
  80421088a7:	49 8b 04 24          	mov    (%r12),%rax
  80421088ab:	48 8b 34 d8          	mov    (%rax,%rbx,8),%rsi
  80421088af:	40 f6 c6 01          	test   $0x1,%sil
  80421088b3:	74 e5                	je     804210889a <release_address_space+0x69>
  80421088b5:	48 81 fb ff 00 00 00 	cmp    $0xff,%rbx
  80421088bc:	74 dc                	je     804210889a <release_address_space+0x69>
  80421088be:	eb b9                	jmp    8042108879 <release_address_space+0x48>
    unmap_page(space, 0, MAX_CLASS);
  80421088c0:	ba 30 00 00 00       	mov    $0x30,%edx
  80421088c5:	be 00 00 00 00       	mov    $0x0,%esi
  80421088ca:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  80421088ce:	48 89 df             	mov    %rbx,%rdi
  80421088d1:	48 b8 13 7f 10 42 80 	movabs $0x8042107f13,%rax
  80421088d8:	00 00 00 
  80421088db:	ff d0                	call   *%rax
    page_unref(page_lookup(NULL, space->cr3, 0, PARTIAL_NODE, 0));
  80421088dd:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  80421088e1:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80421088e7:	b9 00 00 30 00       	mov    $0x300000,%ecx
  80421088ec:	ba 00 00 00 00       	mov    $0x0,%edx
  80421088f1:	bf 00 00 00 00       	mov    $0x0,%edi
  80421088f6:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  80421088fd:	00 00 00 
  8042108900:	ff d0                	call   *%rax
  8042108902:	48 89 c7             	mov    %rax,%rdi
  8042108905:	48 b8 56 49 10 42 80 	movabs $0x8042104956,%rax
  804210890c:	00 00 00 
  804210890f:	ff d0                	call   *%rax
    memset(space, 0, sizeof *space);
  8042108911:	ba 18 00 00 00       	mov    $0x18,%edx
  8042108916:	be 00 00 00 00       	mov    $0x0,%esi
  804210891b:	48 89 df             	mov    %rbx,%rdi
  804210891e:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042108925:	00 00 00 
  8042108928:	ff d0                	call   *%rax
}
  804210892a:	48 83 c4 18          	add    $0x18,%rsp
  804210892e:	5b                   	pop    %rbx
  804210892f:	41 5c                	pop    %r12
  8042108931:	41 5d                	pop    %r13
  8042108933:	41 5e                	pop    %r14
  8042108935:	41 5f                	pop    %r15
  8042108937:	5d                   	pop    %rbp
  8042108938:	c3                   	ret

0000008042108939 <map_page>:
map_page(struct AddressSpace *spc, uintptr_t addr, struct Page *page, int flags) {
  8042108939:	f3 0f 1e fa          	endbr64
  804210893d:	55                   	push   %rbp
  804210893e:	48 89 e5             	mov    %rsp,%rbp
  8042108941:	41 57                	push   %r15
  8042108943:	41 56                	push   %r14
  8042108945:	41 55                	push   %r13
  8042108947:	41 54                	push   %r12
  8042108949:	53                   	push   %rbx
  804210894a:	48 83 ec 28          	sub    $0x28,%rsp
  804210894e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  8042108952:	89 c8                	mov    %ecx,%eax
  8042108954:	f7 d0                	not    %eax
  8042108956:	a8 c0                	test   $0xc0,%al
  8042108958:	0f 84 93 02 00 00    	je     8042108bf1 <map_page+0x2b8>
  804210895e:	49 89 f5             	mov    %rsi,%r13
  8042108961:	49 89 d4             	mov    %rdx,%r12
  8042108964:	41 89 cf             	mov    %ecx,%r15d
    assert(page && spc);
  8042108967:	48 85 d2             	test   %rdx,%rdx
  804210896a:	0f 84 b6 02 00 00    	je     8042108c26 <map_page+0x2ed>
  8042108970:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8042108975:	0f 84 ab 02 00 00    	je     8042108c26 <map_page+0x2ed>
    assert_physical(page);
  804210897b:	8b 42 28             	mov    0x28(%rdx),%eax
  804210897e:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042108983:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8042108988:	0f 86 cd 02 00 00    	jbe    8042108c5b <map_page+0x322>
    assert(!(addr & CLASS_MASK(page->class)));
  804210898e:	0f b7 4a 34          	movzwl 0x34(%rdx),%ecx
  8042108992:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042108998:	83 c1 0c             	add    $0xc,%ecx
  804210899b:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80421089a2:	48 d3 e0             	shl    %cl,%rax
  80421089a5:	48 f7 d0             	not    %rax
  80421089a8:	48 85 f0             	test   %rsi,%rax
  80421089ab:	0f 85 df 02 00 00    	jne    8042108c90 <map_page+0x357>
    if (!is_new_page) {
  80421089b1:	83 7a 30 00          	cmpl   $0x0,0x30(%rdx)
  80421089b5:	0f 85 0a 03 00 00    	jne    8042108cc5 <map_page+0x38c>
    if (!(flags & ALLOC_WEAK)) {
  80421089bb:	41 f7 c7 00 00 02 00 	test   $0x20000,%r15d
  80421089c2:	0f 85 88 00 00 00    	jne    8042108a50 <map_page+0x117>
        page_ref(page);
  80421089c8:	4c 89 e7             	mov    %r12,%rdi
  80421089cb:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  80421089d2:	00 00 00 
  80421089d5:	ff d0                	call   *%rax
        unmap_page(spc, addr, page->class);
  80421089d7:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  80421089dd:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  80421089e3:	4c 89 ee             	mov    %r13,%rsi
  80421089e6:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  80421089ea:	48 89 df             	mov    %rbx,%rdi
  80421089ed:	48 b8 13 7f 10 42 80 	movabs $0x8042107f13,%rax
  80421089f4:	00 00 00 
  80421089f7:	ff d0                	call   *%rax
        struct Page *mapping = page_lookup_virtual(spc->root, addr, page->class, LOOKUP_ALLOC);
  80421089f9:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  80421089ff:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  8042108a05:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  8042108a09:	b9 01 00 00 00       	mov    $0x1,%ecx
  8042108a0e:	4c 89 ee             	mov    %r13,%rsi
  8042108a11:	48 b8 fa 72 10 42 80 	movabs $0x80421072fa,%rax
  8042108a18:	00 00 00 
  8042108a1b:	ff d0                	call   *%rax
        if (!mapping) return -E_NO_MEM;
  8042108a1d:	48 85 c0             	test   %rax,%rax
  8042108a20:	0f 84 5f 0e 00 00    	je     8042109885 <map_page+0xf4c>
        mapping->phy = page;
  8042108a26:	4c 89 60 30          	mov    %r12,0x30(%rax)
        mapping->state = (PAGE_PROT(flags) & ~PROT_COMBINE) | MAPPING_NODE;
  8042108a2a:	44 89 fa             	mov    %r15d,%edx
  8042108a2d:	81 e2 ff fe 0f ff    	and    $0xff0ffeff,%edx
  8042108a33:	81 ca 00 00 10 00    	or     $0x100000,%edx
  8042108a39:	89 50 28             	mov    %edx,0x28(%rax)
    struct List *list_next = list->next;
  8042108a3c:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    list_prev->next = list_cur;
  8042108a41:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    list_next->prev = list_cur;
  8042108a46:	48 89 02             	mov    %rax,(%rdx)
    list_cur->prev = list_prev;
  8042108a49:	4c 89 20             	mov    %r12,(%rax)
    list_cur->next = list_next;
  8042108a4c:	48 89 50 08          	mov    %rdx,0x8(%rax)
    uintptr_t end = addr + CLASS_SIZE(page->class);
  8042108a50:	41 0f b7 4c 24 34    	movzwl 0x34(%r12),%ecx
  8042108a56:	89 ce                	mov    %ecx,%esi
  8042108a58:	66 81 e6 ff 0f       	and    $0xfff,%si
  8042108a5d:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  8042108a63:	83 c1 0c             	add    $0xc,%ecx
  8042108a66:	41 be 01 00 00 00    	mov    $0x1,%r14d
  8042108a6c:	49 d3 e6             	shl    %cl,%r14
  8042108a6f:	4d 01 ee             	add    %r13,%r14
    return page->addr << CLASS_BASE;
  8042108a72:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8042108a79:	ff 0f 00 
  8042108a7c:	48 89 d0             	mov    %rdx,%rax
  8042108a7f:	49 23 44 24 38       	and    0x38(%r12),%rax
  8042108a84:	48 c1 e0 0c          	shl    $0xc,%rax
  8042108a88:	48 21 d0             	and    %rdx,%rax
    pte_t res = PTE_P | (flags & (PTE_AVAIL | PTE_PCD | PTE_PWT));
  8042108a8b:	44 89 fb             	mov    %r15d,%ebx
  8042108a8e:	81 e3 18 0e 00 00    	and    $0xe18,%ebx
    if (flags & PROT_W && !(flags & PROT_LAZY))
  8042108a94:	44 89 ff             	mov    %r15d,%edi
  8042108a97:	81 e7 82 00 00 00    	and    $0x82,%edi
    pte_t res = PTE_P | (flags & (PTE_AVAIL | PTE_PCD | PTE_PWT));
  8042108a9d:	89 da                	mov    %ebx,%edx
  8042108a9f:	83 ca 01             	or     $0x1,%edx
  8042108aa2:	83 cb 03             	or     $0x3,%ebx
  8042108aa5:	83 ff 02             	cmp    $0x2,%edi
  8042108aa8:	0f 45 da             	cmovne %edx,%ebx
  8042108aab:	48 63 db             	movslq %ebx,%rbx
    if (!(flags & PROT_X) && nx_supported)
  8042108aae:	41 f6 c7 01          	test   $0x1,%r15b
  8042108ab2:	75 20                	jne    8042108ad4 <map_page+0x19b>
  8042108ab4:	48 ba 29 61 00 43 80 	movabs $0x8043006129,%rdx
  8042108abb:	00 00 00 
  8042108abe:	0f b6 12             	movzbl (%rdx),%edx
  8042108ac1:	48 f7 da             	neg    %rdx
  8042108ac4:	48 bf 00 00 00 00 00 	movabs $0x8000000000000000,%rdi
  8042108acb:	00 00 80 
  8042108ace:	48 21 fa             	and    %rdi,%rdx
  8042108ad1:	48 09 d3             	or     %rdx,%rbx
        res |= PTE_SHARE;
  8042108ad4:	48 89 da             	mov    %rbx,%rdx
  8042108ad7:	80 ce 04             	or     $0x4,%dh
  8042108ada:	41 f6 c7 40          	test   $0x40,%r15b
  8042108ade:	48 0f 45 da          	cmovne %rdx,%rbx
        res |= PTE_U;
  8042108ae2:	48 89 da             	mov    %rbx,%rdx
  8042108ae5:	48 83 ca 04          	or     $0x4,%rdx
  8042108ae9:	41 f6 c7 20          	test   $0x20,%r15b
  8042108aed:	48 0f 45 da          	cmovne %rdx,%rbx
    uintptr_t base = page2pa(page) | prot2pte(flags);
  8042108af1:	48 09 c3             	or     %rax,%rbx
    assert(!(page2pa(page) & CLASS_MASK(page->class)));
  8042108af4:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  8042108afb:	48 d3 e2             	shl    %cl,%rdx
  8042108afe:	48 f7 d2             	not    %rdx
  8042108b01:	48 85 c2             	test   %rax,%rdx
  8042108b04:	0f 85 de 01 00 00    	jne    8042108ce8 <map_page+0x3af>
    size_t pml4i0 = PML4_INDEX(addr), pml4i1 = PML4_INDEX(end);
  8042108b0a:	4d 89 ef             	mov    %r13,%r15
  8042108b0d:	49 c1 ef 27          	shr    $0x27,%r15
  8042108b11:	41 81 e7 ff 01 00 00 	and    $0x1ff,%r15d
    if (page->class >= 27) {
  8042108b18:	66 83 fe 1a          	cmp    $0x1a,%si
  8042108b1c:	0f 87 fb 01 00 00    	ja     8042108d1d <map_page+0x3e4>
    if (!(spc->pml4[pml4i0] & PTE_P)) {
  8042108b22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042108b26:	48 8b 00             	mov    (%rax),%rax
  8042108b29:	4a 8d 04 f8          	lea    (%rax,%r15,8),%rax
  8042108b2d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042108b31:	f6 00 01             	testb  $0x1,(%rax)
  8042108b34:	0f 84 0a 04 00 00    	je     8042108f44 <map_page+0x60b>
    assert(!(spc->pml4[pml4i0] & PTE_PS)); /* There's (yet) no support for 512GB pages in x86 arch */
  8042108b3a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042108b3e:	48 8b 00             	mov    (%rax),%rax
  8042108b41:	4a 8b 0c f8          	mov    (%rax,%r15,8),%rcx
  8042108b45:	f6 c1 80             	test   $0x80,%cl
  8042108b48:	0f 85 1c 05 00 00    	jne    804210906a <map_page+0x731>
    pdpe_t *pdp = KADDR(PTE_ADDR(spc->pml4[pml4i0]));
  8042108b4e:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8042108b55:	ff ff 7f 
  8042108b58:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  8042108b5b:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042108b62:	00 00 00 
  8042108b65:	48 39 c8             	cmp    %rcx,%rax
  8042108b68:	0f 82 31 05 00 00    	jb     804210909f <map_page+0x766>
    return (void *)(pa + KERN_BASE_ADDR);
  8042108b6e:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042108b75:	00 00 00 
  8042108b78:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
    size_t pdpi0 = PDP_INDEX(addr), pdpi1 = PDP_INDEX(end);
  8042108b7c:	4c 89 ea             	mov    %r13,%rdx
  8042108b7f:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8042108b83:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8042108b89:	4c 89 f6             	mov    %r14,%rsi
  8042108b8c:	48 c1 ee 1e          	shr    $0x1e,%rsi
  8042108b90:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
    if (pdpi0 > pdpi1)
  8042108b96:	48 39 d6             	cmp    %rdx,%rsi
  8042108b99:	0f 82 f7 0f 00 00    	jb     8042109b96 <map_page+0x125d>
    if (page->class >= 18)
  8042108b9f:	41 0f b7 44 24 34    	movzwl 0x34(%r12),%eax
  8042108ba5:	66 25 ff 0f          	and    $0xfff,%ax
  8042108ba9:	66 83 f8 11          	cmp    $0x11,%ax
  8042108bad:	0f 86 f7 0f 00 00    	jbe    8042109baa <map_page+0x1271>
    assert(i0 < i1);
  8042108bb3:	48 39 f2             	cmp    %rsi,%rdx
  8042108bb6:	0f 82 16 05 00 00    	jb     80421090d2 <map_page+0x799>
  8042108bbc:	48 b9 da f8 11 42 80 	movabs $0x804211f8da,%rcx
  8042108bc3:	00 00 00 
  8042108bc6:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108bcd:	00 00 00 
  8042108bd0:	be 25 03 00 00       	mov    $0x325,%esi
  8042108bd5:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108bdc:	00 00 00 
  8042108bdf:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108be4:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108beb:	00 00 00 
  8042108bee:	41 ff d0             	call   *%r8
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  8042108bf1:	48 b9 c8 0e 12 42 80 	movabs $0x8042120ec8,%rcx
  8042108bf8:	00 00 00 
  8042108bfb:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108c02:	00 00 00 
  8042108c05:	be e1 03 00 00       	mov    $0x3e1,%esi
  8042108c0a:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108c11:	00 00 00 
  8042108c14:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108c19:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108c20:	00 00 00 
  8042108c23:	41 ff d0             	call   *%r8
    assert(page && spc);
  8042108c26:	48 b9 0a f9 11 42 80 	movabs $0x804211f90a,%rcx
  8042108c2d:	00 00 00 
  8042108c30:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108c37:	00 00 00 
  8042108c3a:	be e2 03 00 00       	mov    $0x3e2,%esi
  8042108c3f:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108c46:	00 00 00 
  8042108c49:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108c4e:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108c55:	00 00 00 
  8042108c58:	41 ff d0             	call   *%r8
    assert_physical(page);
  8042108c5b:	48 b9 b0 06 12 42 80 	movabs $0x80421206b0,%rcx
  8042108c62:	00 00 00 
  8042108c65:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108c6c:	00 00 00 
  8042108c6f:	be e3 03 00 00       	mov    $0x3e3,%esi
  8042108c74:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108c7b:	00 00 00 
  8042108c7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108c83:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108c8a:	00 00 00 
  8042108c8d:	41 ff d0             	call   *%r8
    assert(!(addr & CLASS_MASK(page->class)));
  8042108c90:	48 b9 f8 0e 12 42 80 	movabs $0x8042120ef8,%rcx
  8042108c97:	00 00 00 
  8042108c9a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108ca1:	00 00 00 
  8042108ca4:	be e4 03 00 00       	mov    $0x3e4,%esi
  8042108ca9:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108cb0:	00 00 00 
  8042108cb3:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108cb8:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108cbf:	00 00 00 
  8042108cc2:	41 ff d0             	call   *%r8
        delete_from_lru_list(page);
  8042108cc5:	48 89 d7             	mov    %rdx,%rdi
  8042108cc8:	48 b8 10 17 11 42 80 	movabs $0x8042111710,%rax
  8042108ccf:	00 00 00 
  8042108cd2:	ff d0                	call   *%rax
        add_to_lru_list(page);
  8042108cd4:	4c 89 e7             	mov    %r12,%rdi
  8042108cd7:	48 b8 90 16 11 42 80 	movabs $0x8042111690,%rax
  8042108cde:	00 00 00 
  8042108ce1:	ff d0                	call   *%rax
  8042108ce3:	e9 d3 fc ff ff       	jmp    80421089bb <map_page+0x82>
    assert(!(page2pa(page) & CLASS_MASK(page->class)));
  8042108ce8:	48 b9 d0 07 12 42 80 	movabs $0x80421207d0,%rcx
  8042108cef:	00 00 00 
  8042108cf2:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108cf9:	00 00 00 
  8042108cfc:	be 06 04 00 00       	mov    $0x406,%esi
  8042108d01:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108d08:	00 00 00 
  8042108d0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108d10:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108d17:	00 00 00 
  8042108d1a:	41 ff d0             	call   *%r8
    size_t pml4i0 = PML4_INDEX(addr), pml4i1 = PML4_INDEX(end);
  8042108d1d:	49 c1 ee 27          	shr    $0x27,%r14
  8042108d21:	4c 89 f0             	mov    %r14,%rax
  8042108d24:	25 ff 01 00 00       	and    $0x1ff,%eax
        int res = alloc_fill_pt(spc->pml4, base, 512 * GB, pml4i0, pml4i1);
  8042108d29:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042108d2d:	48 8b 16             	mov    (%rsi),%rdx
    assert(i0 < i1);
  8042108d30:	49 39 c7             	cmp    %rax,%r15
  8042108d33:	73 1b                	jae    8042108d50 <map_page+0x417>
  8042108d35:	4e 8d 24 fa          	lea    (%rdx,%r15,8),%r12
  8042108d39:	4c 8d 34 c2          	lea    (%rdx,%rax,8),%r14
    if (pa > max_memory_map_addr)
  8042108d3d:	49 bf f8 10 00 43 80 	movabs $0x80430010f8,%r15
  8042108d44:	00 00 00 
  8042108d47:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8042108d4b:	e9 f9 00 00 00       	jmp    8042108e49 <map_page+0x510>
  8042108d50:	48 b9 da f8 11 42 80 	movabs $0x804211f8da,%rcx
  8042108d57:	00 00 00 
  8042108d5a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108d61:	00 00 00 
  8042108d64:	be 25 03 00 00       	mov    $0x325,%esi
  8042108d69:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108d70:	00 00 00 
  8042108d73:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108d78:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108d7f:	00 00 00 
  8042108d82:	41 ff d0             	call   *%r8
        assert(!page->refc);
  8042108d85:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042108d8c:	00 00 00 
  8042108d8f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042108d96:	00 00 00 
  8042108d99:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042108d9e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108da5:	00 00 00 
  8042108da8:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108dad:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042108db4:	00 00 00 
  8042108db7:	41 ff d0             	call   *%r8
    return (void *)(pa + KERN_BASE_ADDR);
  8042108dba:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042108dc1:	00 00 00 
  8042108dc4:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042108dc8:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042108dcd:	be 00 00 00 00       	mov    $0x0,%esi
  8042108dd2:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042108dd9:	00 00 00 
  8042108ddc:	ff d0                	call   *%rax
            res = alloc_fill_pt(KADDR(PTE_ADDR(dst[i])), base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  8042108dde:	48 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdi
  8042108de5:	ff ff 7f 
  8042108de8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042108dec:	48 23 38             	and    (%rax),%rdi
    if (pa > max_memory_map_addr)
  8042108def:	4d 8b 07             	mov    (%r15),%r8
  8042108df2:	49 39 f8             	cmp    %rdi,%r8
  8042108df5:	0f 82 c2 0a 00 00    	jb     80421098bd <map_page+0xf84>
    return (void *)(pa + KERN_BASE_ADDR);
  8042108dfb:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042108e02:	00 00 00 
  8042108e05:	48 01 c7             	add    %rax,%rdi
  8042108e08:	41 b8 00 02 00 00    	mov    $0x200,%r8d
  8042108e0e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8042108e13:	ba 00 00 00 40       	mov    $0x40000000,%edx
  8042108e18:	48 89 de             	mov    %rbx,%rsi
  8042108e1b:	48 b8 ed 79 10 42 80 	movabs $0x80421079ed,%rax
  8042108e22:	00 00 00 
  8042108e25:	ff d0                	call   *%rax
            if (res < 0)
  8042108e27:	85 c0                	test   %eax,%eax
  8042108e29:	0f 88 0c 01 00 00    	js     8042108f3b <map_page+0x602>
    for (size_t i = i0; i < i1; i++, base += step) {
  8042108e2f:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  8042108e36:	00 00 00 
  8042108e39:	48 01 c3             	add    %rax,%rbx
  8042108e3c:	49 83 c4 08          	add    $0x8,%r12
  8042108e40:	4d 39 e6             	cmp    %r12,%r14
  8042108e43:	0f 84 bd 00 00 00    	je     8042108f06 <map_page+0x5cd>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8042108e49:	4c 89 65 c0          	mov    %r12,-0x40(%rbp)
  8042108e4d:	49 8b 04 24          	mov    (%r12),%rax
  8042108e51:	25 81 00 00 00       	and    $0x81,%eax
  8042108e56:	48 83 f8 01          	cmp    $0x1,%rax
  8042108e5a:	74 82                	je     8042108dde <map_page+0x4a5>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8042108e5c:	be 00 00 04 00       	mov    $0x40000,%esi
  8042108e61:	bf 00 00 00 00       	mov    $0x0,%edi
  8042108e66:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  8042108e6d:	00 00 00 
  8042108e70:	ff d0                	call   *%rax
  8042108e72:	49 89 c5             	mov    %rax,%r13
        if (!page) return -E_NO_MEM;
  8042108e75:	48 85 c0             	test   %rax,%rax
  8042108e78:	0f 84 b1 00 00 00    	je     8042108f2f <map_page+0x5f6>
        assert(!page->refc);
  8042108e7e:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042108e82:	0f 85 fd fe ff ff    	jne    8042108d85 <map_page+0x44c>
        page_ref(page);
  8042108e88:	48 89 c7             	mov    %rax,%rdi
  8042108e8b:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  8042108e92:	00 00 00 
  8042108e95:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8042108e97:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  8042108e9e:	ff 0f 00 
  8042108ea1:	49 23 45 38          	and    0x38(%r13),%rax
  8042108ea5:	48 c1 e0 0c          	shl    $0xc,%rax
  8042108ea9:	48 bf ff ff ff ff ff 	movabs $0xfffffffffffff,%rdi
  8042108eb0:	ff 0f 00 
  8042108eb3:	48 21 f8             	and    %rdi,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8042108eb6:	48 83 c8 07          	or     $0x7,%rax
  8042108eba:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8042108ebe:	48 89 06             	mov    %rax,(%rsi)
  8042108ec1:	48 89 f9             	mov    %rdi,%rcx
  8042108ec4:	49 23 4d 38          	and    0x38(%r13),%rcx
  8042108ec8:	48 c1 e1 0c          	shl    $0xc,%rcx
  8042108ecc:	48 21 f9             	and    %rdi,%rcx
    if (pa > max_memory_map_addr)
  8042108ecf:	4d 8b 07             	mov    (%r15),%r8
  8042108ed2:	49 39 c8             	cmp    %rcx,%r8
  8042108ed5:	0f 83 df fe ff ff    	jae    8042108dba <map_page+0x481>
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042108edb:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042108ee2:	00 00 00 
  8042108ee5:	be ff 02 00 00       	mov    $0x2ff,%esi
  8042108eea:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042108ef1:	00 00 00 
  8042108ef4:	b8 00 00 00 00       	mov    $0x0,%eax
  8042108ef9:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042108f00:	00 00 00 
  8042108f03:	41 ff d1             	call   *%r9
    return 0;
  8042108f06:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042108f0a:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        if (pml4i1 - 1 >= NUSERPML4)
  8042108f10:	48 83 f8 01          	cmp    $0x1,%rax
  8042108f14:	0f 84 59 09 00 00    	je     8042109873 <map_page+0xf3a>
            propagate_pml4(spc);
  8042108f1a:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042108f1e:	48 b8 48 71 10 42 80 	movabs $0x8042107148,%rax
  8042108f25:	00 00 00 
  8042108f28:	ff d0                	call   *%rax
  8042108f2a:	e9 44 09 00 00       	jmp    8042109873 <map_page+0xf3a>
        if (!page) return -E_NO_MEM;
  8042108f2f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042108f33:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  8042108f39:	eb d5                	jmp    8042108f10 <map_page+0x5d7>
  8042108f3b:	41 89 c5             	mov    %eax,%r13d
  8042108f3e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042108f42:	eb cc                	jmp    8042108f10 <map_page+0x5d7>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  8042108f44:	be 00 00 04 00       	mov    $0x40000,%esi
  8042108f49:	bf 00 00 00 00       	mov    $0x0,%edi
  8042108f4e:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  8042108f55:	00 00 00 
  8042108f58:	ff d0                	call   *%rax
  8042108f5a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (!page) return -E_NO_MEM;
  8042108f5e:	48 85 c0             	test   %rax,%rax
  8042108f61:	0f 84 26 09 00 00    	je     804210988d <map_page+0xf54>
        assert(!page->refc);
  8042108f67:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042108f6b:	0f 85 96 00 00 00    	jne    8042109007 <map_page+0x6ce>
        page_ref(page);
  8042108f71:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042108f75:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  8042108f7c:	00 00 00 
  8042108f7f:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8042108f81:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8042108f88:	ff 0f 00 
  8042108f8b:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042108f8f:	48 89 d0             	mov    %rdx,%rax
  8042108f92:	48 23 47 38          	and    0x38(%rdi),%rax
  8042108f96:	48 c1 e0 0c          	shl    $0xc,%rax
  8042108f9a:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8042108f9d:	48 83 c8 07          	or     $0x7,%rax
  8042108fa1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8042108fa5:	48 89 06             	mov    %rax,(%rsi)
  8042108fa8:	48 89 d1             	mov    %rdx,%rcx
  8042108fab:	48 23 4f 38          	and    0x38(%rdi),%rcx
  8042108faf:	48 c1 e1 0c          	shl    $0xc,%rcx
  8042108fb3:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8042108fb6:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042108fbd:	00 00 00 
  8042108fc0:	48 39 c8             	cmp    %rcx,%rax
  8042108fc3:	72 77                	jb     804210903c <map_page+0x703>
    return (void *)(pa + KERN_BASE_ADDR);
  8042108fc5:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042108fcc:	00 00 00 
  8042108fcf:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042108fd3:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042108fd8:	be 00 00 00 00       	mov    $0x0,%esi
  8042108fdd:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042108fe4:	00 00 00 
  8042108fe7:	ff d0                	call   *%rax
        if (pml4i0 >= NUSERPML4)
  8042108fe9:	4d 85 ff             	test   %r15,%r15
  8042108fec:	0f 84 48 fb ff ff    	je     8042108b3a <map_page+0x201>
            propagate_pml4(spc);
  8042108ff2:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042108ff6:	48 b8 48 71 10 42 80 	movabs $0x8042107148,%rax
  8042108ffd:	00 00 00 
  8042109000:	ff d0                	call   *%rax
  8042109002:	e9 33 fb ff ff       	jmp    8042108b3a <map_page+0x201>
        assert(!page->refc);
  8042109007:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  804210900e:	00 00 00 
  8042109011:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109018:	00 00 00 
  804210901b:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042109020:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109027:	00 00 00 
  804210902a:	b8 00 00 00 00       	mov    $0x0,%eax
  804210902f:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109036:	00 00 00 
  8042109039:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804210903c:	49 89 c0             	mov    %rax,%r8
  804210903f:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042109046:	00 00 00 
  8042109049:	be ff 02 00 00       	mov    $0x2ff,%esi
  804210904e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109055:	00 00 00 
  8042109058:	b8 00 00 00 00       	mov    $0x0,%eax
  804210905d:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042109064:	00 00 00 
  8042109067:	41 ff d1             	call   *%r9
    assert(!(spc->pml4[pml4i0] & PTE_PS)); /* There's (yet) no support for 512GB pages in x86 arch */
  804210906a:	48 b9 16 f9 11 42 80 	movabs $0x804211f916,%rcx
  8042109071:	00 00 00 
  8042109074:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210907b:	00 00 00 
  804210907e:	be 1a 04 00 00       	mov    $0x41a,%esi
  8042109083:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210908a:	00 00 00 
  804210908d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109092:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109099:	00 00 00 
  804210909c:	41 ff d0             	call   *%r8
  804210909f:	49 89 c0             	mov    %rax,%r8
  80421090a2:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421090a9:	00 00 00 
  80421090ac:	be 1b 04 00 00       	mov    $0x41b,%esi
  80421090b1:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421090b8:	00 00 00 
  80421090bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80421090c0:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421090c7:	00 00 00 
  80421090ca:	41 ff d1             	call   *%r9
        pdpi1 = PDP_ENTRY_COUNT;
  80421090cd:	be 00 02 00 00       	mov    $0x200,%esi
    bool need_recur = step > 1 * GB || (step == 1 * GB && !has_1gb_pages);
  80421090d2:	a0 28 61 00 43 80 00 	movabs 0x8043006128,%al
  80421090d9:	00 00 
  80421090db:	41 89 c6             	mov    %eax,%r14d
  80421090de:	41 83 f6 01          	xor    $0x1,%r14d
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  80421090e2:	49 89 d8             	mov    %rbx,%r8
  80421090e5:	41 80 c8 80          	or     $0x80,%r8b
  80421090e9:	3c 01                	cmp    $0x1,%al
  80421090eb:	49 0f 44 d8          	cmove  %r8,%rbx
    for (size_t i = i0; i < i1; i++, base += step) {
  80421090ef:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  80421090f6:	00 00 00 
  80421090f9:	4c 8d 24 d0          	lea    (%rax,%rdx,8),%r12
  80421090fd:	49 01 cc             	add    %rcx,%r12
  8042109100:	4c 8d 3c f7          	lea    (%rdi,%rsi,8),%r15
  8042109104:	e9 fa 07 00 00       	jmp    8042109903 <map_page+0xfca>
            int res = alloc_pt(dst + i);
  8042109109:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  804210910d:	49 8b 04 24          	mov    (%r12),%rax
  8042109111:	25 81 00 00 00       	and    $0x81,%eax
  8042109116:	48 83 f8 01          	cmp    $0x1,%rax
  804210911a:	75 63                	jne    804210917f <map_page+0x846>
            res = alloc_fill_pt(KADDR(PTE_ADDR(dst[i])), base, step / PT_ENTRY_COUNT, 0, PT_ENTRY_COUNT);
  804210911c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042109120:	48 bf 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rdi
  8042109127:	ff ff 7f 
  804210912a:	48 23 38             	and    (%rax),%rdi
    if (pa > max_memory_map_addr)
  804210912d:	48 b8 f8 10 00 43 80 	movabs $0x80430010f8,%rax
  8042109134:	00 00 00 
  8042109137:	4c 8b 00             	mov    (%rax),%r8
  804210913a:	49 39 f8             	cmp    %rdi,%r8
  804210913d:	0f 82 3f 01 00 00    	jb     8042109282 <map_page+0x949>
    return (void *)(pa + KERN_BASE_ADDR);
  8042109143:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804210914a:	00 00 00 
  804210914d:	48 01 c7             	add    %rax,%rdi
  8042109150:	41 b8 00 02 00 00    	mov    $0x200,%r8d
  8042109156:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210915b:	ba 00 00 20 00       	mov    $0x200000,%edx
  8042109160:	48 89 de             	mov    %rbx,%rsi
  8042109163:	48 b8 ed 79 10 42 80 	movabs $0x80421079ed,%rax
  804210916a:	00 00 00 
  804210916d:	ff d0                	call   *%rax
            if (res < 0)
  804210916f:	85 c0                	test   %eax,%eax
  8042109171:	0f 89 78 07 00 00    	jns    80421098ef <map_page+0xfb6>
  8042109177:	41 89 c5             	mov    %eax,%r13d
  804210917a:	e9 f4 06 00 00       	jmp    8042109873 <map_page+0xf3a>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  804210917f:	be 00 00 04 00       	mov    $0x40000,%esi
  8042109184:	bf 00 00 00 00       	mov    $0x0,%edi
  8042109189:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  8042109190:	00 00 00 
  8042109193:	ff d0                	call   *%rax
  8042109195:	49 89 c5             	mov    %rax,%r13
        if (!page) return -E_NO_MEM;
  8042109198:	48 85 c0             	test   %rax,%rax
  804210919b:	0f 84 f4 06 00 00    	je     8042109895 <map_page+0xf5c>
        assert(!page->refc);
  80421091a1:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  80421091a5:	75 7b                	jne    8042109222 <map_page+0x8e9>
        page_ref(page);
  80421091a7:	48 89 c7             	mov    %rax,%rdi
  80421091aa:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  80421091b1:	00 00 00 
  80421091b4:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  80421091b6:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  80421091bd:	ff 0f 00 
  80421091c0:	48 89 d0             	mov    %rdx,%rax
  80421091c3:	49 23 45 38          	and    0x38(%r13),%rax
  80421091c7:	48 c1 e0 0c          	shl    $0xc,%rax
  80421091cb:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  80421091ce:	48 83 c8 07          	or     $0x7,%rax
  80421091d2:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80421091d6:	48 89 06             	mov    %rax,(%rsi)
  80421091d9:	48 89 d1             	mov    %rdx,%rcx
  80421091dc:	49 23 4d 38          	and    0x38(%r13),%rcx
  80421091e0:	48 c1 e1 0c          	shl    $0xc,%rcx
  80421091e4:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  80421091e7:	48 b8 f8 10 00 43 80 	movabs $0x80430010f8,%rax
  80421091ee:	00 00 00 
  80421091f1:	4c 8b 00             	mov    (%rax),%r8
  80421091f4:	49 39 c8             	cmp    %rcx,%r8
  80421091f7:	72 5e                	jb     8042109257 <map_page+0x91e>
    return (void *)(pa + KERN_BASE_ADDR);
  80421091f9:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042109200:	00 00 00 
  8042109203:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042109207:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210920c:	be 00 00 00 00       	mov    $0x0,%esi
  8042109211:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042109218:	00 00 00 
  804210921b:	ff d0                	call   *%rax
  804210921d:	e9 fa fe ff ff       	jmp    804210911c <map_page+0x7e3>
        assert(!page->refc);
  8042109222:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042109229:	00 00 00 
  804210922c:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109233:	00 00 00 
  8042109236:	be f8 02 00 00       	mov    $0x2f8,%esi
  804210923b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109242:	00 00 00 
  8042109245:	b8 00 00 00 00       	mov    $0x0,%eax
  804210924a:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109251:	00 00 00 
  8042109254:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042109257:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210925e:	00 00 00 
  8042109261:	be ff 02 00 00       	mov    $0x2ff,%esi
  8042109266:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210926d:	00 00 00 
  8042109270:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109275:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210927c:	00 00 00 
  804210927f:	41 ff d1             	call   *%r9
  8042109282:	48 89 f9             	mov    %rdi,%rcx
  8042109285:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210928c:	00 00 00 
  804210928f:	be 33 03 00 00       	mov    $0x333,%esi
  8042109294:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210929b:	00 00 00 
  804210929e:	b8 00 00 00 00       	mov    $0x0,%eax
  80421092a3:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421092aa:	00 00 00 
  80421092ad:	41 ff d1             	call   *%r9
    return 0;
  80421092b0:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  80421092b6:	e9 b8 05 00 00       	jmp    8042109873 <map_page+0xf3a>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  80421092bb:	be 00 00 04 00       	mov    $0x40000,%esi
  80421092c0:	bf 00 00 00 00       	mov    $0x0,%edi
  80421092c5:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  80421092cc:	00 00 00 
  80421092cf:	ff d0                	call   *%rax
  80421092d1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        if (!page) return -E_NO_MEM;
  80421092d5:	48 85 c0             	test   %rax,%rax
  80421092d8:	0f 84 bf 05 00 00    	je     804210989d <map_page+0xf64>
        assert(!page->refc);
  80421092de:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  80421092e2:	75 79                	jne    804210935d <map_page+0xa24>
        page_ref(page);
  80421092e4:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  80421092e8:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  80421092ef:	00 00 00 
  80421092f2:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  80421092f4:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  80421092fb:	ff 0f 00 
  80421092fe:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042109302:	48 89 d0             	mov    %rdx,%rax
  8042109305:	48 23 46 38          	and    0x38(%rsi),%rax
  8042109309:	48 c1 e0 0c          	shl    $0xc,%rax
  804210930d:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8042109310:	48 83 c8 07          	or     $0x7,%rax
  8042109314:	49 89 07             	mov    %rax,(%r15)
  8042109317:	48 89 d1             	mov    %rdx,%rcx
  804210931a:	48 23 4e 38          	and    0x38(%rsi),%rcx
  804210931e:	48 c1 e1 0c          	shl    $0xc,%rcx
  8042109322:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8042109325:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210932c:	00 00 00 
  804210932f:	48 39 c8             	cmp    %rcx,%rax
  8042109332:	72 5e                	jb     8042109392 <map_page+0xa59>
    return (void *)(pa + KERN_BASE_ADDR);
  8042109334:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804210933b:	00 00 00 
  804210933e:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042109342:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042109347:	be 00 00 00 00       	mov    $0x0,%esi
  804210934c:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042109353:	00 00 00 
  8042109356:	ff d0                	call   *%rax
  8042109358:	e9 5b 08 00 00       	jmp    8042109bb8 <map_page+0x127f>
        assert(!page->refc);
  804210935d:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042109364:	00 00 00 
  8042109367:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210936e:	00 00 00 
  8042109371:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042109376:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210937d:	00 00 00 
  8042109380:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109385:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210938c:	00 00 00 
  804210938f:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042109392:	49 89 c0             	mov    %rax,%r8
  8042109395:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210939c:	00 00 00 
  804210939f:	be ff 02 00 00       	mov    $0x2ff,%esi
  80421093a4:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421093ab:	00 00 00 
  80421093ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80421093b3:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421093ba:	00 00 00 
  80421093bd:	41 ff d1             	call   *%r9
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  80421093c0:	be 00 00 04 00       	mov    $0x40000,%esi
  80421093c5:	bf 00 00 00 00       	mov    $0x0,%edi
  80421093ca:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  80421093d1:	00 00 00 
  80421093d4:	ff d0                	call   *%rax
  80421093d6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (!page) return -E_NO_MEM;
  80421093da:	48 85 c0             	test   %rax,%rax
  80421093dd:	0f 84 c2 04 00 00    	je     80421098a5 <map_page+0xf6c>
        assert(!page->refc);
  80421093e3:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  80421093e7:	75 79                	jne    8042109462 <map_page+0xb29>
        page_ref(page);
  80421093e9:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  80421093ed:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  80421093f4:	00 00 00 
  80421093f7:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  80421093f9:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  8042109400:	ff 0f 00 
  8042109403:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8042109407:	48 89 d0             	mov    %rdx,%rax
  804210940a:	48 23 47 38          	and    0x38(%rdi),%rax
  804210940e:	48 c1 e0 0c          	shl    $0xc,%rax
  8042109412:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8042109415:	48 83 c8 07          	or     $0x7,%rax
  8042109419:	49 89 07             	mov    %rax,(%r15)
  804210941c:	48 89 d1             	mov    %rdx,%rcx
  804210941f:	48 23 4f 38          	and    0x38(%rdi),%rcx
  8042109423:	48 c1 e1 0c          	shl    $0xc,%rcx
  8042109427:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  804210942a:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042109431:	00 00 00 
  8042109434:	48 39 c8             	cmp    %rcx,%rax
  8042109437:	72 5e                	jb     8042109497 <map_page+0xb5e>
    return (void *)(pa + KERN_BASE_ADDR);
  8042109439:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042109440:	00 00 00 
  8042109443:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042109447:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210944c:	be 00 00 00 00       	mov    $0x0,%esi
  8042109451:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042109458:	00 00 00 
  804210945b:	ff d0                	call   *%rax
  804210945d:	e9 74 07 00 00       	jmp    8042109bd6 <map_page+0x129d>
        assert(!page->refc);
  8042109462:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042109469:	00 00 00 
  804210946c:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109473:	00 00 00 
  8042109476:	be f8 02 00 00       	mov    $0x2f8,%esi
  804210947b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109482:	00 00 00 
  8042109485:	b8 00 00 00 00       	mov    $0x0,%eax
  804210948a:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109491:	00 00 00 
  8042109494:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  8042109497:	49 89 c0             	mov    %rax,%r8
  804210949a:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421094a1:	00 00 00 
  80421094a4:	be ff 02 00 00       	mov    $0x2ff,%esi
  80421094a9:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421094b0:	00 00 00 
  80421094b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80421094b8:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421094bf:	00 00 00 
  80421094c2:	41 ff d1             	call   *%r9
  80421094c5:	49 89 c0             	mov    %rax,%r8
  80421094c8:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421094cf:	00 00 00 
  80421094d2:	be 31 04 00 00       	mov    $0x431,%esi
  80421094d7:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421094de:	00 00 00 
  80421094e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80421094e6:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421094ed:	00 00 00 
  80421094f0:	41 ff d1             	call   *%r9
    pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi0]));
  80421094f3:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  80421094fa:	ff ff 7f 
  80421094fd:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8042109500:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042109507:	00 00 00 
  804210950a:	48 39 c8             	cmp    %rcx,%rax
  804210950d:	72 7e                	jb     804210958d <map_page+0xc54>
    return (void *)(pa + KERN_BASE_ADDR);
  804210950f:	48 be 00 00 00 40 80 	movabs $0x8040000000,%rsi
  8042109516:	00 00 00 
  8042109519:	48 01 ce             	add    %rcx,%rsi
    size_t pdi0 = PD_INDEX(addr);
  804210951c:	4c 89 e8             	mov    %r13,%rax
  804210951f:	48 c1 e8 15          	shr    $0x15,%rax
  8042109523:	25 ff 01 00 00       	and    $0x1ff,%eax
    size_t pdi1 = PD_INDEX(end);
  8042109528:	4c 89 f2             	mov    %r14,%rdx
  804210952b:	48 c1 ea 15          	shr    $0x15,%rdx
  804210952f:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    if (pdi0 > pdi1) {
  8042109535:	48 39 c2             	cmp    %rax,%rdx
  8042109538:	0f 82 44 05 00 00    	jb     8042109a82 <map_page+0x1149>
    if (page->class >= 9) {
  804210953e:	41 0f b7 7c 24 34    	movzwl 0x34(%r12),%edi
  8042109544:	66 81 e7 ff 0f       	and    $0xfff,%di
  8042109549:	66 83 ff 08          	cmp    $0x8,%di
  804210954d:	0f 86 44 05 00 00    	jbe    8042109a97 <map_page+0x115e>
    assert(i0 < i1);
  8042109553:	48 39 d0             	cmp    %rdx,%rax
  8042109556:	72 68                	jb     80421095c0 <map_page+0xc87>
  8042109558:	48 b9 da f8 11 42 80 	movabs $0x804211f8da,%rcx
  804210955f:	00 00 00 
  8042109562:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109569:	00 00 00 
  804210956c:	be 25 03 00 00       	mov    $0x325,%esi
  8042109571:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109578:	00 00 00 
  804210957b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109580:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109587:	00 00 00 
  804210958a:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804210958d:	49 89 c0             	mov    %rax,%r8
  8042109590:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  8042109597:	00 00 00 
  804210959a:	be 36 04 00 00       	mov    $0x436,%esi
  804210959f:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421095a6:	00 00 00 
  80421095a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80421095ae:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421095b5:	00 00 00 
  80421095b8:	41 ff d1             	call   *%r9
		pdi1 = PD_ENTRY_COUNT;
  80421095bb:	ba 00 02 00 00       	mov    $0x200,%edx
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  80421095c0:	80 cb 80             	or     $0x80,%bl
    for (size_t i = i0; i < i1; i++, base += step) {
  80421095c3:	48 bf 00 00 00 40 80 	movabs $0x8040000000,%rdi
  80421095ca:	00 00 00 
  80421095cd:	48 8d 04 c7          	lea    (%rdi,%rax,8),%rax
  80421095d1:	48 01 c8             	add    %rcx,%rax
  80421095d4:	48 8d 14 d6          	lea    (%rsi,%rdx,8),%rdx
  80421095d8:	e9 ac 03 00 00       	jmp    8042109989 <map_page+0x1050>
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  80421095dd:	be 00 00 04 00       	mov    $0x40000,%esi
  80421095e2:	bf 00 00 00 00       	mov    $0x0,%edi
  80421095e7:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  80421095ee:	00 00 00 
  80421095f1:	ff d0                	call   *%rax
  80421095f3:	49 89 c4             	mov    %rax,%r12
        if (!page) return -E_NO_MEM;
  80421095f6:	48 85 c0             	test   %rax,%rax
  80421095f9:	0f 84 ae 02 00 00    	je     80421098ad <map_page+0xf74>
        assert(!page->refc);
  80421095ff:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042109603:	75 76                	jne    804210967b <map_page+0xd42>
        page_ref(page);
  8042109605:	48 89 c7             	mov    %rax,%rdi
  8042109608:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  804210960f:	00 00 00 
  8042109612:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8042109614:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  804210961b:	ff 0f 00 
  804210961e:	48 89 d0             	mov    %rdx,%rax
  8042109621:	49 23 44 24 38       	and    0x38(%r12),%rax
  8042109626:	48 c1 e0 0c          	shl    $0xc,%rax
  804210962a:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  804210962d:	48 83 c8 07          	or     $0x7,%rax
  8042109631:	49 89 07             	mov    %rax,(%r15)
  8042109634:	48 89 d1             	mov    %rdx,%rcx
  8042109637:	49 23 4c 24 38       	and    0x38(%r12),%rcx
  804210963c:	48 c1 e1 0c          	shl    $0xc,%rcx
  8042109640:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8042109643:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210964a:	00 00 00 
  804210964d:	48 39 c8             	cmp    %rcx,%rax
  8042109650:	72 5e                	jb     80421096b0 <map_page+0xd77>
    return (void *)(pa + KERN_BASE_ADDR);
  8042109652:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042109659:	00 00 00 
  804210965c:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042109660:	ba 00 10 00 00       	mov    $0x1000,%edx
  8042109665:	be 00 00 00 00       	mov    $0x0,%esi
  804210966a:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042109671:	00 00 00 
  8042109674:	ff d0                	call   *%rax
  8042109676:	e9 2a 04 00 00       	jmp    8042109aa5 <map_page+0x116c>
        assert(!page->refc);
  804210967b:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042109682:	00 00 00 
  8042109685:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210968c:	00 00 00 
  804210968f:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042109694:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210969b:	00 00 00 
  804210969e:	b8 00 00 00 00       	mov    $0x0,%eax
  80421096a3:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421096aa:	00 00 00 
  80421096ad:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  80421096b0:	49 89 c0             	mov    %rax,%r8
  80421096b3:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421096ba:	00 00 00 
  80421096bd:	be ff 02 00 00       	mov    $0x2ff,%esi
  80421096c2:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421096c9:	00 00 00 
  80421096cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80421096d1:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421096d8:	00 00 00 
  80421096db:	41 ff d1             	call   *%r9
        struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  80421096de:	be 00 00 04 00       	mov    $0x40000,%esi
  80421096e3:	bf 00 00 00 00       	mov    $0x0,%edi
  80421096e8:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  80421096ef:	00 00 00 
  80421096f2:	ff d0                	call   *%rax
  80421096f4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        if (!page) return -E_NO_MEM;
  80421096f8:	48 85 c0             	test   %rax,%rax
  80421096fb:	0f 84 b4 01 00 00    	je     80421098b5 <map_page+0xf7c>
        assert(!page->refc);
  8042109701:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042109705:	75 79                	jne    8042109780 <map_page+0xe47>
        page_ref(page);
  8042109707:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210970b:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  8042109712:	00 00 00 
  8042109715:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  8042109717:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  804210971e:	ff 0f 00 
  8042109721:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042109725:	48 89 d0             	mov    %rdx,%rax
  8042109728:	48 23 47 38          	and    0x38(%rdi),%rax
  804210972c:	48 c1 e0 0c          	shl    $0xc,%rax
  8042109730:	48 21 d0             	and    %rdx,%rax
        *dst = page2pa(page) | PTE_U | PTE_W | PTE_P;
  8042109733:	48 83 c8 07          	or     $0x7,%rax
  8042109737:	49 89 07             	mov    %rax,(%r15)
  804210973a:	48 89 d1             	mov    %rdx,%rcx
  804210973d:	48 23 4f 38          	and    0x38(%rdi),%rcx
  8042109741:	48 c1 e1 0c          	shl    $0xc,%rcx
  8042109745:	48 21 d1             	and    %rdx,%rcx
    if (pa > max_memory_map_addr)
  8042109748:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210974f:	00 00 00 
  8042109752:	48 39 c8             	cmp    %rcx,%rax
  8042109755:	72 5e                	jb     80421097b5 <map_page+0xe7c>
    return (void *)(pa + KERN_BASE_ADDR);
  8042109757:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804210975e:	00 00 00 
  8042109761:	48 8d 3c 01          	lea    (%rcx,%rax,1),%rdi
        memset(KADDR(page2pa(page)), 0, CLASS_SIZE(0));
  8042109765:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210976a:	be 00 00 00 00       	mov    $0x0,%esi
  804210976f:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042109776:	00 00 00 
  8042109779:	ff d0                	call   *%rax
  804210977b:	e9 40 03 00 00       	jmp    8042109ac0 <map_page+0x1187>
        assert(!page->refc);
  8042109780:	48 b9 ec f8 11 42 80 	movabs $0x804211f8ec,%rcx
  8042109787:	00 00 00 
  804210978a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109791:	00 00 00 
  8042109794:	be f8 02 00 00       	mov    $0x2f8,%esi
  8042109799:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421097a0:	00 00 00 
  80421097a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80421097a8:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421097af:	00 00 00 
  80421097b2:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  80421097b5:	49 89 c0             	mov    %rax,%r8
  80421097b8:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421097bf:	00 00 00 
  80421097c2:	be ff 02 00 00       	mov    $0x2ff,%esi
  80421097c7:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421097ce:	00 00 00 
  80421097d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80421097d6:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421097dd:	00 00 00 
  80421097e0:	41 ff d1             	call   *%r9
  80421097e3:	49 89 c0             	mov    %rax,%r8
  80421097e6:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421097ed:	00 00 00 
  80421097f0:	be 53 04 00 00       	mov    $0x453,%esi
  80421097f5:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421097fc:	00 00 00 
  80421097ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109804:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210980b:	00 00 00 
  804210980e:	41 ff d1             	call   *%r9
  8042109811:	49 89 c0             	mov    %rax,%r8
  8042109814:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210981b:	00 00 00 
  804210981e:	be 56 04 00 00       	mov    $0x456,%esi
  8042109823:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210982a:	00 00 00 
  804210982d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109832:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  8042109839:	00 00 00 
  804210983c:	41 ff d1             	call   *%r9
        pti1 = PT_ENTRY_COUNT;
  804210983f:	41 be 00 02 00 00    	mov    $0x200,%r14d
  8042109845:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804210984c:	00 00 00 
  804210984f:	4a 8d 04 e8          	lea    (%rax,%r13,8),%rax
  8042109853:	48 01 c8             	add    %rcx,%rax
  8042109856:	4a 8d 14 f2          	lea    (%rdx,%r14,8),%rdx
            dst[i] = base;
  804210985a:	48 89 18             	mov    %rbx,(%rax)
    for (size_t i = i0; i < i1; i++, base += step) {
  804210985d:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
  8042109864:	48 83 c0 08          	add    $0x8,%rax
  8042109868:	48 39 c2             	cmp    %rax,%rdx
  804210986b:	75 ed                	jne    804210985a <map_page+0xf21>
        return alloc_fill_pt(pt, base, 4 * KB, pti0, pti1);
  804210986d:	41 bd 00 00 00 00    	mov    $0x0,%r13d
}
  8042109873:	44 89 e8             	mov    %r13d,%eax
  8042109876:	48 83 c4 28          	add    $0x28,%rsp
  804210987a:	5b                   	pop    %rbx
  804210987b:	41 5c                	pop    %r12
  804210987d:	41 5d                	pop    %r13
  804210987f:	41 5e                	pop    %r14
  8042109881:	41 5f                	pop    %r15
  8042109883:	5d                   	pop    %rbp
  8042109884:	c3                   	ret
        if (!mapping) return -E_NO_MEM;
  8042109885:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  804210988b:	eb e6                	jmp    8042109873 <map_page+0xf3a>
            return -E_NO_MEM;
  804210988d:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  8042109893:	eb de                	jmp    8042109873 <map_page+0xf3a>
        if (!page) return -E_NO_MEM;
  8042109895:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  804210989b:	eb d6                	jmp    8042109873 <map_page+0xf3a>
        return -E_NO_MEM;
  804210989d:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80421098a3:	eb ce                	jmp    8042109873 <map_page+0xf3a>
            return -E_NO_MEM;
  80421098a5:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80421098ab:	eb c6                	jmp    8042109873 <map_page+0xf3a>
        return -E_NO_MEM;
  80421098ad:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80421098b3:	eb be                	jmp    8042109873 <map_page+0xf3a>
        if (alloc_pt(pd + pdi0) < 0) return -E_NO_MEM;
  80421098b5:	41 bd fc ff ff ff    	mov    $0xfffffffc,%r13d
  80421098bb:	eb b6                	jmp    8042109873 <map_page+0xf3a>
  80421098bd:	48 89 f9             	mov    %rdi,%rcx
  80421098c0:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  80421098c7:	00 00 00 
  80421098ca:	be 33 03 00 00       	mov    $0x333,%esi
  80421098cf:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421098d6:	00 00 00 
  80421098d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80421098de:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  80421098e5:	00 00 00 
  80421098e8:	41 ff d1             	call   *%r9
            dst[i] = base;
  80421098eb:	49 89 1c 24          	mov    %rbx,(%r12)
    for (size_t i = i0; i < i1; i++, base += step) {
  80421098ef:	48 81 c3 00 00 00 40 	add    $0x40000000,%rbx
  80421098f6:	49 83 c4 08          	add    $0x8,%r12
  80421098fa:	4d 39 e7             	cmp    %r12,%r15
  80421098fd:	0f 84 ad f9 ff ff    	je     80421092b0 <map_page+0x977>
        if (need_recur) {
  8042109903:	45 84 f6             	test   %r14b,%r14b
  8042109906:	0f 85 fd f7 ff ff    	jne    8042109109 <map_page+0x7d0>
            if ((PTE_ADDR(base) & (step - 1)))
  804210990c:	f7 c3 00 f0 ff 3f    	test   $0x3ffff000,%ebx
  8042109912:	74 d7                	je     80421098eb <map_page+0xfb2>
                cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  8042109914:	48 be 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rsi
  804210991b:	ff ff 7f 
  804210991e:	48 21 de             	and    %rbx,%rsi
  8042109921:	ba 00 00 00 40       	mov    $0x40000000,%edx
  8042109926:	48 bf f8 f8 11 42 80 	movabs $0x804211f8f8,%rdi
  804210992d:	00 00 00 
  8042109930:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109935:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  804210993c:	00 00 00 
  804210993f:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  8042109941:	48 b9 a8 0e 12 42 80 	movabs $0x8042120ea8,%rcx
  8042109948:	00 00 00 
  804210994b:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109952:	00 00 00 
  8042109955:	be 3b 03 00 00       	mov    $0x33b,%esi
  804210995a:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109961:	00 00 00 
  8042109964:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109969:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109970:	00 00 00 
  8042109973:	41 ff d0             	call   *%r8
            dst[i] = base;
  8042109976:	48 89 18             	mov    %rbx,(%rax)
    for (size_t i = i0; i < i1; i++, base += step) {
  8042109979:	48 81 c3 00 00 20 00 	add    $0x200000,%rbx
  8042109980:	48 83 c0 08          	add    $0x8,%rax
  8042109984:	48 39 d0             	cmp    %rdx,%rax
  8042109987:	74 6d                	je     80421099f6 <map_page+0x10bd>
            if ((PTE_ADDR(base) & (step - 1)))
  8042109989:	f7 c3 00 f0 1f 00    	test   $0x1ff000,%ebx
  804210998f:	74 e5                	je     8042109976 <map_page+0x103d>
                cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  8042109991:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8042109998:	ff ff 7f 
  804210999b:	48 89 de             	mov    %rbx,%rsi
  804210999e:	48 21 c6             	and    %rax,%rsi
  80421099a1:	ba 00 00 20 00       	mov    $0x200000,%edx
  80421099a6:	48 bf f8 f8 11 42 80 	movabs $0x804211f8f8,%rdi
  80421099ad:	00 00 00 
  80421099b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80421099b5:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  80421099bc:	00 00 00 
  80421099bf:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  80421099c1:	48 b9 a8 0e 12 42 80 	movabs $0x8042120ea8,%rcx
  80421099c8:	00 00 00 
  80421099cb:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  80421099d2:	00 00 00 
  80421099d5:	be 3b 03 00 00       	mov    $0x33b,%esi
  80421099da:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  80421099e1:	00 00 00 
  80421099e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80421099e9:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  80421099f0:	00 00 00 
  80421099f3:	41 ff d0             	call   *%r8
		return alloc_fill_pt(pd, base, 2 * MB, pdi0, pdi1);
  80421099f6:	41 bd 00 00 00 00    	mov    $0x0,%r13d
  80421099fc:	e9 72 fe ff ff       	jmp    8042109873 <map_page+0xf3a>
            dst[i] = base;
  8042109a01:	48 89 31             	mov    %rsi,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  8042109a04:	48 81 c6 00 00 20 00 	add    $0x200000,%rsi
  8042109a0b:	48 83 c1 08          	add    $0x8,%rcx
  8042109a0f:	48 39 c6             	cmp    %rax,%rsi
  8042109a12:	0f 84 db fa ff ff    	je     80421094f3 <map_page+0xbba>
            if ((PTE_ADDR(base) & (step - 1)))
  8042109a18:	f7 c6 00 f0 1f 00    	test   $0x1ff000,%esi
  8042109a1e:	74 e1                	je     8042109a01 <map_page+0x10c8>
                cprintf("%08lX %08lX\n", (long)PTE_ADDR(base), step);
  8042109a20:	48 b8 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rax
  8042109a27:	ff ff 7f 
  8042109a2a:	48 21 c6             	and    %rax,%rsi
  8042109a2d:	ba 00 00 20 00       	mov    $0x200000,%edx
  8042109a32:	48 bf f8 f8 11 42 80 	movabs $0x804211f8f8,%rdi
  8042109a39:	00 00 00 
  8042109a3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109a41:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  8042109a48:	00 00 00 
  8042109a4b:	ff d1                	call   *%rcx
            assert(!(PTE_ADDR(base) & (step - 1)));
  8042109a4d:	48 b9 a8 0e 12 42 80 	movabs $0x8042120ea8,%rcx
  8042109a54:	00 00 00 
  8042109a57:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109a5e:	00 00 00 
  8042109a61:	be 3b 03 00 00       	mov    $0x33b,%esi
  8042109a66:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109a6d:	00 00 00 
  8042109a70:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109a75:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109a7c:	00 00 00 
  8042109a7f:	41 ff d0             	call   *%r8
    if (page->class >= 9) {
  8042109a82:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  8042109a88:	66 81 e2 ff 0f       	and    $0xfff,%dx
  8042109a8d:	66 83 fa 08          	cmp    $0x8,%dx
  8042109a91:	0f 87 24 fb ff ff    	ja     80421095bb <map_page+0xc82>
    if (!(pd[pdi0] & PTE_P) && alloc_pt(pd + pdi0) < 0) {
  8042109a97:	4c 8d 3c c6          	lea    (%rsi,%rax,8),%r15
  8042109a9b:	41 f6 07 01          	testb  $0x1,(%r15)
  8042109a9f:	0f 84 38 fb ff ff    	je     80421095dd <map_page+0xca4>
	} else if (pd[pdi0] & PTE_PS) {
  8042109aa5:	4d 8b 27             	mov    (%r15),%r12
  8042109aa8:	41 f6 c4 80          	test   $0x80,%r12b
  8042109aac:	74 5e                	je     8042109b0c <map_page+0x11d3>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8042109aae:	4c 89 e0             	mov    %r12,%rax
  8042109ab1:	25 81 00 00 00       	and    $0x81,%eax
  8042109ab6:	48 83 f8 01          	cmp    $0x1,%rax
  8042109aba:	0f 85 1e fc ff ff    	jne    80421096de <map_page+0xda5>
        pte_t *pt = KADDR(PTE_ADDR(pd[pdi0]));
  8042109ac0:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042109ac7:	ff ff 7f 
  8042109aca:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8042109acd:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042109ad4:	00 00 00 
  8042109ad7:	48 39 c8             	cmp    %rcx,%rax
  8042109ada:	0f 82 03 fd ff ff    	jb     80421097e3 <map_page+0xeaa>
    return (void *)(pa + KERN_BASE_ADDR);
  8042109ae0:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042109ae7:	00 00 00 
  8042109aea:	48 01 c1             	add    %rax,%rcx
        if (alloc_fill_pt(pt, old & ~PTE_PS, 4 * KB, 0, PT_ENTRY_COUNT) < 0) return -E_NO_MEM;
  8042109aed:	41 80 e4 7f          	and    $0x7f,%r12b
    for (size_t i = i0; i < i1; i++, base += step) {
  8042109af1:	49 8d 84 24 00 00 20 	lea    0x200000(%r12),%rax
  8042109af8:	00 
            dst[i] = base;
  8042109af9:	4c 89 21             	mov    %r12,(%rcx)
    for (size_t i = i0; i < i1; i++, base += step) {
  8042109afc:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
  8042109b03:	48 83 c1 08          	add    $0x8,%rcx
  8042109b07:	49 39 c4             	cmp    %rax,%r12
  8042109b0a:	75 ed                	jne    8042109af9 <map_page+0x11c0>
    pte_t *pt = KADDR(PTE_ADDR(pd[pdi0]));
  8042109b0c:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042109b13:	ff ff 7f 
  8042109b16:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8042109b19:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042109b20:	00 00 00 
  8042109b23:	48 39 c8             	cmp    %rcx,%rax
  8042109b26:	0f 82 e5 fc ff ff    	jb     8042109811 <map_page+0xed8>
    return (void *)(pa + KERN_BASE_ADDR);
  8042109b2c:	48 ba 00 00 00 40 80 	movabs $0x8040000000,%rdx
  8042109b33:	00 00 00 
  8042109b36:	48 01 ca             	add    %rcx,%rdx
    size_t pti0 = PT_INDEX(addr), pti1 = PT_INDEX(end);
  8042109b39:	49 c1 ed 0c          	shr    $0xc,%r13
  8042109b3d:	41 81 e5 ff 01 00 00 	and    $0x1ff,%r13d
  8042109b44:	49 c1 ee 0c          	shr    $0xc,%r14
  8042109b48:	41 81 e6 ff 01 00 00 	and    $0x1ff,%r14d
    if (pti0 > pti1)
  8042109b4f:	4d 39 ee             	cmp    %r13,%r14
  8042109b52:	0f 82 e7 fc ff ff    	jb     804210983f <map_page+0xf06>
    assert(i0 < i1);
  8042109b58:	4d 39 f5             	cmp    %r14,%r13
  8042109b5b:	0f 82 e4 fc ff ff    	jb     8042109845 <map_page+0xf0c>
  8042109b61:	48 b9 da f8 11 42 80 	movabs $0x804211f8da,%rcx
  8042109b68:	00 00 00 
  8042109b6b:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109b72:	00 00 00 
  8042109b75:	be 25 03 00 00       	mov    $0x325,%esi
  8042109b7a:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109b81:	00 00 00 
  8042109b84:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109b89:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109b90:	00 00 00 
  8042109b93:	41 ff d0             	call   *%r8
    if (page->class >= 18)
  8042109b96:	41 0f b7 44 24 34    	movzwl 0x34(%r12),%eax
  8042109b9c:	66 25 ff 0f          	and    $0xfff,%ax
  8042109ba0:	66 83 f8 11          	cmp    $0x11,%ax
  8042109ba4:	0f 87 23 f5 ff ff    	ja     80421090cd <map_page+0x794>
    if (!(pdp[pdpi0] & PTE_P) && alloc_pt(pdp + pdpi0) < 0) {
  8042109baa:	4c 8d 3c d7          	lea    (%rdi,%rdx,8),%r15
  8042109bae:	41 f6 07 01          	testb  $0x1,(%r15)
  8042109bb2:	0f 84 03 f7 ff ff    	je     80421092bb <map_page+0x982>
    } else if (pdp[pdpi0] & PTE_PS) {
  8042109bb8:	49 8b 07             	mov    (%r15),%rax
  8042109bbb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8042109bbf:	a8 80                	test   $0x80,%al
  8042109bc1:	0f 84 2c f9 ff ff    	je     80421094f3 <map_page+0xbba>
    if (!(*dst & PTE_P) || (*dst & PTE_PS)) {
  8042109bc7:	25 81 00 00 00       	and    $0x81,%eax
  8042109bcc:	48 83 f8 01          	cmp    $0x1,%rax
  8042109bd0:	0f 85 ea f7 ff ff    	jne    80421093c0 <map_page+0xa87>
        pde_t *pd = KADDR(PTE_ADDR(pdp[pdpi0]));
  8042109bd6:	48 b9 00 f0 ff ff ff 	movabs $0x7ffffffffffff000,%rcx
  8042109bdd:	ff ff 7f 
  8042109be0:	49 23 0f             	and    (%r15),%rcx
    if (pa > max_memory_map_addr)
  8042109be3:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  8042109bea:	00 00 00 
  8042109bed:	48 39 c8             	cmp    %rcx,%rax
  8042109bf0:	0f 82 cf f8 ff ff    	jb     80421094c5 <map_page+0xb8c>
    return (void *)(pa + KERN_BASE_ADDR);
  8042109bf6:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  8042109bfd:	00 00 00 
  8042109c00:	48 01 c1             	add    %rax,%rcx
    if (!need_recur && step != 4 * KB) base |= PTE_PS;
  8042109c03:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042109c07:	40 80 ce 80          	or     $0x80,%sil
    for (size_t i = i0; i < i1; i++, base += step) {
  8042109c0b:	48 8d 86 00 00 00 40 	lea    0x40000000(%rsi),%rax
  8042109c12:	e9 01 fe ff ff       	jmp    8042109a18 <map_page+0x10df>

0000008042109c17 <map_physical_region>:
map_physical_region(struct AddressSpace *dst, uintptr_t dstart, uintptr_t pstart, size_t size, int flags) {
  8042109c17:	f3 0f 1e fa          	endbr64
  8042109c1b:	55                   	push   %rbp
  8042109c1c:	48 89 e5             	mov    %rsp,%rbp
  8042109c1f:	41 57                	push   %r15
  8042109c21:	41 56                	push   %r14
  8042109c23:	41 55                	push   %r13
  8042109c25:	41 54                	push   %r12
  8042109c27:	53                   	push   %rbx
  8042109c28:	48 83 ec 38          	sub    $0x38,%rsp
  8042109c2c:	49 89 fd             	mov    %rdi,%r13
  8042109c2f:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
    assert(dstart > MAX_USER_ADDRESS || dst == &kspace || (flags & MAP_USER_MMIO && dstart <= MAX_USER_ADDRESS && dst != &kspace));
  8042109c33:	48 b8 e0 10 00 43 80 	movabs $0x80430010e0,%rax
  8042109c3a:	00 00 00 
  8042109c3d:	48 39 c7             	cmp    %rax,%rdi
  8042109c40:	74 1c                	je     8042109c5e <map_physical_region+0x47>
  8042109c42:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  8042109c49:	00 00 00 
  8042109c4c:	48 39 f0             	cmp    %rsi,%rax
  8042109c4f:	72 0d                	jb     8042109c5e <map_physical_region+0x47>
  8042109c51:	41 f7 c0 00 00 40 00 	test   $0x400000,%r8d
  8042109c58:	0f 84 98 00 00 00    	je     8042109cf6 <map_physical_region+0xdf>
    uintptr_t start = ROUNDDOWN(dstart, CLASS_SIZE(0));
  8042109c5e:	49 89 f4             	mov    %rsi,%r12
  8042109c61:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
    uintptr_t end = ROUNDUP(dstart + size, CLASS_SIZE(0));
  8042109c68:	48 8d bc 0e ff 0f 00 	lea    0xfff(%rsi,%rcx,1),%rdi
  8042109c6f:	00 
  8042109c70:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
    pstart = ROUNDDOWN(pstart, CLASS_SIZE(0));
  8042109c77:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
    assert(!((addr1 | addr2) & CLASS_MASK(0)));
  8042109c7e:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
  8042109c84:	0f 85 ab 00 00 00    	jne    8042109d35 <map_physical_region+0x11e>
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  8042109c8a:	48 31 d6             	xor    %rdx,%rsi
    int res = 0;
  8042109c8d:	b8 00 00 00 00       	mov    $0x0,%eax
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  8042109c92:	f7 c6 00 10 00 00    	test   $0x1000,%esi
  8042109c98:	0f 85 8d 00 00 00    	jne    8042109d2b <map_physical_region+0x114>
  8042109c9e:	41 89 c0             	mov    %eax,%r8d
  8042109ca1:	83 c0 01             	add    $0x1,%eax
  8042109ca4:	41 8d 48 0d          	lea    0xd(%r8),%ecx
  8042109ca8:	48 0f a3 ce          	bt     %rcx,%rsi
  8042109cac:	72 05                	jb     8042109cb3 <map_physical_region+0x9c>
  8042109cae:	83 f8 2f             	cmp    $0x2f,%eax
  8042109cb1:	7e eb                	jle    8042109c9e <map_physical_region+0x87>
    for (; class < max_class && start + CLASS_SIZE(class) <= end; class ++) {
  8042109cb3:	85 c0                	test   %eax,%eax
  8042109cb5:	0f 8e de 01 00 00    	jle    8042109e99 <map_physical_region+0x282>
  8042109cbb:	4d 8d b4 24 00 10 00 	lea    0x1000(%r12),%r14
  8042109cc2:	00 
  8042109cc3:	4c 39 f7             	cmp    %r14,%rdi
  8042109cc6:	0f 82 d4 01 00 00    	jb     8042109ea0 <map_physical_region+0x289>
  8042109ccc:	41 bf 00 10 00 00    	mov    $0x1000,%r15d
  8042109cd2:	bb 00 00 00 00       	mov    $0x0,%ebx
            if (flags & MAP_USER_MMIO) {
  8042109cd7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8042109cda:	25 00 00 40 00       	and    $0x400000,%eax
  8042109cdf:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8042109ce2:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8042109ce6:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  8042109cea:	4c 89 6d b0          	mov    %r13,-0x50(%rbp)
  8042109cee:	45 89 c5             	mov    %r8d,%r13d
  8042109cf1:	e9 ca 00 00 00       	jmp    8042109dc0 <map_physical_region+0x1a9>
    assert(dstart > MAX_USER_ADDRESS || dst == &kspace || (flags & MAP_USER_MMIO && dstart <= MAX_USER_ADDRESS && dst != &kspace));
  8042109cf6:	48 b9 20 0f 12 42 80 	movabs $0x8042120f20,%rcx
  8042109cfd:	00 00 00 
  8042109d00:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109d07:	00 00 00 
  8042109d0a:	be e4 04 00 00       	mov    $0x4e4,%esi
  8042109d0f:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109d16:	00 00 00 
  8042109d19:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109d1e:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109d25:	00 00 00 
  8042109d28:	41 ff d0             	call   *%r8
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  8042109d2b:	be 00 00 00 00       	mov    $0x0,%esi
  8042109d30:	e9 21 01 00 00       	jmp    8042109e56 <map_physical_region+0x23f>
    assert(!((addr1 | addr2) & CLASS_MASK(0)));
  8042109d35:	48 b9 98 0f 12 42 80 	movabs $0x8042120f98,%rcx
  8042109d3c:	00 00 00 
  8042109d3f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109d46:	00 00 00 
  8042109d49:	be da 04 00 00       	mov    $0x4da,%esi
  8042109d4e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109d55:	00 00 00 
  8042109d58:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109d5d:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109d64:	00 00 00 
  8042109d67:	41 ff d0             	call   *%r8
            assert(page);
  8042109d6a:	48 85 c0             	test   %rax,%rax
  8042109d6d:	0f 84 a2 00 00 00    	je     8042109e15 <map_physical_region+0x1fe>
            if ((res = map_page(dst, start, page, flags)) < 0) return res;
  8042109d73:	8b 4d cc             	mov    -0x34(%rbp),%ecx
  8042109d76:	4c 89 e6             	mov    %r12,%rsi
  8042109d79:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8042109d7d:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  8042109d84:	00 00 00 
  8042109d87:	ff d0                	call   *%rax
  8042109d89:	85 c0                	test   %eax,%eax
  8042109d8b:	0f 88 6b 02 00 00    	js     8042109ffc <map_physical_region+0x3e5>
            pstart += CLASS_SIZE(class);
  8042109d91:	4c 01 7d b8          	add    %r15,-0x48(%rbp)
            start += CLASS_SIZE(class);
  8042109d95:	4d 89 f4             	mov    %r14,%r12
    for (; class < max_class && start + CLASS_SIZE(class) <= end; class ++) {
  8042109d98:	8d 73 01             	lea    0x1(%rbx),%esi
  8042109d9b:	44 39 eb             	cmp    %r13d,%ebx
  8042109d9e:	0f 8d a6 00 00 00    	jge    8042109e4a <map_physical_region+0x233>
  8042109da4:	8d 4b 0d             	lea    0xd(%rbx),%ecx
  8042109da7:	41 bf 01 00 00 00    	mov    $0x1,%r15d
  8042109dad:	49 d3 e7             	shl    %cl,%r15
  8042109db0:	4f 8d 34 27          	lea    (%r15,%r12,1),%r14
  8042109db4:	4c 39 75 c0          	cmp    %r14,-0x40(%rbp)
  8042109db8:	0f 82 f3 00 00 00    	jb     8042109eb1 <map_physical_region+0x29a>
  8042109dbe:	89 f3                	mov    %esi,%ebx
        if (start & CLASS_SIZE(class)) {
  8042109dc0:	8d 43 0c             	lea    0xc(%rbx),%eax
  8042109dc3:	49 0f a3 c4          	bt     %rax,%r12
  8042109dc7:	73 cf                	jae    8042109d98 <map_physical_region+0x181>
            struct Page *page = page_lookup(NULL, pstart, class, PARTIAL_NODE, 1);
  8042109dc9:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8042109dcf:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8042109dd4:	89 da                	mov    %ebx,%edx
  8042109dd6:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042109dda:	bf 00 00 00 00       	mov    $0x0,%edi
  8042109ddf:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  8042109de6:	00 00 00 
  8042109de9:	ff d0                	call   *%rax
  8042109deb:	48 89 c2             	mov    %rax,%rdx
            if (flags & MAP_USER_MMIO) {
  8042109dee:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  8042109df2:	0f 84 72 ff ff ff    	je     8042109d6a <map_physical_region+0x153>
                if (!page) return -E_NO_MEM;
  8042109df8:	48 85 c0             	test   %rax,%rax
  8042109dfb:	0f 84 ef 01 00 00    	je     8042109ff0 <map_physical_region+0x3d9>
                if (page->refc) return -E_NO_ENT;
  8042109e01:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042109e05:	0f 84 68 ff ff ff    	je     8042109d73 <map_physical_region+0x15c>
  8042109e0b:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8042109e10:	e9 e7 01 00 00       	jmp    8042109ffc <map_physical_region+0x3e5>
            assert(page);
  8042109e15:	48 b9 9d f7 11 42 80 	movabs $0x804211f79d,%rcx
  8042109e1c:	00 00 00 
  8042109e1f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109e26:	00 00 00 
  8042109e29:	be fb 04 00 00       	mov    $0x4fb,%esi
  8042109e2e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109e35:	00 00 00 
  8042109e38:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109e3d:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109e44:	00 00 00 
  8042109e47:	41 ff d0             	call   *%r8
  8042109e4a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8042109e4e:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8042109e52:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
    for (; class >= 0 && start < end; class --) {
  8042109e56:	85 f6                	test   %esi,%esi
  8042109e58:	78 4d                	js     8042109ea7 <map_physical_region+0x290>
  8042109e5a:	49 39 fc             	cmp    %rdi,%r12
  8042109e5d:	73 48                	jae    8042109ea7 <map_physical_region+0x290>
        while (start + CLASS_SIZE(class) <= end) {
  8042109e5f:	8d 4e 0c             	lea    0xc(%rsi),%ecx
  8042109e62:	41 bf 01 00 00 00    	mov    $0x1,%r15d
  8042109e68:	49 d3 e7             	shl    %cl,%r15
  8042109e6b:	4b 8d 0c 27          	lea    (%r15,%r12,1),%rcx
  8042109e6f:	48 39 cf             	cmp    %rcx,%rdi
  8042109e72:	0f 82 63 01 00 00    	jb     8042109fdb <map_physical_region+0x3c4>
  8042109e78:	48 89 d3             	mov    %rdx,%rbx
  8042109e7b:	49 29 d4             	sub    %rdx,%r12
            if (flags & MAP_USER_MMIO) {
  8042109e7e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8042109e81:	25 00 00 40 00       	and    $0x400000,%eax
  8042109e86:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042109e89:	4c 89 65 b0          	mov    %r12,-0x50(%rbp)
  8042109e8d:	89 75 c0             	mov    %esi,-0x40(%rbp)
  8042109e90:	49 89 ce             	mov    %rcx,%r14
  8042109e93:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8042109e97:	eb 77                	jmp    8042109f10 <map_physical_region+0x2f9>
    for (; class < max_class && start + CLASS_SIZE(class) <= end; class ++) {
  8042109e99:	be 00 00 00 00       	mov    $0x0,%esi
  8042109e9e:	eb b6                	jmp    8042109e56 <map_physical_region+0x23f>
  8042109ea0:	be 00 00 00 00       	mov    $0x0,%esi
  8042109ea5:	eb af                	jmp    8042109e56 <map_physical_region+0x23f>
    return 0;
  8042109ea7:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109eac:	e9 4b 01 00 00       	jmp    8042109ffc <map_physical_region+0x3e5>
  8042109eb1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8042109eb5:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8042109eb9:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
  8042109ebd:	eb 97                	jmp    8042109e56 <map_physical_region+0x23f>
            assert(page);
  8042109ebf:	48 85 c0             	test   %rax,%rax
  8042109ec2:	0f 84 9c 00 00 00    	je     8042109f64 <map_physical_region+0x34d>
            if ((res = map_page(dst, start, page, flags)) < 0) return res;
  8042109ec8:	8b 4d cc             	mov    -0x34(%rbp),%ecx
  8042109ecb:	4c 89 e6             	mov    %r12,%rsi
  8042109ece:	4c 89 ef             	mov    %r13,%rdi
  8042109ed1:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  8042109ed8:	00 00 00 
  8042109edb:	ff d0                	call   *%rax
  8042109edd:	85 c0                	test   %eax,%eax
  8042109edf:	0f 88 17 01 00 00    	js     8042109ffc <map_physical_region+0x3e5>
            assert_virtual(dst->root);
  8042109ee5:	49 8b 45 10          	mov    0x10(%r13),%rax
  8042109ee9:	8b 40 28             	mov    0x28(%rax),%eax
  8042109eec:	25 00 00 f0 00       	and    $0xf00000,%eax
  8042109ef1:	3d ff ff 2f 00       	cmp    $0x2fffff,%eax
  8042109ef6:	0f 87 9d 00 00 00    	ja     8042109f99 <map_physical_region+0x382>
            pstart += CLASS_SIZE(class);
  8042109efc:	4c 01 fb             	add    %r15,%rbx
        while (start + CLASS_SIZE(class) <= end) {
  8042109eff:	4b 8d 04 3e          	lea    (%r14,%r15,1),%rax
  8042109f03:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  8042109f07:	0f 82 c1 00 00 00    	jb     8042109fce <map_physical_region+0x3b7>
  8042109f0d:	49 89 c6             	mov    %rax,%r14
  8042109f10:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042109f14:	4c 8d 24 18          	lea    (%rax,%rbx,1),%r12
            struct Page *page = page_lookup(NULL, pstart, class, PARTIAL_NODE, 1);
  8042109f18:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8042109f1e:	b9 00 00 30 00       	mov    $0x300000,%ecx
  8042109f23:	8b 55 c0             	mov    -0x40(%rbp),%edx
  8042109f26:	48 89 de             	mov    %rbx,%rsi
  8042109f29:	bf 00 00 00 00       	mov    $0x0,%edi
  8042109f2e:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  8042109f35:	00 00 00 
  8042109f38:	ff d0                	call   *%rax
  8042109f3a:	48 89 c2             	mov    %rax,%rdx
            if (flags & MAP_USER_MMIO) {
  8042109f3d:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8042109f41:	0f 84 78 ff ff ff    	je     8042109ebf <map_physical_region+0x2a8>
                if (!page) return -E_NO_MEM;
  8042109f47:	48 85 c0             	test   %rax,%rax
  8042109f4a:	0f 84 a7 00 00 00    	je     8042109ff7 <map_physical_region+0x3e0>
                if (page->refc) return -E_NO_ENT;
  8042109f50:	83 78 30 00          	cmpl   $0x0,0x30(%rax)
  8042109f54:	0f 84 6e ff ff ff    	je     8042109ec8 <map_physical_region+0x2b1>
  8042109f5a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8042109f5f:	e9 98 00 00 00       	jmp    8042109ffc <map_physical_region+0x3e5>
            assert(page);
  8042109f64:	48 b9 9d f7 11 42 80 	movabs $0x804211f79d,%rcx
  8042109f6b:	00 00 00 
  8042109f6e:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109f75:	00 00 00 
  8042109f78:	be 09 05 00 00       	mov    $0x509,%esi
  8042109f7d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109f84:	00 00 00 
  8042109f87:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109f8c:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109f93:	00 00 00 
  8042109f96:	41 ff d0             	call   *%r8
            assert_virtual(dst->root);
  8042109f99:	48 b9 c0 0f 12 42 80 	movabs $0x8042120fc0,%rcx
  8042109fa0:	00 00 00 
  8042109fa3:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  8042109faa:	00 00 00 
  8042109fad:	be 0b 05 00 00       	mov    $0x50b,%esi
  8042109fb2:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  8042109fb9:	00 00 00 
  8042109fbc:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109fc1:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  8042109fc8:	00 00 00 
  8042109fcb:	41 ff d0             	call   *%r8
  8042109fce:	8b 75 c0             	mov    -0x40(%rbp),%esi
  8042109fd1:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8042109fd5:	4d 89 f4             	mov    %r14,%r12
  8042109fd8:	48 89 da             	mov    %rbx,%rdx
    for (; class >= 0 && start < end; class --) {
  8042109fdb:	83 ee 01             	sub    $0x1,%esi
  8042109fde:	78 09                	js     8042109fe9 <map_physical_region+0x3d2>
  8042109fe0:	49 39 fc             	cmp    %rdi,%r12
  8042109fe3:	0f 82 76 fe ff ff    	jb     8042109e5f <map_physical_region+0x248>
    return 0;
  8042109fe9:	b8 00 00 00 00       	mov    $0x0,%eax
  8042109fee:	eb 0c                	jmp    8042109ffc <map_physical_region+0x3e5>
                if (!page) return -E_NO_MEM;
  8042109ff0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8042109ff5:	eb 05                	jmp    8042109ffc <map_physical_region+0x3e5>
                if (!page) return -E_NO_MEM;
  8042109ff7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  8042109ffc:	48 83 c4 38          	add    $0x38,%rsp
  804210a000:	5b                   	pop    %rbx
  804210a001:	41 5c                	pop    %r12
  804210a003:	41 5d                	pop    %r13
  804210a005:	41 5e                	pop    %r14
  804210a007:	41 5f                	pop    %r15
  804210a009:	5d                   	pop    %rbp
  804210a00a:	c3                   	ret

000000804210a00b <mmio_map_region>:
mmio_map_region(physaddr_t addr, size_t size) {
  804210a00b:	f3 0f 1e fa          	endbr64
  804210a00f:	55                   	push   %rbp
  804210a010:	48 89 e5             	mov    %rsp,%rbp
  804210a013:	41 55                	push   %r13
  804210a015:	41 54                	push   %r12
  804210a017:	53                   	push   %rbx
  804210a018:	48 83 ec 08          	sub    $0x8,%rsp
    assert(current_space == &kspace);
  804210a01c:	48 ba d0 10 00 43 80 	movabs $0x80430010d0,%rdx
  804210a023:	00 00 00 
  804210a026:	48 b8 e0 10 00 43 80 	movabs $0x80430010e0,%rax
  804210a02d:	00 00 00 
  804210a030:	48 39 02             	cmp    %rax,(%rdx)
  804210a033:	0f 85 81 00 00 00    	jne    804210a0ba <mmio_map_region+0xaf>
  804210a039:	48 89 fb             	mov    %rdi,%rbx
  804210a03c:	49 89 f5             	mov    %rsi,%r13
    uintptr_t start = ROUNDDOWN(addr, PAGE_SIZE);
  804210a03f:	49 89 fc             	mov    %rdi,%r12
  804210a042:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
    prev_mmio = metaheaptop;
  804210a049:	48 ba 30 61 00 43 80 	movabs $0x8043006130,%rdx
  804210a050:	00 00 00 
  804210a053:	48 8b 32             	mov    (%rdx),%rsi
  804210a056:	48 89 f0             	mov    %rsi,%rax
  804210a059:	48 a3 10 61 00 43 80 	movabs %rax,0x8043006110
  804210a060:	00 00 00 
    uintptr_t end = ROUNDUP(addr + size, PAGE_SIZE);
  804210a063:	4a 8d 8c 2f ff 0f 00 	lea    0xfff(%rdi,%r13,1),%rcx
  804210a06a:	00 
    metaheaptop += end - start;
  804210a06b:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
  804210a072:	4c 29 e1             	sub    %r12,%rcx
  804210a075:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
  804210a079:	48 89 02             	mov    %rax,(%rdx)
    if (map_physical_region(&kspace, prev_mmio, start, end - start, PROT_R | PROT_W | PROT_CD) < 0)
  804210a07c:	41 b8 1e 00 00 00    	mov    $0x1e,%r8d
  804210a082:	4c 89 e2             	mov    %r12,%rdx
  804210a085:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210a08c:	00 00 00 
  804210a08f:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210a096:	00 00 00 
  804210a099:	ff d0                	call   *%rax
  804210a09b:	85 c0                	test   %eax,%eax
  804210a09d:	78 50                	js     804210a0ef <mmio_map_region+0xe4>
    return (void *)(prev_mmio + addr - start);
  804210a09f:	48 a1 10 61 00 43 80 	movabs 0x8043006110,%rax
  804210a0a6:	00 00 00 
  804210a0a9:	48 01 d8             	add    %rbx,%rax
  804210a0ac:	4c 29 e0             	sub    %r12,%rax
}
  804210a0af:	48 83 c4 08          	add    $0x8,%rsp
  804210a0b3:	5b                   	pop    %rbx
  804210a0b4:	41 5c                	pop    %r12
  804210a0b6:	41 5d                	pop    %r13
  804210a0b8:	5d                   	pop    %rbp
  804210a0b9:	c3                   	ret
    assert(current_space == &kspace);
  804210a0ba:	48 b9 34 f9 11 42 80 	movabs $0x804211f934,%rcx
  804210a0c1:	00 00 00 
  804210a0c4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210a0cb:	00 00 00 
  804210a0ce:	be fd 06 00 00       	mov    $0x6fd,%esi
  804210a0d3:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a0da:	00 00 00 
  804210a0dd:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a0e2:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210a0e9:	00 00 00 
  804210a0ec:	41 ff d0             	call   *%r8
        panic("Cannot map physical region at %p of size %zd", (void *)addr, size);
  804210a0ef:	4d 89 e8             	mov    %r13,%r8
  804210a0f2:	48 89 d9             	mov    %rbx,%rcx
  804210a0f5:	48 ba f8 0f 12 42 80 	movabs $0x8042120ff8,%rdx
  804210a0fc:	00 00 00 
  804210a0ff:	be 05 07 00 00       	mov    $0x705,%esi
  804210a104:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a10b:	00 00 00 
  804210a10e:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a113:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210a11a:	00 00 00 
  804210a11d:	41 ff d1             	call   *%r9

000000804210a120 <mmio_remap_last_region>:
mmio_remap_last_region(physaddr_t addr, void *oldva, size_t oldsz, size_t size) {
  804210a120:	f3 0f 1e fa          	endbr64
  804210a124:	55                   	push   %rbp
  804210a125:	48 89 e5             	mov    %rsp,%rbp
  804210a128:	49 89 f1             	mov    %rsi,%r9
  804210a12b:	48 89 ce             	mov    %rcx,%rsi
    uintptr_t start = ROUNDDOWN(addr, PAGE_SIZE);
  804210a12e:	49 89 f8             	mov    %rdi,%r8
  804210a131:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
    uintptr_t end = ROUNDUP(addr + size, PAGE_SIZE);
  804210a138:	48 8d 84 0f ff 0f 00 	lea    0xfff(%rdi,%rcx,1),%rax
  804210a13f:	00 
  804210a140:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804210a146:	48 89 c2             	mov    %rax,%rdx
    if (prev_mmio + addr - start != (uintptr_t)oldva &&
  804210a149:	48 a1 10 61 00 43 80 	movabs 0x8043006110,%rax
  804210a150:	00 00 00 
  804210a153:	48 8d 0c 38          	lea    (%rax,%rdi,1),%rcx
  804210a157:	4c 29 c1             	sub    %r8,%rcx
  804210a15a:	49 39 c9             	cmp    %rcx,%r9
  804210a15d:	74 15                	je     804210a174 <mmio_remap_last_region+0x54>
        (prev_mmio + end - start != metaheaptop))
  804210a15f:	4c 29 c2             	sub    %r8,%rdx
  804210a162:	48 01 c2             	add    %rax,%rdx
  804210a165:	48 b9 30 61 00 43 80 	movabs $0x8043006130,%rcx
  804210a16c:	00 00 00 
    if (prev_mmio + addr - start != (uintptr_t)oldva &&
  804210a16f:	48 3b 11             	cmp    (%rcx),%rdx
  804210a172:	75 18                	jne    804210a18c <mmio_remap_last_region+0x6c>
    metaheaptop = prev_mmio;
  804210a174:	48 a3 30 61 00 43 80 	movabs %rax,0x8043006130
  804210a17b:	00 00 00 
    return mmio_map_region(addr, size);
  804210a17e:	48 b8 0b a0 10 42 80 	movabs $0x804210a00b,%rax
  804210a185:	00 00 00 
  804210a188:	ff d0                	call   *%rax
}
  804210a18a:	5d                   	pop    %rbp
  804210a18b:	c3                   	ret
        panic("Trying to remap non-last MMIO region!\n");
  804210a18c:	48 ba 28 10 12 42 80 	movabs $0x8042121028,%rdx
  804210a193:	00 00 00 
  804210a196:	be 11 07 00 00       	mov    $0x711,%esi
  804210a19b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a1a2:	00 00 00 
  804210a1a5:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a1aa:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210a1b1:	00 00 00 
  804210a1b4:	ff d1                	call   *%rcx

000000804210a1b6 <init_memory>:
init_memory(void) {
  804210a1b6:	f3 0f 1e fa          	endbr64
  804210a1ba:	55                   	push   %rbp
  804210a1bb:	48 89 e5             	mov    %rsp,%rbp
  804210a1be:	41 57                	push   %r15
  804210a1c0:	41 56                	push   %r14
  804210a1c2:	41 55                	push   %r13
  804210a1c4:	41 54                	push   %r12
  804210a1c6:	53                   	push   %rbx
  804210a1c7:	48 83 ec 38          	sub    $0x38,%rsp
    is_swap_full = 0;
  804210a1cb:	48 b8 00 00 00 43 80 	movabs $0x8043000000,%rax
  804210a1d2:	00 00 00 
  804210a1d5:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    metaheaptop = KERN_HEAP_START + ROUNDUP(uefi_lp->FrameBufferSize, PAGE_SIZE);
  804210a1db:	48 a1 00 30 14 42 80 	movabs 0x8042143000,%rax
  804210a1e2:	00 00 00 
  804210a1e5:	8b 40 48             	mov    0x48(%rax),%eax
  804210a1e8:	48 05 ff 0f 00 00    	add    $0xfff,%rax
  804210a1ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  804210a1f3:	48 ba 00 00 e0 1f 80 	movabs $0x801fe00000,%rdx
  804210a1fa:	00 00 00 
  804210a1fd:	48 01 d0             	add    %rdx,%rax
  804210a200:	48 a3 30 61 00 43 80 	movabs %rax,0x8043006130
  804210a207:	00 00 00 
    for (size_t i = 0; i < MAX_CLASS; i++)
  804210a20a:	48 b8 60 61 00 43 80 	movabs $0x8043006160,%rax
  804210a211:	00 00 00 
  804210a214:	48 8d 90 00 03 00 00 	lea    0x300(%rax),%rdx
    list->next = list->prev = list;
  804210a21b:	48 89 00             	mov    %rax,(%rax)
  804210a21e:	48 89 40 08          	mov    %rax,0x8(%rax)
    for (size_t i = 0; i < MAX_CLASS; i++)
  804210a222:	48 83 c0 10          	add    $0x10,%rax
  804210a226:	48 39 d0             	cmp    %rdx,%rax
  804210a229:	75 f0                	jne    804210a21b <init_memory+0x65>
    list->next = list->prev = list;
  804210a22b:	48 b8 40 61 00 43 80 	movabs $0x8043006140,%rax
  804210a232:	00 00 00 
  804210a235:	48 89 00             	mov    %rax,(%rax)
  804210a238:	48 89 40 08          	mov    %rax,0x8(%rax)
    free_desc_count = INIT_DESCR;
  804210a23c:	48 b8 38 61 00 43 80 	movabs $0x8043006138,%rax
  804210a243:	00 00 00 
  804210a246:	48 c7 00 00 01 00 00 	movq   $0x100,(%rax)
    for (size_t i = 0; i < INIT_DESCR; i++)
  804210a24d:	48 b8 00 11 00 43 80 	movabs $0x8043001100,%rax
  804210a254:	00 00 00 
  804210a257:	48 8d b0 00 50 00 00 	lea    0x5000(%rax),%rsi
    struct List *list_next = list->next;
  804210a25e:	48 ba 40 61 00 43 80 	movabs $0x8043006140,%rdx
  804210a265:	00 00 00 
  804210a268:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
    list_prev->next = list_cur;
  804210a26c:	48 89 42 08          	mov    %rax,0x8(%rdx)
    list_next->prev = list_cur;
  804210a270:	48 89 01             	mov    %rax,(%rcx)
    list_cur->prev = list_prev;
  804210a273:	48 89 10             	mov    %rdx,(%rax)
    list_cur->next = list_next;
  804210a276:	48 89 48 08          	mov    %rcx,0x8(%rax)
    for (size_t i = 0; i < INIT_DESCR; i++)
  804210a27a:	48 83 c0 50          	add    $0x50,%rax
  804210a27e:	48 39 f0             	cmp    %rsi,%rax
  804210a281:	75 e5                	jne    804210a268 <init_memory+0xb2>
    list->next = list->prev = list;
  804210a283:	48 b8 80 10 00 43 80 	movabs $0x8043001080,%rax
  804210a28a:	00 00 00 
  804210a28d:	48 89 00             	mov    %rax,(%rax)
  804210a290:	48 89 40 08          	mov    %rax,0x8(%rax)
    root.class = MAX_CLASS;
  804210a294:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  804210a298:	66 81 e2 00 f0       	and    $0xf000,%dx
  804210a29d:	83 ca 30             	or     $0x30,%edx
  804210a2a0:	66 89 50 34          	mov    %dx,0x34(%rax)
    root.state = PARTIAL_NODE;
  804210a2a4:	c7 40 28 00 00 30 00 	movl   $0x300000,0x28(%rax)
}

static inline void __attribute__((always_inline))
cpuid(uint32_t info, uint32_t *raxp, uint32_t *rbxp, uint32_t *rcxp, uint32_t *rdxp) {
    uint32_t eax, ebx, ecx, edx;
    asm volatile("cpuid"
  804210a2ab:	b8 01 00 00 80       	mov    $0x80000001,%eax
  804210a2b0:	0f a2                	cpuid
    has_1gb_pages = edx & (1 << 26);
  804210a2b2:	89 d1                	mov    %edx,%ecx
  804210a2b4:	c1 e9 1a             	shr    $0x1a,%ecx
  804210a2b7:	83 e1 01             	and    $0x1,%ecx
  804210a2ba:	89 c8                	mov    %ecx,%eax
  804210a2bc:	a2 28 61 00 43 80 00 	movabs %al,0x8043006128
  804210a2c3:	00 00 
    nx_supported = edx & (1 << 20);
  804210a2c5:	c1 ea 14             	shr    $0x14,%edx
  804210a2c8:	83 e2 01             	and    $0x1,%edx
  804210a2cb:	89 d0                	mov    %edx,%eax
  804210a2cd:	a2 29 61 00 43 80 00 	movabs %al,0x8043006129
  804210a2d4:	00 00 
        cprintf("CPUID: 1GB pages: %d, NX: %d\n", has_1gb_pages, nx_supported);
  804210a2d6:	0f b6 d2             	movzbl %dl,%edx
  804210a2d9:	0f b6 f1             	movzbl %cl,%esi
  804210a2dc:	48 bf 4d f9 11 42 80 	movabs $0x804211f94d,%rdi
  804210a2e3:	00 00 00 
  804210a2e6:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a2eb:	48 bb 70 cf 10 42 80 	movabs $0x804210cf70,%rbx
  804210a2f2:	00 00 00 
  804210a2f5:	ff d3                	call   *%rbx
    if (trace_init) cprintf("Memory allocator is initialized\n");
  804210a2f7:	48 bf 50 10 12 42 80 	movabs $0x8042121050,%rdi
  804210a2fe:	00 00 00 
  804210a301:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a306:	ff d3                	call   *%rbx
    attach_region(0, PAGE_SIZE, RESERVED_NODE);
  804210a308:	ba 00 00 50 00       	mov    $0x500000,%edx
  804210a30d:	be 00 10 00 00       	mov    $0x1000,%esi
  804210a312:	bf 00 00 00 00       	mov    $0x0,%edi
  804210a317:	48 b8 e8 71 10 42 80 	movabs $0x80421071e8,%rax
  804210a31e:	00 00 00 
  804210a321:	ff d0                	call   *%rax
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804210a323:	48 b8 00 80 00 43 80 	movabs $0x8043008000,%rax
  804210a32a:	00 00 00 
  804210a32d:	48 ba ff ff ff 3f 80 	movabs $0x803fffffff,%rdx
  804210a334:	00 00 00 
  804210a337:	48 39 c2             	cmp    %rax,%rdx
  804210a33a:	73 76                	jae    804210a3b2 <init_memory+0x1fc>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804210a33c:	48 ba 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rdx
  804210a343:	ff ff ff 
  804210a346:	48 8d 34 10          	lea    (%rax,%rdx,1),%rsi
    attach_region(IOPHYSMEM, PADDR(end), RESERVED_NODE);
  804210a34a:	ba 00 00 50 00       	mov    $0x500000,%edx
  804210a34f:	bf 00 00 0a 00       	mov    $0xa0000,%edi
  804210a354:	48 b8 e8 71 10 42 80 	movabs $0x80421071e8,%rax
  804210a35b:	00 00 00 
  804210a35e:	ff d0                	call   *%rax
    if (uefi_lp && uefi_lp->MemoryMap) {
  804210a360:	48 a1 00 30 14 42 80 	movabs 0x8042143000,%rax
  804210a367:	00 00 00 
  804210a36a:	48 85 c0             	test   %rax,%rax
  804210a36d:	0f 84 fc 00 00 00    	je     804210a46f <init_memory+0x2b9>
  804210a373:	48 8b 50 28          	mov    0x28(%rax),%rdx
  804210a377:	48 85 d2             	test   %rdx,%rdx
  804210a37a:	0f 84 ef 00 00 00    	je     804210a46f <init_memory+0x2b9>
        EFI_MEMORY_DESCRIPTOR *start = (void *)uefi_lp->MemoryMap;
  804210a380:	48 89 d3             	mov    %rdx,%rbx
        EFI_MEMORY_DESCRIPTOR *end = (void *)(uefi_lp->MemoryMap + uefi_lp->MemoryMapSize);
  804210a383:	49 89 d6             	mov    %rdx,%r14
  804210a386:	4c 03 70 38          	add    0x38(%rax),%r14
        while (start < end) {
  804210a38a:	4c 39 f2             	cmp    %r14,%rdx
  804210a38d:	0f 83 c4 00 00 00    	jae    804210a457 <init_memory+0x2a1>
        size_t total_mem = 0;
  804210a393:	41 bf 00 00 00 00    	mov    $0x0,%r15d
            max_memory_map_addr = MAX(start->NumberOfPages * EFI_PAGE_SIZE + start->PhysicalStart, max_memory_map_addr);
  804210a399:	49 bc f8 10 00 43 80 	movabs $0x80430010f8,%r12
  804210a3a0:	00 00 00 
            start = (void *)((uint8_t *)start + uefi_lp->MemoryMapDescriptorSize);
  804210a3a3:	49 bd 00 30 14 42 80 	movabs $0x8042143000,%r13
  804210a3aa:	00 00 00 
  804210a3ad:	e9 93 00 00 00       	jmp    804210a445 <init_memory+0x28f>
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804210a3b2:	48 89 c1             	mov    %rax,%rcx
  804210a3b5:	48 ba 40 0b 12 42 80 	movabs $0x8042120b40,%rdx
  804210a3bc:	00 00 00 
  804210a3bf:	be 7d 06 00 00       	mov    $0x67d,%esi
  804210a3c4:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a3cb:	00 00 00 
  804210a3ce:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a3d3:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210a3da:	00 00 00 
  804210a3dd:	41 ff d0             	call   *%r8
            switch (start->Type) {
  804210a3e0:	ba 00 00 50 00       	mov    $0x500000,%edx
  804210a3e5:	83 f8 07             	cmp    $0x7,%eax
  804210a3e8:	75 24                	jne    804210a40e <init_memory+0x258>
                type = start->Attribute & EFI_MEMORY_WB ? ALLOCATABLE_NODE : RESERVED_NODE;
  804210a3ea:	48 8b 43 20          	mov    0x20(%rbx),%rax
  804210a3ee:	83 e0 08             	and    $0x8,%eax
  804210a3f1:	48 83 f8 01          	cmp    $0x1,%rax
  804210a3f5:	19 d2                	sbb    %edx,%edx
  804210a3f7:	81 e2 00 00 10 00    	and    $0x100000,%edx
  804210a3fd:	81 c2 00 00 40 00    	add    $0x400000,%edx
                total_mem += start->NumberOfPages * EFI_PAGE_SIZE;
  804210a403:	48 8b 43 18          	mov    0x18(%rbx),%rax
  804210a407:	48 c1 e0 0c          	shl    $0xc,%rax
  804210a40b:	49 01 c7             	add    %rax,%r15
            max_memory_map_addr = MAX(start->NumberOfPages * EFI_PAGE_SIZE + start->PhysicalStart, max_memory_map_addr);
  804210a40e:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  804210a412:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  804210a416:	48 c1 e6 0c          	shl    $0xc,%rsi
  804210a41a:	48 01 fe             	add    %rdi,%rsi
  804210a41d:	49 8b 04 24          	mov    (%r12),%rax
  804210a421:	48 39 f0             	cmp    %rsi,%rax
  804210a424:	48 0f 42 c6          	cmovb  %rsi,%rax
  804210a428:	49 89 04 24          	mov    %rax,(%r12)
			attach_region((uintptr_t) start->PhysicalStart, (uintptr_t) start->PhysicalStart + PAGE_SIZE * start->NumberOfPages, type);
  804210a42c:	48 b8 e8 71 10 42 80 	movabs $0x80421071e8,%rax
  804210a433:	00 00 00 
  804210a436:	ff d0                	call   *%rax
            start = (void *)((uint8_t *)start + uefi_lp->MemoryMapDescriptorSize);
  804210a438:	49 8b 45 00          	mov    0x0(%r13),%rax
  804210a43c:	48 03 58 20          	add    0x20(%rax),%rbx
        while (start < end) {
  804210a440:	4c 39 f3             	cmp    %r14,%rbx
  804210a443:	73 18                	jae    804210a45d <init_memory+0x2a7>
            switch (start->Type) {
  804210a445:	8b 03                	mov    (%rbx),%eax
  804210a447:	83 f8 04             	cmp    $0x4,%eax
  804210a44a:	77 94                	ja     804210a3e0 <init_memory+0x22a>
  804210a44c:	ba 00 00 50 00       	mov    $0x500000,%edx
  804210a451:	85 c0                	test   %eax,%eax
  804210a453:	74 b9                	je     804210a40e <init_memory+0x258>
  804210a455:	eb 93                	jmp    804210a3ea <init_memory+0x234>
        size_t total_mem = 0;
  804210a457:	41 bf 00 00 00 00    	mov    $0x0,%r15d
        basemem = MIN(total_mem, IOPHYSMEM);
  804210a45d:	41 bc 00 00 0a 00    	mov    $0xa0000,%r12d
  804210a463:	4d 39 e7             	cmp    %r12,%r15
  804210a466:	4d 0f 46 e7          	cmovbe %r15,%r12
        extmem = total_mem - basemem;
  804210a46a:	4d 29 e7             	sub    %r12,%r15
    if (uefi_lp && uefi_lp->MemoryMap) {
  804210a46d:	eb 6b                	jmp    804210a4da <init_memory+0x324>
        basemem = cmos_read16(CMOS_BASELO) * KB;
  804210a46f:	bf 15 00 00 00       	mov    $0x15,%edi
  804210a474:	49 bd 20 ca 10 42 80 	movabs $0x804210ca20,%r13
  804210a47b:	00 00 00 
  804210a47e:	41 ff d5             	call   *%r13
  804210a481:	44 0f b7 e0          	movzwl %ax,%r12d
  804210a485:	49 c1 e4 0a          	shl    $0xa,%r12
        extmem = cmos_read16(CMOS_EXTLO) * KB;
  804210a489:	bf 17 00 00 00       	mov    $0x17,%edi
  804210a48e:	41 ff d5             	call   *%r13
  804210a491:	41 89 c7             	mov    %eax,%r15d
        size_t pextmem = (size_t)cmos_read16(CMOS_PEXTLO) * KB * 64;
  804210a494:	bf 34 00 00 00       	mov    $0x34,%edi
  804210a499:	41 ff d5             	call   *%r13
  804210a49c:	0f b7 c0             	movzwl %ax,%eax
        if (pextmem) extmem = (16 * MB + pextmem - MB);
  804210a49f:	48 c1 e0 10          	shl    $0x10,%rax
  804210a4a3:	0f 84 3d 04 00 00    	je     804210a8e6 <init_memory+0x730>
  804210a4a9:	4c 8d b8 00 00 f0 00 	lea    0xf00000(%rax),%r15
        max_memory_map_addr = extmem ? EXTPHYSMEM + extmem : basemem;
  804210a4b0:	49 8d b7 00 00 10 00 	lea    0x100000(%r15),%rsi
  804210a4b7:	48 89 f0             	mov    %rsi,%rax
  804210a4ba:	48 a3 f8 10 00 43 80 	movabs %rax,0x80430010f8
  804210a4c1:	00 00 00 
        attach_region(0, max_memory_map_addr, ALLOCATABLE_NODE);
  804210a4c4:	ba 00 00 40 00       	mov    $0x400000,%edx
  804210a4c9:	bf 00 00 00 00       	mov    $0x0,%edi
  804210a4ce:	48 b8 e8 71 10 42 80 	movabs $0x80421071e8,%rax
  804210a4d5:	00 00 00 
  804210a4d8:	ff d0                	call   *%rax
                (size_t)((basemem + extmem) / MB), (size_t)(basemem / KB), (size_t)(extmem / KB));
  804210a4da:	4c 89 f9             	mov    %r15,%rcx
  804210a4dd:	48 c1 e9 0a          	shr    $0xa,%rcx
  804210a4e1:	4c 89 e2             	mov    %r12,%rdx
  804210a4e4:	48 c1 ea 0a          	shr    $0xa,%rdx
  804210a4e8:	4b 8d 34 27          	lea    (%r15,%r12,1),%rsi
  804210a4ec:	48 c1 ee 14          	shr    $0x14,%rsi
        cprintf("Physical memory: %zuM available, base = %zuK, extended = %zuK\n",
  804210a4f0:	48 bf 78 10 12 42 80 	movabs $0x8042121078,%rdi
  804210a4f7:	00 00 00 
  804210a4fa:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a4ff:	49 b8 70 cf 10 42 80 	movabs $0x804210cf70,%r8
  804210a506:	00 00 00 
  804210a509:	41 ff d0             	call   *%r8
    check_physical_tree(&root);
  804210a50c:	48 bf 80 10 00 43 80 	movabs $0x8043001080,%rdi
  804210a513:	00 00 00 
  804210a516:	48 b8 da 4d 10 42 80 	movabs $0x8042104dda,%rax
  804210a51d:	00 00 00 
  804210a520:	ff d0                	call   *%rax
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804210a522:	48 b8 00 00 c0 42 80 	movabs $0x8042c00000,%rax
  804210a529:	00 00 00 
  804210a52c:	48 ba ff ff ff 3f 80 	movabs $0x803fffffff,%rdx
  804210a533:	00 00 00 
  804210a536:	48 39 c2             	cmp    %rax,%rdx
  804210a539:	0f 83 bd 03 00 00    	jae    804210a8fc <init_memory+0x746>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804210a53f:	48 ba 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rdx
  804210a546:	ff ff ff 
  804210a549:	48 8d 34 10          	lea    (%rax,%rdx,1),%rsi
    one_page = page_lookup(NULL, PADDR(one_page_raw), MAX_ALLOCATION_CLASS, PARTIAL_NODE, 1);
  804210a54d:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804210a553:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804210a558:	ba 09 00 00 00       	mov    $0x9,%edx
  804210a55d:	bf 00 00 00 00       	mov    $0x0,%edi
  804210a562:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  804210a569:	00 00 00 
  804210a56c:	ff d0                	call   *%rax
  804210a56e:	48 a3 18 61 00 43 80 	movabs %rax,0x8043006118
  804210a575:	00 00 00 
    page_ref(one_page);
  804210a578:	48 89 c7             	mov    %rax,%rdi
  804210a57b:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  804210a582:	00 00 00 
  804210a585:	ff d0                	call   *%rax
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804210a587:	48 bb 00 00 e0 42 80 	movabs $0x8042e00000,%rbx
  804210a58e:	00 00 00 
  804210a591:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804210a598:	00 00 00 
  804210a59b:	48 39 d8             	cmp    %rbx,%rax
  804210a59e:	0f 83 86 03 00 00    	jae    804210a92a <init_memory+0x774>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804210a5a4:	48 be 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rsi
  804210a5ab:	ff ff ff 
  804210a5ae:	48 01 de             	add    %rbx,%rsi
    zero_page = page_lookup(NULL, PADDR(zero_page_raw), MAX_ALLOCATION_CLASS, PARTIAL_NODE, 1);
  804210a5b1:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804210a5b7:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804210a5bc:	ba 09 00 00 00       	mov    $0x9,%edx
  804210a5c1:	bf 00 00 00 00       	mov    $0x0,%edi
  804210a5c6:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  804210a5cd:	00 00 00 
  804210a5d0:	ff d0                	call   *%rax
  804210a5d2:	49 89 c4             	mov    %rax,%r12
  804210a5d5:	48 a3 20 61 00 43 80 	movabs %rax,0x8043006120
  804210a5dc:	00 00 00 
    page_ref(zero_page);
  804210a5df:	48 89 c7             	mov    %rax,%rdi
  804210a5e2:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  804210a5e9:	00 00 00 
  804210a5ec:	ff d0                	call   *%rax
    assert(zero_page && one_page);
  804210a5ee:	4d 85 e4             	test   %r12,%r12
  804210a5f1:	0f 84 61 03 00 00    	je     804210a958 <init_memory+0x7a2>
  804210a5f7:	48 b8 18 61 00 43 80 	movabs $0x8043006118,%rax
  804210a5fe:	00 00 00 
  804210a601:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210a605:	0f 84 4d 03 00 00    	je     804210a958 <init_memory+0x7a2>
    check_physical_tree(&root);
  804210a60b:	48 bf 80 10 00 43 80 	movabs $0x8043001080,%rdi
  804210a612:	00 00 00 
  804210a615:	48 b8 da 4d 10 42 80 	movabs $0x8042104dda,%rax
  804210a61c:	00 00 00 
  804210a61f:	ff d0                	call   *%rax
    if (trace_init) cprintf("Physical memory tree is correct\n");
  804210a621:	48 bf b8 10 12 42 80 	movabs $0x80421210b8,%rdi
  804210a628:	00 00 00 
  804210a62b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a630:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210a637:	00 00 00 
  804210a63a:	ff d2                	call   *%rdx
    struct Page *page = alloc_page(0, ALLOC_BOOTMEM);
  804210a63c:	be 00 00 04 00       	mov    $0x40000,%esi
  804210a641:	bf 00 00 00 00       	mov    $0x0,%edi
  804210a646:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  804210a64d:	00 00 00 
  804210a650:	ff d0                	call   *%rax
  804210a652:	49 89 c4             	mov    %rax,%r12
    page_ref(page);
  804210a655:	48 89 c7             	mov    %rax,%rdi
  804210a658:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  804210a65f:	00 00 00 
  804210a662:	ff d0                	call   *%rax
    return page->addr << CLASS_BASE;
  804210a664:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804210a66b:	ff 0f 00 
  804210a66e:	48 89 c1             	mov    %rax,%rcx
  804210a671:	49 23 4c 24 38       	and    0x38(%r12),%rcx
  804210a676:	48 c1 e1 0c          	shl    $0xc,%rcx
  804210a67a:	48 21 c1             	and    %rax,%rcx
    if (pa > max_memory_map_addr)
  804210a67d:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210a684:	00 00 00 
  804210a687:	48 39 c8             	cmp    %rcx,%rax
  804210a68a:	0f 82 fd 02 00 00    	jb     804210a98d <init_memory+0x7d7>
    return (void *)(pa + KERN_BASE_ADDR);
  804210a690:	49 bd 00 00 00 40 80 	movabs $0x8040000000,%r13
  804210a697:	00 00 00 
  804210a69a:	4a 8d 3c 29          	lea    (%rcx,%r13,1),%rdi
    kspace.pml4 = KADDR(page2pa(page));
  804210a69e:	49 bc e0 10 00 43 80 	movabs $0x80430010e0,%r12
  804210a6a5:	00 00 00 
  804210a6a8:	49 89 3c 24          	mov    %rdi,(%r12)
    kspace.cr3 = page2pa(page);
  804210a6ac:	49 89 4c 24 08       	mov    %rcx,0x8(%r12)
    memset(kspace.pml4, 0, CLASS_SIZE(0));
  804210a6b1:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210a6b6:	be 00 00 00 00       	mov    $0x0,%esi
  804210a6bb:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  804210a6c2:	00 00 00 
  804210a6c5:	ff d0                	call   *%rax
    kspace.pml4[PML4_INDEX(UVPT)] = kspace.cr3 | PTE_P | PTE_U;
  804210a6c7:	49 8b 14 24          	mov    (%r12),%rdx
  804210a6cb:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  804210a6d0:	48 83 c8 05          	or     $0x5,%rax
  804210a6d4:	48 89 82 f8 07 00 00 	mov    %rax,0x7f8(%rdx)
    kspace.root = alloc_descriptor(INTERMEDIATE_NODE);
  804210a6db:	bf 00 00 20 00       	mov    $0x200000,%edi
  804210a6e0:	48 b8 02 65 10 42 80 	movabs $0x8042106502,%rax
  804210a6e7:	00 00 00 
  804210a6ea:	ff d0                	call   *%rax
  804210a6ec:	49 89 44 24 10       	mov    %rax,0x10(%r12)
	if (map_physical_region(&kspace, KERN_BASE_ADDR, 0, max_memory_map_addr, PROT_R | PROT_W | ALLOC_WEAK) < 0) {
  804210a6f1:	41 b8 06 00 02 00    	mov    $0x20006,%r8d
  804210a6f7:	48 b8 f8 10 00 43 80 	movabs $0x80430010f8,%rax
  804210a6fe:	00 00 00 
  804210a701:	48 8b 08             	mov    (%rax),%rcx
  804210a704:	ba 00 00 00 00       	mov    $0x0,%edx
  804210a709:	4c 89 ee             	mov    %r13,%rsi
  804210a70c:	4c 89 e7             	mov    %r12,%rdi
  804210a70f:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210a716:	00 00 00 
  804210a719:	ff d0                	call   *%rax
  804210a71b:	85 c0                	test   %eax,%eax
  804210a71d:	0f 88 98 02 00 00    	js     804210a9bb <init_memory+0x805>
    assert(!((uintptr_t)__text_start & CLASS_MASK(0)));
  804210a723:	48 b8 00 00 10 42 80 	movabs $0x8042100000,%rax
  804210a72a:	00 00 00 
  804210a72d:	a9 ff 0f 00 00       	test   $0xfff,%eax
  804210a732:	0f 85 c0 02 00 00    	jne    804210a9f8 <init_memory+0x842>
    assert(__text_end - __text_start < MAX_LOW_ADDR_KERN_SIZE);
  804210a738:	48 b9 d0 f3 11 42 80 	movabs $0x804211f3d0,%rcx
  804210a73f:	00 00 00 
  804210a742:	48 b8 00 00 10 42 80 	movabs $0x8042100000,%rax
  804210a749:	00 00 00 
  804210a74c:	48 29 c1             	sub    %rax,%rcx
  804210a74f:	48 81 f9 ff ff 1f 03 	cmp    $0x31fffff,%rcx
  804210a756:	0f 8f d1 02 00 00    	jg     804210aa2d <init_memory+0x877>
    assert((uintptr_t)(end - KERN_BASE_ADDR) < MIN(BOOT_MEM_SIZE, max_memory_map_addr));
  804210a75c:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210a763:	00 00 00 
  804210a766:	ba 00 00 00 40       	mov    $0x40000000,%edx
  804210a76b:	48 39 d0             	cmp    %rdx,%rax
  804210a76e:	48 0f 47 c2          	cmova  %rdx,%rax
  804210a772:	48 ba 00 80 00 03 00 	movabs $0x3008000,%rdx
  804210a779:	00 00 00 
  804210a77c:	48 39 c2             	cmp    %rax,%rdx
  804210a77f:	0f 83 dd 02 00 00    	jae    804210aa62 <init_memory+0x8ac>
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804210a785:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804210a78c:	00 00 00 
  804210a78f:	48 bf 00 00 10 42 80 	movabs $0x8042100000,%rdi
  804210a796:	00 00 00 
  804210a799:	48 39 f8             	cmp    %rdi,%rax
  804210a79c:	0f 83 f5 02 00 00    	jae    804210aa97 <init_memory+0x8e1>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804210a7a2:	48 b8 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rax
  804210a7a9:	ff ff ff 
  804210a7ac:	48 bf 00 00 10 42 80 	movabs $0x8042100000,%rdi
  804210a7b3:	00 00 00 
  804210a7b6:	48 01 f8             	add    %rdi,%rax
  804210a7b9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	if (map_physical_region(&kspace, (uintptr_t)__text_start, PADDR(__text_start), (size_t)(__text_end - __text_start), PROT_R | PROT_X) < 0) {
  804210a7bd:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  804210a7c3:	48 89 c2             	mov    %rax,%rdx
  804210a7c6:	48 89 fe             	mov    %rdi,%rsi
  804210a7c9:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210a7d0:	00 00 00 
  804210a7d3:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210a7da:	00 00 00 
  804210a7dd:	ff d0                	call   *%rax
  804210a7df:	85 c0                	test   %eax,%eax
  804210a7e1:	0f 88 de 02 00 00    	js     804210aac5 <init_memory+0x90f>
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804210a7e7:	48 b8 00 30 12 42 80 	movabs $0x8042123000,%rax
  804210a7ee:	00 00 00 
  804210a7f1:	48 ba ff ff ff 3f 80 	movabs $0x803fffffff,%rdx
  804210a7f8:	00 00 00 
  804210a7fb:	48 39 c2             	cmp    %rax,%rdx
  804210a7fe:	0f 83 44 03 00 00    	jae    804210ab48 <init_memory+0x992>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804210a804:	48 ba 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rdx
  804210a80b:	ff ff ff 
  804210a80e:	48 01 d0             	add    %rdx,%rax
  804210a811:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	if (map_physical_region(&kspace, KERN_STACK_TOP - KERN_STACK_SIZE, PADDR(bootstack), KERN_STACK_SIZE, PROT_R | PROT_W) < 0) {
  804210a815:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804210a81b:	b9 00 00 01 00       	mov    $0x10000,%ecx
  804210a820:	48 89 c2             	mov    %rax,%rdx
  804210a823:	48 be 00 00 ff 3f 80 	movabs $0x803fff0000,%rsi
  804210a82a:	00 00 00 
  804210a82d:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210a834:	00 00 00 
  804210a837:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210a83e:	00 00 00 
  804210a841:	ff d0                	call   *%rax
  804210a843:	85 c0                	test   %eax,%eax
  804210a845:	0f 88 2b 03 00 00    	js     804210ab76 <init_memory+0x9c0>
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804210a84b:	48 b8 00 30 13 42 80 	movabs $0x8042133000,%rax
  804210a852:	00 00 00 
  804210a855:	48 ba ff ff ff 3f 80 	movabs $0x803fffffff,%rdx
  804210a85c:	00 00 00 
  804210a85f:	48 39 c2             	cmp    %rax,%rdx
  804210a862:	0f 83 43 03 00 00    	jae    804210abab <init_memory+0x9f5>
    return (physaddr_t)kva - KERN_BASE_ADDR;
  804210a868:	48 ba 00 00 00 c0 7f 	movabs $0xffffff7fc0000000,%rdx
  804210a86f:	ff ff ff 
  804210a872:	48 01 d0             	add    %rdx,%rax
  804210a875:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if (map_physical_region(&kspace, KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE, PADDR(pfstack), KERN_PF_STACK_SIZE, PROT_R | PROT_W) < 0) {
  804210a879:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804210a87f:	b9 00 00 01 00       	mov    $0x10000,%ecx
  804210a884:	48 89 c2             	mov    %rax,%rdx
  804210a887:	48 be 00 80 fd 3f 80 	movabs $0x803ffd8000,%rsi
  804210a88e:	00 00 00 
  804210a891:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210a898:	00 00 00 
  804210a89b:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210a8a2:	00 00 00 
  804210a8a5:	ff d0                	call   *%rax
  804210a8a7:	85 c0                	test   %eax,%eax
  804210a8a9:	0f 88 2a 03 00 00    	js     804210abd9 <init_memory+0xa23>
    EFI_MEMORY_DESCRIPTOR *mstart = (void *)uefi_lp->MemoryMap;
  804210a8af:	48 a1 00 30 14 42 80 	movabs 0x8042143000,%rax
  804210a8b6:	00 00 00 
  804210a8b9:	4c 8b 60 28          	mov    0x28(%rax),%r12
    EFI_MEMORY_DESCRIPTOR *mend = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapSize);
  804210a8bd:	4d 89 e5             	mov    %r12,%r13
  804210a8c0:	4c 03 68 38          	add    0x38(%rax),%r13
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804210a8c4:	4d 39 ec             	cmp    %r13,%r12
  804210a8c7:	0f 83 b8 03 00 00    	jae    804210ac85 <init_memory+0xacf>
            if (map_physical_region(&kspace, mstart->VirtualStart, mstart->PhysicalStart, mstart->NumberOfPages * PAGE_SIZE, PROT_R | PROT_W) < 0) {
  804210a8cd:	49 bf 17 9c 10 42 80 	movabs $0x8042109c17,%r15
  804210a8d4:	00 00 00 
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804210a8d7:	49 be 00 30 14 42 80 	movabs $0x8042143000,%r14
  804210a8de:	00 00 00 
  804210a8e1:	e9 34 03 00 00       	jmp    804210ac1a <init_memory+0xa64>
        extmem = cmos_read16(CMOS_EXTLO) * KB;
  804210a8e6:	45 0f b7 ff          	movzwl %r15w,%r15d
        max_memory_map_addr = extmem ? EXTPHYSMEM + extmem : basemem;
  804210a8ea:	4c 89 e6             	mov    %r12,%rsi
  804210a8ed:	49 c1 e7 0a          	shl    $0xa,%r15
  804210a8f1:	0f 84 c0 fb ff ff    	je     804210a4b7 <init_memory+0x301>
  804210a8f7:	e9 b4 fb ff ff       	jmp    804210a4b0 <init_memory+0x2fa>
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804210a8fc:	48 89 c1             	mov    %rax,%rcx
  804210a8ff:	48 ba 40 0b 12 42 80 	movabs $0x8042120b40,%rdx
  804210a906:	00 00 00 
  804210a909:	be b3 06 00 00       	mov    $0x6b3,%esi
  804210a90e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a915:	00 00 00 
  804210a918:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a91d:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210a924:	00 00 00 
  804210a927:	41 ff d0             	call   *%r8
  804210a92a:	48 89 d9             	mov    %rbx,%rcx
  804210a92d:	48 ba 40 0b 12 42 80 	movabs $0x8042120b40,%rdx
  804210a934:	00 00 00 
  804210a937:	be b6 06 00 00       	mov    $0x6b6,%esi
  804210a93c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a943:	00 00 00 
  804210a946:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a94b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210a952:	00 00 00 
  804210a955:	41 ff d0             	call   *%r8
    assert(zero_page && one_page);
  804210a958:	48 b9 6b f9 11 42 80 	movabs $0x804211f96b,%rcx
  804210a95f:	00 00 00 
  804210a962:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210a969:	00 00 00 
  804210a96c:	be b9 06 00 00       	mov    $0x6b9,%esi
  804210a971:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a978:	00 00 00 
  804210a97b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a980:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210a987:	00 00 00 
  804210a98a:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804210a98d:	49 89 c0             	mov    %rax,%r8
  804210a990:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210a997:	00 00 00 
  804210a99a:	be 1b 07 00 00       	mov    $0x71b,%esi
  804210a99f:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a9a6:	00 00 00 
  804210a9a9:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a9ae:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210a9b5:	00 00 00 
  804210a9b8:	41 ff d1             	call   *%r9
        panic("Cannot map physical region at %p of size %zd", (void *)0, max_memory_map_addr);
  804210a9bb:	48 b8 f8 10 00 43 80 	movabs $0x80430010f8,%rax
  804210a9c2:	00 00 00 
  804210a9c5:	4c 8b 00             	mov    (%rax),%r8
  804210a9c8:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210a9cd:	48 ba f8 0f 12 42 80 	movabs $0x8042120ff8,%rdx
  804210a9d4:	00 00 00 
  804210a9d7:	be 6e 07 00 00       	mov    $0x76e,%esi
  804210a9dc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210a9e3:	00 00 00 
  804210a9e6:	b8 00 00 00 00       	mov    $0x0,%eax
  804210a9eb:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210a9f2:	00 00 00 
  804210a9f5:	41 ff d1             	call   *%r9
    assert(!((uintptr_t)__text_start & CLASS_MASK(0)));
  804210a9f8:	48 b9 e0 10 12 42 80 	movabs $0x80421210e0,%rcx
  804210a9ff:	00 00 00 
  804210aa02:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210aa09:	00 00 00 
  804210aa0c:	be 71 07 00 00       	mov    $0x771,%esi
  804210aa11:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210aa18:	00 00 00 
  804210aa1b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210aa20:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210aa27:	00 00 00 
  804210aa2a:	41 ff d0             	call   *%r8
    assert(__text_end - __text_start < MAX_LOW_ADDR_KERN_SIZE);
  804210aa2d:	48 b9 10 11 12 42 80 	movabs $0x8042121110,%rcx
  804210aa34:	00 00 00 
  804210aa37:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210aa3e:	00 00 00 
  804210aa41:	be 72 07 00 00       	mov    $0x772,%esi
  804210aa46:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210aa4d:	00 00 00 
  804210aa50:	b8 00 00 00 00       	mov    $0x0,%eax
  804210aa55:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210aa5c:	00 00 00 
  804210aa5f:	41 ff d0             	call   *%r8
    assert((uintptr_t)(end - KERN_BASE_ADDR) < MIN(BOOT_MEM_SIZE, max_memory_map_addr));
  804210aa62:	48 b9 48 11 12 42 80 	movabs $0x8042121148,%rcx
  804210aa69:	00 00 00 
  804210aa6c:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210aa73:	00 00 00 
  804210aa76:	be 73 07 00 00       	mov    $0x773,%esi
  804210aa7b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210aa82:	00 00 00 
  804210aa85:	b8 00 00 00 00       	mov    $0x0,%eax
  804210aa8a:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210aa91:	00 00 00 
  804210aa94:	41 ff d0             	call   *%r8
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804210aa97:	48 89 f9             	mov    %rdi,%rcx
  804210aa9a:	48 ba 40 0b 12 42 80 	movabs $0x8042120b40,%rdx
  804210aaa1:	00 00 00 
  804210aaa4:	be 7a 07 00 00       	mov    $0x77a,%esi
  804210aaa9:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210aab0:	00 00 00 
  804210aab3:	b8 00 00 00 00       	mov    $0x0,%eax
  804210aab8:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210aabf:	00 00 00 
  804210aac2:	41 ff d0             	call   *%r8
    if ((uint64_t)kva < KERN_BASE_ADDR)
  804210aac5:	49 b8 d0 f3 11 42 80 	movabs $0x804211f3d0,%r8
  804210aacc:	00 00 00 
  804210aacf:	48 b8 ff ff ff 3f 80 	movabs $0x803fffffff,%rax
  804210aad6:	00 00 00 
  804210aad9:	4c 39 c0             	cmp    %r8,%rax
  804210aadc:	73 3c                	jae    804210ab1a <init_memory+0x964>
        panic("Cannot map physical region at %p of size %zd", (void *)PADDR(__text_start), PADDR(__text_end) - PADDR(__text_start));
  804210aade:	48 b8 00 00 10 42 80 	movabs $0x8042100000,%rax
  804210aae5:	00 00 00 
  804210aae8:	49 29 c0             	sub    %rax,%r8
  804210aaeb:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804210aaef:	48 ba f8 0f 12 42 80 	movabs $0x8042120ff8,%rdx
  804210aaf6:	00 00 00 
  804210aaf9:	be 7b 07 00 00       	mov    $0x77b,%esi
  804210aafe:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210ab05:	00 00 00 
  804210ab08:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ab0d:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210ab14:	00 00 00 
  804210ab17:	41 ff d1             	call   *%r9
        _panic(file, line, "PADDR called with invalid kva %p", kva);
  804210ab1a:	4c 89 c1             	mov    %r8,%rcx
  804210ab1d:	48 ba 40 0b 12 42 80 	movabs $0x8042120b40,%rdx
  804210ab24:	00 00 00 
  804210ab27:	be 7b 07 00 00       	mov    $0x77b,%esi
  804210ab2c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210ab33:	00 00 00 
  804210ab36:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ab3b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210ab42:	00 00 00 
  804210ab45:	41 ff d0             	call   *%r8
  804210ab48:	48 89 c1             	mov    %rax,%rcx
  804210ab4b:	48 ba 40 0b 12 42 80 	movabs $0x8042120b40,%rdx
  804210ab52:	00 00 00 
  804210ab55:	be 83 07 00 00       	mov    $0x783,%esi
  804210ab5a:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210ab61:	00 00 00 
  804210ab64:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ab69:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210ab70:	00 00 00 
  804210ab73:	41 ff d0             	call   *%r8
        panic("Can`t map physical region at %p of size %lld", (void *)PADDR(bootstack), KERN_STACK_SIZE);
  804210ab76:	41 b8 00 00 01 00    	mov    $0x10000,%r8d
  804210ab7c:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  804210ab80:	48 ba 98 11 12 42 80 	movabs $0x8042121198,%rdx
  804210ab87:	00 00 00 
  804210ab8a:	be 84 07 00 00       	mov    $0x784,%esi
  804210ab8f:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210ab96:	00 00 00 
  804210ab99:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ab9e:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210aba5:	00 00 00 
  804210aba8:	41 ff d1             	call   *%r9
  804210abab:	48 89 c1             	mov    %rax,%rcx
  804210abae:	48 ba 40 0b 12 42 80 	movabs $0x8042120b40,%rdx
  804210abb5:	00 00 00 
  804210abb8:	be 86 07 00 00       	mov    $0x786,%esi
  804210abbd:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210abc4:	00 00 00 
  804210abc7:	b8 00 00 00 00       	mov    $0x0,%eax
  804210abcc:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210abd3:	00 00 00 
  804210abd6:	41 ff d0             	call   *%r8
        panic("Can`t map physical region at %p of size %lld", (void *)PADDR(pfstack), KERN_PF_STACK_SIZE);
  804210abd9:	41 b8 00 00 01 00    	mov    $0x10000,%r8d
  804210abdf:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  804210abe3:	48 ba 98 11 12 42 80 	movabs $0x8042121198,%rdx
  804210abea:	00 00 00 
  804210abed:	be 87 07 00 00       	mov    $0x787,%esi
  804210abf2:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210abf9:	00 00 00 
  804210abfc:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ac01:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210ac08:	00 00 00 
  804210ac0b:	41 ff d1             	call   *%r9
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804210ac0e:	49 8b 06             	mov    (%r14),%rax
  804210ac11:	4c 03 60 20          	add    0x20(%rax),%r12
  804210ac15:	4d 39 ec             	cmp    %r13,%r12
  804210ac18:	73 6b                	jae    804210ac85 <init_memory+0xacf>
        if (mstart->Attribute & EFI_MEMORY_RUNTIME) {
  804210ac1a:	49 83 7c 24 20 00    	cmpq   $0x0,0x20(%r12)
  804210ac20:	79 ec                	jns    804210ac0e <init_memory+0xa58>
            if (map_physical_region(&kspace, mstart->VirtualStart, mstart->PhysicalStart, mstart->NumberOfPages * PAGE_SIZE, PROT_R | PROT_W) < 0) {
  804210ac22:	49 8b 4c 24 18       	mov    0x18(%r12),%rcx
  804210ac27:	48 c1 e1 0c          	shl    $0xc,%rcx
  804210ac2b:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  804210ac30:	49 8b 74 24 10       	mov    0x10(%r12),%rsi
  804210ac35:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804210ac3b:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210ac42:	00 00 00 
  804210ac45:	41 ff d7             	call   *%r15
  804210ac48:	85 c0                	test   %eax,%eax
  804210ac4a:	79 c2                	jns    804210ac0e <init_memory+0xa58>
                panic("Can`t map physical region at %p of size %llu", (void *)mstart->PhysicalStart, mstart->NumberOfPages * PAGE_SIZE);
  804210ac4c:	4d 8b 44 24 18       	mov    0x18(%r12),%r8
  804210ac51:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
  804210ac56:	49 c1 e0 0c          	shl    $0xc,%r8
  804210ac5a:	48 ba c8 11 12 42 80 	movabs $0x80421211c8,%rdx
  804210ac61:	00 00 00 
  804210ac64:	be 95 07 00 00       	mov    $0x795,%esi
  804210ac69:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210ac70:	00 00 00 
  804210ac73:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ac78:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210ac7f:	00 00 00 
  804210ac82:	41 ff d1             	call   *%r9
    uefi_lp = (LOADER_PARAMS *)uefi_lp->SelfVirtual;
  804210ac85:	48 b8 00 30 14 42 80 	movabs $0x8042143000,%rax
  804210ac8c:	00 00 00 
  804210ac8f:	48 8b 10             	mov    (%rax),%rdx
  804210ac92:	48 8b 12             	mov    (%rdx),%rdx
  804210ac95:	48 89 10             	mov    %rdx,(%rax)
    asm volatile("movq %0,%%cr0" ::"r"(val));
  804210ac98:	b8 23 00 05 80       	mov    $0x80050023,%eax
  804210ac9d:	0f 22 c0             	mov    %rax,%cr0
    asm volatile("movq %0,%%cr4" ::"r"(val));
  804210aca0:	b8 30 01 00 00       	mov    $0x130,%eax
  804210aca5:	0f 22 e0             	mov    %rax,%cr4
    asm volatile("rdmsr"
  804210aca8:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
  804210acad:	0f 32                	rdmsr
    asm volatile("rdmsr"
  804210acaf:	0f 32                	rdmsr
    for (size_t i = 0; i < CLASS_SIZE(MAX_ALLOCATION_CLASS); i++)
  804210acb1:	48 b8 00 00 00 43 80 	movabs $0x8043000000,%rax
  804210acb8:	00 00 00 
        assert(!zero_page_raw[i]);
  804210acbb:	80 3b 00             	cmpb   $0x0,(%rbx)
  804210acbe:	0f 85 b9 00 00 00    	jne    804210ad7d <init_memory+0xbc7>
    for (size_t i = 0; i < CLASS_SIZE(MAX_ALLOCATION_CLASS); i++)
  804210acc4:	48 83 c3 01          	add    $0x1,%rbx
  804210acc8:	48 39 c3             	cmp    %rax,%rbx
  804210accb:	75 ee                	jne    804210acbb <init_memory+0xb05>
    switch_address_space(&kspace);
  804210accd:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210acd4:	00 00 00 
  804210acd7:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210acde:	00 00 00 
  804210ace1:	ff d0                	call   *%rax
    nosan_memset(one_page_raw, 0xFF, CLASS_SIZE(MAX_ALLOCATION_CLASS));
  804210ace3:	ba 00 00 20 00       	mov    $0x200000,%edx
  804210ace8:	be ff 00 00 00       	mov    $0xff,%esi
  804210aced:	48 bf 00 00 c0 42 80 	movabs $0x8042c00000,%rdi
  804210acf4:	00 00 00 
  804210acf7:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  804210acfe:	00 00 00 
  804210ad01:	ff d0                	call   *%rax
    while (ctor < &__ctors_end) (*ctor++)();
  804210ad03:	48 ba b0 e7 97 42 80 	movabs $0x804297e7b0,%rdx
  804210ad0a:	00 00 00 
  804210ad0d:	48 b8 b0 e7 97 42 80 	movabs $0x804297e7b0,%rax
  804210ad14:	00 00 00 
  804210ad17:	48 39 c2             	cmp    %rax,%rdx
  804210ad1a:	73 17                	jae    804210ad33 <init_memory+0xb7d>
    void (**ctor)() = &__ctors_start;
  804210ad1c:	48 89 d3             	mov    %rdx,%rbx
    while (ctor < &__ctors_end) (*ctor++)();
  804210ad1f:	49 89 c4             	mov    %rax,%r12
  804210ad22:	48 83 c3 08          	add    $0x8,%rbx
  804210ad26:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ad2b:	ff 53 f8             	call   *-0x8(%rbx)
  804210ad2e:	4c 39 e3             	cmp    %r12,%rbx
  804210ad31:	72 ef                	jb     804210ad22 <init_memory+0xb6c>
    trap_init();
  804210ad33:	48 b8 2b d1 10 42 80 	movabs $0x804210d12b,%rax
  804210ad3a:	00 00 00 
  804210ad3d:	ff d0                	call   *%rax
    mstart = (void *)uefi_lp->MemoryMapVirt;
  804210ad3f:	48 a1 00 30 14 42 80 	movabs 0x8042143000,%rax
  804210ad46:	00 00 00 
  804210ad49:	48 8b 58 30          	mov    0x30(%rax),%rbx
    mend = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapSize);
  804210ad4d:	49 89 dc             	mov    %rbx,%r12
  804210ad50:	4c 03 60 38          	add    0x38(%rax),%r12
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804210ad54:	4c 39 e3             	cmp    %r12,%rbx
  804210ad57:	0f 83 fb 00 00 00    	jae    804210ae58 <init_memory+0xca2>
    if (pa > max_memory_map_addr)
  804210ad5d:	49 bf f8 10 00 43 80 	movabs $0x80430010f8,%r15
  804210ad64:	00 00 00 
    return (void *)(pa + KERN_BASE_ADDR);
  804210ad67:	49 be 00 00 00 40 80 	movabs $0x8040000000,%r14
  804210ad6e:	00 00 00 
  804210ad71:	49 bd 00 30 14 42 80 	movabs $0x8042143000,%r13
  804210ad78:	00 00 00 
  804210ad7b:	eb 70                	jmp    804210aded <init_memory+0xc37>
        assert(!zero_page_raw[i]);
  804210ad7d:	48 b9 81 f9 11 42 80 	movabs $0x804211f981,%rcx
  804210ad84:	00 00 00 
  804210ad87:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210ad8e:	00 00 00 
  804210ad91:	be ab 07 00 00       	mov    $0x7ab,%esi
  804210ad96:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210ad9d:	00 00 00 
  804210ada0:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ada5:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210adac:	00 00 00 
  804210adaf:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804210adb2:	48 89 f1             	mov    %rsi,%rcx
  804210adb5:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210adbc:	00 00 00 
  804210adbf:	be c7 07 00 00       	mov    $0x7c7,%esi
  804210adc4:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210adcb:	00 00 00 
  804210adce:	b8 00 00 00 00       	mov    $0x0,%eax
  804210add3:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210adda:	00 00 00 
  804210addd:	41 ff d1             	call   *%r9
    for (; mstart < mend; mstart = (void *)((uint8_t *)mstart + uefi_lp->MemoryMapDescriptorSize)) {
  804210ade0:	49 8b 45 00          	mov    0x0(%r13),%rax
  804210ade4:	48 03 58 20          	add    0x20(%rax),%rbx
  804210ade8:	4c 39 e3             	cmp    %r12,%rbx
  804210adeb:	73 6b                	jae    804210ae58 <init_memory+0xca2>
        if (mstart->Attribute & EFI_MEMORY_RUNTIME) {
  804210aded:	48 83 7b 20 00       	cmpq   $0x0,0x20(%rbx)
  804210adf2:	79 ec                	jns    804210ade0 <init_memory+0xc2a>
            nosan_memcpy(&expected, KADDR(mstart->PhysicalStart), sizeof(int));
  804210adf4:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    if (pa > max_memory_map_addr)
  804210adf8:	4d 8b 07             	mov    (%r15),%r8
  804210adfb:	49 39 f0             	cmp    %rsi,%r8
  804210adfe:	72 b2                	jb     804210adb2 <init_memory+0xbfc>
    return (void *)(pa + KERN_BASE_ADDR);
  804210ae00:	4c 01 f6             	add    %r14,%rsi
  804210ae03:	ba 04 00 00 00       	mov    $0x4,%edx
  804210ae08:	48 8d 7d cc          	lea    -0x34(%rbp),%rdi
  804210ae0c:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210ae13:	00 00 00 
  804210ae16:	ff d0                	call   *%rax
            assert(*(volatile int *)mstart->VirtualStart == expected);
  804210ae18:	48 8b 43 10          	mov    0x10(%rbx),%rax
  804210ae1c:	8b 00                	mov    (%rax),%eax
  804210ae1e:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  804210ae21:	74 bd                	je     804210ade0 <init_memory+0xc2a>
  804210ae23:	48 b9 f8 11 12 42 80 	movabs $0x80421211f8,%rcx
  804210ae2a:	00 00 00 
  804210ae2d:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210ae34:	00 00 00 
  804210ae37:	be c8 07 00 00       	mov    $0x7c8,%esi
  804210ae3c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210ae43:	00 00 00 
  804210ae46:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ae4b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210ae52:	00 00 00 
  804210ae55:	41 ff d0             	call   *%r8
    if (map_physical_region(&kspace, FRAMEBUFFER, uefi_lp->FrameBufferBase, (uintptr_t)uefi_lp->FrameBufferSize, PROT_R | PROT_W | PROT_WC) < 0) {
  804210ae58:	48 a1 00 30 14 42 80 	movabs 0x8042143000,%rax
  804210ae5f:	00 00 00 
  804210ae62:	8b 48 48             	mov    0x48(%rax),%ecx
  804210ae65:	48 8b 50 40          	mov    0x40(%rax),%rdx
  804210ae69:	41 b8 16 00 00 00    	mov    $0x16,%r8d
  804210ae6f:	48 be 00 00 e0 1f 80 	movabs $0x801fe00000,%rsi
  804210ae76:	00 00 00 
  804210ae79:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210ae80:	00 00 00 
  804210ae83:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210ae8a:	00 00 00 
  804210ae8d:	ff d0                	call   *%rax
  804210ae8f:	85 c0                	test   %eax,%eax
  804210ae91:	0f 88 74 01 00 00    	js     804210b00b <init_memory+0xe55>
    if (map_physical_region(&kspace, X86ADDR(KERN_BASE_ADDR), 0, (uintptr_t)MIN(MAX_LOW_ADDR_KERN_SIZE, max_memory_map_addr), PROT_R | PROT_W | ALLOC_WEAK) < 0) {
  804210ae97:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210ae9e:	00 00 00 
  804210aea1:	ba 00 00 20 03       	mov    $0x3200000,%edx
  804210aea6:	48 39 d0             	cmp    %rdx,%rax
  804210aea9:	48 89 d1             	mov    %rdx,%rcx
  804210aeac:	48 0f 46 c8          	cmovbe %rax,%rcx
  804210aeb0:	41 b8 06 00 02 00    	mov    $0x20006,%r8d
  804210aeb6:	ba 00 00 00 00       	mov    $0x0,%edx
  804210aebb:	be 00 00 00 40       	mov    $0x40000000,%esi
  804210aec0:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210aec7:	00 00 00 
  804210aeca:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210aed1:	00 00 00 
  804210aed4:	ff d0                	call   *%rax
  804210aed6:	85 c0                	test   %eax,%eax
  804210aed8:	0f 88 6a 01 00 00    	js     804210b048 <init_memory+0xe92>
    if (map_physical_region(&kspace, X86ADDR((uintptr_t)__text_start), PADDR(__text_start), (uintptr_t)ROUNDUP(X86ADDR((uintptr_t)__text_end), CLASS_SIZE(0)) - X86ADDR((uintptr_t)__text_start), PROT_R | PROT_X) < 0) {
  804210aede:	48 b8 00 00 10 42 80 	movabs $0x8042100000,%rax
  804210aee5:	00 00 00 
  804210aee8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  804210aeec:	8b 75 a0             	mov    -0x60(%rbp),%esi
  804210aeef:	48 b8 d0 f3 11 42 80 	movabs $0x804211f3d0,%rax
  804210aef6:	00 00 00 
  804210aef9:	89 c0                	mov    %eax,%eax
  804210aefb:	48 05 ff 0f 00 00    	add    $0xfff,%rax
  804210af01:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804210af07:	48 29 f0             	sub    %rsi,%rax
  804210af0a:	48 89 c3             	mov    %rax,%rbx
  804210af0d:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  804210af13:	48 89 c1             	mov    %rax,%rcx
  804210af16:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804210af1a:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210af21:	00 00 00 
  804210af24:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210af2b:	00 00 00 
  804210af2e:	ff d0                	call   *%rax
  804210af30:	85 c0                	test   %eax,%eax
  804210af32:	0f 88 57 01 00 00    	js     804210b08f <init_memory+0xed9>
    if (map_physical_region(&kspace, X86ADDR(KERN_STACK_TOP - KERN_STACK_SIZE), PADDR(bootstack), (uintptr_t)KERN_STACK_SIZE, PROT_R | PROT_W) < 0) {
  804210af38:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804210af3e:	b9 00 00 01 00       	mov    $0x10000,%ecx
  804210af43:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  804210af47:	be 00 00 ff 3f       	mov    $0x3fff0000,%esi
  804210af4c:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210af53:	00 00 00 
  804210af56:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210af5d:	00 00 00 
  804210af60:	ff d0                	call   *%rax
  804210af62:	85 c0                	test   %eax,%eax
  804210af64:	0f 88 57 01 00 00    	js     804210b0c1 <init_memory+0xf0b>
    if (map_physical_region(&kspace, X86ADDR(KERN_PF_STACK_TOP - KERN_PF_STACK_SIZE), PADDR(pfstack), (uintptr_t)KERN_PF_STACK_SIZE, PROT_R | PROT_W) < 0) {
  804210af6a:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  804210af70:	b9 00 00 01 00       	mov    $0x10000,%ecx
  804210af75:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804210af79:	be 00 80 fd 3f       	mov    $0x3ffd8000,%esi
  804210af7e:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210af85:	00 00 00 
  804210af88:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210af8f:	00 00 00 
  804210af92:	ff d0                	call   *%rax
  804210af94:	85 c0                	test   %eax,%eax
  804210af96:	0f 88 5a 01 00 00    	js     804210b0f6 <init_memory+0xf40>
    check_physical_tree(&root);
  804210af9c:	48 bf 80 10 00 43 80 	movabs $0x8043001080,%rdi
  804210afa3:	00 00 00 
  804210afa6:	48 b8 da 4d 10 42 80 	movabs $0x8042104dda,%rax
  804210afad:	00 00 00 
  804210afb0:	ff d0                	call   *%rax
    if (trace_init) cprintf("Physical memory tree is still correct\n");
  804210afb2:	48 bf 60 12 12 42 80 	movabs $0x8042121260,%rdi
  804210afb9:	00 00 00 
  804210afbc:	b8 00 00 00 00       	mov    $0x0,%eax
  804210afc1:	48 bb 70 cf 10 42 80 	movabs $0x804210cf70,%rbx
  804210afc8:	00 00 00 
  804210afcb:	ff d3                	call   *%rbx
    check_virtual_tree(kspace.root, MAX_CLASS);
  804210afcd:	be 30 00 00 00       	mov    $0x30,%esi
  804210afd2:	48 b8 f0 10 00 43 80 	movabs $0x80430010f0,%rax
  804210afd9:	00 00 00 
  804210afdc:	48 8b 38             	mov    (%rax),%rdi
  804210afdf:	48 b8 08 54 10 42 80 	movabs $0x8042105408,%rax
  804210afe6:	00 00 00 
  804210afe9:	ff d0                	call   *%rax
    if (trace_init) cprintf("Kernel virtual memory tree is correct\n");
  804210afeb:	48 bf 88 12 12 42 80 	movabs $0x8042121288,%rdi
  804210aff2:	00 00 00 
  804210aff5:	b8 00 00 00 00       	mov    $0x0,%eax
  804210affa:	ff d3                	call   *%rbx
}
  804210affc:	48 83 c4 38          	add    $0x38,%rsp
  804210b000:	5b                   	pop    %rbx
  804210b001:	41 5c                	pop    %r12
  804210b003:	41 5d                	pop    %r13
  804210b005:	41 5e                	pop    %r14
  804210b007:	41 5f                	pop    %r15
  804210b009:	5d                   	pop    %rbp
  804210b00a:	c3                   	ret
        panic("Can`t map physical region at %p of size %zd", (void *)uefi_lp->FrameBufferBase, (uintptr_t)uefi_lp->FrameBufferSize);
  804210b00b:	48 a1 00 30 14 42 80 	movabs 0x8042143000,%rax
  804210b012:	00 00 00 
  804210b015:	48 8b 48 40          	mov    0x40(%rax),%rcx
  804210b019:	44 8b 40 48          	mov    0x48(%rax),%r8d
  804210b01d:	48 ba 30 12 12 42 80 	movabs $0x8042121230,%rdx
  804210b024:	00 00 00 
  804210b027:	be da 07 00 00       	mov    $0x7da,%esi
  804210b02c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b033:	00 00 00 
  804210b036:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b03b:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210b042:	00 00 00 
  804210b045:	41 ff d1             	call   *%r9
        panic("Can`t map physical region at %p of size %zd", (void *)0, (uintptr_t)MIN(MAX_LOW_ADDR_KERN_SIZE, max_memory_map_addr));
  804210b048:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210b04f:	00 00 00 
  804210b052:	41 b8 00 00 20 03    	mov    $0x3200000,%r8d
  804210b058:	4c 39 c0             	cmp    %r8,%rax
  804210b05b:	4c 0f 46 c0          	cmovbe %rax,%r8
  804210b05f:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210b064:	48 ba 30 12 12 42 80 	movabs $0x8042121230,%rdx
  804210b06b:	00 00 00 
  804210b06e:	be dd 07 00 00       	mov    $0x7dd,%esi
  804210b073:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b07a:	00 00 00 
  804210b07d:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b082:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210b089:	00 00 00 
  804210b08c:	41 ff d1             	call   *%r9
        panic("Can`t map physical region at %p of size %zd", (void *)PADDR(__text_start), (uintptr_t)ROUNDUP(X86ADDR((uintptr_t)__text_end), CLASS_SIZE(0)) - X86ADDR((uintptr_t)__text_start));
  804210b08f:	49 89 d8             	mov    %rbx,%r8
  804210b092:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804210b096:	48 ba 30 12 12 42 80 	movabs $0x8042121230,%rdx
  804210b09d:	00 00 00 
  804210b0a0:	be e0 07 00 00       	mov    $0x7e0,%esi
  804210b0a5:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b0ac:	00 00 00 
  804210b0af:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b0b4:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210b0bb:	00 00 00 
  804210b0be:	41 ff d1             	call   *%r9
        panic("Can`t map physical region at %p of size %zd", (void *)PADDR(bootstack), (uintptr_t)KERN_STACK_SIZE);
  804210b0c1:	41 b8 00 00 01 00    	mov    $0x10000,%r8d
  804210b0c7:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  804210b0cb:	48 ba 30 12 12 42 80 	movabs $0x8042121230,%rdx
  804210b0d2:	00 00 00 
  804210b0d5:	be e3 07 00 00       	mov    $0x7e3,%esi
  804210b0da:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b0e1:	00 00 00 
  804210b0e4:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b0e9:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210b0f0:	00 00 00 
  804210b0f3:	41 ff d1             	call   *%r9
        panic("Can`t map physical region at %p of size %zd", (void *)PADDR(pfstack), (uintptr_t)KERN_PF_STACK_SIZE);
  804210b0f6:	41 b8 00 00 01 00    	mov    $0x10000,%r8d
  804210b0fc:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  804210b100:	48 ba 30 12 12 42 80 	movabs $0x8042121230,%rdx
  804210b107:	00 00 00 
  804210b10a:	be e6 07 00 00       	mov    $0x7e6,%esi
  804210b10f:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b116:	00 00 00 
  804210b119:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b11e:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210b125:	00 00 00 
  804210b128:	41 ff d1             	call   *%r9

000000804210b12b <alloc_composite_page>:
alloc_composite_page(struct AddressSpace *spc, uintptr_t addr, int class, int flags) {
  804210b12b:	f3 0f 1e fa          	endbr64
  804210b12f:	55                   	push   %rbp
  804210b130:	48 89 e5             	mov    %rsp,%rbp
  804210b133:	41 57                	push   %r15
  804210b135:	41 56                	push   %r14
  804210b137:	41 55                	push   %r13
  804210b139:	41 54                	push   %r12
  804210b13b:	53                   	push   %rbx
  804210b13c:	48 83 ec 18          	sub    $0x18,%rsp
  804210b140:	41 89 ce             	mov    %ecx,%r14d
    assert(!(addr & CLASS_MASK(class)));
  804210b143:	8d 4a 0c             	lea    0xc(%rdx),%ecx
  804210b146:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  804210b14d:	48 d3 e0             	shl    %cl,%rax
  804210b150:	48 f7 d0             	not    %rax
  804210b153:	48 85 f0             	test   %rsi,%rax
  804210b156:	75 4b                	jne    804210b1a3 <alloc_composite_page+0x78>
  804210b158:	49 89 ff             	mov    %rdi,%r15
  804210b15b:	49 89 f5             	mov    %rsi,%r13
  804210b15e:	89 d3                	mov    %edx,%ebx
    struct Page *page = alloc_page(class, flags);
  804210b160:	44 89 f6             	mov    %r14d,%esi
  804210b163:	89 d7                	mov    %edx,%edi
  804210b165:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  804210b16c:	00 00 00 
  804210b16f:	ff d0                	call   *%rax
    if (page) {
  804210b171:	48 85 c0             	test   %rax,%rax
  804210b174:	74 62                	je     804210b1d8 <alloc_composite_page+0xad>
        res = map_page(spc, addr, page, flags);
  804210b176:	44 89 f1             	mov    %r14d,%ecx
  804210b179:	48 89 c2             	mov    %rax,%rdx
  804210b17c:	4c 89 ee             	mov    %r13,%rsi
  804210b17f:	4c 89 ff             	mov    %r15,%rdi
  804210b182:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  804210b189:	00 00 00 
  804210b18c:	ff d0                	call   *%rax
  804210b18e:	41 89 c4             	mov    %eax,%r12d
}
  804210b191:	44 89 e0             	mov    %r12d,%eax
  804210b194:	48 83 c4 18          	add    $0x18,%rsp
  804210b198:	5b                   	pop    %rbx
  804210b199:	41 5c                	pop    %r12
  804210b19b:	41 5d                	pop    %r13
  804210b19d:	41 5e                	pop    %r14
  804210b19f:	41 5f                	pop    %r15
  804210b1a1:	5d                   	pop    %rbp
  804210b1a2:	c3                   	ret
    assert(!(addr & CLASS_MASK(class)));
  804210b1a3:	48 b9 8c f8 11 42 80 	movabs $0x804211f88c,%rcx
  804210b1aa:	00 00 00 
  804210b1ad:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b1b4:	00 00 00 
  804210b1b7:	be 19 05 00 00       	mov    $0x519,%esi
  804210b1bc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b1c3:	00 00 00 
  804210b1c6:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b1cb:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b1d2:	00 00 00 
  804210b1d5:	41 ff d0             	call   *%r8
    } else if (class) {
  804210b1d8:	85 db                	test   %ebx,%ebx
  804210b1da:	74 6c                	je     804210b248 <alloc_composite_page+0x11d>
        if ((res = alloc_composite_page(spc, addr, class - 1, flags)) < 0) return res;
  804210b1dc:	8d 43 ff             	lea    -0x1(%rbx),%eax
  804210b1df:	44 89 f1             	mov    %r14d,%ecx
  804210b1e2:	89 45 cc             	mov    %eax,-0x34(%rbp)
  804210b1e5:	89 c2                	mov    %eax,%edx
  804210b1e7:	4c 89 ee             	mov    %r13,%rsi
  804210b1ea:	4c 89 ff             	mov    %r15,%rdi
  804210b1ed:	48 b8 2b b1 10 42 80 	movabs $0x804210b12b,%rax
  804210b1f4:	00 00 00 
  804210b1f7:	ff d0                	call   *%rax
  804210b1f9:	41 89 c4             	mov    %eax,%r12d
  804210b1fc:	85 c0                	test   %eax,%eax
  804210b1fe:	78 91                	js     804210b191 <alloc_composite_page+0x66>
        if ((res = alloc_composite_page(spc, addr + CLASS_SIZE(class - 1), class - 1, flags)) < 0)
  804210b200:	8d 4b 0b             	lea    0xb(%rbx),%ecx
  804210b203:	be 01 00 00 00       	mov    $0x1,%esi
  804210b208:	48 d3 e6             	shl    %cl,%rsi
  804210b20b:	4c 01 ee             	add    %r13,%rsi
  804210b20e:	44 89 f1             	mov    %r14d,%ecx
  804210b211:	8b 55 cc             	mov    -0x34(%rbp),%edx
  804210b214:	4c 89 ff             	mov    %r15,%rdi
  804210b217:	48 b8 2b b1 10 42 80 	movabs $0x804210b12b,%rax
  804210b21e:	00 00 00 
  804210b221:	ff d0                	call   *%rax
  804210b223:	41 89 c4             	mov    %eax,%r12d
  804210b226:	85 c0                	test   %eax,%eax
  804210b228:	0f 89 63 ff ff ff    	jns    804210b191 <alloc_composite_page+0x66>
            unmap_page(spc, addr, class - 1);
  804210b22e:	8b 55 cc             	mov    -0x34(%rbp),%edx
  804210b231:	4c 89 ee             	mov    %r13,%rsi
  804210b234:	4c 89 ff             	mov    %r15,%rdi
  804210b237:	48 b8 13 7f 10 42 80 	movabs $0x8042107f13,%rax
  804210b23e:	00 00 00 
  804210b241:	ff d0                	call   *%rax
  804210b243:	e9 49 ff ff ff       	jmp    804210b191 <alloc_composite_page+0x66>
    int res = -E_NO_MEM;
  804210b248:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
  804210b24e:	e9 3e ff ff ff       	jmp    804210b191 <alloc_composite_page+0x66>

000000804210b253 <force_alloc_page>:
force_alloc_page(struct AddressSpace *spc, uintptr_t va, int maxclass) {
  804210b253:	f3 0f 1e fa          	endbr64
  804210b257:	55                   	push   %rbp
  804210b258:	48 89 e5             	mov    %rsp,%rbp
  804210b25b:	41 57                	push   %r15
  804210b25d:	41 56                	push   %r14
  804210b25f:	41 55                	push   %r13
  804210b261:	41 54                	push   %r12
  804210b263:	53                   	push   %rbx
  804210b264:	48 83 ec 18          	sub    $0x18,%rsp
    assert(current_space);
  804210b268:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  804210b26f:	00 00 00 
  804210b272:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210b276:	0f 84 75 01 00 00    	je     804210b3f1 <force_alloc_page+0x19e>
  804210b27c:	48 89 fb             	mov    %rdi,%rbx
  804210b27f:	49 89 f6             	mov    %rsi,%r14
  804210b282:	41 89 d4             	mov    %edx,%r12d
    old = switch_address_space(spc = (va > MAX_USER_ADDRESS ? &kspace : spc));
  804210b285:	48 b8 00 00 00 00 80 	movabs $0x8000000000,%rax
  804210b28c:	00 00 00 
  804210b28f:	48 39 f0             	cmp    %rsi,%rax
  804210b292:	48 b8 e0 10 00 43 80 	movabs $0x80430010e0,%rax
  804210b299:	00 00 00 
  804210b29c:	48 0f 42 d8          	cmovb  %rax,%rbx
  804210b2a0:	48 89 df             	mov    %rbx,%rdi
  804210b2a3:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210b2aa:	00 00 00 
  804210b2ad:	ff d0                	call   *%rax
  804210b2af:	49 89 c7             	mov    %rax,%r15
    if (!(page = page_lookup_virtual(spc->root, va, maxclass, LOOKUP_SPLIT))) goto fault;
  804210b2b2:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  804210b2b6:	b9 02 00 00 00       	mov    $0x2,%ecx
  804210b2bb:	44 89 e2             	mov    %r12d,%edx
  804210b2be:	4c 89 f6             	mov    %r14,%rsi
  804210b2c1:	48 b8 fa 72 10 42 80 	movabs $0x80421072fa,%rax
  804210b2c8:	00 00 00 
  804210b2cb:	ff d0                	call   *%rax
  804210b2cd:	48 85 c0             	test   %rax,%rax
  804210b2d0:	0f 84 f1 02 00 00    	je     804210b5c7 <force_alloc_page+0x374>
    if (!(page = page_lookup_virtual(spc->root, va, 0, LOOKUP_PRESERVE))) goto fault;
  804210b2d6:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  804210b2da:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210b2df:	ba 00 00 00 00       	mov    $0x0,%edx
  804210b2e4:	4c 89 f6             	mov    %r14,%rsi
  804210b2e7:	48 b8 fa 72 10 42 80 	movabs $0x80421072fa,%rax
  804210b2ee:	00 00 00 
  804210b2f1:	ff d0                	call   *%rax
  804210b2f3:	49 89 c5             	mov    %rax,%r13
  804210b2f6:	48 85 c0             	test   %rax,%rax
  804210b2f9:	0f 84 c8 02 00 00    	je     804210b5c7 <force_alloc_page+0x374>
    if (!(page->state & PROT_LAZY)) goto fault;
  804210b2ff:	8b 50 28             	mov    0x28(%rax),%edx
  804210b302:	f6 c2 80             	test   $0x80,%dl
  804210b305:	0f 84 bc 02 00 00    	je     804210b5c7 <force_alloc_page+0x374>
    va &= ~CLASS_MASK(page->phy->class);
  804210b30b:	4c 8b 60 30          	mov    0x30(%rax),%r12
  804210b30f:	41 0f b7 4c 24 34    	movzwl 0x34(%r12),%ecx
  804210b315:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  804210b31b:	83 c1 0c             	add    $0xc,%ecx
  804210b31e:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  804210b325:	48 d3 e0             	shl    %cl,%rax
  804210b328:	49 21 c6             	and    %rax,%r14
    if (PAGE_IS_UNIQ(page->phy)) {
  804210b32b:	41 83 7c 24 30 01    	cmpl   $0x1,0x30(%r12)
  804210b331:	75 0c                	jne    804210b33f <force_alloc_page+0xec>
  804210b333:	49 83 7c 24 10 00    	cmpq   $0x0,0x10(%r12)
  804210b339:	0f 84 e7 00 00 00    	je     804210b426 <force_alloc_page+0x1d3>
        page_ref(phy);
  804210b33f:	4c 89 e7             	mov    %r12,%rdi
  804210b342:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  804210b349:	00 00 00 
  804210b34c:	ff d0                	call   *%rax
        res = alloc_composite_page(spc, va, phy->class, page->state & PROT_ALL & ~PROT_LAZY);
  804210b34e:	41 8b 4d 28          	mov    0x28(%r13),%ecx
  804210b352:	81 e1 7f 0f 00 00    	and    $0xf7f,%ecx
  804210b358:	41 0f b7 54 24 34    	movzwl 0x34(%r12),%edx
  804210b35e:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  804210b364:	4c 89 f6             	mov    %r14,%rsi
  804210b367:	48 89 df             	mov    %rbx,%rdi
  804210b36a:	48 b8 2b b1 10 42 80 	movabs $0x804210b12b,%rax
  804210b371:	00 00 00 
  804210b374:	ff d0                	call   *%rax
  804210b376:	41 89 c5             	mov    %eax,%r13d
        if (!res) memcpy_page(spc, va, phy);
  804210b379:	85 c0                	test   %eax,%eax
  804210b37b:	0f 84 d3 00 00 00    	je     804210b454 <force_alloc_page+0x201>
        page_unref(phy);
  804210b381:	4c 89 e7             	mov    %r12,%rdi
  804210b384:	48 b8 56 49 10 42 80 	movabs $0x8042104956,%rax
  804210b38b:	00 00 00 
  804210b38e:	ff d0                	call   *%rax
    switch_address_space(old);
  804210b390:	4c 89 ff             	mov    %r15,%rdi
  804210b393:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210b39a:	00 00 00 
  804210b39d:	ff d0                	call   *%rax
    if (res == -E_NO_MEM) {
  804210b39f:	41 83 fd fc          	cmp    $0xfffffffc,%r13d
  804210b3a3:	0f 84 c0 01 00 00    	je     804210b569 <force_alloc_page+0x316>
        assert(!res || res == -E_FAULT);
  804210b3a9:	45 85 ed             	test   %r13d,%r13d
  804210b3ac:	0f 84 d9 01 00 00    	je     804210b58b <force_alloc_page+0x338>
  804210b3b2:	41 83 fd f9          	cmp    $0xfffffff9,%r13d
  804210b3b6:	0f 84 cf 01 00 00    	je     804210b58b <force_alloc_page+0x338>
  804210b3bc:	48 b9 a1 f9 11 42 80 	movabs $0x804211f9a1,%rcx
  804210b3c3:	00 00 00 
  804210b3c6:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b3cd:	00 00 00 
  804210b3d0:	be 5e 05 00 00       	mov    $0x55e,%esi
  804210b3d5:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b3dc:	00 00 00 
  804210b3df:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b3e4:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b3eb:	00 00 00 
  804210b3ee:	41 ff d0             	call   *%r8
    assert(current_space);
  804210b3f1:	48 b9 93 f9 11 42 80 	movabs $0x804211f993,%rcx
  804210b3f8:	00 00 00 
  804210b3fb:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b402:	00 00 00 
  804210b405:	be 36 05 00 00       	mov    $0x536,%esi
  804210b40a:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b411:	00 00 00 
  804210b414:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b419:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b420:	00 00 00 
  804210b423:	41 ff d0             	call   *%r8
    if (PAGE_IS_UNIQ(page->phy)) {
  804210b426:	49 83 7c 24 18 00    	cmpq   $0x0,0x18(%r12)
  804210b42c:	0f 85 0d ff ff ff    	jne    804210b33f <force_alloc_page+0xec>
        res = map_page(spc, va, page->phy, page->state & ~PROT_LAZY);
  804210b432:	80 e2 7f             	and    $0x7f,%dl
  804210b435:	89 d1                	mov    %edx,%ecx
  804210b437:	4c 89 e2             	mov    %r12,%rdx
  804210b43a:	4c 89 f6             	mov    %r14,%rsi
  804210b43d:	48 89 df             	mov    %rbx,%rdi
  804210b440:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  804210b447:	00 00 00 
  804210b44a:	ff d0                	call   *%rax
  804210b44c:	41 89 c5             	mov    %eax,%r13d
  804210b44f:	e9 3c ff ff ff       	jmp    804210b390 <force_alloc_page+0x13d>
    assert(current_space);
  804210b454:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  804210b45b:	00 00 00 
  804210b45e:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210b462:	0f 84 9b 00 00 00    	je     804210b503 <force_alloc_page+0x2b0>
    struct AddressSpace *old = switch_address_space(dst);
  804210b468:	48 89 df             	mov    %rbx,%rdi
  804210b46b:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210b472:	00 00 00 
  804210b475:	ff d0                	call   *%rax
  804210b477:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    asm volatile("movq %%cr0,%0"
  804210b47b:	0f 20 c0             	mov    %cr0,%rax
}

inline static void
set_wp(bool wp) {
    uintptr_t old = rcr0();
    lcr0(wp ? old | CR0_WP : old & ~CR0_WP);
  804210b47e:	48 25 ff ff fe ff    	and    $0xfffffffffffeffff,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  804210b484:	0f 22 c0             	mov    %rax,%cr0
    nosan_memcpy((void *)va, KADDR(page2pa(page)), CLASS_SIZE(page->class));
  804210b487:	41 0f b7 4c 24 34    	movzwl 0x34(%r12),%ecx
  804210b48d:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  804210b493:	83 c1 0c             	add    $0xc,%ecx
  804210b496:	ba 01 00 00 00       	mov    $0x1,%edx
  804210b49b:	48 d3 e2             	shl    %cl,%rdx
    return page->addr << CLASS_BASE;
  804210b49e:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804210b4a5:	ff 0f 00 
  804210b4a8:	48 89 c6             	mov    %rax,%rsi
  804210b4ab:	49 23 74 24 38       	and    0x38(%r12),%rsi
  804210b4b0:	48 c1 e6 0c          	shl    $0xc,%rsi
  804210b4b4:	48 21 c6             	and    %rax,%rsi
    if (pa > max_memory_map_addr)
  804210b4b7:	48 a1 f8 10 00 43 80 	movabs 0x80430010f8,%rax
  804210b4be:	00 00 00 
  804210b4c1:	48 39 f0             	cmp    %rsi,%rax
  804210b4c4:	72 72                	jb     804210b538 <force_alloc_page+0x2e5>
    return (void *)(pa + KERN_BASE_ADDR);
  804210b4c6:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804210b4cd:	00 00 00 
  804210b4d0:	48 01 c6             	add    %rax,%rsi
  804210b4d3:	4c 89 f7             	mov    %r14,%rdi
  804210b4d6:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210b4dd:	00 00 00 
  804210b4e0:	ff d0                	call   *%rax
    asm volatile("movq %%cr0,%0"
  804210b4e2:	0f 20 c0             	mov    %cr0,%rax
    lcr0(wp ? old | CR0_WP : old & ~CR0_WP);
  804210b4e5:	48 0d 00 00 01 00    	or     $0x10000,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  804210b4eb:	0f 22 c0             	mov    %rax,%cr0
    switch_address_space(old);
  804210b4ee:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210b4f2:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210b4f9:	00 00 00 
  804210b4fc:	ff d0                	call   *%rax
}
  804210b4fe:	e9 7e fe ff ff       	jmp    804210b381 <force_alloc_page+0x12e>
    assert(current_space);
  804210b503:	48 b9 93 f9 11 42 80 	movabs $0x804211f993,%rcx
  804210b50a:	00 00 00 
  804210b50d:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b514:	00 00 00 
  804210b517:	be 53 03 00 00       	mov    $0x353,%esi
  804210b51c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b523:	00 00 00 
  804210b526:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b52b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b532:	00 00 00 
  804210b535:	41 ff d0             	call   *%r8
        _panic(file, line, "KADDR called with invalid pa %p with max_memory_map_addr=%p", (void *)pa, (void *)max_memory_map_addr);
  804210b538:	49 89 c0             	mov    %rax,%r8
  804210b53b:	48 89 f1             	mov    %rsi,%rcx
  804210b53e:	48 ba 88 0a 12 42 80 	movabs $0x8042120a88,%rdx
  804210b545:	00 00 00 
  804210b548:	be 59 03 00 00       	mov    $0x359,%esi
  804210b54d:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b554:	00 00 00 
  804210b557:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b55c:	49 b9 e0 02 10 42 80 	movabs $0x80421002e0,%r9
  804210b563:	00 00 00 
  804210b566:	41 ff d1             	call   *%r9
        if (spc != &kspace) {
  804210b569:	48 b8 e0 10 00 43 80 	movabs $0x80430010e0,%rax
  804210b570:	00 00 00 
  804210b573:	48 39 c3             	cmp    %rax,%rbx
  804210b576:	74 25                	je     804210b59d <force_alloc_page+0x34a>
            struct Env *env = (void *)((uint8_t *)spc - offsetof(struct Env, address_space));
  804210b578:	48 8d bb 18 ff ff ff 	lea    -0xe8(%rbx),%rdi
            env_destroy(env);
  804210b57f:	48 b8 e4 c7 10 42 80 	movabs $0x804210c7e4,%rax
  804210b586:	00 00 00 
  804210b589:	ff d0                	call   *%rax
}
  804210b58b:	44 89 e8             	mov    %r13d,%eax
  804210b58e:	48 83 c4 18          	add    $0x18,%rsp
  804210b592:	5b                   	pop    %rbx
  804210b593:	41 5c                	pop    %r12
  804210b595:	41 5d                	pop    %r13
  804210b597:	41 5e                	pop    %r14
  804210b599:	41 5f                	pop    %r15
  804210b59b:	5d                   	pop    %rbp
  804210b59c:	c3                   	ret
            panic("Out of memory\n");
  804210b59d:	48 ba 64 f8 11 42 80 	movabs $0x804211f864,%rdx
  804210b5a4:	00 00 00 
  804210b5a7:	be 5c 05 00 00       	mov    $0x55c,%esi
  804210b5ac:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b5b3:	00 00 00 
  804210b5b6:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b5bb:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210b5c2:	00 00 00 
  804210b5c5:	ff d1                	call   *%rcx
    switch_address_space(old);
  804210b5c7:	4c 89 ff             	mov    %r15,%rdi
  804210b5ca:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210b5d1:	00 00 00 
  804210b5d4:	ff d0                	call   *%rax
  804210b5d6:	41 bd f9 ff ff ff    	mov    $0xfffffff9,%r13d
  804210b5dc:	eb ad                	jmp    804210b58b <force_alloc_page+0x338>

000000804210b5de <do_map_page>:
do_map_page(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, struct Page *phy, int oldflags, int flags) {
  804210b5de:	f3 0f 1e fa          	endbr64
  804210b5e2:	55                   	push   %rbp
  804210b5e3:	48 89 e5             	mov    %rsp,%rbp
  804210b5e6:	41 57                	push   %r15
  804210b5e8:	41 56                	push   %r14
  804210b5ea:	41 55                	push   %r13
  804210b5ec:	41 54                	push   %r12
  804210b5ee:	53                   	push   %rbx
  804210b5ef:	48 83 ec 28          	sub    $0x28,%rsp
  804210b5f3:	49 89 ff             	mov    %rdi,%r15
  804210b5f6:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
  804210b5fa:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  804210b5fe:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  804210b602:	4d 89 c5             	mov    %r8,%r13
  804210b605:	44 89 cb             	mov    %r9d,%ebx
  804210b608:	44 8b 65 10          	mov    0x10(%rbp),%r12d
    if (flags & PROT_COMBINE) {
  804210b60c:	41 f7 c4 00 01 00 00 	test   $0x100,%r12d
  804210b613:	74 0d                	je     804210b622 <do_map_page+0x44>
        if (oldflags & PROT_SHARE)
  804210b615:	41 f6 c1 40          	test   $0x40,%r9b
  804210b619:	0f 84 8a 00 00 00    	je     804210b6a9 <do_map_page+0xcb>
            flags &= oldflags;
  804210b61f:	45 21 cc             	and    %r9d,%r12d
    assert(!(oldflags & PROT_LAZY) | !(oldflags & PROT_SHARE));
  804210b622:	89 d8                	mov    %ebx,%eax
  804210b624:	f7 d0                	not    %eax
  804210b626:	a8 c0                	test   $0xc0,%al
  804210b628:	0f 84 85 00 00 00    	je     804210b6b3 <do_map_page+0xd5>
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  804210b62e:	44 89 e0             	mov    %r12d,%eax
  804210b631:	f7 d0                	not    %eax
  804210b633:	a8 c0                	test   $0xc0,%al
  804210b635:	0f 84 ad 00 00 00    	je     804210b6e8 <do_map_page+0x10a>
    if (!(flags & PROT_LAZY) && ~oldflags &
  804210b63b:	41 f6 c4 80          	test   $0x80,%r12b
  804210b63f:	0f 85 0a 02 00 00    	jne    804210b84f <do_map_page+0x271>
  804210b645:	89 d8                	mov    %ebx,%eax
  804210b647:	f7 d0                	not    %eax
                                        (PROT_R | PROT_W | PROT_X) & flags) return -E_INVAL;
  804210b649:	44 21 e0             	and    %r12d,%eax
    if (!(flags & PROT_LAZY) && ~oldflags &
  804210b64c:	a8 07                	test   $0x7,%al
  804210b64e:	0f 85 f0 01 00 00    	jne    804210b844 <do_map_page+0x266>
    if (!(flags & PROT_LAZY) && (oldflags & PROT_LAZY)) {
  804210b654:	f6 c3 80             	test   $0x80,%bl
  804210b657:	0f 85 c0 00 00 00    	jne    804210b71d <do_map_page+0x13f>
    page_ref(phy);
  804210b65d:	4c 89 ef             	mov    %r13,%rdi
  804210b660:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  804210b667:	00 00 00 
  804210b66a:	ff d0                	call   *%rax
    res = map_page(dspace, dst, phy, flags);
  804210b66c:	44 89 e1             	mov    %r12d,%ecx
  804210b66f:	4c 89 ea             	mov    %r13,%rdx
  804210b672:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804210b676:	4c 89 ff             	mov    %r15,%rdi
  804210b679:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  804210b680:	00 00 00 
  804210b683:	ff d0                	call   *%rax
  804210b685:	41 89 c6             	mov    %eax,%r14d
    page_unref(phy);
  804210b688:	4c 89 ef             	mov    %r13,%rdi
  804210b68b:	48 b8 56 49 10 42 80 	movabs $0x8042104956,%rax
  804210b692:	00 00 00 
  804210b695:	ff d0                	call   *%rax
}
  804210b697:	44 89 f0             	mov    %r14d,%eax
  804210b69a:	48 83 c4 28          	add    $0x28,%rsp
  804210b69e:	5b                   	pop    %rbx
  804210b69f:	41 5c                	pop    %r12
  804210b6a1:	41 5d                	pop    %r13
  804210b6a3:	41 5e                	pop    %r14
  804210b6a5:	41 5f                	pop    %r15
  804210b6a7:	5d                   	pop    %rbp
  804210b6a8:	c3                   	ret
            flags &= oldflags | PROT_LAZY;
  804210b6a9:	44 89 c8             	mov    %r9d,%eax
  804210b6ac:	0c 80                	or     $0x80,%al
  804210b6ae:	41 21 c4             	and    %eax,%r12d
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  804210b6b1:	eb 88                	jmp    804210b63b <do_map_page+0x5d>
    assert(!(oldflags & PROT_LAZY) | !(oldflags & PROT_SHARE));
  804210b6b3:	48 b9 b0 12 12 42 80 	movabs $0x80421212b0,%rcx
  804210b6ba:	00 00 00 
  804210b6bd:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b6c4:	00 00 00 
  804210b6c7:	be 6f 05 00 00       	mov    $0x56f,%esi
  804210b6cc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b6d3:	00 00 00 
  804210b6d6:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b6db:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b6e2:	00 00 00 
  804210b6e5:	41 ff d0             	call   *%r8
    assert(!(flags & PROT_LAZY) | !(flags & PROT_SHARE));
  804210b6e8:	48 b9 c8 0e 12 42 80 	movabs $0x8042120ec8,%rcx
  804210b6ef:	00 00 00 
  804210b6f2:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b6f9:	00 00 00 
  804210b6fc:	be 70 05 00 00       	mov    $0x570,%esi
  804210b701:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b708:	00 00 00 
  804210b70b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b710:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b717:	00 00 00 
  804210b71a:	41 ff d0             	call   *%r8
        int class = phy->class;
  804210b71d:	41 0f b7 45 34       	movzwl 0x34(%r13),%eax
  804210b722:	66 25 ff 0f          	and    $0xfff,%ax
  804210b726:	89 c3                	mov    %eax,%ebx
        res = force_alloc_page(sspace, src, MAX_CLASS);
  804210b728:	ba 30 00 00 00       	mov    $0x30,%edx
  804210b72d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804210b731:	4c 8b 6d c0          	mov    -0x40(%rbp),%r13
  804210b735:	4c 89 ef             	mov    %r13,%rdi
  804210b738:	48 b8 53 b2 10 42 80 	movabs $0x804210b253,%rax
  804210b73f:	00 00 00 
  804210b742:	ff d0                	call   *%rax
  804210b744:	41 89 c6             	mov    %eax,%r14d
        if (res < 0 || (sspace == dspace && src == dst)) return res;
  804210b747:	85 c0                	test   %eax,%eax
  804210b749:	0f 88 48 ff ff ff    	js     804210b697 <do_map_page+0xb9>
  804210b74f:	4d 39 fd             	cmp    %r15,%r13
  804210b752:	75 0e                	jne    804210b762 <do_map_page+0x184>
  804210b754:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804210b758:	48 39 4d c8          	cmp    %rcx,-0x38(%rbp)
  804210b75c:	0f 84 35 ff ff ff    	je     804210b697 <do_map_page+0xb9>
        int class = phy->class;
  804210b762:	0f b7 db             	movzwl %bx,%ebx
        struct Page *newv = page_lookup_virtual(sspace->root, src, class, LOOKUP_PRESERVE);
  804210b765:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804210b769:	48 8b 78 10          	mov    0x10(%rax),%rdi
  804210b76d:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210b772:	89 da                	mov    %ebx,%edx
  804210b774:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804210b778:	48 b8 fa 72 10 42 80 	movabs $0x80421072fa,%rax
  804210b77f:	00 00 00 
  804210b782:	ff d0                	call   *%rax
  804210b784:	49 89 c5             	mov    %rax,%r13
        check_virtual_class(newv, class);
  804210b787:	89 de                	mov    %ebx,%esi
  804210b789:	48 89 c7             	mov    %rax,%rdi
  804210b78c:	48 b8 82 4d 10 42 80 	movabs $0x8042104d82,%rax
  804210b793:	00 00 00 
  804210b796:	ff d0                	call   *%rax
        assert(newv && newv->phy);
  804210b798:	4d 85 ed             	test   %r13,%r13
  804210b79b:	74 0d                	je     804210b7aa <do_map_page+0x1cc>
  804210b79d:	4d 8b 6d 30          	mov    0x30(%r13),%r13
  804210b7a1:	4d 85 ed             	test   %r13,%r13
  804210b7a4:	0f 85 b3 fe ff ff    	jne    804210b65d <do_map_page+0x7f>
  804210b7aa:	48 b9 b9 f9 11 42 80 	movabs $0x804211f9b9,%rcx
  804210b7b1:	00 00 00 
  804210b7b4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b7bb:	00 00 00 
  804210b7be:	be 8e 05 00 00       	mov    $0x58e,%esi
  804210b7c3:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b7ca:	00 00 00 
  804210b7cd:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b7d2:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b7d9:	00 00 00 
  804210b7dc:	41 ff d0             	call   *%r8
    bool need_remap = (flags & PROT_LAZY) && (sspace != dspace || src != dst);
  804210b7df:	4c 39 7d c0          	cmp    %r15,-0x40(%rbp)
  804210b7e3:	0f 95 c2             	setne  %dl
  804210b7e6:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804210b7ea:	48 39 75 c8          	cmp    %rsi,-0x38(%rbp)
  804210b7ee:	0f 95 c0             	setne  %al
  804210b7f1:	09 c2                	or     %eax,%edx
  804210b7f3:	88 55 b8             	mov    %dl,-0x48(%rbp)
    res = map_page(dspace, dst, phy, flags);
  804210b7f6:	44 89 e1             	mov    %r12d,%ecx
  804210b7f9:	4c 89 ea             	mov    %r13,%rdx
  804210b7fc:	4c 89 ff             	mov    %r15,%rdi
  804210b7ff:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  804210b806:	00 00 00 
  804210b809:	ff d0                	call   *%rax
  804210b80b:	41 89 c6             	mov    %eax,%r14d
    if (!res && need_remap) {
  804210b80e:	85 c0                	test   %eax,%eax
  804210b810:	0f 85 72 fe ff ff    	jne    804210b688 <do_map_page+0xaa>
  804210b816:	80 7d b8 00          	cmpb   $0x0,-0x48(%rbp)
  804210b81a:	0f 84 68 fe ff ff    	je     804210b688 <do_map_page+0xaa>
        res = map_page(sspace, src, phy, oldflags | PROT_LAZY);
  804210b820:	80 cb 80             	or     $0x80,%bl
  804210b823:	89 d9                	mov    %ebx,%ecx
  804210b825:	4c 89 ea             	mov    %r13,%rdx
  804210b828:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804210b82c:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804210b830:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  804210b837:	00 00 00 
  804210b83a:	ff d0                	call   *%rax
  804210b83c:	41 89 c6             	mov    %eax,%r14d
  804210b83f:	e9 44 fe ff ff       	jmp    804210b688 <do_map_page+0xaa>
                                        (PROT_R | PROT_W | PROT_X) & flags) return -E_INVAL;
  804210b844:	41 be fd ff ff ff    	mov    $0xfffffffd,%r14d
  804210b84a:	e9 48 fe ff ff       	jmp    804210b697 <do_map_page+0xb9>
    page_ref(phy);
  804210b84f:	4c 89 ef             	mov    %r13,%rdi
  804210b852:	48 b8 72 48 10 42 80 	movabs $0x8042104872,%rax
  804210b859:	00 00 00 
  804210b85c:	ff d0                	call   *%rax
    if (oldflags & PROT_SHARE && flags & PROT_LAZY)
  804210b85e:	f6 c3 40             	test   $0x40,%bl
  804210b861:	0f 84 78 ff ff ff    	je     804210b7df <do_map_page+0x201>
        flags = (flags & ~PROT_LAZY) | PROT_SHARE;
  804210b867:	41 80 e4 3f          	and    $0x3f,%r12b
  804210b86b:	41 83 cc 40          	or     $0x40,%r12d
    bool need_remap = (flags & PROT_LAZY) && (sspace != dspace || src != dst);
  804210b86f:	e9 f8 fd ff ff       	jmp    804210b66c <do_map_page+0x8e>

000000804210b874 <do_map_subtree>:
do_map_subtree(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, struct Page *vpage, int class, int flags) {
  804210b874:	f3 0f 1e fa          	endbr64
  804210b878:	55                   	push   %rbp
  804210b879:	48 89 e5             	mov    %rsp,%rbp
  804210b87c:	41 57                	push   %r15
  804210b87e:	41 56                	push   %r14
  804210b880:	41 55                	push   %r13
  804210b882:	41 54                	push   %r12
  804210b884:	53                   	push   %rbx
  804210b885:	48 83 ec 18          	sub    $0x18,%rsp
  804210b889:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  804210b88d:	49 89 f5             	mov    %rsi,%r13
  804210b890:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  804210b894:	49 89 ce             	mov    %rcx,%r14
  804210b897:	4c 89 c3             	mov    %r8,%rbx
  804210b89a:	45 89 cc             	mov    %r9d,%r12d
    check_virtual_class(vpage, class);
  804210b89d:	44 89 ce             	mov    %r9d,%esi
  804210b8a0:	4c 89 c7             	mov    %r8,%rdi
  804210b8a3:	48 b8 82 4d 10 42 80 	movabs $0x8042104d82,%rax
  804210b8aa:	00 00 00 
  804210b8ad:	ff d0                	call   *%rax
    while (!res && vpage) {
  804210b8af:	48 85 db             	test   %rbx,%rbx
  804210b8b2:	0f 84 94 01 00 00    	je     804210ba4c <do_map_subtree+0x1d8>
        assert(class >= 0);
  804210b8b8:	45 85 e4             	test   %r12d,%r12d
  804210b8bb:	78 0f                	js     804210b8cc <do_map_subtree+0x58>
  804210b8bd:	41 83 ec 01          	sub    $0x1,%r12d
  804210b8c1:	41 bf 00 00 00 00    	mov    $0x0,%r15d
  804210b8c7:	e9 27 01 00 00       	jmp    804210b9f3 <do_map_subtree+0x17f>
  804210b8cc:	48 b9 be f7 11 42 80 	movabs $0x804211f7be,%rcx
  804210b8d3:	00 00 00 
  804210b8d6:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b8dd:	00 00 00 
  804210b8e0:	be aa 05 00 00       	mov    $0x5aa,%esi
  804210b8e5:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b8ec:	00 00 00 
  804210b8ef:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b8f4:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b8fb:	00 00 00 
  804210b8fe:	41 ff d0             	call   *%r8
            assert((vpage->state & NODE_TYPE_MASK) == MAPPING_NODE);
  804210b901:	44 8b 4b 28          	mov    0x28(%rbx),%r9d
  804210b905:	44 89 c8             	mov    %r9d,%eax
  804210b908:	25 00 00 f0 00       	and    $0xf00000,%eax
  804210b90d:	3d 00 00 10 00       	cmp    $0x100000,%eax
  804210b912:	75 3c                	jne    804210b950 <do_map_subtree+0xdc>
            return do_map_page(dspace, dst, sspace, src,
  804210b914:	48 83 ec 08          	sub    $0x8,%rsp
  804210b918:	8b 45 10             	mov    0x10(%rbp),%eax
  804210b91b:	50                   	push   %rax
  804210b91c:	41 81 e1 ff 0f 00 00 	and    $0xfff,%r9d
  804210b923:	4c 89 f1             	mov    %r14,%rcx
  804210b926:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804210b92a:	4c 89 ee             	mov    %r13,%rsi
  804210b92d:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210b931:	48 b8 de b5 10 42 80 	movabs $0x804210b5de,%rax
  804210b938:	00 00 00 
  804210b93b:	ff d0                	call   *%rax
  804210b93d:	48 83 c4 10          	add    $0x10,%rsp
}
  804210b941:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  804210b945:	5b                   	pop    %rbx
  804210b946:	41 5c                	pop    %r12
  804210b948:	41 5d                	pop    %r13
  804210b94a:	41 5e                	pop    %r14
  804210b94c:	41 5f                	pop    %r15
  804210b94e:	5d                   	pop    %rbp
  804210b94f:	c3                   	ret
            assert((vpage->state & NODE_TYPE_MASK) == MAPPING_NODE);
  804210b950:	48 b9 e8 12 12 42 80 	movabs $0x80421212e8,%rcx
  804210b957:	00 00 00 
  804210b95a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b961:	00 00 00 
  804210b964:	be ac 05 00 00       	mov    $0x5ac,%esi
  804210b969:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b970:	00 00 00 
  804210b973:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b978:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b97f:	00 00 00 
  804210b982:	41 ff d0             	call   *%r8
        assert(vpage->state == INTERMEDIATE_NODE);
  804210b985:	48 b9 18 13 12 42 80 	movabs $0x8042121318,%rcx
  804210b98c:	00 00 00 
  804210b98f:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210b996:	00 00 00 
  804210b999:	be b0 05 00 00       	mov    $0x5b0,%esi
  804210b99e:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210b9a5:	00 00 00 
  804210b9a8:	b8 00 00 00 00       	mov    $0x0,%eax
  804210b9ad:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210b9b4:	00 00 00 
  804210b9b7:	41 ff d0             	call   *%r8
  804210b9ba:	44 89 f8             	mov    %r15d,%eax
        dst += CLASS_SIZE(class - 1);
  804210b9bd:	41 8d 4c 24 0c       	lea    0xc(%r12),%ecx
  804210b9c2:	ba 01 00 00 00       	mov    $0x1,%edx
  804210b9c7:	48 d3 e2             	shl    %cl,%rdx
  804210b9ca:	49 01 d5             	add    %rdx,%r13
        src += CLASS_SIZE(class - 1);
  804210b9cd:	49 01 d6             	add    %rdx,%r14
        vpage = vpage->right;
  804210b9d0:	48 8b 5b 18          	mov    0x18(%rbx),%rbx
    while (!res && vpage) {
  804210b9d4:	85 c0                	test   %eax,%eax
  804210b9d6:	0f 85 65 ff ff ff    	jne    804210b941 <do_map_subtree+0xcd>
  804210b9dc:	48 85 db             	test   %rbx,%rbx
  804210b9df:	0f 84 5c ff ff ff    	je     804210b941 <do_map_subtree+0xcd>
        assert(class >= 0);
  804210b9e5:	41 83 ec 01          	sub    $0x1,%r12d
  804210b9e9:	41 83 fc fe          	cmp    $0xfffffffe,%r12d
  804210b9ed:	0f 84 d9 fe ff ff    	je     804210b8cc <do_map_subtree+0x58>
        if (vpage->phy) {
  804210b9f3:	4c 8b 43 30          	mov    0x30(%rbx),%r8
  804210b9f7:	4d 85 c0             	test   %r8,%r8
  804210b9fa:	0f 85 01 ff ff ff    	jne    804210b901 <do_map_subtree+0x8d>
        assert(vpage->state == INTERMEDIATE_NODE);
  804210ba00:	81 7b 28 00 00 20 00 	cmpl   $0x200000,0x28(%rbx)
  804210ba07:	0f 85 78 ff ff ff    	jne    804210b985 <do_map_subtree+0x111>
        if (vpage->left && (res = do_map_subtree(dspace, dst,
  804210ba0d:	4c 8b 43 10          	mov    0x10(%rbx),%r8
  804210ba11:	4d 85 c0             	test   %r8,%r8
  804210ba14:	74 a4                	je     804210b9ba <do_map_subtree+0x146>
  804210ba16:	48 83 ec 08          	sub    $0x8,%rsp
  804210ba1a:	8b 45 10             	mov    0x10(%rbp),%eax
  804210ba1d:	50                   	push   %rax
  804210ba1e:	45 89 e1             	mov    %r12d,%r9d
  804210ba21:	4c 89 f1             	mov    %r14,%rcx
  804210ba24:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804210ba28:	4c 89 ee             	mov    %r13,%rsi
  804210ba2b:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210ba2f:	48 b8 74 b8 10 42 80 	movabs $0x804210b874,%rax
  804210ba36:	00 00 00 
  804210ba39:	ff d0                	call   *%rax
  804210ba3b:	48 83 c4 10          	add    $0x10,%rsp
  804210ba3f:	85 c0                	test   %eax,%eax
  804210ba41:	0f 89 76 ff ff ff    	jns    804210b9bd <do_map_subtree+0x149>
  804210ba47:	e9 f5 fe ff ff       	jmp    804210b941 <do_map_subtree+0xcd>
    int res = 0;
  804210ba4c:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ba51:	e9 eb fe ff ff       	jmp    804210b941 <do_map_subtree+0xcd>

000000804210ba56 <do_map_region_one_page>:
do_map_region_one_page(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, int class, int flags) {
  804210ba56:	f3 0f 1e fa          	endbr64
  804210ba5a:	55                   	push   %rbp
  804210ba5b:	48 89 e5             	mov    %rsp,%rbp
  804210ba5e:	41 57                	push   %r15
  804210ba60:	41 56                	push   %r14
  804210ba62:	41 55                	push   %r13
  804210ba64:	41 54                	push   %r12
  804210ba66:	53                   	push   %rbx
  804210ba67:	48 83 ec 18          	sub    $0x18,%rsp
  804210ba6b:	49 89 fd             	mov    %rdi,%r13
  804210ba6e:	48 89 f3             	mov    %rsi,%rbx
  804210ba71:	49 89 d7             	mov    %rdx,%r15
  804210ba74:	49 89 cc             	mov    %rcx,%r12
  804210ba77:	45 89 c6             	mov    %r8d,%r14d
  804210ba7a:	44 89 4d c4          	mov    %r9d,-0x3c(%rbp)
    if (dspace == sspace && src != dst) assert(ABSDIFF(dst, src) >= CLASS_SIZE(class));
  804210ba7e:	48 39 d7             	cmp    %rdx,%rdi
  804210ba81:	75 28                	jne    804210baab <do_map_region_one_page+0x55>
  804210ba83:	48 39 f1             	cmp    %rsi,%rcx
  804210ba86:	74 23                	je     804210baab <do_map_region_one_page+0x55>
  804210ba88:	48 89 f2             	mov    %rsi,%rdx
  804210ba8b:	48 29 ca             	sub    %rcx,%rdx
  804210ba8e:	48 89 c8             	mov    %rcx,%rax
  804210ba91:	48 29 f0             	sub    %rsi,%rax
  804210ba94:	48 39 f1             	cmp    %rsi,%rcx
  804210ba97:	48 0f 42 c2          	cmovb  %rdx,%rax
  804210ba9b:	41 8d 48 0c          	lea    0xc(%r8),%ecx
  804210ba9f:	48 d3 e8             	shr    %cl,%rax
  804210baa2:	48 85 c0             	test   %rax,%rax
  804210baa5:	0f 84 08 01 00 00    	je     804210bbb3 <do_map_region_one_page+0x15d>
    if (flags & (ALLOC_ONE | ALLOC_ZERO)) {
  804210baab:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  804210baae:	a9 00 00 30 00       	test   $0x300000,%eax
  804210bab3:	0f 84 74 02 00 00    	je     804210bd2d <do_map_region_one_page+0x2d7>
        if (flags & PROT_SHARE) {
  804210bab9:	41 89 c4             	mov    %eax,%r12d
  804210babc:	41 83 e4 40          	and    $0x40,%r12d
  804210bac0:	0f 85 1d 01 00 00    	jne    804210bbe3 <do_map_region_one_page+0x18d>
            struct Page *cpage = flags & ALLOC_ONE ? one_page : zero_page;
  804210bac6:	48 a1 20 61 00 43 80 	movabs 0x8043006120,%rax
  804210bacd:	00 00 00 
  804210bad0:	f7 45 c4 00 00 20 00 	testl  $0x200000,-0x3c(%rbp)
  804210bad7:	74 0a                	je     804210bae3 <do_map_region_one_page+0x8d>
  804210bad9:	48 a1 18 61 00 43 80 	movabs 0x8043006118,%rax
  804210bae0:	00 00 00 
            cpage = page_lookup(cpage, page2pa(cpage), MIN(class, MAX_ALLOCATION_CLASS), PARTIAL_NODE, 1);
  804210bae3:	ba 09 00 00 00       	mov    $0x9,%edx
  804210bae8:	41 39 d6             	cmp    %edx,%r14d
  804210baeb:	41 0f 4e d6          	cmovle %r14d,%edx
  804210baef:	41 89 d7             	mov    %edx,%r15d
    return page->addr << CLASS_BASE;
  804210baf2:	48 ba ff ff ff ff ff 	movabs $0xfffffffffffff,%rdx
  804210baf9:	ff 0f 00 
  804210bafc:	48 89 d6             	mov    %rdx,%rsi
  804210baff:	48 23 70 38          	and    0x38(%rax),%rsi
  804210bb03:	48 c1 e6 0c          	shl    $0xc,%rsi
  804210bb07:	48 21 d6             	and    %rdx,%rsi
  804210bb0a:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804210bb10:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804210bb15:	44 89 fa             	mov    %r15d,%edx
  804210bb18:	48 89 c7             	mov    %rax,%rdi
  804210bb1b:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  804210bb22:	00 00 00 
  804210bb25:	ff d0                	call   *%rax
  804210bb27:	48 89 c7             	mov    %rax,%rdi
  804210bb2a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (!cpage) return -E_NO_MEM;
  804210bb2e:	48 85 c0             	test   %rax,%rax
  804210bb31:	0f 84 17 03 00 00    	je     804210be4e <do_map_region_one_page+0x3f8>
            size_t size_inc = CLASS_SIZE(MIN(class, MAX_ALLOCATION_CLASS));
  804210bb37:	41 8d 4f 0c          	lea    0xc(%r15),%ecx
  804210bb3b:	b8 01 00 00 00       	mov    $0x1,%eax
  804210bb40:	49 89 c7             	mov    %rax,%r15
  804210bb43:	49 d3 e7             	shl    %cl,%r15
            uintptr_t end = dst + CLASS_SIZE(class);
  804210bb46:	41 8d 4e 0c          	lea    0xc(%r14),%ecx
  804210bb4a:	49 89 c6             	mov    %rax,%r14
  804210bb4d:	49 d3 e6             	shl    %cl,%r14
  804210bb50:	49 01 de             	add    %rbx,%r14
            assert(CLASS_SIZE(cpage->class) == size_inc);
  804210bb53:	0f b7 4f 34          	movzwl 0x34(%rdi),%ecx
  804210bb57:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  804210bb5d:	83 c1 0c             	add    $0xc,%ecx
  804210bb60:	48 d3 e0             	shl    %cl,%rax
  804210bb63:	4c 39 f8             	cmp    %r15,%rax
  804210bb66:	0f 85 8c 01 00 00    	jne    804210bcf8 <do_map_region_one_page+0x2a2>
                res = map_page(dspace, dst, cpage, (flags & PROT_ALL & ~PROT_COMBINE) | PROT_LAZY);
  804210bb6c:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  804210bb6f:	25 7f 0e 00 00       	and    $0xe7f,%eax
  804210bb74:	0c 80                	or     $0x80,%al
  804210bb76:	89 45 c4             	mov    %eax,-0x3c(%rbp)
            while (dst < end && !res) {
  804210bb79:	4c 39 f3             	cmp    %r14,%rbx
  804210bb7c:	0f 83 2f 02 00 00    	jae    804210bdb1 <do_map_region_one_page+0x35b>
                res = map_page(dspace, dst, cpage, (flags & PROT_ALL & ~PROT_COMBINE) | PROT_LAZY);
  804210bb82:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
  804210bb85:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804210bb89:	48 89 de             	mov    %rbx,%rsi
  804210bb8c:	4c 89 ef             	mov    %r13,%rdi
  804210bb8f:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  804210bb96:	00 00 00 
  804210bb99:	ff d0                	call   *%rax
  804210bb9b:	41 89 c4             	mov    %eax,%r12d
                dst += size_inc;
  804210bb9e:	4c 01 fb             	add    %r15,%rbx
            while (dst < end && !res) {
  804210bba1:	4c 39 f3             	cmp    %r14,%rbx
  804210bba4:	0f 83 07 02 00 00    	jae    804210bdb1 <do_map_region_one_page+0x35b>
  804210bbaa:	85 c0                	test   %eax,%eax
  804210bbac:	74 d4                	je     804210bb82 <do_map_region_one_page+0x12c>
  804210bbae:	e9 fe 01 00 00       	jmp    804210bdb1 <do_map_region_one_page+0x35b>
    if (dspace == sspace && src != dst) assert(ABSDIFF(dst, src) >= CLASS_SIZE(class));
  804210bbb3:	48 b9 40 13 12 42 80 	movabs $0x8042121340,%rcx
  804210bbba:	00 00 00 
  804210bbbd:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210bbc4:	00 00 00 
  804210bbc7:	be c1 05 00 00       	mov    $0x5c1,%esi
  804210bbcc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210bbd3:	00 00 00 
  804210bbd6:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210bbdd:	00 00 00 
  804210bbe0:	41 ff d0             	call   *%r8
            res = alloc_composite_page(dspace, dst, class, flags & PROT_ALL & ~(PROT_LAZY | PROT_COMBINE));
  804210bbe3:	89 c1                	mov    %eax,%ecx
  804210bbe5:	81 e1 7f 0e 00 00    	and    $0xe7f,%ecx
  804210bbeb:	44 89 f2             	mov    %r14d,%edx
  804210bbee:	48 89 de             	mov    %rbx,%rsi
  804210bbf1:	4c 89 ef             	mov    %r13,%rdi
  804210bbf4:	48 b8 2b b1 10 42 80 	movabs $0x804210b12b,%rax
  804210bbfb:	00 00 00 
  804210bbfe:	ff d0                	call   *%rax
  804210bc00:	41 89 c4             	mov    %eax,%r12d
            if (!res) {
  804210bc03:	85 c0                	test   %eax,%eax
  804210bc05:	0f 85 a6 01 00 00    	jne    804210bdb1 <do_map_region_one_page+0x35b>
                assert(current_space);
  804210bc0b:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  804210bc12:	00 00 00 
  804210bc15:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210bc19:	74 73                	je     804210bc8e <do_map_region_one_page+0x238>
                assert(dspace);
  804210bc1b:	4d 85 ed             	test   %r13,%r13
  804210bc1e:	0f 84 9f 00 00 00    	je     804210bcc3 <do_map_region_one_page+0x26d>
                struct AddressSpace *old = switch_address_space(dspace);
  804210bc24:	4c 89 ef             	mov    %r13,%rdi
  804210bc27:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210bc2e:	00 00 00 
  804210bc31:	ff d0                	call   *%rax
  804210bc33:	49 89 c5             	mov    %rax,%r13
    asm volatile("movq %%cr0,%0"
  804210bc36:	0f 20 c0             	mov    %cr0,%rax
    lcr0(wp ? old | CR0_WP : old & ~CR0_WP);
  804210bc39:	48 25 ff ff fe ff    	and    $0xfffffffffffeffff,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  804210bc3f:	0f 22 c0             	mov    %rax,%cr0
                nosan_memset((void *)dst, flags & ALLOC_ONE ? 0xFF : 0x00, CLASS_SIZE(class));
  804210bc42:	41 8d 4e 0c          	lea    0xc(%r14),%ecx
  804210bc46:	ba 01 00 00 00       	mov    $0x1,%edx
  804210bc4b:	48 d3 e2             	shl    %cl,%rdx
  804210bc4e:	8b 75 c4             	mov    -0x3c(%rbp),%esi
  804210bc51:	81 e6 00 00 20 00    	and    $0x200000,%esi
  804210bc57:	f7 de                	neg    %esi
  804210bc59:	19 f6                	sbb    %esi,%esi
  804210bc5b:	40 0f b6 f6          	movzbl %sil,%esi
  804210bc5f:	48 89 df             	mov    %rbx,%rdi
  804210bc62:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  804210bc69:	00 00 00 
  804210bc6c:	ff d0                	call   *%rax
    asm volatile("movq %%cr0,%0"
  804210bc6e:	0f 20 c0             	mov    %cr0,%rax
  804210bc71:	48 0d 00 00 01 00    	or     $0x10000,%rax
    asm volatile("movq %0,%%cr0" ::"r"(val));
  804210bc77:	0f 22 c0             	mov    %rax,%cr0
                switch_address_space(old);
  804210bc7a:	4c 89 ef             	mov    %r13,%rdi
  804210bc7d:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210bc84:	00 00 00 
  804210bc87:	ff d0                	call   *%rax
  804210bc89:	e9 23 01 00 00       	jmp    804210bdb1 <do_map_region_one_page+0x35b>
                assert(current_space);
  804210bc8e:	48 b9 93 f9 11 42 80 	movabs $0x804211f993,%rcx
  804210bc95:	00 00 00 
  804210bc98:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210bc9f:	00 00 00 
  804210bca2:	be ca 05 00 00       	mov    $0x5ca,%esi
  804210bca7:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210bcae:	00 00 00 
  804210bcb1:	b8 00 00 00 00       	mov    $0x0,%eax
  804210bcb6:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210bcbd:	00 00 00 
  804210bcc0:	41 ff d0             	call   *%r8
                assert(dspace);
  804210bcc3:	48 b9 cb f9 11 42 80 	movabs $0x804211f9cb,%rcx
  804210bcca:	00 00 00 
  804210bccd:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210bcd4:	00 00 00 
  804210bcd7:	be cb 05 00 00       	mov    $0x5cb,%esi
  804210bcdc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210bce3:	00 00 00 
  804210bce6:	b8 00 00 00 00       	mov    $0x0,%eax
  804210bceb:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210bcf2:	00 00 00 
  804210bcf5:	41 ff d0             	call   *%r8
            assert(CLASS_SIZE(cpage->class) == size_inc);
  804210bcf8:	48 b9 68 13 12 42 80 	movabs $0x8042121368,%rcx
  804210bcff:	00 00 00 
  804210bd02:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210bd09:	00 00 00 
  804210bd0c:	be de 05 00 00       	mov    $0x5de,%esi
  804210bd11:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210bd18:	00 00 00 
  804210bd1b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210bd20:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210bd27:	00 00 00 
  804210bd2a:	41 ff d0             	call   *%r8
        struct Page *page1 = page_lookup_virtual(sspace->root, src, class, LOOKUP_ALLOC);
  804210bd2d:	49 8b 7f 10          	mov    0x10(%r15),%rdi
  804210bd31:	b9 01 00 00 00       	mov    $0x1,%ecx
  804210bd36:	44 89 f2             	mov    %r14d,%edx
  804210bd39:	4c 89 e6             	mov    %r12,%rsi
  804210bd3c:	48 b8 fa 72 10 42 80 	movabs $0x80421072fa,%rax
  804210bd43:	00 00 00 
  804210bd46:	ff d0                	call   *%rax
  804210bd48:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        assert(page1);
  804210bd4c:	48 85 c0             	test   %rax,%rax
  804210bd4f:	74 72                	je     804210bdc3 <do_map_region_one_page+0x36d>
        if (page1->phy && page1->phy->class > class) {
  804210bd51:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210bd55:	48 8b 78 30          	mov    0x30(%rax),%rdi
  804210bd59:	48 85 ff             	test   %rdi,%rdi
  804210bd5c:	74 12                	je     804210bd70 <do_map_region_one_page+0x31a>
  804210bd5e:	0f b7 47 34          	movzwl 0x34(%rdi),%eax
  804210bd62:	25 ff 0f 00 00       	and    $0xfff,%eax
  804210bd67:	44 39 f0             	cmp    %r14d,%eax
  804210bd6a:	0f 8f 83 00 00 00    	jg     804210bdf3 <do_map_region_one_page+0x39d>
            check_virtual_class(page1, class);
  804210bd70:	44 89 f6             	mov    %r14d,%esi
  804210bd73:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210bd77:	48 b8 82 4d 10 42 80 	movabs $0x8042104d82,%rax
  804210bd7e:	00 00 00 
  804210bd81:	ff d0                	call   *%rax
            return do_map_subtree(dspace, dst, sspace, src, page1, class, flags);
  804210bd83:	48 83 ec 08          	sub    $0x8,%rsp
  804210bd87:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  804210bd8a:	50                   	push   %rax
  804210bd8b:	45 89 f1             	mov    %r14d,%r9d
  804210bd8e:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
  804210bd92:	4c 89 e1             	mov    %r12,%rcx
  804210bd95:	4c 89 fa             	mov    %r15,%rdx
  804210bd98:	48 89 de             	mov    %rbx,%rsi
  804210bd9b:	4c 89 ef             	mov    %r13,%rdi
  804210bd9e:	48 b8 74 b8 10 42 80 	movabs $0x804210b874,%rax
  804210bda5:	00 00 00 
  804210bda8:	ff d0                	call   *%rax
  804210bdaa:	41 89 c4             	mov    %eax,%r12d
  804210bdad:	48 83 c4 10          	add    $0x10,%rsp
}
  804210bdb1:	44 89 e0             	mov    %r12d,%eax
  804210bdb4:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  804210bdb8:	5b                   	pop    %rbx
  804210bdb9:	41 5c                	pop    %r12
  804210bdbb:	41 5d                	pop    %r13
  804210bdbd:	41 5e                	pop    %r14
  804210bdbf:	41 5f                	pop    %r15
  804210bdc1:	5d                   	pop    %rbp
  804210bdc2:	c3                   	ret
        assert(page1);
  804210bdc3:	48 b9 d2 f9 11 42 80 	movabs $0x804211f9d2,%rcx
  804210bdca:	00 00 00 
  804210bdcd:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210bdd4:	00 00 00 
  804210bdd7:	be e7 05 00 00       	mov    $0x5e7,%esi
  804210bddc:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210bde3:	00 00 00 
  804210bde6:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210bded:	00 00 00 
  804210bdf0:	41 ff d0             	call   *%r8
            struct Page *page = page_lookup(page1->phy, src, class, PARTIAL_NODE, 1);
  804210bdf3:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804210bdf9:	b9 00 00 30 00       	mov    $0x300000,%ecx
  804210bdfe:	44 89 f2             	mov    %r14d,%edx
  804210be01:	4c 89 e6             	mov    %r12,%rsi
  804210be04:	48 b8 d7 67 10 42 80 	movabs $0x80421067d7,%rax
  804210be0b:	00 00 00 
  804210be0e:	ff d0                	call   *%rax
  804210be10:	49 89 c0             	mov    %rax,%r8
            return do_map_page(dspace, dst, sspace, src, page, page1->state & PROT_ALL, flags);
  804210be13:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210be17:	44 8b 48 28          	mov    0x28(%rax),%r9d
  804210be1b:	48 83 ec 08          	sub    $0x8,%rsp
  804210be1f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  804210be22:	50                   	push   %rax
  804210be23:	41 81 e1 ff 0f 00 00 	and    $0xfff,%r9d
  804210be2a:	4c 89 e1             	mov    %r12,%rcx
  804210be2d:	4c 89 fa             	mov    %r15,%rdx
  804210be30:	48 89 de             	mov    %rbx,%rsi
  804210be33:	4c 89 ef             	mov    %r13,%rdi
  804210be36:	48 b8 de b5 10 42 80 	movabs $0x804210b5de,%rax
  804210be3d:	00 00 00 
  804210be40:	ff d0                	call   *%rax
  804210be42:	41 89 c4             	mov    %eax,%r12d
  804210be45:	48 83 c4 10          	add    $0x10,%rsp
  804210be49:	e9 63 ff ff ff       	jmp    804210bdb1 <do_map_region_one_page+0x35b>
            if (!cpage) return -E_NO_MEM;
  804210be4e:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
  804210be54:	e9 58 ff ff ff       	jmp    804210bdb1 <do_map_region_one_page+0x35b>

000000804210be59 <map_region>:
map_region(struct AddressSpace *dspace, uintptr_t dst, struct AddressSpace *sspace, uintptr_t src, uintptr_t size, int flags) {
  804210be59:	f3 0f 1e fa          	endbr64
  804210be5d:	55                   	push   %rbp
  804210be5e:	48 89 e5             	mov    %rsp,%rbp
  804210be61:	41 57                	push   %r15
  804210be63:	41 56                	push   %r14
  804210be65:	41 55                	push   %r13
  804210be67:	41 54                	push   %r12
  804210be69:	53                   	push   %rbx
  804210be6a:	48 83 ec 38          	sub    $0x38,%rsp
  804210be6e:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  804210be72:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  804210be76:	44 89 4d b4          	mov    %r9d,-0x4c(%rbp)
    if (src & CLASS_MASK(0) || (!sspace && !(flags & (ALLOC_ZERO | ALLOC_ONE)))) return -E_INVAL;
  804210be7a:	f7 c1 ff 0f 00 00    	test   $0xfff,%ecx
  804210be80:	0f 85 11 02 00 00    	jne    804210c097 <map_region+0x23e>
  804210be86:	48 89 f7             	mov    %rsi,%rdi
  804210be89:	49 89 ce             	mov    %rcx,%r14
  804210be8c:	48 85 d2             	test   %rdx,%rdx
  804210be8f:	0f 84 97 00 00 00    	je     804210bf2c <map_region+0xd3>
    if (dst & CLASS_MASK(0) || !dspace) return -E_INVAL;
  804210be95:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  804210be99:	48 85 c9             	test   %rcx,%rcx
  804210be9c:	0f 84 fc 01 00 00    	je     804210c09e <map_region+0x245>
    if (size & CLASS_MASK(0) || !size) return -E_INVAL;
  804210bea2:	48 89 f8             	mov    %rdi,%rax
  804210bea5:	4c 09 c0             	or     %r8,%rax
  804210bea8:	a9 ff 0f 00 00       	test   $0xfff,%eax
  804210bead:	0f 85 f2 01 00 00    	jne    804210c0a5 <map_region+0x24c>
  804210beb3:	4d 85 c0             	test   %r8,%r8
  804210beb6:	0f 84 e9 01 00 00    	je     804210c0a5 <map_region+0x24c>
    assert(sspace != dspace || dst <= src || ABSDIFF(src, dst) >= size);
  804210bebc:	48 39 4d b8          	cmp    %rcx,-0x48(%rbp)
  804210bec0:	75 10                	jne    804210bed2 <map_region+0x79>
  804210bec2:	49 39 fe             	cmp    %rdi,%r14
  804210bec5:	73 0b                	jae    804210bed2 <map_region+0x79>
  804210bec7:	48 89 f8             	mov    %rdi,%rax
  804210beca:	4c 29 f0             	sub    %r14,%rax
  804210becd:	4c 39 c0             	cmp    %r8,%rax
  804210bed0:	72 71                	jb     804210bf43 <map_region+0xea>
    uintptr_t end = dst + size;
  804210bed2:	4a 8d 04 07          	lea    (%rdi,%r8,1),%rax
  804210bed6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  804210beda:	4c 89 f1             	mov    %r14,%rcx
  804210bedd:	48 31 f9             	xor    %rdi,%rcx
  804210bee0:	f6 c5 10             	test   $0x10,%ch
  804210bee3:	0f 85 2d 01 00 00    	jne    804210c016 <map_region+0x1bd>
    int res = 0;
  804210bee9:	b8 00 00 00 00       	mov    $0x0,%eax
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  804210beee:	41 89 c5             	mov    %eax,%r13d
  804210bef1:	83 c0 01             	add    $0x1,%eax
  804210bef4:	41 8d 55 0d          	lea    0xd(%r13),%edx
  804210bef8:	48 0f a3 d1          	bt     %rdx,%rcx
  804210befc:	72 05                	jb     804210bf03 <map_region+0xaa>
  804210befe:	83 f8 2f             	cmp    $0x2f,%eax
  804210bf01:	7e eb                	jle    804210beee <map_region+0x95>
    for (; class < max_class && dst + CLASS_SIZE(class) <= end; class ++) {
  804210bf03:	85 c0                	test   %eax,%eax
  804210bf05:	0f 8e 12 01 00 00    	jle    804210c01d <map_region+0x1c4>
  804210bf0b:	4c 8d bf 00 10 00 00 	lea    0x1000(%rdi),%r15
  804210bf12:	4c 39 7d c8          	cmp    %r15,-0x38(%rbp)
  804210bf16:	0f 82 08 01 00 00    	jb     804210c024 <map_region+0x1cb>
  804210bf1c:	bb 00 00 00 00       	mov    $0x0,%ebx
  804210bf21:	41 bc 00 10 00 00    	mov    $0x1000,%r12d
  804210bf27:	48 89 fe             	mov    %rdi,%rsi
  804210bf2a:	eb 70                	jmp    804210bf9c <map_region+0x143>
    if (src & CLASS_MASK(0) || (!sspace && !(flags & (ALLOC_ZERO | ALLOC_ONE)))) return -E_INVAL;
  804210bf2c:	41 f7 c1 00 00 30 00 	test   $0x300000,%r9d
  804210bf33:	0f 85 5c ff ff ff    	jne    804210be95 <map_region+0x3c>
  804210bf39:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210bf3e:	e9 ed 00 00 00       	jmp    804210c030 <map_region+0x1d7>
    assert(sspace != dspace || dst <= src || ABSDIFF(src, dst) >= size);
  804210bf43:	48 b9 90 13 12 42 80 	movabs $0x8042121390,%rcx
  804210bf4a:	00 00 00 
  804210bf4d:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210bf54:	00 00 00 
  804210bf57:	be ff 05 00 00       	mov    $0x5ff,%esi
  804210bf5c:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210bf63:	00 00 00 
  804210bf66:	b8 00 00 00 00       	mov    $0x0,%eax
  804210bf6b:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210bf72:	00 00 00 
  804210bf75:	41 ff d0             	call   *%r8
    for (; class < max_class && dst + CLASS_SIZE(class) <= end; class ++) {
  804210bf78:	8d 53 01             	lea    0x1(%rbx),%edx
  804210bf7b:	44 39 eb             	cmp    %r13d,%ebx
  804210bf7e:	7d 4f                	jge    804210bfcf <map_region+0x176>
  804210bf80:	8d 4b 0d             	lea    0xd(%rbx),%ecx
  804210bf83:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  804210bf89:	49 d3 e4             	shl    %cl,%r12
  804210bf8c:	4d 8d 3c 34          	lea    (%r12,%rsi,1),%r15
  804210bf90:	4c 39 7d c8          	cmp    %r15,-0x38(%rbp)
  804210bf94:	0f 82 a5 00 00 00    	jb     804210c03f <map_region+0x1e6>
  804210bf9a:	89 d3                	mov    %edx,%ebx
        if (dst & CLASS_SIZE(class)) {
  804210bf9c:	8d 43 0c             	lea    0xc(%rbx),%eax
  804210bf9f:	48 0f a3 c6          	bt     %rax,%rsi
  804210bfa3:	73 d3                	jae    804210bf78 <map_region+0x11f>
            res = do_map_region_one_page(dspace, dst, sspace, src, class, flags);
  804210bfa5:	44 8b 4d b4          	mov    -0x4c(%rbp),%r9d
  804210bfa9:	41 89 d8             	mov    %ebx,%r8d
  804210bfac:	4c 89 f1             	mov    %r14,%rcx
  804210bfaf:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804210bfb3:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804210bfb7:	48 b8 56 ba 10 42 80 	movabs $0x804210ba56,%rax
  804210bfbe:	00 00 00 
  804210bfc1:	ff d0                	call   *%rax
            if (res < 0) return res;
  804210bfc3:	85 c0                	test   %eax,%eax
  804210bfc5:	78 69                	js     804210c030 <map_region+0x1d7>
            src += CLASS_SIZE(class);
  804210bfc7:	4d 01 e6             	add    %r12,%r14
            dst += CLASS_SIZE(class);
  804210bfca:	4c 89 fe             	mov    %r15,%rsi
  804210bfcd:	eb a9                	jmp    804210bf78 <map_region+0x11f>
  804210bfcf:	48 89 f7             	mov    %rsi,%rdi
    for (; class >= 0 && dst < end; class --) {
  804210bfd2:	85 d2                	test   %edx,%edx
  804210bfd4:	78 55                	js     804210c02b <map_region+0x1d2>
            res = do_map_region_one_page(dspace, dst, sspace, src, class, flags);
  804210bfd6:	49 bc 56 ba 10 42 80 	movabs $0x804210ba56,%r12
  804210bfdd:	00 00 00 
    for (; class >= 0 && dst < end; class --) {
  804210bfe0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210bfe4:	4d 89 f5             	mov    %r14,%r13
  804210bfe7:	49 89 fe             	mov    %rdi,%r14
  804210bfea:	48 39 c7             	cmp    %rax,%rdi
  804210bfed:	73 3c                	jae    804210c02b <map_region+0x1d2>
        while (dst + CLASS_SIZE(class) <= end) {
  804210bfef:	8d 4a 0c             	lea    0xc(%rdx),%ecx
  804210bff2:	b8 01 00 00 00       	mov    $0x1,%eax
  804210bff7:	48 d3 e0             	shl    %cl,%rax
  804210bffa:	49 89 c7             	mov    %rax,%r15
  804210bffd:	4a 8d 0c 30          	lea    (%rax,%r14,1),%rcx
  804210c001:	4c 89 eb             	mov    %r13,%rbx
  804210c004:	48 39 4d c8          	cmp    %rcx,-0x38(%rbp)
  804210c008:	72 74                	jb     804210c07e <map_region+0x225>
  804210c00a:	89 55 b0             	mov    %edx,-0x50(%rbp)
  804210c00d:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
  804210c011:	49 89 ce             	mov    %rcx,%r14
  804210c014:	eb 31                	jmp    804210c047 <map_region+0x1ee>
    while (!((addr1 ^ addr2) & CLASS_SIZE(res)) && res < MAX_CLASS) res++;
  804210c016:	ba 00 00 00 00       	mov    $0x0,%edx
  804210c01b:	eb b5                	jmp    804210bfd2 <map_region+0x179>
    for (; class < max_class && dst + CLASS_SIZE(class) <= end; class ++) {
  804210c01d:	ba 00 00 00 00       	mov    $0x0,%edx
  804210c022:	eb ae                	jmp    804210bfd2 <map_region+0x179>
  804210c024:	ba 00 00 00 00       	mov    $0x0,%edx
  804210c029:	eb a7                	jmp    804210bfd2 <map_region+0x179>
    return 0;
  804210c02b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804210c030:	48 83 c4 38          	add    $0x38,%rsp
  804210c034:	5b                   	pop    %rbx
  804210c035:	41 5c                	pop    %r12
  804210c037:	41 5d                	pop    %r13
  804210c039:	41 5e                	pop    %r14
  804210c03b:	41 5f                	pop    %r15
  804210c03d:	5d                   	pop    %rbp
  804210c03e:	c3                   	ret
  804210c03f:	48 89 f7             	mov    %rsi,%rdi
  804210c042:	eb 8e                	jmp    804210bfd2 <map_region+0x179>
  804210c044:	49 89 c6             	mov    %rax,%r14
  804210c047:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  804210c04b:	4c 29 ee             	sub    %r13,%rsi
            res = do_map_region_one_page(dspace, dst, sspace, src, class, flags);
  804210c04e:	48 01 de             	add    %rbx,%rsi
  804210c051:	44 8b 4d b4          	mov    -0x4c(%rbp),%r9d
  804210c055:	44 8b 45 b0          	mov    -0x50(%rbp),%r8d
  804210c059:	48 89 d9             	mov    %rbx,%rcx
  804210c05c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804210c060:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804210c064:	41 ff d4             	call   *%r12
            if (res < 0) return res;
  804210c067:	85 c0                	test   %eax,%eax
  804210c069:	78 c5                	js     804210c030 <map_region+0x1d7>
            src += CLASS_SIZE(class);
  804210c06b:	4c 01 fb             	add    %r15,%rbx
        while (dst + CLASS_SIZE(class) <= end) {
  804210c06e:	4b 8d 04 3e          	lea    (%r14,%r15,1),%rax
  804210c072:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  804210c076:	73 cc                	jae    804210c044 <map_region+0x1eb>
  804210c078:	8b 55 b0             	mov    -0x50(%rbp),%edx
  804210c07b:	49 89 dd             	mov    %rbx,%r13
    for (; class >= 0 && dst < end; class --) {
  804210c07e:	83 ea 01             	sub    $0x1,%edx
  804210c081:	78 0d                	js     804210c090 <map_region+0x237>
  804210c083:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210c087:	49 39 c6             	cmp    %rax,%r14
  804210c08a:	0f 82 5f ff ff ff    	jb     804210bfef <map_region+0x196>
    return 0;
  804210c090:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c095:	eb 99                	jmp    804210c030 <map_region+0x1d7>
    if (src & CLASS_MASK(0) || (!sspace && !(flags & (ALLOC_ZERO | ALLOC_ONE)))) return -E_INVAL;
  804210c097:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210c09c:	eb 92                	jmp    804210c030 <map_region+0x1d7>
    if (dst & CLASS_MASK(0) || !dspace) return -E_INVAL;
  804210c09e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210c0a3:	eb 8b                	jmp    804210c030 <map_region+0x1d7>
    if (size & CLASS_MASK(0) || !size) return -E_INVAL;
  804210c0a5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210c0aa:	eb 84                	jmp    804210c030 <map_region+0x1d7>

000000804210c0ac <kzalloc_region>:
kzalloc_region(size_t size) {
  804210c0ac:	f3 0f 1e fa          	endbr64
  804210c0b0:	55                   	push   %rbp
  804210c0b1:	48 89 e5             	mov    %rsp,%rbp
  804210c0b4:	53                   	push   %rbx
  804210c0b5:	48 83 ec 08          	sub    $0x8,%rsp
    assert(current_space);
  804210c0b9:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  804210c0c0:	00 00 00 
  804210c0c3:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210c0c7:	74 6e                	je     804210c137 <kzalloc_region+0x8b>
    size = ROUNDUP(size, PAGE_SIZE);
  804210c0c9:	4c 8d 87 ff 0f 00 00 	lea    0xfff(%rdi),%r8
  804210c0d0:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
    if (metaheaptop + size > KERN_HEAP_END) panic("Kernel heap overflow\n");
  804210c0d7:	48 b8 30 61 00 43 80 	movabs $0x8043006130,%rax
  804210c0de:	00 00 00 
  804210c0e1:	48 8b 18             	mov    (%rax),%rbx
  804210c0e4:	4a 8d 04 03          	lea    (%rbx,%r8,1),%rax
  804210c0e8:	48 ba 00 00 e0 3f 80 	movabs $0x803fe00000,%rdx
  804210c0ef:	00 00 00 
  804210c0f2:	48 39 c2             	cmp    %rax,%rdx
  804210c0f5:	72 75                	jb     804210c16c <kzalloc_region+0xc0>
    metaheaptop += size;
  804210c0f7:	48 a3 30 61 00 43 80 	movabs %rax,0x8043006130
  804210c0fe:	00 00 00 
    int r = map_region(&kspace, res, NULL, 0, size, PROT_R | PROT_W | ALLOC_ZERO);
  804210c101:	41 b9 06 00 10 00    	mov    $0x100006,%r9d
  804210c107:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210c10c:	ba 00 00 00 00       	mov    $0x0,%edx
  804210c111:	48 89 de             	mov    %rbx,%rsi
  804210c114:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210c11b:	00 00 00 
  804210c11e:	48 b8 59 be 10 42 80 	movabs $0x804210be59,%rax
  804210c125:	00 00 00 
  804210c128:	ff d0                	call   *%rax
    if (r < 0) panic("kzalloc_region: %i\n", r);
  804210c12a:	85 c0                	test   %eax,%eax
  804210c12c:	78 68                	js     804210c196 <kzalloc_region+0xea>
}
  804210c12e:	48 89 d8             	mov    %rbx,%rax
  804210c131:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804210c135:	c9                   	leave
  804210c136:	c3                   	ret
    assert(current_space);
  804210c137:	48 b9 93 f9 11 42 80 	movabs $0x804211f993,%rcx
  804210c13e:	00 00 00 
  804210c141:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210c148:	00 00 00 
  804210c14b:	be e3 06 00 00       	mov    $0x6e3,%esi
  804210c150:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210c157:	00 00 00 
  804210c15a:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c15f:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210c166:	00 00 00 
  804210c169:	41 ff d0             	call   *%r8
    if (metaheaptop + size > KERN_HEAP_END) panic("Kernel heap overflow\n");
  804210c16c:	48 ba d8 f9 11 42 80 	movabs $0x804211f9d8,%rdx
  804210c173:	00 00 00 
  804210c176:	be e7 06 00 00       	mov    $0x6e7,%esi
  804210c17b:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210c182:	00 00 00 
  804210c185:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c18a:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210c191:	00 00 00 
  804210c194:	ff d1                	call   *%rcx
    if (r < 0) panic("kzalloc_region: %i\n", r);
  804210c196:	89 c1                	mov    %eax,%ecx
  804210c198:	48 ba ee f9 11 42 80 	movabs $0x804211f9ee,%rdx
  804210c19f:	00 00 00 
  804210c1a2:	be ed 06 00 00       	mov    $0x6ed,%esi
  804210c1a7:	48 bf 18 f7 11 42 80 	movabs $0x804211f718,%rdi
  804210c1ae:	00 00 00 
  804210c1b1:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c1b6:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210c1bd:	00 00 00 
  804210c1c0:	41 ff d0             	call   *%r8

000000804210c1c3 <swap_push>:

void swap_push(struct Page *tail)
{
  804210c1c3:	f3 0f 1e fa          	endbr64
  804210c1c7:	55                   	push   %rbp
  804210c1c8:	48 89 e5             	mov    %rsp,%rbp
  804210c1cb:	41 56                	push   %r14
  804210c1cd:	41 55                	push   %r13
  804210c1cf:	41 54                	push   %r12
  804210c1d1:	53                   	push   %rbx
    if (!tail) {
  804210c1d2:	48 85 ff             	test   %rdi,%rdi
  804210c1d5:	0f 84 89 00 00 00    	je     804210c264 <swap_push+0xa1>
  804210c1db:	48 89 fb             	mov    %rdi,%rbx
    return page->addr << CLASS_BASE;
  804210c1de:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804210c1e5:	ff 0f 00 
  804210c1e8:	48 89 c7             	mov    %rax,%rdi
  804210c1eb:	48 23 7b 38          	and    0x38(%rbx),%rdi
  804210c1ef:	48 c1 e7 0c          	shl    $0xc,%rdi
  804210c1f3:	48 21 c7             	and    %rax,%rdi
        cprintf("swap_push: null page\n");
        return;
    }

    int k = SWAP_AMOUNT - 1;
    int cur_size = LZ4_compress_default((char *)page2pa(tail), CompressionBuffer, PAGE_SIZE, COMP_SIZE);
  804210c1f6:	b9 20 10 00 00       	mov    $0x1020,%ecx
  804210c1fb:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210c200:	49 be 20 00 00 43 80 	movabs $0x8043000020,%r14
  804210c207:	00 00 00 
  804210c20a:	4c 89 f6             	mov    %r14,%rsi
  804210c20d:	48 b8 6d 5d 11 42 80 	movabs $0x8042115d6d,%rax
  804210c214:	00 00 00 
  804210c217:	ff d0                	call   *%rax
  804210c219:	41 89 c4             	mov    %eax,%r12d
    memcpy(swap_info[k].buffer, CompressionBuffer, cur_size);
  804210c21c:	48 63 d0             	movslq %eax,%rdx
  804210c21f:	49 bd 60 10 00 43 80 	movabs $0x8043001060,%r13
  804210c226:	00 00 00 
  804210c229:	49 8b 7d 10          	mov    0x10(%r13),%rdi
  804210c22d:	4c 89 f6             	mov    %r14,%rsi
  804210c230:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210c237:	00 00 00 
  804210c23a:	ff d0                	call   *%rax
    swap_info[k].size = cur_size;
  804210c23c:	45 89 65 18          	mov    %r12d,0x18(%r13)

    tail->state = SWAPPED_PAGE;
  804210c240:	c7 43 28 00 00 00 01 	movl   $0x1000000,0x28(%rbx)

 
    update_all_pte(tail, k);
  804210c247:	be 01 00 00 00       	mov    $0x1,%esi
  804210c24c:	48 89 df             	mov    %rbx,%rdi
  804210c24f:	48 b8 9a 78 10 42 80 	movabs $0x804210789a,%rax
  804210c256:	00 00 00 
  804210c259:	ff d0                	call   *%rax
}
  804210c25b:	5b                   	pop    %rbx
  804210c25c:	41 5c                	pop    %r12
  804210c25e:	41 5d                	pop    %r13
  804210c260:	41 5e                	pop    %r14
  804210c262:	5d                   	pop    %rbp
  804210c263:	c3                   	ret
        cprintf("swap_push: null page\n");
  804210c264:	48 bf 02 fa 11 42 80 	movabs $0x804211fa02,%rdi
  804210c26b:	00 00 00 
  804210c26e:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c273:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210c27a:	00 00 00 
  804210c27d:	ff d2                	call   *%rdx
        return;
  804210c27f:	eb da                	jmp    804210c25b <swap_push+0x98>

000000804210c281 <envid2env>:
 * RETURNS
 *     0 on success, -E_BAD_ENV on error.
 *   On success, sets *env_store to the environment.
 *   On error, sets *env_store to NULL. */
int
envid2env(envid_t envid, struct Env **env_store, bool need_check_perm) {
  804210c281:	f3 0f 1e fa          	endbr64
    struct Env *env;

    /* If envid is zero, return the current environment. */
    if (!envid) {
  804210c285:	85 ff                	test   %edi,%edi
  804210c287:	74 72                	je     804210c2fb <envid2env+0x7a>
    /* Look up the Env structure via the index part of the envid,
     * then check the env_id field in that struct Env
     * to ensure that the envid is not stale
     * (i.e., does not refer to a _previous_ environment
     * that used the same slot in the envs[] array). */
    env = &envs[ENVX(envid)];
  804210c289:	89 f8                	mov    %edi,%eax
  804210c28b:	25 ff 03 00 00       	and    $0x3ff,%eax
  804210c290:	48 8d 0c c0          	lea    (%rax,%rax,8),%rcx
  804210c294:	48 8d 0c 48          	lea    (%rax,%rcx,2),%rcx
  804210c298:	48 c1 e1 04          	shl    $0x4,%rcx
  804210c29c:	48 a1 68 64 00 43 80 	movabs 0x8043006468,%rax
  804210c2a3:	00 00 00 
  804210c2a6:	48 01 c1             	add    %rax,%rcx
    if (env->env_status == ENV_FREE || env->env_id != envid) {
  804210c2a9:	83 b9 d4 00 00 00 00 	cmpl   $0x0,0xd4(%rcx)
  804210c2b0:	74 5c                	je     804210c30e <envid2env+0x8d>
  804210c2b2:	39 b9 c8 00 00 00    	cmp    %edi,0xc8(%rcx)
  804210c2b8:	75 60                	jne    804210c31a <envid2env+0x99>
        *env_store = NULL;
        return -E_BAD_ENV;
    }

    *env_store = env;
    return 0;
  804210c2ba:	b8 00 00 00 00       	mov    $0x0,%eax
    if (need_check_perm && env != curenv && env->env_parent_id != curenv->env_id) {
  804210c2bf:	84 d2                	test   %dl,%dl
  804210c2c1:	74 47                	je     804210c30a <envid2env+0x89>
  804210c2c3:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210c2ca:	00 00 00 
  804210c2cd:	48 8b 10             	mov    (%rax),%rdx
    return 0;
  804210c2d0:	b8 00 00 00 00       	mov    $0x0,%eax
    if (need_check_perm && env != curenv && env->env_parent_id != curenv->env_id) {
  804210c2d5:	48 39 ca             	cmp    %rcx,%rdx
  804210c2d8:	74 30                	je     804210c30a <envid2env+0x89>
  804210c2da:	8b b9 cc 00 00 00    	mov    0xcc(%rcx),%edi
    return 0;
  804210c2e0:	3b ba c8 00 00 00    	cmp    0xc8(%rdx),%edi
  804210c2e6:	0f 94 c0             	sete   %al
  804210c2e9:	0f b6 c0             	movzbl %al,%eax
  804210c2ec:	8d 44 00 fe          	lea    -0x2(%rax,%rax,1),%eax
  804210c2f0:	ba 00 00 00 00       	mov    $0x0,%edx
  804210c2f5:	48 0f 45 ca          	cmovne %rdx,%rcx
  804210c2f9:	eb 0f                	jmp    804210c30a <envid2env+0x89>
        *env_store = curenv;
  804210c2fb:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210c302:	00 00 00 
  804210c305:	48 8b 08             	mov    (%rax),%rcx
        return 0;
  804210c308:	89 f8                	mov    %edi,%eax
        *env_store = curenv;
  804210c30a:	48 89 0e             	mov    %rcx,(%rsi)
}
  804210c30d:	c3                   	ret
  804210c30e:	b9 00 00 00 00       	mov    $0x0,%ecx
        return -E_BAD_ENV;
  804210c313:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804210c318:	eb f0                	jmp    804210c30a <envid2env+0x89>
  804210c31a:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210c31f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804210c324:	eb e4                	jmp    804210c30a <envid2env+0x89>

000000804210c326 <env_init>:
 * Make sure the environments are in the free list in the same order
 * they are in the envs array (i.e., so that the first call to
 * env_alloc() returns envs[0]).
 */
void
env_init(void) {
  804210c326:	f3 0f 1e fa          	endbr64
  804210c32a:	55                   	push   %rbp
  804210c32b:	48 89 e5             	mov    %rsp,%rbp
  804210c32e:	41 55                	push   %r13
  804210c330:	41 54                	push   %r12
  804210c332:	53                   	push   %rbx
  804210c333:	48 83 ec 08          	sub    $0x8,%rsp
    /* Allocate vsys array with kzalloc_region().
     * Don't forget about rounding.
     * kzalloc_region only works with current_space != NULL */
    // LAB 12: Your code here
    vsys = kzalloc_region(UVSYS_SIZE);
  804210c337:	bf 00 10 00 00       	mov    $0x1000,%edi
  804210c33c:	49 bc ac c0 10 42 80 	movabs $0x804210c0ac,%r12
  804210c343:	00 00 00 
  804210c346:	41 ff d4             	call   *%r12
  804210c349:	48 a3 60 64 00 43 80 	movabs %rax,0x8043006460
  804210c350:	00 00 00 
    map_region(&kspace, UVSYS, &kspace, (uintptr_t)vsys, UVSYS_SIZE, PROT_R | PROT_USER_);
  804210c353:	41 b9 24 00 00 00    	mov    $0x24,%r9d
  804210c359:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  804210c35f:	48 89 c1             	mov    %rax,%rcx
  804210c362:	48 bb e0 10 00 43 80 	movabs $0x80430010e0,%rbx
  804210c369:	00 00 00 
  804210c36c:	48 89 da             	mov    %rbx,%rdx
  804210c36f:	48 be 00 f0 9f 1f 80 	movabs $0x801f9ff000,%rsi
  804210c376:	00 00 00 
  804210c379:	48 89 df             	mov    %rbx,%rdi
  804210c37c:	49 bd 59 be 10 42 80 	movabs $0x804210be59,%r13
  804210c383:	00 00 00 
  804210c386:	41 ff d5             	call   *%r13
    /* Allocate envs array with kzalloc_region().
     * Don't forget about rounding.
     * kzalloc_region() only works with current_space != NULL */
    // LAB 8: Your code here
    envs = (struct Env *)kzalloc_region(sizeof(*envs) * NENV);
  804210c389:	bf 00 c0 04 00       	mov    $0x4c000,%edi
  804210c38e:	41 ff d4             	call   *%r12
  804210c391:	48 89 c1             	mov    %rax,%rcx
  804210c394:	49 bc 68 64 00 43 80 	movabs $0x8043006468,%r12
  804210c39b:	00 00 00 
  804210c39e:	49 89 04 24          	mov    %rax,(%r12)
    /* Map envs to UENVS read-only,
     * but user-accessible (with PROT_USER_ set) */
    // LAB 8: Your code here
    map_region(&kspace, UENVS, &kspace, (uintptr_t)envs, UENVS_SIZE, PROT_R | PROT_USER_);
  804210c3a2:	41 b9 24 00 00 00    	mov    $0x24,%r9d
  804210c3a8:	41 b8 00 00 20 00    	mov    $0x200000,%r8d
  804210c3ae:	48 89 da             	mov    %rbx,%rdx
  804210c3b1:	48 be 00 00 a0 1f 80 	movabs $0x801fa00000,%rsi
  804210c3b8:	00 00 00 
  804210c3bb:	48 89 df             	mov    %rbx,%rdi
  804210c3be:	41 ff d5             	call   *%r13
    /* Set up envs array */

    // LAB 3: Your code here
    env_free_list = envs;
  804210c3c1:	49 8b 04 24          	mov    (%r12),%rax
  804210c3c5:	48 a3 78 64 00 43 80 	movabs %rax,0x8043006478
  804210c3cc:	00 00 00 
	for (unsigned int i = 0; i < NENV - 1; i++) {
  804210c3cf:	48 8d 90 30 01 00 00 	lea    0x130(%rax),%rdx
  804210c3d6:	48 8d 88 00 c0 04 00 	lea    0x4c000(%rax),%rcx
		envs[i].env_id = 0;
  804210c3dd:	c7 42 98 00 00 00 00 	movl   $0x0,-0x68(%rdx)
		envs[i].env_link = &envs[i+1];
  804210c3e4:	48 89 52 90          	mov    %rdx,-0x70(%rdx)
	for (unsigned int i = 0; i < NENV - 1; i++) {
  804210c3e8:	48 81 c2 30 01 00 00 	add    $0x130,%rdx
  804210c3ef:	48 39 ca             	cmp    %rcx,%rdx
  804210c3f2:	75 e9                	jne    804210c3dd <env_init+0xb7>
	}
	envs[NENV - 1].env_id = 0;
  804210c3f4:	c7 80 98 bf 04 00 00 	movl   $0x0,0x4bf98(%rax)
  804210c3fb:	00 00 00 
	envs[NENV - 1].env_link = NULL;
  804210c3fe:	48 c7 80 90 bf 04 00 	movq   $0x0,0x4bf90(%rax)
  804210c405:	00 00 00 00 
}
  804210c409:	48 83 c4 08          	add    $0x8,%rsp
  804210c40d:	5b                   	pop    %rbx
  804210c40e:	41 5c                	pop    %r12
  804210c410:	41 5d                	pop    %r13
  804210c412:	5d                   	pop    %rbp
  804210c413:	c3                   	ret

000000804210c414 <env_alloc>:
 * Errors
 *    -E_NO_FREE_ENV if all NENVS environments are allocated
 *    -E_NO_MEM on memory exhaustion
 */
int
env_alloc(struct Env **newenv_store, envid_t parent_id, enum EnvType type) {
  804210c414:	f3 0f 1e fa          	endbr64
  804210c418:	55                   	push   %rbp
  804210c419:	48 89 e5             	mov    %rsp,%rbp
  804210c41c:	41 56                	push   %r14
  804210c41e:	41 55                	push   %r13
  804210c420:	41 54                	push   %r12
  804210c422:	53                   	push   %rbx

    struct Env *env;
    if (!(env = env_free_list))
  804210c423:	48 b8 78 64 00 43 80 	movabs $0x8043006478,%rax
  804210c42a:	00 00 00 
  804210c42d:	48 8b 18             	mov    (%rax),%rbx
  804210c430:	48 85 db             	test   %rbx,%rbx
  804210c433:	0f 84 1c 01 00 00    	je     804210c555 <env_alloc+0x141>
  804210c439:	49 89 fd             	mov    %rdi,%r13
  804210c43c:	41 89 f6             	mov    %esi,%r14d
  804210c43f:	41 89 d4             	mov    %edx,%r12d
        return -E_NO_FREE_ENV;

    /* Allocate and set up the page directory for this environment. */
    int res = init_address_space(&env->address_space);
  804210c442:	48 8d bb e8 00 00 00 	lea    0xe8(%rbx),%rdi
  804210c449:	48 b8 3b 7d 10 42 80 	movabs $0x8042107d3b,%rax
  804210c450:	00 00 00 
  804210c453:	ff d0                	call   *%rax
    if (res < 0) return res;
  804210c455:	85 c0                	test   %eax,%eax
  804210c457:	0f 88 ef 00 00 00    	js     804210c54c <env_alloc+0x138>

    /* Generate an env_id for this environment */
    int32_t generation = (env->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  804210c45d:	8b 83 c8 00 00 00    	mov    0xc8(%rbx),%eax
  804210c463:	05 00 10 00 00       	add    $0x1000,%eax
    /* Don't create a negative env_id */
    if (generation <= 0) generation = 1 << ENVGENSHIFT;
  804210c468:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  804210c46d:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210c472:	0f 4e c2             	cmovle %edx,%eax
    env->env_id = generation | (env - envs);
  804210c475:	48 ba 68 64 00 43 80 	movabs $0x8043006468,%rdx
  804210c47c:	00 00 00 
  804210c47f:	48 89 d9             	mov    %rbx,%rcx
  804210c482:	48 2b 0a             	sub    (%rdx),%rcx
  804210c485:	48 89 ca             	mov    %rcx,%rdx
  804210c488:	48 c1 fa 04          	sar    $0x4,%rdx
  804210c48c:	69 d2 1b ca 6b 28    	imul   $0x286bca1b,%edx,%edx
  804210c492:	09 d0                	or     %edx,%eax
  804210c494:	89 83 c8 00 00 00    	mov    %eax,0xc8(%rbx)

    /* Set the basic status variables */
    env->env_parent_id = parent_id;
  804210c49a:	44 89 b3 cc 00 00 00 	mov    %r14d,0xcc(%rbx)
#ifdef CONFIG_KSPACE
    env->env_type = ENV_TYPE_KERNEL;
#else
    env->env_type = type;
  804210c4a1:	44 89 a3 d0 00 00 00 	mov    %r12d,0xd0(%rbx)
#endif
    env->env_status = ENV_RUNNABLE;
  804210c4a8:	c7 83 d4 00 00 00 02 	movl   $0x2,0xd4(%rbx)
  804210c4af:	00 00 00 
    env->env_runs = 0;
  804210c4b2:	c7 83 d8 00 00 00 00 	movl   $0x0,0xd8(%rbx)
  804210c4b9:	00 00 00 

    /* Clear out all the saved register state,
     * to prevent the register values
     * of a prior environment inhabiting this Env structure
     * from "leaking" into our new environment */
    memset(&env->env_tf, 0, sizeof(env->env_tf));
  804210c4bc:	ba c0 00 00 00       	mov    $0xc0,%edx
  804210c4c1:	be 00 00 00 00       	mov    $0x0,%esi
  804210c4c6:	48 89 df             	mov    %rbx,%rdi
  804210c4c9:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  804210c4d0:	00 00 00 
  804210c4d3:	ff d0                	call   *%rax
    // LAB 3: Your code here:
    static uintptr_t stack_top = 0x2000000;
    env->env_tf.tf_rsp = stack_top;
    stack_top -= PAGE_SIZE * 2;
#else
    env->env_tf.tf_ds = GD_UD | 3;
  804210c4d5:	66 c7 83 80 00 00 00 	movw   $0x33,0x80(%rbx)
  804210c4dc:	33 00 
    env->env_tf.tf_es = GD_UD | 3;
  804210c4de:	66 c7 43 78 33 00    	movw   $0x33,0x78(%rbx)
    env->env_tf.tf_ss = GD_UD | 3;
  804210c4e4:	66 c7 83 b8 00 00 00 	movw   $0x33,0xb8(%rbx)
  804210c4eb:	33 00 
    env->env_tf.tf_cs = GD_UT | 3;
  804210c4ed:	66 c7 83 a0 00 00 00 	movw   $0x2b,0xa0(%rbx)
  804210c4f4:	2b 00 
    env->env_tf.tf_rsp = USER_STACK_TOP;
  804210c4f6:	48 b8 00 70 ff ff 7f 	movabs $0x7fffff7000,%rax
  804210c4fd:	00 00 00 
  804210c500:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
#endif

    /* For now init trapframe with IF set */
    env->env_tf.tf_rflags = FL_IF | (type == ENV_TYPE_FS ? FL_IOPL_3 : FL_IOPL_0);
  804210c507:	41 83 fc 03          	cmp    $0x3,%r12d
  804210c50b:	b8 00 02 00 00       	mov    $0x200,%eax
  804210c510:	ba 00 32 00 00       	mov    $0x3200,%edx
  804210c515:	48 0f 44 c2          	cmove  %rdx,%rax
  804210c519:	48 89 83 a8 00 00 00 	mov    %rax,0xa8(%rbx)

    /* Clear the page fault handler until user installs one. */
    env->env_pgfault_upcall = 0;
  804210c520:	48 c7 83 00 01 00 00 	movq   $0x0,0x100(%rbx)
  804210c527:	00 00 00 00 

    /* Also clear the IPC receiving flag. */
    env->env_ipc_recving = 0;
  804210c52b:	c6 83 08 01 00 00 00 	movb   $0x0,0x108(%rbx)

    /* Commit the allocation */
    env_free_list = env->env_link;
  804210c532:	48 8b 83 c0 00 00 00 	mov    0xc0(%rbx),%rax
  804210c539:	48 a3 78 64 00 43 80 	movabs %rax,0x8043006478
  804210c540:	00 00 00 
    *newenv_store = env;
  804210c543:	49 89 5d 00          	mov    %rbx,0x0(%r13)

    if (trace_envs) cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, env->env_id);
    return 0;
  804210c547:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804210c54c:	5b                   	pop    %rbx
  804210c54d:	41 5c                	pop    %r12
  804210c54f:	41 5d                	pop    %r13
  804210c551:	41 5e                	pop    %r14
  804210c553:	5d                   	pop    %rbp
  804210c554:	c3                   	ret
        return -E_NO_FREE_ENV;
  804210c555:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  804210c55a:	eb f0                	jmp    804210c54c <env_alloc+0x138>

000000804210c55c <env_create>:
 * This function is ONLY called during kernel initialization,
 * before running the first user-mode environment.
 * The new env's parent ID is set to 0.
 */
void
env_create(uint8_t *binary, size_t size, enum EnvType type) {
  804210c55c:	f3 0f 1e fa          	endbr64
  804210c560:	55                   	push   %rbp
  804210c561:	48 89 e5             	mov    %rsp,%rbp
  804210c564:	41 57                	push   %r15
  804210c566:	41 56                	push   %r14
  804210c568:	41 55                	push   %r13
  804210c56a:	41 54                	push   %r12
  804210c56c:	53                   	push   %rbx
  804210c56d:	48 83 ec 28          	sub    $0x28,%rsp
  804210c571:	49 89 fe             	mov    %rdi,%r14
    // LAB 3: Your code here
    // LAB 8: Your code here
    struct Env *env;
    int r = env_alloc(&env, 0, type);
  804210c574:	be 00 00 00 00       	mov    $0x0,%esi
  804210c579:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210c57d:	48 b8 14 c4 10 42 80 	movabs $0x804210c414,%rax
  804210c584:	00 00 00 
  804210c587:	ff d0                	call   *%rax
    if (r < 0) {
  804210c589:	85 c0                	test   %eax,%eax
  804210c58b:	78 4d                	js     804210c5da <env_create+0x7e>
        panic("env_create: %i", r);
    }
    env->binary = binary;
  804210c58d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210c591:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  804210c595:	4c 89 b0 e0 00 00 00 	mov    %r14,0xe0(%rax)
    switch_address_space(&env->address_space);
  804210c59c:	4c 8d b8 e8 00 00 00 	lea    0xe8(%rax),%r15
  804210c5a3:	4c 89 ff             	mov    %r15,%rdi
  804210c5a6:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210c5ad:	00 00 00 
  804210c5b0:	ff d0                	call   *%rax
    if (elf->e_magic != ELF_MAGIC) {
  804210c5b2:	41 81 3e 7f 45 4c 46 	cmpl   $0x464c457f,(%r14)
  804210c5b9:	0f 85 84 01 00 00    	jne    804210c743 <env_create+0x1e7>
    struct Proghdr *ph = (struct Proghdr *) (binary + elf->e_phoff);
  804210c5bf:	49 8b 5e 20          	mov    0x20(%r14),%rbx
    for (int i = 0; i < elf->e_phnum; i++) {
  804210c5c3:	66 41 83 7e 38 00    	cmpw   $0x0,0x38(%r14)
  804210c5c9:	0f 84 cf 00 00 00    	je     804210c69e <env_create+0x142>
  804210c5cf:	4c 01 f3             	add    %r14,%rbx
  804210c5d2:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  804210c5d8:	eb 43                	jmp    804210c61d <env_create+0xc1>
        panic("env_create: %i", r);
  804210c5da:	89 c1                	mov    %eax,%ecx
  804210c5dc:	48 ba 18 fa 11 42 80 	movabs $0x804211fa18,%rdx
  804210c5e3:	00 00 00 
  804210c5e6:	be 75 01 00 00       	mov    $0x175,%esi
  804210c5eb:	48 bf 27 fa 11 42 80 	movabs $0x804211fa27,%rdi
  804210c5f2:	00 00 00 
  804210c5f5:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c5fa:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210c601:	00 00 00 
  804210c604:	41 ff d0             	call   *%r8
    for (int i = 0; i < elf->e_phnum; i++) {
  804210c607:	41 83 c4 01          	add    $0x1,%r12d
  804210c60b:	48 83 c3 38          	add    $0x38,%rbx
  804210c60f:	41 0f b7 46 38       	movzwl 0x38(%r14),%eax
  804210c614:	41 39 c4             	cmp    %eax,%r12d
  804210c617:	0f 8d 81 00 00 00    	jge    804210c69e <env_create+0x142>
        if (ph[i].p_type != ELF_PROG_LOAD || ph[i].p_memsz == 0) {
  804210c61d:	83 3b 01             	cmpl   $0x1,(%rbx)
  804210c620:	75 e5                	jne    804210c607 <env_create+0xab>
  804210c622:	48 8b 43 28          	mov    0x28(%rbx),%rax
  804210c626:	48 85 c0             	test   %rax,%rax
  804210c629:	74 dc                	je     804210c607 <env_create+0xab>
        if (ph[i].p_filesz > ph[i].p_memsz) {
  804210c62b:	48 3b 43 20          	cmp    0x20(%rbx),%rax
  804210c62f:	0f 82 0e 01 00 00    	jb     804210c743 <env_create+0x1e7>
        uintptr_t start_aligned = ROUNDDOWN((uintptr_t)ph[i].p_va, PAGE_SIZE);
  804210c635:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  804210c639:	48 89 d6             	mov    %rdx,%rsi
  804210c63c:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
        uintptr_t end_aligned = ROUNDUP((uintptr_t)ph[i].p_va + ph[i].p_memsz, PAGE_SIZE);
  804210c643:	4c 8d 84 10 ff 0f 00 	lea    0xfff(%rax,%rdx,1),%r8
  804210c64a:	00 
        map_region(&env->address_space, start_aligned, NULL, 0, end_aligned - start_aligned, ph[i].p_flags | PROT_W | PROT_USER_ | ALLOC_ZERO);
  804210c64b:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
  804210c652:	44 8b 4b 04          	mov    0x4(%rbx),%r9d
  804210c656:	41 81 c9 22 00 10 00 	or     $0x100022,%r9d
  804210c65d:	49 29 f0             	sub    %rsi,%r8
  804210c660:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210c665:	ba 00 00 00 00       	mov    $0x0,%edx
  804210c66a:	4c 89 ff             	mov    %r15,%rdi
  804210c66d:	48 b8 59 be 10 42 80 	movabs $0x804210be59,%rax
  804210c674:	00 00 00 
  804210c677:	ff d0                	call   *%rax
        if (ph[i].p_filesz) {
  804210c679:	48 8b 53 20          	mov    0x20(%rbx),%rdx
  804210c67d:	48 85 d2             	test   %rdx,%rdx
  804210c680:	74 85                	je     804210c607 <env_create+0xab>
            memcpy((void *)ph[i].p_va, (void *)(binary + ph[i].p_offset), ph[i].p_filesz);
  804210c682:	4c 89 f6             	mov    %r14,%rsi
  804210c685:	48 03 73 08          	add    0x8(%rbx),%rsi
  804210c689:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  804210c68d:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210c694:	00 00 00 
  804210c697:	ff d0                	call   *%rax
  804210c699:	e9 69 ff ff ff       	jmp    804210c607 <env_create+0xab>
    env->env_tf.tf_rip = elf->e_entry;
  804210c69e:	49 8b 46 18          	mov    0x18(%r14),%rax
  804210c6a2:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
  804210c6a6:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
    map_region(&env->address_space, USER_STACK_TOP - PAGE_SIZE, NULL, 0, PAGE_SIZE, PROT_R | PROT_W | PROT_USER_ | ALLOC_ZERO);
  804210c6ad:	41 b9 26 00 10 00    	mov    $0x100026,%r9d
  804210c6b3:	41 b8 00 10 00 00    	mov    $0x1000,%r8d
  804210c6b9:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210c6be:	ba 00 00 00 00       	mov    $0x0,%edx
  804210c6c3:	48 be 00 60 ff ff 7f 	movabs $0x7fffff6000,%rsi
  804210c6ca:	00 00 00 
  804210c6cd:	4c 89 ff             	mov    %r15,%rdi
  804210c6d0:	48 b8 59 be 10 42 80 	movabs $0x804210be59,%rax
  804210c6d7:	00 00 00 
  804210c6da:	ff d0                	call   *%rax
    switch_address_space(&kspace);
  804210c6dc:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210c6e3:	00 00 00 
  804210c6e6:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210c6ed:	00 00 00 
  804210c6f0:	ff d0                	call   *%rax
    if (env->env_type == ENV_TYPE_FS) {
  804210c6f2:	83 bb d0 00 00 00 03 	cmpl   $0x3,0xd0(%rbx)
  804210c6f9:	74 0f                	je     804210c70a <env_create+0x1ae>
    r = load_icode(env, binary, size);
    if (r < 0) {
        panic("load_icode: %i", r);
    }
    // LAB 10: Your code here
}
  804210c6fb:	48 83 c4 28          	add    $0x28,%rsp
  804210c6ff:	5b                   	pop    %rbx
  804210c700:	41 5c                	pop    %r12
  804210c702:	41 5d                	pop    %r13
  804210c704:	41 5e                	pop    %r14
  804210c706:	41 5f                	pop    %r15
  804210c708:	5d                   	pop    %rbp
  804210c709:	c3                   	ret
        struct AddressSpace *as = switch_address_space(&env->address_space);
  804210c70a:	4c 89 ff             	mov    %r15,%rdi
  804210c70d:	49 bc ac 5b 10 42 80 	movabs $0x8042105bac,%r12
  804210c714:	00 00 00 
  804210c717:	41 ff d4             	call   *%r12
  804210c71a:	48 89 c3             	mov    %rax,%rbx
        env->env_tf.tf_rsp = make_fs_args((char *)env->env_tf.tf_rsp);
  804210c71d:	4c 8b 7d b8          	mov    -0x48(%rbp),%r15
  804210c721:	49 8b bf b0 00 00 00 	mov    0xb0(%r15),%rdi
  804210c728:	48 b8 f3 e8 10 42 80 	movabs $0x804210e8f3,%rax
  804210c72f:	00 00 00 
  804210c732:	ff d0                	call   *%rax
  804210c734:	49 89 87 b0 00 00 00 	mov    %rax,0xb0(%r15)
        switch_address_space(as);
  804210c73b:	48 89 df             	mov    %rbx,%rdi
  804210c73e:	41 ff d4             	call   *%r12
  804210c741:	eb b8                	jmp    804210c6fb <env_create+0x19f>
        panic("load_icode: %i", r);
  804210c743:	b9 f8 ff ff ff       	mov    $0xfffffff8,%ecx
  804210c748:	48 ba 32 fa 11 42 80 	movabs $0x804211fa32,%rdx
  804210c74f:	00 00 00 
  804210c752:	be 7a 01 00 00       	mov    $0x17a,%esi
  804210c757:	48 bf 27 fa 11 42 80 	movabs $0x804211fa27,%rdi
  804210c75e:	00 00 00 
  804210c761:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c766:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210c76d:	00 00 00 
  804210c770:	41 ff d0             	call   *%r8

000000804210c773 <env_free>:


/* Frees env and all memory it uses */
void
env_free(struct Env *env) {
  804210c773:	f3 0f 1e fa          	endbr64
  804210c777:	55                   	push   %rbp
  804210c778:	48 89 e5             	mov    %rsp,%rbp
  804210c77b:	41 54                	push   %r12
  804210c77d:	53                   	push   %rbx
  804210c77e:	48 89 fb             	mov    %rdi,%rbx

#ifndef CONFIG_KSPACE
    /* If freeing the current environment, switch to kern_pgdir
     * before freeing the page directory, just in case the page
     * gets reused. */
    if (&env->address_space == current_space)
  804210c781:	4c 8d a7 e8 00 00 00 	lea    0xe8(%rdi),%r12
  804210c788:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  804210c78f:	00 00 00 
  804210c792:	4c 3b 20             	cmp    (%rax),%r12
  804210c795:	74 35                	je     804210c7cc <env_free+0x59>
        switch_address_space(&kspace);

    static_assert(MAX_USER_ADDRESS % HUGE_PAGE_SIZE == 0, "Misaligned MAX_USER_ADDRESS");
    release_address_space(&env->address_space);
  804210c797:	4c 89 e7             	mov    %r12,%rdi
  804210c79a:	48 b8 31 88 10 42 80 	movabs $0x8042108831,%rax
  804210c7a1:	00 00 00 
  804210c7a4:	ff d0                	call   *%rax
#endif

    /* Return the environment to the free list */
    env->env_status = ENV_FREE;
  804210c7a6:	c7 83 d4 00 00 00 00 	movl   $0x0,0xd4(%rbx)
  804210c7ad:	00 00 00 
    env->env_link = env_free_list;
  804210c7b0:	48 b8 78 64 00 43 80 	movabs $0x8043006478,%rax
  804210c7b7:	00 00 00 
  804210c7ba:	48 8b 10             	mov    (%rax),%rdx
  804210c7bd:	48 89 93 c0 00 00 00 	mov    %rdx,0xc0(%rbx)
    env_free_list = env;
  804210c7c4:	48 89 18             	mov    %rbx,(%rax)
}
  804210c7c7:	5b                   	pop    %rbx
  804210c7c8:	41 5c                	pop    %r12
  804210c7ca:	5d                   	pop    %rbp
  804210c7cb:	c3                   	ret
        switch_address_space(&kspace);
  804210c7cc:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210c7d3:	00 00 00 
  804210c7d6:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210c7dd:	00 00 00 
  804210c7e0:	ff d0                	call   *%rax
  804210c7e2:	eb b3                	jmp    804210c797 <env_free+0x24>

000000804210c7e4 <env_destroy>:
 *
 * If env was the current one, then runs a new environment
 * (and does not return to the caller)
 */
void
env_destroy(struct Env *env) {
  804210c7e4:	f3 0f 1e fa          	endbr64
  804210c7e8:	55                   	push   %rbp
  804210c7e9:	48 89 e5             	mov    %rsp,%rbp
  804210c7ec:	53                   	push   %rbx
  804210c7ed:	48 83 ec 08          	sub    $0x8,%rsp
  804210c7f1:	48 89 fb             	mov    %rdi,%rbx
    /* If env is currently running on other CPUs, we change its state to
     * ENV_DYING. A zombie environment will be freed the next time
     * it traps to the kernel. */

    // LAB 3: Your code here
    env->env_status = ENV_DYING;
  804210c7f4:	c7 87 d4 00 00 00 01 	movl   $0x1,0xd4(%rdi)
  804210c7fb:	00 00 00 
    env_free(env);
  804210c7fe:	48 b8 73 c7 10 42 80 	movabs $0x804210c773,%rax
  804210c805:	00 00 00 
  804210c808:	ff d0                	call   *%rax
    if (curenv == env) {
  804210c80a:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210c811:	00 00 00 
  804210c814:	48 39 18             	cmp    %rbx,(%rax)
  804210c817:	74 06                	je     804210c81f <env_destroy+0x3b>
     * is getting destroyed after performing invalid memory access. */
    // LAB 8: Your code here
    if (env == curenv) {
        in_page_fault = 0;
    }
}
  804210c819:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804210c81d:	c9                   	leave
  804210c81e:	c3                   	ret
        sched_yield();
  804210c81f:	48 b8 a6 f1 10 42 80 	movabs $0x804210f1a6,%rax
  804210c826:	00 00 00 
  804210c829:	ff d0                	call   *%rax

000000804210c82b <env_pop_tf>:
 *
 * This function does not return.
 */

_Noreturn void
env_pop_tf(struct Trapframe *tf) {
  804210c82b:	f3 0f 1e fa          	endbr64
  804210c82f:	55                   	push   %rbp
  804210c830:	48 89 e5             	mov    %rsp,%rbp
    asm volatile(
  804210c833:	48 89 fc             	mov    %rdi,%rsp
  804210c836:	4c 8b 3c 24          	mov    (%rsp),%r15
  804210c83a:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  804210c83f:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  804210c844:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  804210c849:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  804210c84e:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  804210c853:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  804210c858:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  804210c85d:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  804210c862:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  804210c867:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  804210c86c:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  804210c871:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  804210c876:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  804210c87b:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  804210c880:	8e 44 24 78          	mov    0x78(%rsp),%es
  804210c884:	8e 9c 24 80 00 00 00 	mov    0x80(%rsp),%ds
  804210c88b:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  804210c892:	48 cf                	iretq
            "addq $152,%%rsp\n" /* skip tf_trapno and tf_errcode */
            "iretq" ::"g"(tf)
            : "memory");

    /* Mostly to placate the compiler */
    panic("Reached unrecheble\n");
  804210c894:	48 ba 41 fa 11 42 80 	movabs $0x804211fa41,%rdx
  804210c89b:	00 00 00 
  804210c89e:	be e0 01 00 00       	mov    $0x1e0,%esi
  804210c8a3:	48 bf 27 fa 11 42 80 	movabs $0x804211fa27,%rdi
  804210c8aa:	00 00 00 
  804210c8ad:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c8b2:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210c8b9:	00 00 00 
  804210c8bc:	ff d1                	call   *%rcx

000000804210c8be <env_run>:
 *    env->env_tf.  Go back through the code you wrote above
 *    and make sure you have set the relevant parts of
 *    env->env_tf to sensible values.
 */
_Noreturn void
env_run(struct Env *env) {
  804210c8be:	f3 0f 1e fa          	endbr64
  804210c8c2:	55                   	push   %rbp
  804210c8c3:	48 89 e5             	mov    %rsp,%rbp
  804210c8c6:	53                   	push   %rbx
  804210c8c7:	48 83 ec 08          	sub    $0x8,%rsp
    assert(env);
  804210c8cb:	48 85 ff             	test   %rdi,%rdi
  804210c8ce:	74 58                	je     804210c928 <env_run+0x6a>
        if (curenv) cprintf("[%08X] env stopped: %s\n", curenv->env_id, state[curenv->env_status]);
        cprintf("[%08X] env started: %s\n", env->env_id, state[env->env_status]);
    }

    // LAB 3: Your code here
    if (curenv && curenv->env_status == ENV_RUNNING) {
  804210c8d0:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210c8d7:	00 00 00 
  804210c8da:	48 85 c0             	test   %rax,%rax
  804210c8dd:	74 09                	je     804210c8e8 <env_run+0x2a>
  804210c8df:	83 b8 d4 00 00 00 03 	cmpl   $0x3,0xd4(%rax)
  804210c8e6:	74 75                	je     804210c95d <env_run+0x9f>
        curenv->env_status = ENV_RUNNABLE;
    }
    curenv = env;
  804210c8e8:	48 bb 70 64 00 43 80 	movabs $0x8043006470,%rbx
  804210c8ef:	00 00 00 
  804210c8f2:	48 89 3b             	mov    %rdi,(%rbx)
    curenv->env_status = ENV_RUNNING;
  804210c8f5:	c7 87 d4 00 00 00 03 	movl   $0x3,0xd4(%rdi)
  804210c8fc:	00 00 00 
    curenv->env_runs++;
  804210c8ff:	83 87 d8 00 00 00 01 	addl   $0x1,0xd8(%rdi)
    // LAB 8: Your code here
    switch_address_space(&curenv->address_space);
  804210c906:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
  804210c90d:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210c914:	00 00 00 
  804210c917:	ff d0                	call   *%rax
    env_pop_tf(&curenv->env_tf);
  804210c919:	48 8b 3b             	mov    (%rbx),%rdi
  804210c91c:	48 b8 2b c8 10 42 80 	movabs $0x804210c82b,%rax
  804210c923:	00 00 00 
  804210c926:	ff d0                	call   *%rax
    assert(env);
  804210c928:	48 b9 c0 fc 11 42 80 	movabs $0x804211fcc0,%rcx
  804210c92f:	00 00 00 
  804210c932:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210c939:	00 00 00 
  804210c93c:	be fa 01 00 00       	mov    $0x1fa,%esi
  804210c941:	48 bf 27 fa 11 42 80 	movabs $0x804211fa27,%rdi
  804210c948:	00 00 00 
  804210c94b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210c950:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210c957:	00 00 00 
  804210c95a:	41 ff d0             	call   *%r8
        curenv->env_status = ENV_RUNNABLE;
  804210c95d:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  804210c964:	00 00 00 
  804210c967:	e9 7c ff ff ff       	jmp    804210c8e8 <env_run+0x2a>

000000804210c96c <rtc_timer_pic_interrupt>:
cmos_read16(uint8_t reg) {
    return cmos_read8(reg) | (cmos_read8(reg + 1) << 8);
}

static void
rtc_timer_pic_interrupt(void) {
  804210c96c:	f3 0f 1e fa          	endbr64
  804210c970:	55                   	push   %rbp
  804210c971:	48 89 e5             	mov    %rsp,%rbp
    // LAB 4: Your code here
    // Enable PIC interrupts.
    pic_irq_unmask(IRQ_CLOCK);
  804210c974:	bf 08 00 00 00       	mov    $0x8,%edi
  804210c979:	48 b8 a0 ce 10 42 80 	movabs $0x804210cea0,%rax
  804210c980:	00 00 00 
  804210c983:	ff d0                	call   *%rax
}
  804210c985:	5d                   	pop    %rbp
  804210c986:	c3                   	ret

000000804210c987 <cmos_read8>:
cmos_read8(uint8_t reg) {
  804210c987:	f3 0f 1e fa          	endbr64
    asm volatile("inb %w1,%0"
  804210c98b:	b9 70 00 00 00       	mov    $0x70,%ecx
  804210c990:	89 ca                	mov    %ecx,%edx
  804210c992:	ec                   	in     (%dx),%al
    outb(CMOS_CMD, inb(CMOS_CMD) & ~CMOS_NMI_LOCK);
}

static inline void __attribute__((always_inline))
nmi_disable(void) {
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
  804210c993:	83 c8 80             	or     $0xffffff80,%eax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804210c996:	ee                   	out    %al,(%dx)
	outb(CMOS_CMD, reg|CMOS_NMI_LOCK);
  804210c997:	83 cf 80             	or     $0xffffff80,%edi
  804210c99a:	89 f8                	mov    %edi,%eax
  804210c99c:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  804210c99d:	ba 71 00 00 00       	mov    $0x71,%edx
  804210c9a2:	ec                   	in     (%dx),%al
  804210c9a3:	89 c6                	mov    %eax,%esi
  804210c9a5:	89 ca                	mov    %ecx,%edx
  804210c9a7:	ec                   	in     (%dx),%al
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804210c9a8:	83 e0 7f             	and    $0x7f,%eax
  804210c9ab:	ee                   	out    %al,(%dx)
}
  804210c9ac:	89 f0                	mov    %esi,%eax
  804210c9ae:	c3                   	ret

000000804210c9af <cmos_write8>:
cmos_write8(uint8_t reg, uint8_t value) {
  804210c9af:	f3 0f 1e fa          	endbr64
    asm volatile("inb %w1,%0"
  804210c9b3:	b9 70 00 00 00       	mov    $0x70,%ecx
  804210c9b8:	89 ca                	mov    %ecx,%edx
  804210c9ba:	ec                   	in     (%dx),%al
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
  804210c9bb:	83 c8 80             	or     $0xffffff80,%eax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804210c9be:	ee                   	out    %al,(%dx)
  804210c9bf:	89 f8                	mov    %edi,%eax
  804210c9c1:	ee                   	out    %al,(%dx)
  804210c9c2:	ba 71 00 00 00       	mov    $0x71,%edx
  804210c9c7:	89 f0                	mov    %esi,%eax
  804210c9c9:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  804210c9ca:	89 ca                	mov    %ecx,%edx
  804210c9cc:	ec                   	in     (%dx),%al
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804210c9cd:	83 e0 7f             	and    $0x7f,%eax
  804210c9d0:	ee                   	out    %al,(%dx)
}
  804210c9d1:	c3                   	ret

000000804210c9d2 <rtc_timer_init>:
    int res = get_time();
    return res;
}

void
rtc_timer_init(void) {
  804210c9d2:	f3 0f 1e fa          	endbr64
  804210c9d6:	55                   	push   %rbp
  804210c9d7:	48 89 e5             	mov    %rsp,%rbp
  804210c9da:	41 54                	push   %r12
  804210c9dc:	53                   	push   %rbx
    // LAB 4: Your code here
    // (use cmos_read8()/cmos_write8())
	uint8_t b = cmos_read8(RTC_BREG);
  804210c9dd:	bf 0b 00 00 00       	mov    $0xb,%edi
  804210c9e2:	49 bc 87 c9 10 42 80 	movabs $0x804210c987,%r12
  804210c9e9:	00 00 00 
  804210c9ec:	41 ff d4             	call   *%r12
	b |= RTC_PIE;
  804210c9ef:	83 c8 40             	or     $0x40,%eax
	cmos_write8(RTC_BREG, b);
  804210c9f2:	0f b6 f0             	movzbl %al,%esi
  804210c9f5:	bf 0b 00 00 00       	mov    $0xb,%edi
  804210c9fa:	48 bb af c9 10 42 80 	movabs $0x804210c9af,%rbx
  804210ca01:	00 00 00 
  804210ca04:	ff d3                	call   *%rbx
	uint8_t a = cmos_read8(RTC_AREG);
  804210ca06:	bf 0a 00 00 00       	mov    $0xa,%edi
  804210ca0b:	41 ff d4             	call   *%r12
	a |= 0x0F;
  804210ca0e:	83 c8 0f             	or     $0xf,%eax
	cmos_write8(RTC_AREG, a);
  804210ca11:	0f b6 f0             	movzbl %al,%esi
  804210ca14:	bf 0a 00 00 00       	mov    $0xa,%edi
  804210ca19:	ff d3                	call   *%rbx
}
  804210ca1b:	5b                   	pop    %rbx
  804210ca1c:	41 5c                	pop    %r12
  804210ca1e:	5d                   	pop    %rbp
  804210ca1f:	c3                   	ret

000000804210ca20 <cmos_read16>:
cmos_read16(uint8_t reg) {
  804210ca20:	f3 0f 1e fa          	endbr64
  804210ca24:	55                   	push   %rbp
  804210ca25:	48 89 e5             	mov    %rsp,%rbp
  804210ca28:	41 55                	push   %r13
  804210ca2a:	41 54                	push   %r12
  804210ca2c:	53                   	push   %rbx
  804210ca2d:	48 83 ec 08          	sub    $0x8,%rsp
  804210ca31:	89 fb                	mov    %edi,%ebx
    return cmos_read8(reg) | (cmos_read8(reg + 1) << 8);
  804210ca33:	40 0f b6 ff          	movzbl %dil,%edi
  804210ca37:	49 bd 87 c9 10 42 80 	movabs $0x804210c987,%r13
  804210ca3e:	00 00 00 
  804210ca41:	41 ff d5             	call   *%r13
  804210ca44:	41 89 c4             	mov    %eax,%r12d
  804210ca47:	8d 7b 01             	lea    0x1(%rbx),%edi
  804210ca4a:	40 0f b6 ff          	movzbl %dil,%edi
  804210ca4e:	41 ff d5             	call   *%r13
  804210ca51:	c1 e0 08             	shl    $0x8,%eax
  804210ca54:	45 0f b6 e4          	movzbl %r12b,%r12d
  804210ca58:	44 09 e0             	or     %r12d,%eax
}
  804210ca5b:	48 83 c4 08          	add    $0x8,%rsp
  804210ca5f:	5b                   	pop    %rbx
  804210ca60:	41 5c                	pop    %r12
  804210ca62:	41 5d                	pop    %r13
  804210ca64:	5d                   	pop    %rbp
  804210ca65:	c3                   	ret

000000804210ca66 <gettime>:
gettime(void) {
  804210ca66:	f3 0f 1e fa          	endbr64
  804210ca6a:	55                   	push   %rbp
  804210ca6b:	48 89 e5             	mov    %rsp,%rbp
  804210ca6e:	41 57                	push   %r15
  804210ca70:	41 56                	push   %r14
  804210ca72:	41 55                	push   %r13
  804210ca74:	41 54                	push   %r12
  804210ca76:	53                   	push   %rbx
  804210ca77:	48 83 ec 58          	sub    $0x58,%rsp
    s = cmos_read8(RTC_SEC);
  804210ca7b:	bf 00 00 00 00       	mov    $0x0,%edi
  804210ca80:	49 bd 87 c9 10 42 80 	movabs $0x804210c987,%r13
  804210ca87:	00 00 00 
  804210ca8a:	41 ff d5             	call   *%r13
  804210ca8d:	41 89 c6             	mov    %eax,%r14d
    m = cmos_read8(RTC_MIN);
  804210ca90:	bf 02 00 00 00       	mov    $0x2,%edi
  804210ca95:	41 ff d5             	call   *%r13
  804210ca98:	41 89 c4             	mov    %eax,%r12d
    h = cmos_read8(RTC_HOUR);
  804210ca9b:	bf 04 00 00 00       	mov    $0x4,%edi
  804210caa0:	41 ff d5             	call   *%r13
  804210caa3:	89 c3                	mov    %eax,%ebx
    d = cmos_read8(RTC_DAY);
  804210caa5:	bf 07 00 00 00       	mov    $0x7,%edi
  804210caaa:	41 ff d5             	call   *%r13
  804210caad:	41 89 c7             	mov    %eax,%r15d
    M = cmos_read8(RTC_MON);
  804210cab0:	bf 08 00 00 00       	mov    $0x8,%edi
  804210cab5:	41 ff d5             	call   *%r13
  804210cab8:	88 45 8f             	mov    %al,-0x71(%rbp)
    y = cmos_read8(RTC_YEAR);
  804210cabb:	bf 09 00 00 00       	mov    $0x9,%edi
  804210cac0:	41 ff d5             	call   *%r13
  804210cac3:	88 45 8e             	mov    %al,-0x72(%rbp)
    Y = cmos_read8(RTC_YEAR_HIGH);
  804210cac6:	bf 32 00 00 00       	mov    $0x32,%edi
  804210cacb:	41 ff d5             	call   *%r13
  804210cace:	88 45 8d             	mov    %al,-0x73(%rbp)
    state = cmos_read8(RTC_BREG);
  804210cad1:	bf 0b 00 00 00       	mov    $0xb,%edi
  804210cad6:	41 ff d5             	call   *%r13
    if (state & RTC_12H) {
  804210cad9:	a8 02                	test   $0x2,%al
  804210cadb:	74 0d                	je     804210caea <gettime+0x84>
        h = (h & 0x7F) + 12 * !!(h & 0x80);
  804210cadd:	89 da                	mov    %ebx,%edx
  804210cadf:	83 e2 7f             	and    $0x7f,%edx
  804210cae2:	c0 fb 07             	sar    $0x7,%bl
  804210cae5:	83 e3 0c             	and    $0xc,%ebx
  804210cae8:	01 d3                	add    %edx,%ebx
    if (!(state & RTC_BINARY)) {
  804210caea:	a8 04                	test   $0x4,%al
  804210caec:	0f 85 86 00 00 00    	jne    804210cb78 <gettime+0x112>
        s = BCD2BIN(s);
  804210caf2:	44 89 f0             	mov    %r14d,%eax
  804210caf5:	c0 e8 04             	shr    $0x4,%al
  804210caf8:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804210cafb:	41 83 e6 0f          	and    $0xf,%r14d
  804210caff:	45 8d 34 46          	lea    (%r14,%rax,2),%r14d
        m = BCD2BIN(m);
  804210cb03:	44 89 e0             	mov    %r12d,%eax
  804210cb06:	c0 e8 04             	shr    $0x4,%al
  804210cb09:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804210cb0c:	41 83 e4 0f          	and    $0xf,%r12d
  804210cb10:	45 8d 24 44          	lea    (%r12,%rax,2),%r12d
        h = BCD2BIN(h);
  804210cb14:	89 d8                	mov    %ebx,%eax
  804210cb16:	c0 e8 04             	shr    $0x4,%al
  804210cb19:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804210cb1c:	83 e3 0f             	and    $0xf,%ebx
  804210cb1f:	8d 1c 43             	lea    (%rbx,%rax,2),%ebx
        d = BCD2BIN(d);
  804210cb22:	44 89 f8             	mov    %r15d,%eax
  804210cb25:	c0 e8 04             	shr    $0x4,%al
  804210cb28:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804210cb2b:	41 83 e7 0f          	and    $0xf,%r15d
  804210cb2f:	45 8d 3c 47          	lea    (%r15,%rax,2),%r15d
        M = BCD2BIN(M);
  804210cb33:	0f b6 4d 8f          	movzbl -0x71(%rbp),%ecx
  804210cb37:	89 c8                	mov    %ecx,%eax
  804210cb39:	c0 e8 04             	shr    $0x4,%al
  804210cb3c:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804210cb3f:	89 ca                	mov    %ecx,%edx
  804210cb41:	83 e2 0f             	and    $0xf,%edx
  804210cb44:	8d 04 42             	lea    (%rdx,%rax,2),%eax
  804210cb47:	88 45 8f             	mov    %al,-0x71(%rbp)
        y = BCD2BIN(y);
  804210cb4a:	0f b6 4d 8e          	movzbl -0x72(%rbp),%ecx
  804210cb4e:	89 c8                	mov    %ecx,%eax
  804210cb50:	c0 e8 04             	shr    $0x4,%al
  804210cb53:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804210cb56:	89 ca                	mov    %ecx,%edx
  804210cb58:	83 e2 0f             	and    $0xf,%edx
  804210cb5b:	8d 04 42             	lea    (%rdx,%rax,2),%eax
  804210cb5e:	88 45 8e             	mov    %al,-0x72(%rbp)
        Y = BCD2BIN(Y);
  804210cb61:	0f b6 4d 8d          	movzbl -0x73(%rbp),%ecx
  804210cb65:	89 c8                	mov    %ecx,%eax
  804210cb67:	c0 e8 04             	shr    $0x4,%al
  804210cb6a:	8d 04 80             	lea    (%rax,%rax,4),%eax
  804210cb6d:	89 ca                	mov    %ecx,%edx
  804210cb6f:	83 e2 0f             	and    $0xf,%edx
  804210cb72:	8d 04 42             	lea    (%rdx,%rax,2),%eax
  804210cb75:	88 45 8d             	mov    %al,-0x73(%rbp)
    time.tm_sec = s;
  804210cb78:	45 0f b6 f6          	movzbl %r14b,%r14d
    time.tm_min = m;
  804210cb7c:	45 0f b6 e4          	movzbl %r12b,%r12d
    time.tm_hour = h;
  804210cb80:	0f b6 db             	movzbl %bl,%ebx
    time.tm_mday = d;
  804210cb83:	45 0f b6 ff          	movzbl %r15b,%r15d
    time.tm_mon = M - 1;
  804210cb87:	0f b6 4d 8f          	movzbl -0x71(%rbp),%ecx
  804210cb8b:	83 e9 01             	sub    $0x1,%ecx
    time.tm_year = y + Y * 100 - 1900;
  804210cb8e:	0f b6 45 8d          	movzbl -0x73(%rbp),%eax
  804210cb92:	6b c0 64             	imul   $0x64,%eax,%eax
  804210cb95:	0f b6 55 8e          	movzbl -0x72(%rbp),%edx
  804210cb99:	01 d0                	add    %edx,%eax
                                    212, 243, 273, 304, 334, 365}[m] + \
                      (ISLEAP(y) && (m) > 1))

inline static int
timestamp(struct tm *time) {
    return DAY * (Y2DAYS(time->tm_year + 1900) - Y2DAYS(1970) +
  804210cb9b:	69 f8 6d 01 00 00    	imul   $0x16d,%eax,%edi
  804210cba1:	8d 50 02             	lea    0x2(%rax),%edx
  804210cba4:	89 c6                	mov    %eax,%esi
  804210cba6:	83 ee 01             	sub    $0x1,%esi
  804210cba9:	0f 49 d6             	cmovns %esi,%edx
  804210cbac:	c1 fa 02             	sar    $0x2,%edx
  804210cbaf:	01 d7                	add    %edx,%edi
  804210cbb1:	48 63 d6             	movslq %esi,%rdx
  804210cbb4:	48 69 d2 1f 85 eb 51 	imul   $0x51eb851f,%rdx,%rdx
  804210cbbb:	49 89 d2             	mov    %rdx,%r10
  804210cbbe:	49 c1 fa 25          	sar    $0x25,%r10
  804210cbc2:	c1 fe 1f             	sar    $0x1f,%esi
  804210cbc5:	41 89 f0             	mov    %esi,%r8d
  804210cbc8:	45 29 d0             	sub    %r10d,%r8d
  804210cbcb:	44 01 c7             	add    %r8d,%edi
  804210cbce:	48 c1 fa 27          	sar    $0x27,%rdx
  804210cbd2:	29 f2                	sub    %esi,%edx
  804210cbd4:	8d bc 17 59 05 f5 ff 	lea    -0xafaa7(%rdi,%rdx,1),%edi
                  M2DAYS(time->tm_mon, time->tm_year + 1900) + time->tm_mday - 1) +
  804210cbdb:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%rbp)
  804210cbe2:	c7 45 a0 1f 00 00 00 	movl   $0x1f,-0x60(%rbp)
  804210cbe9:	c7 45 a4 3b 00 00 00 	movl   $0x3b,-0x5c(%rbp)
  804210cbf0:	c7 45 a8 5a 00 00 00 	movl   $0x5a,-0x58(%rbp)
  804210cbf7:	c7 45 ac 78 00 00 00 	movl   $0x78,-0x54(%rbp)
  804210cbfe:	c7 45 b0 97 00 00 00 	movl   $0x97,-0x50(%rbp)
  804210cc05:	c7 45 b4 b5 00 00 00 	movl   $0xb5,-0x4c(%rbp)
  804210cc0c:	c7 45 b8 d4 00 00 00 	movl   $0xd4,-0x48(%rbp)
  804210cc13:	c7 45 bc f3 00 00 00 	movl   $0xf3,-0x44(%rbp)
  804210cc1a:	c7 45 c0 11 01 00 00 	movl   $0x111,-0x40(%rbp)
  804210cc21:	c7 45 c4 30 01 00 00 	movl   $0x130,-0x3c(%rbp)
  804210cc28:	c7 45 c8 4e 01 00 00 	movl   $0x14e,-0x38(%rbp)
  804210cc2f:	c7 45 cc 6d 01 00 00 	movl   $0x16d,-0x34(%rbp)
  804210cc36:	48 63 d1             	movslq %ecx,%rdx
  804210cc39:	8b 74 95 9c          	mov    -0x64(%rbp,%rdx,4),%esi
  804210cc3d:	48 63 d0             	movslq %eax,%rdx
  804210cc40:	48 69 d2 1f 85 eb 51 	imul   $0x51eb851f,%rdx,%rdx
  804210cc47:	48 c1 fa 27          	sar    $0x27,%rdx
  804210cc4b:	69 d2 90 01 00 00    	imul   $0x190,%edx,%edx
  804210cc51:	39 d0                	cmp    %edx,%eax
  804210cc53:	74 22                	je     804210cc77 <gettime+0x211>
  804210cc55:	ba 00 00 00 00       	mov    $0x0,%edx
  804210cc5a:	a8 03                	test   $0x3,%al
  804210cc5c:	75 22                	jne    804210cc80 <gettime+0x21a>
  804210cc5e:	48 63 d0             	movslq %eax,%rdx
  804210cc61:	48 69 d2 1f 85 eb 51 	imul   $0x51eb851f,%rdx,%rdx
  804210cc68:	48 c1 fa 25          	sar    $0x25,%rdx
  804210cc6c:	44 6b c2 64          	imul   $0x64,%edx,%r8d
  804210cc70:	44 29 c0             	sub    %r8d,%eax
  804210cc73:	89 c2                	mov    %eax,%edx
  804210cc75:	74 09                	je     804210cc80 <gettime+0x21a>
  804210cc77:	83 f9 01             	cmp    $0x1,%ecx
  804210cc7a:	0f 9f c2             	setg   %dl
  804210cc7d:	0f b6 d2             	movzbl %dl,%edx
  804210cc80:	8d 04 16             	lea    (%rsi,%rdx,1),%eax
    return DAY * (Y2DAYS(time->tm_year + 1900) - Y2DAYS(1970) +
  804210cc83:	01 f8                	add    %edi,%eax
                  M2DAYS(time->tm_mon, time->tm_year + 1900) + time->tm_mday - 1) +
  804210cc85:	41 8d 44 07 ff       	lea    -0x1(%r15,%rax,1),%eax
    return DAY * (Y2DAYS(time->tm_year + 1900) - Y2DAYS(1970) +
  804210cc8a:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
           time->tm_hour * HOUR + time->tm_min * MINUTE + time->tm_sec;
  804210cc90:	69 db 10 0e 00 00    	imul   $0xe10,%ebx,%ebx
                  M2DAYS(time->tm_mon, time->tm_year + 1900) + time->tm_mday - 1) +
  804210cc96:	01 d8                	add    %ebx,%eax
           time->tm_hour * HOUR + time->tm_min * MINUTE + time->tm_sec;
  804210cc98:	45 6b e4 3c          	imul   $0x3c,%r12d,%r12d
  804210cc9c:	44 01 e0             	add    %r12d,%eax
  804210cc9f:	44 01 f0             	add    %r14d,%eax
}
  804210cca2:	48 83 c4 58          	add    $0x58,%rsp
  804210cca6:	5b                   	pop    %rbx
  804210cca7:	41 5c                	pop    %r12
  804210cca9:	41 5d                	pop    %r13
  804210ccab:	41 5e                	pop    %r14
  804210ccad:	41 5f                	pop    %r15
  804210ccaf:	5d                   	pop    %rbp
  804210ccb0:	c3                   	ret

000000804210ccb1 <rtc_check_status>:

uint8_t
rtc_check_status(void) {
  804210ccb1:	f3 0f 1e fa          	endbr64
  804210ccb5:	55                   	push   %rbp
  804210ccb6:	48 89 e5             	mov    %rsp,%rbp
    // LAB 4: Your code here
    // (use cmos_read8())
    return cmos_read8(RTC_CREG);
  804210ccb9:	bf 0c 00 00 00       	mov    $0xc,%edi
  804210ccbe:	48 b8 87 c9 10 42 80 	movabs $0x804210c987,%rax
  804210ccc5:	00 00 00 
  804210ccc8:	ff d0                	call   *%rax
}
  804210ccca:	5d                   	pop    %rbp
  804210cccb:	c3                   	ret

000000804210cccc <rtc_timer_pic_handle>:
rtc_timer_pic_handle(void) {
  804210cccc:	f3 0f 1e fa          	endbr64
  804210ccd0:	55                   	push   %rbp
  804210ccd1:	48 89 e5             	mov    %rsp,%rbp
    rtc_check_status();
  804210ccd4:	48 b8 b1 cc 10 42 80 	movabs $0x804210ccb1,%rax
  804210ccdb:	00 00 00 
  804210ccde:	ff d0                	call   *%rax
    pic_send_eoi(IRQ_CLOCK);
  804210cce0:	bf 08 00 00 00       	mov    $0x8,%edi
  804210cce5:	48 b8 f2 ce 10 42 80 	movabs $0x804210cef2,%rax
  804210ccec:	00 00 00 
  804210ccef:	ff d0                	call   *%rax
}
  804210ccf1:	5d                   	pop    %rbp
  804210ccf2:	c3                   	ret

000000804210ccf3 <print_irq_mask>:
    outb(IO_PIC1_DATA, (uint8_t)mask);
    outb(IO_PIC2_DATA, (uint8_t)(mask >> 8));
}

static void
print_irq_mask(uint16_t mask) {
  804210ccf3:	f3 0f 1e fa          	endbr64
  804210ccf7:	55                   	push   %rbp
  804210ccf8:	48 89 e5             	mov    %rsp,%rbp
  804210ccfb:	41 56                	push   %r14
  804210ccfd:	41 55                	push   %r13
  804210ccff:	41 54                	push   %r12
  804210cd01:	53                   	push   %rbx
  804210cd02:	41 89 fc             	mov    %edi,%r12d
    cprintf("enabled interrupts:");
  804210cd05:	48 bf 59 fa 11 42 80 	movabs $0x804211fa59,%rdi
  804210cd0c:	00 00 00 
  804210cd0f:	b8 00 00 00 00       	mov    $0x0,%eax
  804210cd14:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210cd1b:	00 00 00 
  804210cd1e:	ff d2                	call   *%rdx
    for (int i = 0; i < 16; i++) {
  804210cd20:	bb 00 00 00 00       	mov    $0x0,%ebx
        if (~mask & (1 << i))
  804210cd25:	45 0f b7 e4          	movzwl %r12w,%r12d
  804210cd29:	41 f7 d4             	not    %r12d
            cprintf(" %d", i);
  804210cd2c:	49 be 82 02 12 42 80 	movabs $0x8042120282,%r14
  804210cd33:	00 00 00 
  804210cd36:	49 bd 70 cf 10 42 80 	movabs $0x804210cf70,%r13
  804210cd3d:	00 00 00 
  804210cd40:	eb 08                	jmp    804210cd4a <print_irq_mask+0x57>
    for (int i = 0; i < 16; i++) {
  804210cd42:	83 c3 01             	add    $0x1,%ebx
  804210cd45:	83 fb 10             	cmp    $0x10,%ebx
  804210cd48:	74 15                	je     804210cd5f <print_irq_mask+0x6c>
        if (~mask & (1 << i))
  804210cd4a:	41 0f a3 dc          	bt     %ebx,%r12d
  804210cd4e:	73 f2                	jae    804210cd42 <print_irq_mask+0x4f>
            cprintf(" %d", i);
  804210cd50:	89 de                	mov    %ebx,%esi
  804210cd52:	4c 89 f7             	mov    %r14,%rdi
  804210cd55:	b8 00 00 00 00       	mov    $0x0,%eax
  804210cd5a:	41 ff d5             	call   *%r13
  804210cd5d:	eb e3                	jmp    804210cd42 <print_irq_mask+0x4f>
    }
    cprintf("\n");
  804210cd5f:	48 bf 8a f4 11 42 80 	movabs $0x804211f48a,%rdi
  804210cd66:	00 00 00 
  804210cd69:	b8 00 00 00 00       	mov    $0x0,%eax
  804210cd6e:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210cd75:	00 00 00 
  804210cd78:	ff d2                	call   *%rdx
}
  804210cd7a:	5b                   	pop    %rbx
  804210cd7b:	41 5c                	pop    %r12
  804210cd7d:	41 5d                	pop    %r13
  804210cd7f:	41 5e                	pop    %r14
  804210cd81:	5d                   	pop    %rbp
  804210cd82:	c3                   	ret

000000804210cd83 <pic_init>:


/* Initialize the 8259A interrupt controllers. */
void
pic_init(void) {
  804210cd83:	f3 0f 1e fa          	endbr64
  804210cd87:	55                   	push   %rbp
  804210cd88:	48 89 e5             	mov    %rsp,%rbp
  804210cd8b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804210cd90:	be 21 00 00 00       	mov    $0x21,%esi
  804210cd95:	89 f2                	mov    %esi,%edx
  804210cd97:	ee                   	out    %al,(%dx)
  804210cd98:	b9 a1 00 00 00       	mov    $0xa1,%ecx
  804210cd9d:	89 ca                	mov    %ecx,%edx
  804210cd9f:	ee                   	out    %al,(%dx)
  804210cda0:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  804210cda6:	bf 20 00 00 00       	mov    $0x20,%edi
  804210cdab:	44 89 c8             	mov    %r9d,%eax
  804210cdae:	89 fa                	mov    %edi,%edx
  804210cdb0:	ee                   	out    %al,(%dx)
  804210cdb1:	b8 20 00 00 00       	mov    $0x20,%eax
  804210cdb6:	89 f2                	mov    %esi,%edx
  804210cdb8:	ee                   	out    %al,(%dx)
  804210cdb9:	b8 04 00 00 00       	mov    $0x4,%eax
  804210cdbe:	ee                   	out    %al,(%dx)
  804210cdbf:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  804210cdc5:	44 89 c0             	mov    %r8d,%eax
  804210cdc8:	ee                   	out    %al,(%dx)
  804210cdc9:	be a0 00 00 00       	mov    $0xa0,%esi
  804210cdce:	44 89 c8             	mov    %r9d,%eax
  804210cdd1:	89 f2                	mov    %esi,%edx
  804210cdd3:	ee                   	out    %al,(%dx)
  804210cdd4:	b8 28 00 00 00       	mov    $0x28,%eax
  804210cdd9:	89 ca                	mov    %ecx,%edx
  804210cddb:	ee                   	out    %al,(%dx)
  804210cddc:	b8 02 00 00 00       	mov    $0x2,%eax
  804210cde1:	ee                   	out    %al,(%dx)
  804210cde2:	44 89 c0             	mov    %r8d,%eax
  804210cde5:	ee                   	out    %al,(%dx)
  804210cde6:	41 b8 68 00 00 00    	mov    $0x68,%r8d
  804210cdec:	44 89 c0             	mov    %r8d,%eax
  804210cdef:	89 fa                	mov    %edi,%edx
  804210cdf1:	ee                   	out    %al,(%dx)
  804210cdf2:	b9 0a 00 00 00       	mov    $0xa,%ecx
  804210cdf7:	89 c8                	mov    %ecx,%eax
  804210cdf9:	ee                   	out    %al,(%dx)
  804210cdfa:	44 89 c0             	mov    %r8d,%eax
  804210cdfd:	89 f2                	mov    %esi,%edx
  804210cdff:	ee                   	out    %al,(%dx)
  804210ce00:	89 c8                	mov    %ecx,%eax
  804210ce02:	ee                   	out    %al,(%dx)

    /* OCW3 */
    outb(IO_PIC2_CMND, OCW3 | OCW3_SET);
    outb(IO_PIC2_CMND, OCW3 | OCW3_IRR);

    pic_initilalized = 1;
  804210ce03:	48 b8 80 64 00 43 80 	movabs $0x8043006480,%rax
  804210ce0a:	00 00 00 
  804210ce0d:	c6 00 01             	movb   $0x1,(%rax)

    if (irq_mask_8259A != 0xFFFF)
  804210ce10:	48 b8 48 37 14 42 80 	movabs $0x8042143748,%rax
  804210ce17:	00 00 00 
  804210ce1a:	66 8b 38             	mov    (%rax),%di
  804210ce1d:	66 83 ff ff          	cmp    $0xffff,%di
  804210ce21:	75 11                	jne    804210ce34 <pic_init+0xb1>
        set_irq_mask(irq_mask_8259A);
    print_irq_mask(irq_mask_8259A);
  804210ce23:	0f b7 ff             	movzwl %di,%edi
  804210ce26:	48 b8 f3 cc 10 42 80 	movabs $0x804210ccf3,%rax
  804210ce2d:	00 00 00 
  804210ce30:	ff d0                	call   *%rax
}
  804210ce32:	5d                   	pop    %rbp
  804210ce33:	c3                   	ret
  804210ce34:	ba 21 00 00 00       	mov    $0x21,%edx
  804210ce39:	89 f8                	mov    %edi,%eax
  804210ce3b:	ee                   	out    %al,(%dx)
    outb(IO_PIC2_DATA, (uint8_t)(mask >> 8));
  804210ce3c:	89 f8                	mov    %edi,%eax
  804210ce3e:	66 c1 e8 08          	shr    $0x8,%ax
  804210ce42:	ba a1 00 00 00       	mov    $0xa1,%edx
  804210ce47:	ee                   	out    %al,(%dx)
}
  804210ce48:	eb d9                	jmp    804210ce23 <pic_init+0xa0>

000000804210ce4a <pic_irq_mask>:

void
pic_irq_mask(uint8_t irq) {
  804210ce4a:	f3 0f 1e fa          	endbr64
  804210ce4e:	89 f9                	mov    %edi,%ecx
    irq_mask_8259A |= (1 << irq);
  804210ce50:	48 b8 48 37 14 42 80 	movabs $0x8042143748,%rax
  804210ce57:	00 00 00 
  804210ce5a:	bf 01 00 00 00       	mov    $0x1,%edi
  804210ce5f:	d3 e7                	shl    %cl,%edi
  804210ce61:	66 0b 38             	or     (%rax),%di
  804210ce64:	66 89 38             	mov    %di,(%rax)
    if (pic_initilalized) {
  804210ce67:	48 b8 80 64 00 43 80 	movabs $0x8043006480,%rax
  804210ce6e:	00 00 00 
  804210ce71:	80 38 00             	cmpb   $0x0,(%rax)
  804210ce74:	75 01                	jne    804210ce77 <pic_irq_mask+0x2d>
  804210ce76:	c3                   	ret
pic_irq_mask(uint8_t irq) {
  804210ce77:	55                   	push   %rbp
  804210ce78:	48 89 e5             	mov    %rsp,%rbp
  804210ce7b:	ba 21 00 00 00       	mov    $0x21,%edx
  804210ce80:	89 f8                	mov    %edi,%eax
  804210ce82:	ee                   	out    %al,(%dx)
    outb(IO_PIC2_DATA, (uint8_t)(mask >> 8));
  804210ce83:	89 f8                	mov    %edi,%eax
  804210ce85:	66 c1 e8 08          	shr    $0x8,%ax
  804210ce89:	ba a1 00 00 00       	mov    $0xa1,%edx
  804210ce8e:	ee                   	out    %al,(%dx)
        set_irq_mask(irq_mask_8259A);
  804210ce8f:	0f b7 ff             	movzwl %di,%edi
        print_irq_mask(irq_mask_8259A);
  804210ce92:	48 b8 f3 cc 10 42 80 	movabs $0x804210ccf3,%rax
  804210ce99:	00 00 00 
  804210ce9c:	ff d0                	call   *%rax
    }
}
  804210ce9e:	5d                   	pop    %rbp
  804210ce9f:	c3                   	ret

000000804210cea0 <pic_irq_unmask>:

void
pic_irq_unmask(uint8_t irq) {
  804210cea0:	f3 0f 1e fa          	endbr64
  804210cea4:	89 fa                	mov    %edi,%edx
    irq_mask_8259A &= ~(1 << irq);
  804210cea6:	48 b8 48 37 14 42 80 	movabs $0x8042143748,%rax
  804210cead:	00 00 00 
  804210ceb0:	0f b7 38             	movzwl (%rax),%edi
  804210ceb3:	0f b3 d7             	btr    %edx,%edi
  804210ceb6:	66 89 38             	mov    %di,(%rax)
    if (pic_initilalized) {
  804210ceb9:	48 b8 80 64 00 43 80 	movabs $0x8043006480,%rax
  804210cec0:	00 00 00 
  804210cec3:	80 38 00             	cmpb   $0x0,(%rax)
  804210cec6:	75 01                	jne    804210cec9 <pic_irq_unmask+0x29>
  804210cec8:	c3                   	ret
pic_irq_unmask(uint8_t irq) {
  804210cec9:	55                   	push   %rbp
  804210ceca:	48 89 e5             	mov    %rsp,%rbp
  804210cecd:	ba 21 00 00 00       	mov    $0x21,%edx
  804210ced2:	89 f8                	mov    %edi,%eax
  804210ced4:	ee                   	out    %al,(%dx)
    outb(IO_PIC2_DATA, (uint8_t)(mask >> 8));
  804210ced5:	89 f8                	mov    %edi,%eax
  804210ced7:	66 c1 e8 08          	shr    $0x8,%ax
  804210cedb:	ba a1 00 00 00       	mov    $0xa1,%edx
  804210cee0:	ee                   	out    %al,(%dx)
        set_irq_mask(irq_mask_8259A);
  804210cee1:	0f b7 ff             	movzwl %di,%edi
        print_irq_mask(irq_mask_8259A);
  804210cee4:	48 b8 f3 cc 10 42 80 	movabs $0x804210ccf3,%rax
  804210ceeb:	00 00 00 
  804210ceee:	ff d0                	call   *%rax
    }
}
  804210cef0:	5d                   	pop    %rbp
  804210cef1:	c3                   	ret

000000804210cef2 <pic_send_eoi>:

void
pic_send_eoi(uint8_t irq) {
  804210cef2:	f3 0f 1e fa          	endbr64
    if (irq > 7) outb(IO_PIC2_CMND, PIC_EOI);
  804210cef6:	40 80 ff 07          	cmp    $0x7,%dil
  804210cefa:	76 0b                	jbe    804210cf07 <pic_send_eoi+0x15>
  804210cefc:	b8 20 00 00 00       	mov    $0x20,%eax
  804210cf01:	ba a0 00 00 00       	mov    $0xa0,%edx
  804210cf06:	ee                   	out    %al,(%dx)
  804210cf07:	b8 20 00 00 00       	mov    $0x20,%eax
  804210cf0c:	ba 20 00 00 00       	mov    $0x20,%edx
  804210cf11:	ee                   	out    %al,(%dx)
    outb(IO_PIC1_CMND, PIC_EOI);
}
  804210cf12:	c3                   	ret

000000804210cf13 <putch>:
#include <inc/types.h>
#include <inc/stdio.h>
#include <inc/stdarg.h>

static void
putch(int ch, int *cnt) {
  804210cf13:	f3 0f 1e fa          	endbr64
  804210cf17:	55                   	push   %rbp
  804210cf18:	48 89 e5             	mov    %rsp,%rbp
  804210cf1b:	53                   	push   %rbx
  804210cf1c:	48 83 ec 08          	sub    $0x8,%rsp
  804210cf20:	48 89 f3             	mov    %rsi,%rbx
    cputchar(ch);
  804210cf23:	48 b8 b0 0c 10 42 80 	movabs $0x8042100cb0,%rax
  804210cf2a:	00 00 00 
  804210cf2d:	ff d0                	call   *%rax
    (*cnt)++;
  804210cf2f:	83 03 01             	addl   $0x1,(%rbx)
}
  804210cf32:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  804210cf36:	c9                   	leave
  804210cf37:	c3                   	ret

000000804210cf38 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap) {
  804210cf38:	f3 0f 1e fa          	endbr64
  804210cf3c:	55                   	push   %rbp
  804210cf3d:	48 89 e5             	mov    %rsp,%rbp
  804210cf40:	48 83 ec 10          	sub    $0x10,%rsp
  804210cf44:	48 89 fa             	mov    %rdi,%rdx
  804210cf47:	48 89 f1             	mov    %rsi,%rcx
    int count = 0;
  804210cf4a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    vprintfmt((void *)putch, &count, fmt, ap);
  804210cf51:	48 8d 75 fc          	lea    -0x4(%rbp),%rsi
  804210cf55:	48 bf 13 cf 10 42 80 	movabs $0x804210cf13,%rdi
  804210cf5c:	00 00 00 
  804210cf5f:	48 b8 aa 01 11 42 80 	movabs $0x80421101aa,%rax
  804210cf66:	00 00 00 
  804210cf69:	ff d0                	call   *%rax

    return count;
}
  804210cf6b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804210cf6e:	c9                   	leave
  804210cf6f:	c3                   	ret

000000804210cf70 <cprintf>:

int
cprintf(const char *fmt, ...) {
  804210cf70:	f3 0f 1e fa          	endbr64
  804210cf74:	55                   	push   %rbp
  804210cf75:	48 89 e5             	mov    %rsp,%rbp
  804210cf78:	48 83 ec 50          	sub    $0x50,%rsp
  804210cf7c:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  804210cf80:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  804210cf84:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  804210cf88:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  804210cf8c:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_list ap;
    va_start(ap, fmt);
  804210cf90:	c7 45 b8 08 00 00 00 	movl   $0x8,-0x48(%rbp)
  804210cf97:	48 8d 45 10          	lea    0x10(%rbp),%rax
  804210cf9b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804210cf9f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  804210cfa3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int res = vcprintf(fmt, ap);
  804210cfa7:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
  804210cfab:	48 b8 38 cf 10 42 80 	movabs $0x804210cf38,%rax
  804210cfb2:	00 00 00 
  804210cfb5:	ff d0                	call   *%rax
    va_end(ap);

    return res;
}
  804210cfb7:	c9                   	leave
  804210cfb8:	c3                   	ret

000000804210cfb9 <trap_init_percpu>:
    trap_init_percpu();
}

/* Initialize and load the per-CPU TSS and IDT */
void
trap_init_percpu(void) {
  804210cfb9:	f3 0f 1e fa          	endbr64
    asm volatile("lgdt (%0)" ::"r"(p));
  804210cfbd:	48 b8 60 37 14 42 80 	movabs $0x8042143760,%rax
  804210cfc4:	00 00 00 
  804210cfc7:	0f 01 10             	lgdt   (%rax)
    /* The kernel never uses GS or FS,
     * so we leave those set to the user data segment
     *
     * For good measure, clear the local descriptor table (LDT),
     * since we don't use it */
    asm volatile(
  804210cfca:	b8 10 00 00 00       	mov    $0x10,%eax
  804210cfcf:	ba 33 00 00 00       	mov    $0x33,%edx
  804210cfd4:	b9 08 00 00 00       	mov    $0x8,%ecx
  804210cfd9:	8e ea                	mov    %edx,%gs
  804210cfdb:	8e e2                	mov    %edx,%fs
  804210cfdd:	8e c0                	mov    %eax,%es
  804210cfdf:	8e d8                	mov    %eax,%ds
  804210cfe1:	8e d0                	mov    %eax,%ss
  804210cfe3:	31 c0                	xor    %eax,%eax
  804210cfe5:	0f 00 d0             	lldt   %eax
  804210cfe8:	51                   	push   %rcx
  804210cfe9:	48 b8 f6 cf 10 42 80 	movabs $0x804210cff6,%rax
  804210cff0:	00 00 00 
  804210cff3:	50                   	push   %rax
  804210cff4:	48 cb                	lretq
            "d"(GD_UD | 3), "c"(GD_KT)
            : "cc", "memory");

    /* Setup a TSS so that we get the right stack
     * when we trap to the kernel. */
    ts.ts_rsp0 = KERN_STACK_TOP;
  804210cff6:	48 ba e0 74 00 43 80 	movabs $0x80430074e0,%rdx
  804210cffd:	00 00 00 
  804210d000:	48 b8 00 00 00 40 80 	movabs $0x8040000000,%rax
  804210d007:	00 00 00 
  804210d00a:	48 89 42 04          	mov    %rax,0x4(%rdx)
    ts.ts_ist1 = KERN_PF_STACK_TOP;
  804210d00e:	48 8d 80 00 80 fe ff 	lea    -0x18000(%rax),%rax
  804210d015:	48 89 42 24          	mov    %rax,0x24(%rdx)

    /* Initialize the TSS slot of the gdt. */
    *(volatile struct Segdesc64 *)(&gdt[(GD_TSS0 >> 3)]) = SEG64_TSS(STS_T64A, ((uint64_t)&ts), sizeof(struct Taskstate), 0);
  804210d019:	be 00 00 00 00       	mov    $0x0,%esi
  804210d01e:	bf 00 00 00 00       	mov    $0x0,%edi
  804210d023:	48 89 f0             	mov    %rsi,%rax
  804210d026:	66 b8 00 00          	mov    $0x0,%ax
  804210d02a:	48 83 c8 68          	or     $0x68,%rax
  804210d02e:	0f b7 ca             	movzwl %dx,%ecx
  804210d031:	48 c1 e1 10          	shl    $0x10,%rcx
  804210d035:	49 b8 ff ff 00 00 ff 	movabs $0xffffffff0000ffff,%r8
  804210d03c:	ff ff ff 
  804210d03f:	4c 21 c0             	and    %r8,%rax
  804210d042:	48 09 c8             	or     %rcx,%rax
  804210d045:	49 89 d0             	mov    %rdx,%r8
  804210d048:	49 c1 e8 10          	shr    $0x10,%r8
  804210d04c:	45 0f b6 c0          	movzbl %r8b,%r8d
  804210d050:	49 c1 e0 20          	shl    $0x20,%r8
  804210d054:	48 b9 ff ff ff ff 00 	movabs $0xffffff00ffffffff,%rcx
  804210d05b:	ff ff ff 
  804210d05e:	48 21 c8             	and    %rcx,%rax
  804210d061:	4c 09 c0             	or     %r8,%rax
  804210d064:	49 b8 ff ff ff ff ff 	movabs $0xfffff0ffffffffff,%r8
  804210d06b:	f0 ff ff 
  804210d06e:	4c 21 c0             	and    %r8,%rax
  804210d071:	49 b8 00 00 00 00 00 	movabs $0x90000000000,%r8
  804210d078:	09 00 00 
  804210d07b:	4c 09 c0             	or     %r8,%rax
  804210d07e:	48 0f ba f0 2c       	btr    $0x2c,%rax
  804210d083:	49 b8 ff ff ff ff ff 	movabs $0xffff9fffffffffff,%r8
  804210d08a:	9f ff ff 
  804210d08d:	4c 21 c0             	and    %r8,%rax
  804210d090:	48 0f ba e8 2f       	bts    $0x2f,%rax
  804210d095:	49 b8 ff ff ff ff ff 	movabs $0xfff0ffffffffffff,%r8
  804210d09c:	ff f0 ff 
  804210d09f:	4c 21 c0             	and    %r8,%rax
  804210d0a2:	48 0f ba f0 34       	btr    $0x34,%rax
  804210d0a7:	49 b8 ff ff ff ff ff 	movabs $0xff9fffffffffffff,%r8
  804210d0ae:	ff 9f ff 
  804210d0b1:	4c 21 c0             	and    %r8,%rax
  804210d0b4:	48 0f ba f0 37       	btr    $0x37,%rax
  804210d0b9:	49 89 d0             	mov    %rdx,%r8
  804210d0bc:	49 c1 e8 18          	shr    $0x18,%r8
  804210d0c0:	49 c1 e0 38          	shl    $0x38,%r8
  804210d0c4:	49 b9 ff ff ff ff ff 	movabs $0xffffffffffffff,%r9
  804210d0cb:	ff ff 00 
  804210d0ce:	4c 21 c8             	and    %r9,%rax
  804210d0d1:	4c 09 c0             	or     %r8,%rax
  804210d0d4:	48 89 c6             	mov    %rax,%rsi
  804210d0d7:	48 89 d0             	mov    %rdx,%rax
  804210d0da:	48 c1 e8 20          	shr    $0x20,%rax
  804210d0de:	48 89 fa             	mov    %rdi,%rdx
  804210d0e1:	49 b8 00 00 00 00 ff 	movabs $0xffffffff00000000,%r8
  804210d0e8:	ff ff ff 
  804210d0eb:	4c 21 c2             	and    %r8,%rdx
  804210d0ee:	48 09 c2             	or     %rax,%rdx
  804210d0f1:	48 21 ca             	and    %rcx,%rdx
  804210d0f4:	48 b8 ff ff ff ff ff 	movabs $0xffff00ffffffffff,%rax
  804210d0fb:	00 ff ff 
  804210d0fe:	48 21 c2             	and    %rax,%rdx
  804210d101:	89 d7                	mov    %edx,%edi
  804210d103:	48 b8 80 37 14 42 80 	movabs $0x8042143780,%rax
  804210d10a:	00 00 00 
  804210d10d:	48 89 70 38          	mov    %rsi,0x38(%rax)
  804210d111:	48 89 78 40          	mov    %rdi,0x40(%rax)
    asm volatile("ltr %0" ::"r"(sel));
  804210d115:	b8 38 00 00 00       	mov    $0x38,%eax
  804210d11a:	0f 00 d8             	ltr    %eax
    asm volatile("lidt (%0)" ::"r"(p));
  804210d11d:	48 b8 c8 37 14 42 80 	movabs $0x80421437c8,%rax
  804210d124:	00 00 00 
  804210d127:	0f 01 18             	lidt   (%rax)
     * bottom three bits are special; we leave them 0) */
    ltr(GD_TSS0);

    /* Load the IDT */
    lidt(&idt_pd);
}
  804210d12a:	c3                   	ret

000000804210d12b <trap_init>:
trap_init(void) {
  804210d12b:	f3 0f 1e fa          	endbr64
  804210d12f:	55                   	push   %rbp
  804210d130:	48 89 e5             	mov    %rsp,%rbp
    SET_GATE(T_DIVIDE, 0, 0);
  804210d133:	48 b8 c0 64 00 43 80 	movabs $0x80430064c0,%rax
  804210d13a:	00 00 00 
  804210d13d:	48 ba 04 e2 10 42 80 	movabs $0x804210e204,%rdx
  804210d144:	00 00 00 
  804210d147:	66 89 10             	mov    %dx,(%rax)
  804210d14a:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  804210d150:	c6 40 04 00          	movb   $0x0,0x4(%rax)
  804210d154:	c6 40 05 8e          	movb   $0x8e,0x5(%rax)
  804210d158:	48 89 d1             	mov    %rdx,%rcx
  804210d15b:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d15f:	66 89 48 06          	mov    %cx,0x6(%rax)
  804210d163:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d167:	89 50 08             	mov    %edx,0x8(%rax)
  804210d16a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    SET_GATE(T_DEBUG, 0, 0);
  804210d171:	48 ba 0a e2 10 42 80 	movabs $0x804210e20a,%rdx
  804210d178:	00 00 00 
  804210d17b:	66 89 50 10          	mov    %dx,0x10(%rax)
  804210d17f:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  804210d185:	c6 40 14 00          	movb   $0x0,0x14(%rax)
  804210d189:	c6 40 15 8e          	movb   $0x8e,0x15(%rax)
  804210d18d:	48 89 d1             	mov    %rdx,%rcx
  804210d190:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d194:	66 89 48 16          	mov    %cx,0x16(%rax)
  804210d198:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d19c:	89 50 18             	mov    %edx,0x18(%rax)
  804210d19f:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
    SET_GATE(T_NMI, 0, 0);
  804210d1a6:	48 ba 10 e2 10 42 80 	movabs $0x804210e210,%rdx
  804210d1ad:	00 00 00 
  804210d1b0:	66 89 50 20          	mov    %dx,0x20(%rax)
  804210d1b4:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  804210d1ba:	c6 40 24 00          	movb   $0x0,0x24(%rax)
  804210d1be:	c6 40 25 8e          	movb   $0x8e,0x25(%rax)
  804210d1c2:	48 89 d1             	mov    %rdx,%rcx
  804210d1c5:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d1c9:	66 89 48 26          	mov    %cx,0x26(%rax)
  804210d1cd:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d1d1:	89 50 28             	mov    %edx,0x28(%rax)
  804210d1d4:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
    SET_GATE(T_BRKPT, 0, 3);
  804210d1db:	48 ba 16 e2 10 42 80 	movabs $0x804210e216,%rdx
  804210d1e2:	00 00 00 
  804210d1e5:	66 89 50 30          	mov    %dx,0x30(%rax)
  804210d1e9:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  804210d1ef:	c6 40 34 00          	movb   $0x0,0x34(%rax)
  804210d1f3:	c6 40 35 ee          	movb   $0xee,0x35(%rax)
  804210d1f7:	48 89 d1             	mov    %rdx,%rcx
  804210d1fa:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d1fe:	66 89 48 36          	mov    %cx,0x36(%rax)
  804210d202:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d206:	89 50 38             	mov    %edx,0x38(%rax)
  804210d209:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
    SET_GATE(T_OFLOW, 0, 0);
  804210d210:	48 ba 20 e2 10 42 80 	movabs $0x804210e220,%rdx
  804210d217:	00 00 00 
  804210d21a:	66 89 50 40          	mov    %dx,0x40(%rax)
  804210d21e:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  804210d224:	c6 40 44 00          	movb   $0x0,0x44(%rax)
  804210d228:	c6 40 45 8e          	movb   $0x8e,0x45(%rax)
  804210d22c:	48 89 d1             	mov    %rdx,%rcx
  804210d22f:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d233:	66 89 48 46          	mov    %cx,0x46(%rax)
  804210d237:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d23b:	89 50 48             	mov    %edx,0x48(%rax)
  804210d23e:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
    SET_GATE(T_BOUND, 0, 0);
  804210d245:	48 ba 2a e2 10 42 80 	movabs $0x804210e22a,%rdx
  804210d24c:	00 00 00 
  804210d24f:	66 89 50 50          	mov    %dx,0x50(%rax)
  804210d253:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  804210d259:	c6 40 54 00          	movb   $0x0,0x54(%rax)
  804210d25d:	c6 40 55 8e          	movb   $0x8e,0x55(%rax)
  804210d261:	48 89 d1             	mov    %rdx,%rcx
  804210d264:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d268:	66 89 48 56          	mov    %cx,0x56(%rax)
  804210d26c:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d270:	89 50 58             	mov    %edx,0x58(%rax)
  804210d273:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
    SET_GATE(T_ILLOP, 0, 0);
  804210d27a:	48 ba 34 e2 10 42 80 	movabs $0x804210e234,%rdx
  804210d281:	00 00 00 
  804210d284:	66 89 50 60          	mov    %dx,0x60(%rax)
  804210d288:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  804210d28e:	c6 40 64 00          	movb   $0x0,0x64(%rax)
  804210d292:	c6 40 65 8e          	movb   $0x8e,0x65(%rax)
  804210d296:	48 89 d1             	mov    %rdx,%rcx
  804210d299:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d29d:	66 89 48 66          	mov    %cx,0x66(%rax)
  804210d2a1:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d2a5:	89 50 68             	mov    %edx,0x68(%rax)
  804210d2a8:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
    SET_GATE(T_DEVICE, 0, 0);
  804210d2af:	48 ba 3e e2 10 42 80 	movabs $0x804210e23e,%rdx
  804210d2b6:	00 00 00 
  804210d2b9:	66 89 50 70          	mov    %dx,0x70(%rax)
  804210d2bd:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  804210d2c3:	c6 40 74 00          	movb   $0x0,0x74(%rax)
  804210d2c7:	c6 40 75 8e          	movb   $0x8e,0x75(%rax)
  804210d2cb:	48 89 d1             	mov    %rdx,%rcx
  804210d2ce:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d2d2:	66 89 48 76          	mov    %cx,0x76(%rax)
  804210d2d6:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d2da:	89 50 78             	mov    %edx,0x78(%rax)
  804210d2dd:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
    SET_GATE(T_DBLFLT, 0, 0);
  804210d2e4:	48 ba 48 e2 10 42 80 	movabs $0x804210e248,%rdx
  804210d2eb:	00 00 00 
  804210d2ee:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  804210d2f5:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  804210d2fc:	08 00 
  804210d2fe:	c6 80 84 00 00 00 00 	movb   $0x0,0x84(%rax)
  804210d305:	c6 80 85 00 00 00 8e 	movb   $0x8e,0x85(%rax)
  804210d30c:	48 89 d1             	mov    %rdx,%rcx
  804210d30f:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d313:	66 89 88 86 00 00 00 	mov    %cx,0x86(%rax)
  804210d31a:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d31e:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  804210d324:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  804210d32b:	00 00 00 
    SET_GATE(T_TSS, 0, 0);
  804210d32e:	48 ba 50 e2 10 42 80 	movabs $0x804210e250,%rdx
  804210d335:	00 00 00 
  804210d338:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  804210d33f:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  804210d346:	08 00 
  804210d348:	c6 80 a4 00 00 00 00 	movb   $0x0,0xa4(%rax)
  804210d34f:	c6 80 a5 00 00 00 8e 	movb   $0x8e,0xa5(%rax)
  804210d356:	48 89 d1             	mov    %rdx,%rcx
  804210d359:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d35d:	66 89 88 a6 00 00 00 	mov    %cx,0xa6(%rax)
  804210d364:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d368:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  804210d36e:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  804210d375:	00 00 00 
    SET_GATE(T_SEGNP, 0, 0);
  804210d378:	48 ba 58 e2 10 42 80 	movabs $0x804210e258,%rdx
  804210d37f:	00 00 00 
  804210d382:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  804210d389:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  804210d390:	08 00 
  804210d392:	c6 80 b4 00 00 00 00 	movb   $0x0,0xb4(%rax)
  804210d399:	c6 80 b5 00 00 00 8e 	movb   $0x8e,0xb5(%rax)
  804210d3a0:	48 89 d1             	mov    %rdx,%rcx
  804210d3a3:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d3a7:	66 89 88 b6 00 00 00 	mov    %cx,0xb6(%rax)
  804210d3ae:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d3b2:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  804210d3b8:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  804210d3bf:	00 00 00 
    SET_GATE(T_STACK, 0, 0);
  804210d3c2:	48 ba 60 e2 10 42 80 	movabs $0x804210e260,%rdx
  804210d3c9:	00 00 00 
  804210d3cc:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  804210d3d3:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  804210d3da:	08 00 
  804210d3dc:	c6 80 c4 00 00 00 00 	movb   $0x0,0xc4(%rax)
  804210d3e3:	c6 80 c5 00 00 00 8e 	movb   $0x8e,0xc5(%rax)
  804210d3ea:	48 89 d1             	mov    %rdx,%rcx
  804210d3ed:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d3f1:	66 89 88 c6 00 00 00 	mov    %cx,0xc6(%rax)
  804210d3f8:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d3fc:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  804210d402:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  804210d409:	00 00 00 
    SET_GATE(T_GPFLT, 0, 0);
  804210d40c:	48 ba 68 e2 10 42 80 	movabs $0x804210e268,%rdx
  804210d413:	00 00 00 
  804210d416:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  804210d41d:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  804210d424:	08 00 
  804210d426:	c6 80 d4 00 00 00 00 	movb   $0x0,0xd4(%rax)
  804210d42d:	c6 80 d5 00 00 00 8e 	movb   $0x8e,0xd5(%rax)
  804210d434:	48 89 d1             	mov    %rdx,%rcx
  804210d437:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d43b:	66 89 88 d6 00 00 00 	mov    %cx,0xd6(%rax)
  804210d442:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d446:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  804210d44c:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  804210d453:	00 00 00 
    SET_GATE(T_PGFLT, 0, 0);
  804210d456:	48 ba 70 e2 10 42 80 	movabs $0x804210e270,%rdx
  804210d45d:	00 00 00 
  804210d460:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  804210d467:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  804210d46e:	08 00 
  804210d470:	c6 80 e5 00 00 00 8e 	movb   $0x8e,0xe5(%rax)
  804210d477:	48 89 d1             	mov    %rdx,%rcx
  804210d47a:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d47e:	66 89 88 e6 00 00 00 	mov    %cx,0xe6(%rax)
  804210d485:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d489:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  804210d48f:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  804210d496:	00 00 00 
    SET_GATE(T_FPERR, 0, 0);
  804210d499:	48 ba 78 e2 10 42 80 	movabs $0x804210e278,%rdx
  804210d4a0:	00 00 00 
  804210d4a3:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  804210d4aa:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  804210d4b1:	08 00 
  804210d4b3:	c6 80 04 01 00 00 00 	movb   $0x0,0x104(%rax)
  804210d4ba:	c6 80 05 01 00 00 8e 	movb   $0x8e,0x105(%rax)
  804210d4c1:	48 89 d1             	mov    %rdx,%rcx
  804210d4c4:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d4c8:	66 89 88 06 01 00 00 	mov    %cx,0x106(%rax)
  804210d4cf:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d4d3:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  804210d4d9:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  804210d4e0:	00 00 00 
    SET_GATE(T_ALIGN, 0, 0);
  804210d4e3:	48 ba 82 e2 10 42 80 	movabs $0x804210e282,%rdx
  804210d4ea:	00 00 00 
  804210d4ed:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  804210d4f4:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  804210d4fb:	08 00 
  804210d4fd:	c6 80 14 01 00 00 00 	movb   $0x0,0x114(%rax)
  804210d504:	c6 80 15 01 00 00 8e 	movb   $0x8e,0x115(%rax)
  804210d50b:	48 89 d1             	mov    %rdx,%rcx
  804210d50e:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d512:	66 89 88 16 01 00 00 	mov    %cx,0x116(%rax)
  804210d519:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d51d:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  804210d523:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  804210d52a:	00 00 00 
    SET_GATE(T_MCHK, 0, 0);
  804210d52d:	48 ba 8a e2 10 42 80 	movabs $0x804210e28a,%rdx
  804210d534:	00 00 00 
  804210d537:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  804210d53e:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  804210d545:	08 00 
  804210d547:	c6 80 24 01 00 00 00 	movb   $0x0,0x124(%rax)
  804210d54e:	c6 80 25 01 00 00 8e 	movb   $0x8e,0x125(%rax)
  804210d555:	48 89 d1             	mov    %rdx,%rcx
  804210d558:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d55c:	66 89 88 26 01 00 00 	mov    %cx,0x126(%rax)
  804210d563:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d567:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  804210d56d:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  804210d574:	00 00 00 
    SET_GATE(T_SIMDERR, 0, 0);
  804210d577:	48 ba 94 e2 10 42 80 	movabs $0x804210e294,%rdx
  804210d57e:	00 00 00 
  804210d581:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  804210d588:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  804210d58f:	08 00 
  804210d591:	c6 80 34 01 00 00 00 	movb   $0x0,0x134(%rax)
  804210d598:	c6 80 35 01 00 00 8e 	movb   $0x8e,0x135(%rax)
  804210d59f:	48 89 d1             	mov    %rdx,%rcx
  804210d5a2:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d5a6:	66 89 88 36 01 00 00 	mov    %cx,0x136(%rax)
  804210d5ad:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d5b1:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  804210d5b7:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  804210d5be:	00 00 00 
    SET_GATE(32, 0, 0);
  804210d5c1:	48 ba 9e e2 10 42 80 	movabs $0x804210e29e,%rdx
  804210d5c8:	00 00 00 
  804210d5cb:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  804210d5d2:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  804210d5d9:	08 00 
  804210d5db:	c6 80 04 02 00 00 00 	movb   $0x0,0x204(%rax)
  804210d5e2:	c6 80 05 02 00 00 8e 	movb   $0x8e,0x205(%rax)
  804210d5e9:	48 89 d1             	mov    %rdx,%rcx
  804210d5ec:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d5f0:	66 89 88 06 02 00 00 	mov    %cx,0x206(%rax)
  804210d5f7:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d5fb:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  804210d601:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  804210d608:	00 00 00 
    SET_GATE(33, 0, 0);
  804210d60b:	48 ba b2 e2 10 42 80 	movabs $0x804210e2b2,%rdx
  804210d612:	00 00 00 
  804210d615:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  804210d61c:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  804210d623:	08 00 
  804210d625:	c6 80 14 02 00 00 00 	movb   $0x0,0x214(%rax)
  804210d62c:	c6 80 15 02 00 00 8e 	movb   $0x8e,0x215(%rax)
  804210d633:	48 89 d1             	mov    %rdx,%rcx
  804210d636:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d63a:	66 89 88 16 02 00 00 	mov    %cx,0x216(%rax)
  804210d641:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d645:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  804210d64b:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  804210d652:	00 00 00 
    SET_GATE(36, 0, 0);
  804210d655:	48 ba bc e2 10 42 80 	movabs $0x804210e2bc,%rdx
  804210d65c:	00 00 00 
  804210d65f:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  804210d666:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  804210d66d:	08 00 
  804210d66f:	c6 80 44 02 00 00 00 	movb   $0x0,0x244(%rax)
  804210d676:	c6 80 45 02 00 00 8e 	movb   $0x8e,0x245(%rax)
  804210d67d:	48 89 d1             	mov    %rdx,%rcx
  804210d680:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d684:	66 89 88 46 02 00 00 	mov    %cx,0x246(%rax)
  804210d68b:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d68f:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  804210d695:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  804210d69c:	00 00 00 
    SET_GATE(40, 0, 0);
  804210d69f:	48 ba a8 e2 10 42 80 	movabs $0x804210e2a8,%rdx
  804210d6a6:	00 00 00 
  804210d6a9:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  804210d6b0:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  804210d6b7:	08 00 
  804210d6b9:	c6 80 84 02 00 00 00 	movb   $0x0,0x284(%rax)
  804210d6c0:	c6 80 85 02 00 00 8e 	movb   $0x8e,0x285(%rax)
  804210d6c7:	48 89 d1             	mov    %rdx,%rcx
  804210d6ca:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d6ce:	66 89 88 86 02 00 00 	mov    %cx,0x286(%rax)
  804210d6d5:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d6d9:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  804210d6df:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  804210d6e6:	00 00 00 
    SET_GATE(T_SYSCALL, 0, 3);
  804210d6e9:	48 ba c6 e2 10 42 80 	movabs $0x804210e2c6,%rdx
  804210d6f0:	00 00 00 
  804210d6f3:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  804210d6fa:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  804210d701:	08 00 
  804210d703:	c6 80 04 03 00 00 00 	movb   $0x0,0x304(%rax)
  804210d70a:	c6 80 05 03 00 00 ee 	movb   $0xee,0x305(%rax)
  804210d711:	48 89 d1             	mov    %rdx,%rcx
  804210d714:	48 c1 e9 10          	shr    $0x10,%rcx
  804210d718:	66 89 88 06 03 00 00 	mov    %cx,0x306(%rax)
  804210d71f:	48 c1 ea 20          	shr    $0x20,%rdx
  804210d723:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  804210d729:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  804210d730:	00 00 00 
    idt[T_PGFLT].gd_ist = 1;
  804210d733:	c6 80 e4 00 00 00 01 	movb   $0x1,0xe4(%rax)
    trap_init_percpu();
  804210d73a:	48 b8 b9 cf 10 42 80 	movabs $0x804210cfb9,%rax
  804210d741:	00 00 00 
  804210d744:	ff d0                	call   *%rax
}
  804210d746:	5d                   	pop    %rbp
  804210d747:	c3                   	ret

000000804210d748 <print_regs>:
    cprintf("  rsp  0x%08lx\n", (unsigned long)tf->tf_rsp);
    cprintf("  ss   0x----%04x\n", tf->tf_ss);
}

void
print_regs(struct PushRegs *regs) {
  804210d748:	f3 0f 1e fa          	endbr64
  804210d74c:	55                   	push   %rbp
  804210d74d:	48 89 e5             	mov    %rsp,%rbp
  804210d750:	41 54                	push   %r12
  804210d752:	53                   	push   %rbx
  804210d753:	48 89 fb             	mov    %rdi,%rbx
    cprintf("  r15  0x%08lx\n", (unsigned long)regs->reg_r15);
  804210d756:	48 8b 37             	mov    (%rdi),%rsi
  804210d759:	48 bf 6d fa 11 42 80 	movabs $0x804211fa6d,%rdi
  804210d760:	00 00 00 
  804210d763:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d768:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  804210d76f:	00 00 00 
  804210d772:	41 ff d4             	call   *%r12
    cprintf("  r14  0x%08lx\n", (unsigned long)regs->reg_r14);
  804210d775:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  804210d779:	48 bf 7d fa 11 42 80 	movabs $0x804211fa7d,%rdi
  804210d780:	00 00 00 
  804210d783:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d788:	41 ff d4             	call   *%r12
    cprintf("  r13  0x%08lx\n", (unsigned long)regs->reg_r13);
  804210d78b:	48 8b 73 10          	mov    0x10(%rbx),%rsi
  804210d78f:	48 bf 8d fa 11 42 80 	movabs $0x804211fa8d,%rdi
  804210d796:	00 00 00 
  804210d799:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d79e:	41 ff d4             	call   *%r12
    cprintf("  r12  0x%08lx\n", (unsigned long)regs->reg_r12);
  804210d7a1:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  804210d7a5:	48 bf 9d fa 11 42 80 	movabs $0x804211fa9d,%rdi
  804210d7ac:	00 00 00 
  804210d7af:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d7b4:	41 ff d4             	call   *%r12
    cprintf("  r11  0x%08lx\n", (unsigned long)regs->reg_r11);
  804210d7b7:	48 8b 73 20          	mov    0x20(%rbx),%rsi
  804210d7bb:	48 bf ad fa 11 42 80 	movabs $0x804211faad,%rdi
  804210d7c2:	00 00 00 
  804210d7c5:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d7ca:	41 ff d4             	call   *%r12
    cprintf("  r10  0x%08lx\n", (unsigned long)regs->reg_r10);
  804210d7cd:	48 8b 73 28          	mov    0x28(%rbx),%rsi
  804210d7d1:	48 bf bd fa 11 42 80 	movabs $0x804211fabd,%rdi
  804210d7d8:	00 00 00 
  804210d7db:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d7e0:	41 ff d4             	call   *%r12
    cprintf("  r9   0x%08lx\n", (unsigned long)regs->reg_r9);
  804210d7e3:	48 8b 73 30          	mov    0x30(%rbx),%rsi
  804210d7e7:	48 bf cd fa 11 42 80 	movabs $0x804211facd,%rdi
  804210d7ee:	00 00 00 
  804210d7f1:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d7f6:	41 ff d4             	call   *%r12
    cprintf("  r8   0x%08lx\n", (unsigned long)regs->reg_r8);
  804210d7f9:	48 8b 73 38          	mov    0x38(%rbx),%rsi
  804210d7fd:	48 bf dd fa 11 42 80 	movabs $0x804211fadd,%rdi
  804210d804:	00 00 00 
  804210d807:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d80c:	41 ff d4             	call   *%r12
    cprintf("  rdi  0x%08lx\n", (unsigned long)regs->reg_rdi);
  804210d80f:	48 8b 73 48          	mov    0x48(%rbx),%rsi
  804210d813:	48 bf ed fa 11 42 80 	movabs $0x804211faed,%rdi
  804210d81a:	00 00 00 
  804210d81d:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d822:	41 ff d4             	call   *%r12
    cprintf("  rsi  0x%08lx\n", (unsigned long)regs->reg_rsi);
  804210d825:	48 8b 73 40          	mov    0x40(%rbx),%rsi
  804210d829:	48 bf fd fa 11 42 80 	movabs $0x804211fafd,%rdi
  804210d830:	00 00 00 
  804210d833:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d838:	41 ff d4             	call   *%r12
    cprintf("  rbp  0x%08lx\n", (unsigned long)regs->reg_rbp);
  804210d83b:	48 8b 73 50          	mov    0x50(%rbx),%rsi
  804210d83f:	48 bf 0d fb 11 42 80 	movabs $0x804211fb0d,%rdi
  804210d846:	00 00 00 
  804210d849:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d84e:	41 ff d4             	call   *%r12
    cprintf("  rbx  0x%08lx\n", (unsigned long)regs->reg_rbx);
  804210d851:	48 8b 73 68          	mov    0x68(%rbx),%rsi
  804210d855:	48 bf 1d fb 11 42 80 	movabs $0x804211fb1d,%rdi
  804210d85c:	00 00 00 
  804210d85f:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d864:	41 ff d4             	call   *%r12
    cprintf("  rdx  0x%08lx\n", (unsigned long)regs->reg_rdx);
  804210d867:	48 8b 73 58          	mov    0x58(%rbx),%rsi
  804210d86b:	48 bf 2d fb 11 42 80 	movabs $0x804211fb2d,%rdi
  804210d872:	00 00 00 
  804210d875:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d87a:	41 ff d4             	call   *%r12
    cprintf("  rcx  0x%08lx\n", (unsigned long)regs->reg_rcx);
  804210d87d:	48 8b 73 60          	mov    0x60(%rbx),%rsi
  804210d881:	48 bf 3d fb 11 42 80 	movabs $0x804211fb3d,%rdi
  804210d888:	00 00 00 
  804210d88b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d890:	41 ff d4             	call   *%r12
    cprintf("  rax  0x%08lx\n", (unsigned long)regs->reg_rax);
  804210d893:	48 8b 73 70          	mov    0x70(%rbx),%rsi
  804210d897:	48 bf 4d fb 11 42 80 	movabs $0x804211fb4d,%rdi
  804210d89e:	00 00 00 
  804210d8a1:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d8a6:	41 ff d4             	call   *%r12
}
  804210d8a9:	5b                   	pop    %rbx
  804210d8aa:	41 5c                	pop    %r12
  804210d8ac:	5d                   	pop    %rbp
  804210d8ad:	c3                   	ret

000000804210d8ae <print_trapframe>:
print_trapframe(struct Trapframe *tf) {
  804210d8ae:	f3 0f 1e fa          	endbr64
  804210d8b2:	55                   	push   %rbp
  804210d8b3:	48 89 e5             	mov    %rsp,%rbp
  804210d8b6:	41 54                	push   %r12
  804210d8b8:	53                   	push   %rbx
  804210d8b9:	48 89 fb             	mov    %rdi,%rbx
    cprintf("TRAP frame at %p\n", tf);
  804210d8bc:	48 89 fe             	mov    %rdi,%rsi
  804210d8bf:	48 bf ba fb 11 42 80 	movabs $0x804211fbba,%rdi
  804210d8c6:	00 00 00 
  804210d8c9:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d8ce:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  804210d8d5:	00 00 00 
  804210d8d8:	41 ff d4             	call   *%r12
    print_regs(&tf->tf_regs);
  804210d8db:	48 89 df             	mov    %rbx,%rdi
  804210d8de:	48 b8 48 d7 10 42 80 	movabs $0x804210d748,%rax
  804210d8e5:	00 00 00 
  804210d8e8:	ff d0                	call   *%rax
    cprintf("  es   0x----%04x\n", tf->tf_es);
  804210d8ea:	0f b7 73 78          	movzwl 0x78(%rbx),%esi
  804210d8ee:	48 bf cc fb 11 42 80 	movabs $0x804211fbcc,%rdi
  804210d8f5:	00 00 00 
  804210d8f8:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d8fd:	41 ff d4             	call   *%r12
    cprintf("  ds   0x----%04x\n", tf->tf_ds);
  804210d900:	0f b7 b3 80 00 00 00 	movzwl 0x80(%rbx),%esi
  804210d907:	48 bf df fb 11 42 80 	movabs $0x804211fbdf,%rdi
  804210d90e:	00 00 00 
  804210d911:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d916:	41 ff d4             	call   *%r12
    cprintf("  trap 0x%08lx %s\n", (unsigned long)tf->tf_trapno, trapname(tf->tf_trapno));
  804210d919:	48 8b b3 88 00 00 00 	mov    0x88(%rbx),%rsi
    if (trapno < sizeof(excnames) / sizeof(excnames[0])) return excnames[trapno];
  804210d920:	83 fe 13             	cmp    $0x13,%esi
  804210d923:	0f 86 96 01 00 00    	jbe    804210dabf <print_trapframe+0x211>
    if (trapno == T_SYSCALL) return "System call";
  804210d929:	48 ba 5d fb 11 42 80 	movabs $0x804211fb5d,%rdx
  804210d930:	00 00 00 
  804210d933:	83 fe 30             	cmp    $0x30,%esi
  804210d936:	74 1e                	je     804210d956 <print_trapframe+0xa8>
    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) return "Hardware Interrupt";
  804210d938:	8d 46 e0             	lea    -0x20(%rsi),%eax
    return "(unknown trap)";
  804210d93b:	83 f8 10             	cmp    $0x10,%eax
  804210d93e:	48 ba 78 fb 11 42 80 	movabs $0x804211fb78,%rdx
  804210d945:	00 00 00 
  804210d948:	48 b8 69 fb 11 42 80 	movabs $0x804211fb69,%rax
  804210d94f:	00 00 00 
  804210d952:	48 0f 43 d0          	cmovae %rax,%rdx
    cprintf("  trap 0x%08lx %s\n", (unsigned long)tf->tf_trapno, trapname(tf->tf_trapno));
  804210d956:	48 bf f2 fb 11 42 80 	movabs $0x804211fbf2,%rdi
  804210d95d:	00 00 00 
  804210d960:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d965:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  804210d96c:	00 00 00 
  804210d96f:	ff d1                	call   *%rcx
    if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  804210d971:	48 b8 c0 74 00 43 80 	movabs $0x80430074c0,%rax
  804210d978:	00 00 00 
  804210d97b:	48 39 18             	cmp    %rbx,(%rax)
  804210d97e:	0f 84 51 01 00 00    	je     804210dad5 <print_trapframe+0x227>
    cprintf("  err  0x%08lx", (unsigned long)tf->tf_err);
  804210d984:	48 8b b3 90 00 00 00 	mov    0x90(%rbx),%rsi
  804210d98b:	48 bf 15 fc 11 42 80 	movabs $0x804211fc15,%rdi
  804210d992:	00 00 00 
  804210d995:	b8 00 00 00 00       	mov    $0x0,%eax
  804210d99a:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210d9a1:	00 00 00 
  804210d9a4:	ff d2                	call   *%rdx
    if (tf->tf_trapno == T_PGFLT) {
  804210d9a6:	48 83 bb 88 00 00 00 	cmpq   $0xe,0x88(%rbx)
  804210d9ad:	0e 
  804210d9ae:	0f 85 52 01 00 00    	jne    804210db06 <print_trapframe+0x258>
                tf->tf_err & FEC_P ? "protection" : "not-present");
  804210d9b4:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
        cprintf(" [%s, %s, %s]\n",
  804210d9bb:	a8 01                	test   $0x1,%al
  804210d9bd:	48 b9 96 fb 11 42 80 	movabs $0x804211fb96,%rcx
  804210d9c4:	00 00 00 
  804210d9c7:	48 ba 8b fb 11 42 80 	movabs $0x804211fb8b,%rdx
  804210d9ce:	00 00 00 
  804210d9d1:	48 0f 45 ca          	cmovne %rdx,%rcx
  804210d9d5:	48 ba a7 fb 11 42 80 	movabs $0x804211fba7,%rdx
  804210d9dc:	00 00 00 
  804210d9df:	a8 02                	test   $0x2,%al
  804210d9e1:	75 1a                	jne    804210d9fd <print_trapframe+0x14f>
                tf->tf_err & FEC_W ? "write" : tf->tf_err & FEC_I ? "execute" :
  804210d9e3:	a8 10                	test   $0x10,%al
  804210d9e5:	48 ba a2 fb 11 42 80 	movabs $0x804211fba2,%rdx
  804210d9ec:	00 00 00 
  804210d9ef:	48 be ad fb 11 42 80 	movabs $0x804211fbad,%rsi
  804210d9f6:	00 00 00 
  804210d9f9:	48 0f 45 d6          	cmovne %rsi,%rdx
        cprintf(" [%s, %s, %s]\n",
  804210d9fd:	a8 04                	test   $0x4,%al
  804210d9ff:	48 be e8 fc 11 42 80 	movabs $0x804211fce8,%rsi
  804210da06:	00 00 00 
  804210da09:	48 b8 b5 fb 11 42 80 	movabs $0x804211fbb5,%rax
  804210da10:	00 00 00 
  804210da13:	48 0f 45 f0          	cmovne %rax,%rsi
  804210da17:	48 bf 24 fc 11 42 80 	movabs $0x804211fc24,%rdi
  804210da1e:	00 00 00 
  804210da21:	b8 00 00 00 00       	mov    $0x0,%eax
  804210da26:	49 b8 70 cf 10 42 80 	movabs $0x804210cf70,%r8
  804210da2d:	00 00 00 
  804210da30:	41 ff d0             	call   *%r8
    cprintf("  rip  0x%08lx\n", (unsigned long)tf->tf_rip);
  804210da33:	48 8b b3 98 00 00 00 	mov    0x98(%rbx),%rsi
  804210da3a:	48 bf 33 fc 11 42 80 	movabs $0x804211fc33,%rdi
  804210da41:	00 00 00 
  804210da44:	b8 00 00 00 00       	mov    $0x0,%eax
  804210da49:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  804210da50:	00 00 00 
  804210da53:	41 ff d4             	call   *%r12
    cprintf("  cs   0x----%04x\n", tf->tf_cs);
  804210da56:	0f b7 b3 a0 00 00 00 	movzwl 0xa0(%rbx),%esi
  804210da5d:	48 bf 43 fc 11 42 80 	movabs $0x804211fc43,%rdi
  804210da64:	00 00 00 
  804210da67:	b8 00 00 00 00       	mov    $0x0,%eax
  804210da6c:	41 ff d4             	call   *%r12
    cprintf("  flag 0x%08lx\n", (unsigned long)tf->tf_rflags);
  804210da6f:	48 8b b3 a8 00 00 00 	mov    0xa8(%rbx),%rsi
  804210da76:	48 bf 56 fc 11 42 80 	movabs $0x804211fc56,%rdi
  804210da7d:	00 00 00 
  804210da80:	b8 00 00 00 00       	mov    $0x0,%eax
  804210da85:	41 ff d4             	call   *%r12
    cprintf("  rsp  0x%08lx\n", (unsigned long)tf->tf_rsp);
  804210da88:	48 8b b3 b0 00 00 00 	mov    0xb0(%rbx),%rsi
  804210da8f:	48 bf 66 fc 11 42 80 	movabs $0x804211fc66,%rdi
  804210da96:	00 00 00 
  804210da99:	b8 00 00 00 00       	mov    $0x0,%eax
  804210da9e:	41 ff d4             	call   *%r12
    cprintf("  ss   0x----%04x\n", tf->tf_ss);
  804210daa1:	0f b7 b3 b8 00 00 00 	movzwl 0xb8(%rbx),%esi
  804210daa8:	48 bf 76 fc 11 42 80 	movabs $0x804211fc76,%rdi
  804210daaf:	00 00 00 
  804210dab2:	b8 00 00 00 00       	mov    $0x0,%eax
  804210dab7:	41 ff d4             	call   *%r12
}
  804210daba:	5b                   	pop    %rbx
  804210dabb:	41 5c                	pop    %r12
  804210dabd:	5d                   	pop    %rbp
  804210dabe:	c3                   	ret
    if (trapno < sizeof(excnames) / sizeof(excnames[0])) return excnames[trapno];
  804210dabf:	48 63 c6             	movslq %esi,%rax
  804210dac2:	48 ba 80 1d 12 42 80 	movabs $0x8042121d80,%rdx
  804210dac9:	00 00 00 
  804210dacc:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
  804210dad0:	e9 81 fe ff ff       	jmp    804210d956 <print_trapframe+0xa8>
    if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  804210dad5:	48 83 bb 88 00 00 00 	cmpq   $0xe,0x88(%rbx)
  804210dadc:	0e 
  804210dadd:	0f 85 a1 fe ff ff    	jne    804210d984 <print_trapframe+0xd6>
    asm volatile("movq %%cr2,%0"
  804210dae3:	0f 20 d6             	mov    %cr2,%rsi
        cprintf("  cr2  0x%08lx\n", (unsigned long)rcr2());
  804210dae6:	48 bf 05 fc 11 42 80 	movabs $0x804211fc05,%rdi
  804210daed:	00 00 00 
  804210daf0:	b8 00 00 00 00       	mov    $0x0,%eax
  804210daf5:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210dafc:	00 00 00 
  804210daff:	ff d2                	call   *%rdx
  804210db01:	e9 7e fe ff ff       	jmp    804210d984 <print_trapframe+0xd6>
        cprintf("\n");
  804210db06:	48 bf 8a f4 11 42 80 	movabs $0x804211f48a,%rdi
  804210db0d:	00 00 00 
  804210db10:	b8 00 00 00 00       	mov    $0x0,%eax
  804210db15:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210db1c:	00 00 00 
  804210db1f:	ff d2                	call   *%rdx
  804210db21:	e9 0d ff ff ff       	jmp    804210da33 <print_trapframe+0x185>

000000804210db26 <trap>:

/* We do not support recursive page faults in-kernel */
bool in_page_fault;

_Noreturn void
trap(struct Trapframe *tf) {
  804210db26:	f3 0f 1e fa          	endbr64
  804210db2a:	55                   	push   %rbp
  804210db2b:	48 89 e5             	mov    %rsp,%rbp
  804210db2e:	41 56                	push   %r14
  804210db30:	41 55                	push   %r13
  804210db32:	41 54                	push   %r12
  804210db34:	53                   	push   %rbx
  804210db35:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  804210db3c:	48 89 fb             	mov    %rdi,%rbx
    /* The environment may have set DF and some versions
     * of GCC rely on DF being clear */
    asm volatile("cld" ::
  804210db3f:	fc                   	cld
                         : "cc");

    /* Halt the CPU if some other CPU has called panic() */
    extern char *panicstr;
    if (panicstr) asm volatile("hlt");
  804210db40:	48 b8 00 00 a0 42 80 	movabs $0x8042a00000,%rax
  804210db47:	00 00 00 
  804210db4a:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210db4e:	74 01                	je     804210db51 <trap+0x2b>
  804210db50:	f4                   	hlt
    asm volatile("pushfq; popq %0"
  804210db51:	9c                   	pushf
  804210db52:	58                   	pop    %rax

    /* Check that interrupts are disabled.  If this assertion
     * fails, DO NOT be tempted to fix it by inserting a "cli" in
     * the interrupt path */
    assert(!(read_rflags() & FL_IF));
  804210db53:	f6 c4 02             	test   $0x2,%ah
  804210db56:	75 62                	jne    804210dbba <trap+0x94>

    if (trace_traps) cprintf("Incoming TRAP[%ld] frame at %p\n", tf->tf_trapno, tf);
    if (trace_traps_more) print_trapframe(tf);

    /* #PF should be handled separately */
    if (tf->tf_trapno == T_PGFLT) {
  804210db58:	48 83 bb 88 00 00 00 	cmpq   $0xe,0x88(%rbx)
  804210db5f:	0e 
  804210db60:	0f 84 89 00 00 00    	je     804210dbef <trap+0xc9>
            in_page_fault = 0;
            env_pop_tf(tf);
        }
    }

    assert(curenv);
  804210db66:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210db6d:	00 00 00 
  804210db70:	4c 8b 20             	mov    (%rax),%r12
  804210db73:	4d 85 e4             	test   %r12,%r12
  804210db76:	0f 84 ec 02 00 00    	je     804210de68 <trap+0x342>

    /* Copy trap frame (which is currently on the stack)
     * into 'curenv->env_tf', so that running the environment
     * will restart at the trap point */
    curenv->env_tf = *tf;
  804210db7c:	b9 30 00 00 00       	mov    $0x30,%ecx
  804210db81:	4c 89 e7             	mov    %r12,%rdi
  804210db84:	48 89 de             	mov    %rbx,%rsi
  804210db87:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    /* The trapframe on the stack should be ignored from here on */
    tf = &curenv->env_tf;

    /* Record that tf is the last real trapframe so
     * print_trapframe can print some additional information */
    last_tf = tf;
  804210db89:	4c 89 e0             	mov    %r12,%rax
  804210db8c:	48 a3 c0 74 00 43 80 	movabs %rax,0x80430074c0
  804210db93:	00 00 00 
    switch (tf->tf_trapno) {
  804210db96:	49 8b 84 24 88 00 00 	mov    0x88(%r12),%rax
  804210db9d:	00 
  804210db9e:	48 83 e8 03          	sub    $0x3,%rax
  804210dba2:	48 83 f8 2d          	cmp    $0x2d,%rax
  804210dba6:	0f 87 7b 05 00 00    	ja     804210e127 <trap+0x601>
  804210dbac:	48 ba 00 1c 12 42 80 	movabs $0x8042121c00,%rdx
  804210dbb3:	00 00 00 
  804210dbb6:	3e ff 24 c2          	notrack jmp *(%rdx,%rax,8)
    assert(!(read_rflags() & FL_IF));
  804210dbba:	48 b9 89 fc 11 42 80 	movabs $0x804211fc89,%rcx
  804210dbc1:	00 00 00 
  804210dbc4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210dbcb:	00 00 00 
  804210dbce:	be 4d 01 00 00       	mov    $0x14d,%esi
  804210dbd3:	48 bf a2 fc 11 42 80 	movabs $0x804211fca2,%rdi
  804210dbda:	00 00 00 
  804210dbdd:	b8 00 00 00 00       	mov    $0x0,%eax
  804210dbe2:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210dbe9:	00 00 00 
  804210dbec:	41 ff d0             	call   *%r8
        assert(current_space);
  804210dbef:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  804210dbf6:	00 00 00 
  804210dbf9:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210dbfd:	0f 84 a7 01 00 00    	je     804210ddaa <trap+0x284>
        assert(!in_page_fault);
  804210dc03:	48 b8 a0 64 00 43 80 	movabs $0x80430064a0,%rax
  804210dc0a:	00 00 00 
  804210dc0d:	80 38 00             	cmpb   $0x0,(%rax)
  804210dc10:	0f 85 c9 01 00 00    	jne    804210dddf <trap+0x2b9>
        in_page_fault = 1;
  804210dc16:	48 b8 a0 64 00 43 80 	movabs $0x80430064a0,%rax
  804210dc1d:	00 00 00 
  804210dc20:	c6 00 01             	movb   $0x1,(%rax)
    asm volatile("movq %%cr2,%0"
  804210dc23:	41 0f 20 d5          	mov    %cr2,%r13
        if (va & PTE_PWT) {
  804210dc27:	41 f6 c5 08          	test   $0x8,%r13b
  804210dc2b:	0f 84 34 01 00 00    	je     804210dd65 <trap+0x23f>
            struct Page *page_node = page_lookup_virtual(curenv->address_space.root, va, 0, 0);
  804210dc31:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210dc38:	00 00 00 
  804210dc3b:	48 8b b8 f8 00 00 00 	mov    0xf8(%rax),%rdi
  804210dc42:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210dc47:	ba 00 00 00 00       	mov    $0x0,%edx
  804210dc4c:	4c 89 ee             	mov    %r13,%rsi
  804210dc4f:	48 b8 fa 72 10 42 80 	movabs $0x80421072fa,%rax
  804210dc56:	00 00 00 
  804210dc59:	ff d0                	call   *%rax
            int k = (page_node->state & 0xF000) >> 12;
  804210dc5b:	44 8b 60 28          	mov    0x28(%rax),%r12d
  804210dc5f:	44 89 e0             	mov    %r12d,%eax
  804210dc62:	c1 e8 0c             	shr    $0xc,%eax
  804210dc65:	41 89 c6             	mov    %eax,%r14d
  804210dc68:	41 83 e6 0f          	and    $0xf,%r14d
            flags &= ~PTE_PWT;
  804210dc6c:	41 81 e4 f7 0f 00 00 	and    $0xff7,%r12d
  804210dc73:	41 83 cc 01          	or     $0x1,%r12d
            int cur_size = swap_info[k].size;
  804210dc77:	83 e0 0f             	and    $0xf,%eax
  804210dc7a:	48 c1 e0 04          	shl    $0x4,%rax
  804210dc7e:	48 ba 60 10 00 43 80 	movabs $0x8043001060,%rdx
  804210dc85:	00 00 00 
  804210dc88:	48 01 d0             	add    %rdx,%rax
            LZ4_decompress_safe(swap_info[k].buffer, CompressionBuffer, cur_size, PAGE_SIZE);
  804210dc8b:	b9 00 10 00 00       	mov    $0x1000,%ecx
  804210dc90:	8b 50 08             	mov    0x8(%rax),%edx
  804210dc93:	48 be 20 00 00 43 80 	movabs $0x8043000020,%rsi
  804210dc9a:	00 00 00 
  804210dc9d:	48 8b 38             	mov    (%rax),%rdi
  804210dca0:	48 b8 82 ba 11 42 80 	movabs $0x804211ba82,%rax
  804210dca7:	00 00 00 
  804210dcaa:	ff d0                	call   *%rax
            swap_shift(k);
  804210dcac:	44 89 f7             	mov    %r14d,%edi
  804210dcaf:	48 b8 c6 15 11 42 80 	movabs $0x80421115c6,%rax
  804210dcb6:	00 00 00 
  804210dcb9:	ff d0                	call   *%rax
            struct Page *tail = lru_list->tail;
  804210dcbb:	48 a1 08 00 00 43 80 	movabs 0x8043000008,%rax
  804210dcc2:	00 00 00 
            swap_push(tail);
  804210dcc5:	48 8b 78 08          	mov    0x8(%rax),%rdi
  804210dcc9:	48 b8 c3 c1 10 42 80 	movabs $0x804210c1c3,%rax
  804210dcd0:	00 00 00 
  804210dcd3:	ff d0                	call   *%rax
            struct Page *pg = alloc_page(0, flags);
  804210dcd5:	44 89 e6             	mov    %r12d,%esi
  804210dcd8:	bf 00 00 00 00       	mov    $0x0,%edi
  804210dcdd:	48 b8 e0 5e 10 42 80 	movabs $0x8042105ee0,%rax
  804210dce4:	00 00 00 
  804210dce7:	ff d0                	call   *%rax
  804210dce9:	49 89 c6             	mov    %rax,%r14
            if (!pg) {
  804210dcec:	48 85 c0             	test   %rax,%rax
  804210dcef:	0f 84 1f 01 00 00    	je     804210de14 <trap+0x2ee>
            if (map_page(&curenv->address_space, (uintptr_t)va, pg, flags) < 0) {
  804210dcf5:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210dcfc:	00 00 00 
  804210dcff:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804210dd06:	44 89 e1             	mov    %r12d,%ecx
  804210dd09:	4c 89 f2             	mov    %r14,%rdx
  804210dd0c:	4c 89 ee             	mov    %r13,%rsi
  804210dd0f:	48 b8 39 89 10 42 80 	movabs $0x8042108939,%rax
  804210dd16:	00 00 00 
  804210dd19:	ff d0                	call   *%rax
  804210dd1b:	85 c0                	test   %eax,%eax
  804210dd1d:	0f 88 1b 01 00 00    	js     804210de3e <trap+0x318>
  804210dd23:	48 b8 ff ff ff ff ff 	movabs $0xfffffffffffff,%rax
  804210dd2a:	ff 0f 00 
  804210dd2d:	48 89 c7             	mov    %rax,%rdi
  804210dd30:	49 23 7e 38          	and    0x38(%r14),%rdi
  804210dd34:	48 c1 e7 0c          	shl    $0xc,%rdi
  804210dd38:	48 21 c7             	and    %rax,%rdi
            memcpy((char *)page2pa(pg), CompressionBuffer, PAGE_SIZE);
  804210dd3b:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210dd40:	48 be 20 00 00 43 80 	movabs $0x8043000020,%rsi
  804210dd47:	00 00 00 
  804210dd4a:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210dd51:	00 00 00 
  804210dd54:	ff d0                	call   *%rax
            add_to_lru_list(pg);
  804210dd56:	4c 89 f7             	mov    %r14,%rdi
  804210dd59:	48 b8 90 16 11 42 80 	movabs $0x8042111690,%rax
  804210dd60:	00 00 00 
  804210dd63:	ff d0                	call   *%rax
        int res = force_alloc_page(current_space, va, MAX_ALLOCATION_CLASS);
  804210dd65:	ba 09 00 00 00       	mov    $0x9,%edx
  804210dd6a:	4c 89 ee             	mov    %r13,%rsi
  804210dd6d:	48 b8 d0 10 00 43 80 	movabs $0x80430010d0,%rax
  804210dd74:	00 00 00 
  804210dd77:	48 8b 38             	mov    (%rax),%rdi
  804210dd7a:	48 b8 53 b2 10 42 80 	movabs $0x804210b253,%rax
  804210dd81:	00 00 00 
  804210dd84:	ff d0                	call   *%rax
        if (!res) {
  804210dd86:	85 c0                	test   %eax,%eax
  804210dd88:	0f 85 d8 fd ff ff    	jne    804210db66 <trap+0x40>
            in_page_fault = 0;
  804210dd8e:	48 b8 a0 64 00 43 80 	movabs $0x80430064a0,%rax
  804210dd95:	00 00 00 
  804210dd98:	c6 00 00             	movb   $0x0,(%rax)
            env_pop_tf(tf);
  804210dd9b:	48 89 df             	mov    %rbx,%rdi
  804210dd9e:	48 b8 2b c8 10 42 80 	movabs $0x804210c82b,%rax
  804210dda5:	00 00 00 
  804210dda8:	ff d0                	call   *%rax
        assert(current_space);
  804210ddaa:	48 b9 93 f9 11 42 80 	movabs $0x804211f993,%rcx
  804210ddb1:	00 00 00 
  804210ddb4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210ddbb:	00 00 00 
  804210ddbe:	be 54 01 00 00       	mov    $0x154,%esi
  804210ddc3:	48 bf a2 fc 11 42 80 	movabs $0x804211fca2,%rdi
  804210ddca:	00 00 00 
  804210ddcd:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ddd2:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210ddd9:	00 00 00 
  804210dddc:	41 ff d0             	call   *%r8
        assert(!in_page_fault);
  804210dddf:	48 b9 ae fc 11 42 80 	movabs $0x804211fcae,%rcx
  804210dde6:	00 00 00 
  804210dde9:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210ddf0:	00 00 00 
  804210ddf3:	be 55 01 00 00       	mov    $0x155,%esi
  804210ddf8:	48 bf a2 fc 11 42 80 	movabs $0x804211fca2,%rdi
  804210ddff:	00 00 00 
  804210de02:	b8 00 00 00 00       	mov    $0x0,%eax
  804210de07:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210de0e:	00 00 00 
  804210de11:	41 ff d0             	call   *%r8
                    panic("Page allocation failed in page_fault_handler\n");
  804210de14:	48 ba d0 13 12 42 80 	movabs $0x80421213d0,%rdx
  804210de1b:	00 00 00 
  804210de1e:	be 69 01 00 00       	mov    $0x169,%esi
  804210de23:	48 bf a2 fc 11 42 80 	movabs $0x804211fca2,%rdi
  804210de2a:	00 00 00 
  804210de2d:	b8 00 00 00 00       	mov    $0x0,%eax
  804210de32:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210de39:	00 00 00 
  804210de3c:	ff d1                	call   *%rcx
                panic("Failed to map page in page_fault_handler\n");
  804210de3e:	48 ba 00 14 12 42 80 	movabs $0x8042121400,%rdx
  804210de45:	00 00 00 
  804210de48:	be 6c 01 00 00       	mov    $0x16c,%esi
  804210de4d:	48 bf a2 fc 11 42 80 	movabs $0x804211fca2,%rdi
  804210de54:	00 00 00 
  804210de57:	b8 00 00 00 00       	mov    $0x0,%eax
  804210de5c:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210de63:	00 00 00 
  804210de66:	ff d1                	call   *%rcx
    assert(curenv);
  804210de68:	48 b9 bd fc 11 42 80 	movabs $0x804211fcbd,%rcx
  804210de6f:	00 00 00 
  804210de72:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210de79:	00 00 00 
  804210de7c:	be 95 01 00 00       	mov    $0x195,%esi
  804210de81:	48 bf a2 fc 11 42 80 	movabs $0x804211fca2,%rdi
  804210de88:	00 00 00 
  804210de8b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210de90:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210de97:	00 00 00 
  804210de9a:	41 ff d0             	call   *%r8
        tf->tf_regs.reg_rax = syscall(
  804210de9d:	4d 8b 4c 24 40       	mov    0x40(%r12),%r9
  804210dea2:	4d 8b 44 24 48       	mov    0x48(%r12),%r8
  804210dea7:	49 8b 4c 24 68       	mov    0x68(%r12),%rcx
  804210deac:	49 8b 54 24 60       	mov    0x60(%r12),%rdx
  804210deb1:	49 8b 74 24 58       	mov    0x58(%r12),%rsi
  804210deb6:	49 8b 7c 24 70       	mov    0x70(%r12),%rdi
  804210debb:	48 83 ec 08          	sub    $0x8,%rsp
  804210debf:	41 ff 74 24 38       	push   0x38(%r12)
  804210dec4:	48 b8 9f f2 10 42 80 	movabs $0x804210f29f,%rax
  804210decb:	00 00 00 
  804210dece:	ff d0                	call   *%rax
  804210ded0:	49 89 44 24 70       	mov    %rax,0x70(%r12)
        return;
  804210ded5:	48 83 c4 10          	add    $0x10,%rsp
    trap_dispatch(tf);

    /* If we made it to this point, then no other environment was
     * scheduled, so we should return to the current environment
     * if doing so makes sense */
    if (curenv && curenv->env_status == ENV_RUNNING)
  804210ded9:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210dee0:	00 00 00 
  804210dee3:	48 85 c0             	test   %rax,%rax
  804210dee6:	74 0d                	je     804210def5 <trap+0x3cf>
  804210dee8:	83 b8 d4 00 00 00 03 	cmpl   $0x3,0xd4(%rax)
  804210deef:	0f 84 94 02 00 00    	je     804210e189 <trap+0x663>
        env_run(curenv);
    else
        sched_yield();
  804210def5:	48 b8 a6 f1 10 42 80 	movabs $0x804210f1a6,%rax
  804210defc:	00 00 00 
  804210deff:	ff d0                	call   *%rax
  804210df01:	41 0f 20 d5          	mov    %cr2,%r13
page_fault_handler(struct Trapframe *tf) {
    uintptr_t cr2 = rcr2();
    (void)cr2;

    /* Handle kernel-mode page faults. */
    if (!(tf->tf_err & FEC_U)) {
  804210df05:	41 f6 84 24 90 00 00 	testb  $0x4,0x90(%r12)
  804210df0c:	00 04 
  804210df0e:	0f 84 3f 01 00 00    	je     804210e053 <trap+0x52d>
     * causing pagefault during another pagefault */
    // LAB 9: Your code here:
    /* Force allocate exception stack page to prevent memcpy from
     * causing pagefault during another pagefault */
    // LAB 9: Your code here:
    if (!curenv->env_pgfault_upcall) {
  804210df14:	49 83 bc 24 00 01 00 	cmpq   $0x0,0x100(%r12)
  804210df1b:	00 00 
  804210df1d:	0f 84 69 01 00 00    	je     804210e08c <trap+0x566>
        env_destroy(curenv);
    }
    user_mem_assert(curenv, (void *)(USER_EXCEPTION_STACK_TOP - PAGE_SIZE), PAGE_SIZE, PROT_USER_ | PROT_R | PROT_W);
  804210df23:	49 be 70 64 00 43 80 	movabs $0x8043006470,%r14
  804210df2a:	00 00 00 
  804210df2d:	b9 26 00 00 00       	mov    $0x26,%ecx
  804210df32:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210df37:	48 bb 00 f0 ff ff 7f 	movabs $0x7ffffff000,%rbx
  804210df3e:	00 00 00 
  804210df41:	48 89 de             	mov    %rbx,%rsi
  804210df44:	49 8b 3e             	mov    (%r14),%rdi
  804210df47:	48 b8 2a 78 10 42 80 	movabs $0x804210782a,%rax
  804210df4e:	00 00 00 
  804210df51:	ff d0                	call   *%rax
    /* Assert existance of exception stack */
    // LAB 9: Your code here:
    force_alloc_page(&curenv->address_space, USER_EXCEPTION_STACK_TOP - PAGE_SIZE, PAGE_SIZE);
  804210df53:	49 8b 3e             	mov    (%r14),%rdi
  804210df56:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
  804210df5d:	ba 00 10 00 00       	mov    $0x1000,%edx
  804210df62:	48 89 de             	mov    %rbx,%rsi
  804210df65:	48 b8 53 b2 10 42 80 	movabs $0x804210b253,%rax
  804210df6c:	00 00 00 
  804210df6f:	ff d0                	call   *%rax
    /* Build local copy of UTrapframe */
    // LAB 9: Your code here:
    struct UTrapframe utframe;
    utframe.utf_fault_va = cr2;
  804210df71:	4c 89 ad 40 ff ff ff 	mov    %r13,-0xc0(%rbp)
    utframe.utf_err = tf->tf_err;
  804210df78:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
  804210df7f:	00 
  804210df80:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    utframe.utf_regs = tf->tf_regs;
  804210df87:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi
  804210df8e:	b9 1e 00 00 00       	mov    $0x1e,%ecx
  804210df93:	4c 89 e6             	mov    %r12,%rsi
  804210df96:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    utframe.utf_rip = tf->tf_rip;
  804210df98:	49 8b 84 24 98 00 00 	mov    0x98(%r12),%rax
  804210df9f:	00 
  804210dfa0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    utframe.utf_rflags = tf->tf_rflags;
  804210dfa4:	49 8b 84 24 a8 00 00 	mov    0xa8(%r12),%rax
  804210dfab:	00 
  804210dfac:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    utframe.utf_rsp = tf->tf_rsp;
  804210dfb0:	49 8b 84 24 b0 00 00 	mov    0xb0(%r12),%rax
  804210dfb7:	00 
  804210dfb8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* And then copy it userspace (nosan_memcpy()) */
    // LAB 9: Your code here:
    uintptr_t st = USER_EXCEPTION_STACK_TOP;
    if (tf->tf_rsp < USER_EXCEPTION_STACK_TOP && tf->tf_rsp >= USER_EXCEPTION_STACK_TOP - PAGE_SIZE) {
  804210dfbc:	48 89 c2             	mov    %rax,%rdx
  804210dfbf:	48 29 da             	sub    %rbx,%rdx
    uintptr_t st = USER_EXCEPTION_STACK_TOP;
  804210dfc2:	48 8d 9b 00 10 00 00 	lea    0x1000(%rbx),%rbx
    if (tf->tf_rsp < USER_EXCEPTION_STACK_TOP && tf->tf_rsp >= USER_EXCEPTION_STACK_TOP - PAGE_SIZE) {
  804210dfc9:	48 81 fa ff 0f 00 00 	cmp    $0xfff,%rdx
  804210dfd0:	77 04                	ja     804210dfd6 <trap+0x4b0>
        st = tf->tf_rsp;
        st -= 8;
  804210dfd2:	48 8d 58 f8          	lea    -0x8(%rax),%rbx
    }
    st -= sizeof(utframe);
  804210dfd6:	48 81 eb a0 00 00 00 	sub    $0xa0,%rbx
    user_mem_assert(curenv, (void *)st, sizeof(utframe), PROT_USER_ | PROT_R | PROT_W);
  804210dfdd:	49 bd 70 64 00 43 80 	movabs $0x8043006470,%r13
  804210dfe4:	00 00 00 
  804210dfe7:	b9 26 00 00 00       	mov    $0x26,%ecx
  804210dfec:	ba a0 00 00 00       	mov    $0xa0,%edx
  804210dff1:	48 89 de             	mov    %rbx,%rsi
  804210dff4:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  804210dff8:	48 b8 2a 78 10 42 80 	movabs $0x804210782a,%rax
  804210dfff:	00 00 00 
  804210e002:	ff d0                	call   *%rax
    nosan_memcpy((void *)st, (void *)&utframe, sizeof(utframe));
  804210e004:	ba a0 00 00 00       	mov    $0xa0,%edx
  804210e009:	48 8d b5 40 ff ff ff 	lea    -0xc0(%rbp),%rsi
  804210e010:	48 89 df             	mov    %rbx,%rdi
  804210e013:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210e01a:	00 00 00 
  804210e01d:	ff d0                	call   *%rax
    /* Reset in_page_fault flag */
    // LAB 9: Your code here:
	in_page_fault = 0;
  804210e01f:	48 b8 a0 64 00 43 80 	movabs $0x80430064a0,%rax
  804210e026:	00 00 00 
  804210e029:	c6 00 00             	movb   $0x0,(%rax)
    /* Rerun current environment */
    // LAB 9: Your code here:
    tf->tf_rip = (uintptr_t)curenv->env_pgfault_upcall;
  804210e02c:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  804210e030:	48 8b 87 00 01 00 00 	mov    0x100(%rdi),%rax
  804210e037:	49 89 84 24 98 00 00 	mov    %rax,0x98(%r12)
  804210e03e:	00 
    tf->tf_rsp = st;
  804210e03f:	49 89 9c 24 b0 00 00 	mov    %rbx,0xb0(%r12)
  804210e046:	00 
    env_run(curenv);
  804210e047:	48 b8 be c8 10 42 80 	movabs $0x804210c8be,%rax
  804210e04e:	00 00 00 
  804210e051:	ff d0                	call   *%rax
        print_trapframe(tf);
  804210e053:	4c 89 e7             	mov    %r12,%rdi
  804210e056:	48 b8 ae d8 10 42 80 	movabs $0x804210d8ae,%rax
  804210e05d:	00 00 00 
  804210e060:	ff d0                	call   *%rax
        panic("Kernel pagefault\n");
  804210e062:	48 ba c4 fc 11 42 80 	movabs $0x804211fcc4,%rdx
  804210e069:	00 00 00 
  804210e06c:	be b6 01 00 00       	mov    $0x1b6,%esi
  804210e071:	48 bf a2 fc 11 42 80 	movabs $0x804211fca2,%rdi
  804210e078:	00 00 00 
  804210e07b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e080:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210e087:	00 00 00 
  804210e08a:	ff d1                	call   *%rcx
        env_destroy(curenv);
  804210e08c:	4c 89 e7             	mov    %r12,%rdi
  804210e08f:	48 b8 e4 c7 10 42 80 	movabs $0x804210c7e4,%rax
  804210e096:	00 00 00 
  804210e099:	ff d0                	call   *%rax
  804210e09b:	e9 83 fe ff ff       	jmp    804210df23 <trap+0x3fd>
        monitor(tf);
  804210e0a0:	4c 89 e7             	mov    %r12,%rdi
  804210e0a3:	48 b8 4a 46 10 42 80 	movabs $0x804210464a,%rax
  804210e0aa:	00 00 00 
  804210e0ad:	ff d0                	call   *%rax
        return;
  804210e0af:	e9 25 fe ff ff       	jmp    804210ded9 <trap+0x3b3>
        timer_for_schedule->handle_interrupts();
  804210e0b4:	48 a1 60 75 00 43 80 	movabs 0x8043007560,%rax
  804210e0bb:	00 00 00 
  804210e0be:	ff 50 20             	call   *0x20(%rax)
        vsys[VSYS_gettime] = gettime();
  804210e0c1:	48 b8 60 64 00 43 80 	movabs $0x8043006460,%rax
  804210e0c8:	00 00 00 
  804210e0cb:	48 8b 18             	mov    (%rax),%rbx
  804210e0ce:	48 b8 66 ca 10 42 80 	movabs $0x804210ca66,%rax
  804210e0d5:	00 00 00 
  804210e0d8:	ff d0                	call   *%rax
  804210e0da:	89 03                	mov    %eax,(%rbx)
        rtc_check_status();
  804210e0dc:	48 b8 b1 cc 10 42 80 	movabs $0x804210ccb1,%rax
  804210e0e3:	00 00 00 
  804210e0e6:	ff d0                	call   *%rax
		pic_send_eoi(IRQ_CLOCK);
  804210e0e8:	bf 08 00 00 00       	mov    $0x8,%edi
  804210e0ed:	48 b8 f2 ce 10 42 80 	movabs $0x804210cef2,%rax
  804210e0f4:	00 00 00 
  804210e0f7:	ff d0                	call   *%rax
		sched_yield();
  804210e0f9:	48 b8 a6 f1 10 42 80 	movabs $0x804210f1a6,%rax
  804210e100:	00 00 00 
  804210e103:	ff d0                	call   *%rax
        kbd_intr();
  804210e105:	48 b8 65 0b 10 42 80 	movabs $0x8042100b65,%rax
  804210e10c:	00 00 00 
  804210e10f:	ff d0                	call   *%rax
        return;
  804210e111:	e9 c3 fd ff ff       	jmp    804210ded9 <trap+0x3b3>
        serial_intr();
  804210e116:	48 b8 35 0b 10 42 80 	movabs $0x8042100b35,%rax
  804210e11d:	00 00 00 
  804210e120:	ff d0                	call   *%rax
        return;
  804210e122:	e9 b2 fd ff ff       	jmp    804210ded9 <trap+0x3b3>
        print_trapframe(tf);
  804210e127:	4c 89 e7             	mov    %r12,%rdi
  804210e12a:	48 b8 ae d8 10 42 80 	movabs $0x804210d8ae,%rax
  804210e131:	00 00 00 
  804210e134:	ff d0                	call   *%rax
        if (!(tf->tf_cs & 3))
  804210e136:	41 f6 84 24 a0 00 00 	testb  $0x3,0xa0(%r12)
  804210e13d:	00 03 
  804210e13f:	74 1e                	je     804210e15f <trap+0x639>
        env_destroy(curenv);
  804210e141:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210e148:	00 00 00 
  804210e14b:	48 8b 38             	mov    (%rax),%rdi
  804210e14e:	48 b8 e4 c7 10 42 80 	movabs $0x804210c7e4,%rax
  804210e155:	00 00 00 
  804210e158:	ff d0                	call   *%rax
  804210e15a:	e9 7a fd ff ff       	jmp    804210ded9 <trap+0x3b3>
            panic("Unhandled trap in kernel");
  804210e15f:	48 ba d6 fc 11 42 80 	movabs $0x804211fcd6,%rdx
  804210e166:	00 00 00 
  804210e169:	be 37 01 00 00       	mov    $0x137,%esi
  804210e16e:	48 bf a2 fc 11 42 80 	movabs $0x804211fca2,%rdi
  804210e175:	00 00 00 
  804210e178:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e17d:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210e184:	00 00 00 
  804210e187:	ff d1                	call   *%rcx
        env_run(curenv);
  804210e189:	48 89 c7             	mov    %rax,%rdi
  804210e18c:	48 b8 be c8 10 42 80 	movabs $0x804210c8be,%rax
  804210e193:	00 00 00 
  804210e196:	ff d0                	call   *%rax

000000804210e198 <_alltraps>:
_alltraps:
    # LAB 8: Your code here
    # Complete `struct Trapframe' on stack
    # NOTE: Members after tf_paddind4 already on stack.
    #       For struct PushRegs you can use PUSHA macro.
    subq $16,%rsp
  804210e198:	48 83 ec 10          	sub    $0x10,%rsp
    movw %ds,8(%rsp)
  804210e19c:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
    movw %es,(%rsp)
  804210e1a0:	8c 04 24             	mov    %es,(%rsp)
    PUSHA
  804210e1a3:	48 83 ec 78          	sub    $0x78,%rsp
  804210e1a7:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  804210e1ac:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  804210e1b1:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  804210e1b6:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  804210e1bb:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  804210e1c0:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  804210e1c5:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  804210e1ca:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  804210e1cf:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  804210e1d4:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  804210e1d9:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  804210e1de:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  804210e1e3:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  804210e1e8:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  804210e1ed:	4c 89 3c 24          	mov    %r15,(%rsp)
    # LAB 8: Your code here
    # Invoke `trap' with a pointer to struct trap as an argument.
    movl $GD_KD,%eax
  804210e1f1:	b8 10 00 00 00       	mov    $0x10,%eax
    movw %ax,%ds
  804210e1f6:	8e d8                	mov    %eax,%ds
    movw %ax,%es
  804210e1f8:	8e c0                	mov    %eax,%es
    movq %rsp, %rdi
  804210e1fa:	48 89 e7             	mov    %rsp,%rdi
    call trap
  804210e1fd:	e8 24 f9 ff ff       	call   804210db26 <trap>
    jmp .
  804210e202:	eb fe                	jmp    804210e202 <_alltraps+0x6a>

000000804210e204 <handler0>:
# all trap handlers' entry points
# (Look up their list in inc/trap.h)
#define H(N) handler##N
#define TRP(N) TRAPHANDLER(H(N), N)
#define TRPNOEC(N) TRAPHANDLER_NOEC(H(N), N)
TRPNOEC(0) # T_DIVIDE
  804210e204:	6a 00                	push   $0x0
  804210e206:	6a 00                	push   $0x0
  804210e208:	eb 8e                	jmp    804210e198 <_alltraps>

000000804210e20a <handler1>:
TRPNOEC(1) # T_DEBUG
  804210e20a:	6a 00                	push   $0x0
  804210e20c:	6a 01                	push   $0x1
  804210e20e:	eb 88                	jmp    804210e198 <_alltraps>

000000804210e210 <handler2>:
TRPNOEC(2) # T_NMI
  804210e210:	6a 00                	push   $0x0
  804210e212:	6a 02                	push   $0x2
  804210e214:	eb 82                	jmp    804210e198 <_alltraps>

000000804210e216 <handler3>:
TRPNOEC(3) # T_BRKPT
  804210e216:	6a 00                	push   $0x0
  804210e218:	6a 03                	push   $0x3
  804210e21a:	e9 79 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e21f:	90                   	nop

000000804210e220 <handler4>:
TRPNOEC(4) # T_OFLOW
  804210e220:	6a 00                	push   $0x0
  804210e222:	6a 04                	push   $0x4
  804210e224:	e9 6f ff ff ff       	jmp    804210e198 <_alltraps>
  804210e229:	90                   	nop

000000804210e22a <handler5>:
TRPNOEC(5) # T_BOUND
  804210e22a:	6a 00                	push   $0x0
  804210e22c:	6a 05                	push   $0x5
  804210e22e:	e9 65 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e233:	90                   	nop

000000804210e234 <handler6>:
TRPNOEC(6) # T_ILLOP
  804210e234:	6a 00                	push   $0x0
  804210e236:	6a 06                	push   $0x6
  804210e238:	e9 5b ff ff ff       	jmp    804210e198 <_alltraps>
  804210e23d:	90                   	nop

000000804210e23e <handler7>:
TRPNOEC(7) # T_DEVICE
  804210e23e:	6a 00                	push   $0x0
  804210e240:	6a 07                	push   $0x7
  804210e242:	e9 51 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e247:	90                   	nop

000000804210e248 <handler8>:
TRP(8)    # T_DBLFLT
  804210e248:	6a 08                	push   $0x8
  804210e24a:	e9 49 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e24f:	90                   	nop

000000804210e250 <handler10>:
TRP(10)   # T_TSS
  804210e250:	6a 0a                	push   $0xa
  804210e252:	e9 41 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e257:	90                   	nop

000000804210e258 <handler11>:
TRP(11)   # T_SEGNP
  804210e258:	6a 0b                	push   $0xb
  804210e25a:	e9 39 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e25f:	90                   	nop

000000804210e260 <handler12>:
TRP(12)   # T_STACK
  804210e260:	6a 0c                	push   $0xc
  804210e262:	e9 31 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e267:	90                   	nop

000000804210e268 <handler13>:
TRP(13)   # T_GPFLT
  804210e268:	6a 0d                	push   $0xd
  804210e26a:	e9 29 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e26f:	90                   	nop

000000804210e270 <handler14>:
TRP(14)   # T_PGFLT
  804210e270:	6a 0e                	push   $0xe
  804210e272:	e9 21 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e277:	90                   	nop

000000804210e278 <handler16>:
TRPNOEC(16) # T_FPERR
  804210e278:	6a 00                	push   $0x0
  804210e27a:	6a 10                	push   $0x10
  804210e27c:	e9 17 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e281:	90                   	nop

000000804210e282 <handler17>:
TRP(17)    # T_ALIGN
  804210e282:	6a 11                	push   $0x11
  804210e284:	e9 0f ff ff ff       	jmp    804210e198 <_alltraps>
  804210e289:	90                   	nop

000000804210e28a <handler18>:
TRPNOEC(18) # T_MCHK
  804210e28a:	6a 00                	push   $0x0
  804210e28c:	6a 12                	push   $0x12
  804210e28e:	e9 05 ff ff ff       	jmp    804210e198 <_alltraps>
  804210e293:	90                   	nop

000000804210e294 <handler19>:
TRPNOEC(19) # T_SIMDERR
  804210e294:	6a 00                	push   $0x0
  804210e296:	6a 13                	push   $0x13
  804210e298:	e9 fb fe ff ff       	jmp    804210e198 <_alltraps>
  804210e29d:	90                   	nop

000000804210e29e <handler32>:
TRPNOEC(32) # IRQ_OFFSET + IRQ_CLOCK
  804210e29e:	6a 00                	push   $0x0
  804210e2a0:	6a 20                	push   $0x20
  804210e2a2:	e9 f1 fe ff ff       	jmp    804210e198 <_alltraps>
  804210e2a7:	90                   	nop

000000804210e2a8 <handler40>:
TRPNOEC(40) # IRQ_OFFSET + IRQ_TIMER
  804210e2a8:	6a 00                	push   $0x0
  804210e2aa:	6a 28                	push   $0x28
  804210e2ac:	e9 e7 fe ff ff       	jmp    804210e198 <_alltraps>
  804210e2b1:	90                   	nop

000000804210e2b2 <handler33>:
TRPNOEC(33) # IRQ_OFFSET + IRQ_KBD
  804210e2b2:	6a 00                	push   $0x0
  804210e2b4:	6a 21                	push   $0x21
  804210e2b6:	e9 dd fe ff ff       	jmp    804210e198 <_alltraps>
  804210e2bb:	90                   	nop

000000804210e2bc <handler36>:
TRPNOEC(36) # IRQ_OFFSET + IRQ_SERIAL
  804210e2bc:	6a 00                	push   $0x0
  804210e2be:	6a 24                	push   $0x24
  804210e2c0:	e9 d3 fe ff ff       	jmp    804210e198 <_alltraps>
  804210e2c5:	90                   	nop

000000804210e2c6 <handler48>:
TRPNOEC(48) # syscall
  804210e2c6:	6a 00                	push   $0x0
  804210e2c8:	6a 30                	push   $0x30
  804210e2ca:	e9 c9 fe ff ff       	jmp    804210e198 <_alltraps>

000000804210e2cf <acpi_find_table>:
    while ((inw(fadt->PM1aControlBlock) & 1) == 0) /* nothing */
        ;
}

static void *
acpi_find_table(const char *sign) {
  804210e2cf:	f3 0f 1e fa          	endbr64
  804210e2d3:	55                   	push   %rbp
  804210e2d4:	48 89 e5             	mov    %rsp,%rbp
  804210e2d7:	41 57                	push   %r15
  804210e2d9:	41 56                	push   %r14
  804210e2db:	41 55                	push   %r13
  804210e2dd:	41 54                	push   %r12
  804210e2df:	53                   	push   %rbx
  804210e2e0:	48 83 ec 28          	sub    $0x28,%rsp
  804210e2e4:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    static size_t rsdt_len;
    static size_t rsdt_entsz;
    uint64_t rsdt_pa;
    size_t i = 0;
    uint8_t err = 0;
    uint64_t fadt_pa = 0;
  804210e2e8:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  804210e2ef:	00 
    if (!rsdt) {
  804210e2f0:	48 b8 58 76 00 43 80 	movabs $0x8043007658,%rax
  804210e2f7:	00 00 00 
  804210e2fa:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210e2fe:	74 42                	je     804210e342 <acpi_find_table+0x73>
            }
            rsdt_len = (rsdt->h.Length - sizeof(RSDT)) / 8;
        }
    }
    ACPISDTHeader *head = NULL;
    for (i = 0; i < rsdt_len; i++) {
  804210e300:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        memcpy(&fadt_pa, (uint8_t *)rsdt->PointerToOtherSDT + i * rsdt_entsz, rsdt_entsz);
  804210e306:	49 bf 50 76 00 43 80 	movabs $0x8043007650,%r15
  804210e30d:	00 00 00 
  804210e310:	49 bd 58 76 00 43 80 	movabs $0x8043007658,%r13
  804210e317:	00 00 00 
  804210e31a:	49 be 62 0d 11 42 80 	movabs $0x8042110d62,%r14
  804210e321:	00 00 00 
    for (i = 0; i < rsdt_len; i++) {
  804210e324:	48 b8 48 76 00 43 80 	movabs $0x8043007648,%rax
  804210e32b:	00 00 00 
        }
        if (!strncmp(head->Signature, sign, 4)) {
            return head;
        }
    }
    return NULL;
  804210e32e:	bb 00 00 00 00       	mov    $0x0,%ebx
    for (i = 0; i < rsdt_len; i++) {
  804210e333:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210e337:	0f 85 c7 02 00 00    	jne    804210e604 <acpi_find_table+0x335>
  804210e33d:	e9 71 03 00 00       	jmp    804210e6b3 <acpi_find_table+0x3e4>
        if (!uefi_lp->ACPIRoot) {
  804210e342:	48 a1 00 30 14 42 80 	movabs 0x8042143000,%rax
  804210e349:	00 00 00 
  804210e34c:	48 8b 78 10          	mov    0x10(%rax),%rdi
  804210e350:	48 85 ff             	test   %rdi,%rdi
  804210e353:	74 4f                	je     804210e3a4 <acpi_find_table+0xd5>
        RSDP *rsdp = mmio_map_region(uefi_lp->ACPIRoot, sizeof(RSDP));
  804210e355:	be 24 00 00 00       	mov    $0x24,%esi
  804210e35a:	48 b8 0b a0 10 42 80 	movabs $0x804210a00b,%rax
  804210e361:	00 00 00 
  804210e364:	ff d0                	call   *%rax
  804210e366:	48 89 c3             	mov    %rax,%rbx
        if (!rsdp->Revision) {
  804210e369:	0f b6 50 0f          	movzbl 0xf(%rax),%edx
  804210e36d:	84 d2                	test   %dl,%dl
  804210e36f:	74 5d                	je     804210e3ce <acpi_find_table+0xff>
            for (i = 0; i < rsdp->Length; i++) {
  804210e371:	8b 50 14             	mov    0x14(%rax),%edx
  804210e374:	89 d6                	mov    %edx,%esi
  804210e376:	48 01 c6             	add    %rax,%rsi
    uint8_t err = 0;
  804210e379:	b9 00 00 00 00       	mov    $0x0,%ecx
            for (i = 0; i < rsdp->Length; i++) {
  804210e37e:	85 d2                	test   %edx,%edx
  804210e380:	74 17                	je     804210e399 <acpi_find_table+0xca>
                err += ((uint8_t *)rsdp)[i];
  804210e382:	89 ca                	mov    %ecx,%edx
  804210e384:	02 10                	add    (%rax),%dl
  804210e386:	89 d1                	mov    %edx,%ecx
            for (i = 0; i < rsdp->Length; i++) {
  804210e388:	48 83 c0 01          	add    $0x1,%rax
  804210e38c:	48 39 c6             	cmp    %rax,%rsi
  804210e38f:	75 f1                	jne    804210e382 <acpi_find_table+0xb3>
            if (err) {
  804210e391:	84 d2                	test   %dl,%dl
  804210e393:	0f 85 46 01 00 00    	jne    804210e4df <acpi_find_table+0x210>
            rsdt_pa = rsdp->XsdtAddress;
  804210e399:	4c 8b 6b 18          	mov    0x18(%rbx),%r13
  804210e39d:	b8 08 00 00 00       	mov    $0x8,%eax
  804210e3a2:	eb 4a                	jmp    804210e3ee <acpi_find_table+0x11f>
            panic("No rsdp\n");
  804210e3a4:	48 ba 32 fe 11 42 80 	movabs $0x804211fe32,%rdx
  804210e3ab:	00 00 00 
  804210e3ae:	be 66 00 00 00       	mov    $0x66,%esi
  804210e3b3:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210e3ba:	00 00 00 
  804210e3bd:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e3c2:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210e3c9:	00 00 00 
  804210e3cc:	ff d1                	call   *%rcx
  804210e3ce:	48 8d 70 14          	lea    0x14(%rax),%rsi
                err += ((uint8_t *)rsdp)[i];
  804210e3d2:	02 10                	add    (%rax),%dl
            for (i = 0; i < offsetof(RSDP, Length); i++) {
  804210e3d4:	48 83 c0 01          	add    $0x1,%rax
  804210e3d8:	48 39 f0             	cmp    %rsi,%rax
  804210e3db:	75 f5                	jne    804210e3d2 <acpi_find_table+0x103>
            if (err) {
  804210e3dd:	84 d2                	test   %dl,%dl
  804210e3df:	0f 85 d0 00 00 00    	jne    804210e4b5 <acpi_find_table+0x1e6>
            rsdt_pa = rsdp->RsdtAddress;
  804210e3e5:	44 8b 6b 10          	mov    0x10(%rbx),%r13d
            rsdt_entsz = 4;
  804210e3e9:	b8 04 00 00 00       	mov    $0x4,%eax
  804210e3ee:	48 a3 50 76 00 43 80 	movabs %rax,0x8043007650
  804210e3f5:	00 00 00 
        rsdt = mmio_map_region(rsdt_pa, sizeof(RSDT));
  804210e3f8:	be 24 00 00 00       	mov    $0x24,%esi
  804210e3fd:	4c 89 ef             	mov    %r13,%rdi
  804210e400:	48 b8 0b a0 10 42 80 	movabs $0x804210a00b,%rax
  804210e407:	00 00 00 
  804210e40a:	ff d0                	call   *%rax
  804210e40c:	48 89 c6             	mov    %rax,%rsi
  804210e40f:	49 bc 58 76 00 43 80 	movabs $0x8043007658,%r12
  804210e416:	00 00 00 
  804210e419:	49 89 04 24          	mov    %rax,(%r12)
        rsdt = mmio_remap_last_region(rsdt_pa, rsdt, sizeof(RSDP), rsdt->h.Length);
  804210e41d:	8b 48 04             	mov    0x4(%rax),%ecx
  804210e420:	ba 24 00 00 00       	mov    $0x24,%edx
  804210e425:	4c 89 ef             	mov    %r13,%rdi
  804210e428:	48 b8 20 a1 10 42 80 	movabs $0x804210a120,%rax
  804210e42f:	00 00 00 
  804210e432:	ff d0                	call   *%rax
  804210e434:	49 89 04 24          	mov    %rax,(%r12)
        for (i = 0; i < rsdt->h.Length; i++) {
  804210e438:	8b 50 04             	mov    0x4(%rax),%edx
  804210e43b:	89 d7                	mov    %edx,%edi
  804210e43d:	85 d2                	test   %edx,%edx
  804210e43f:	74 20                	je     804210e461 <acpi_find_table+0x192>
  804210e441:	48 89 c2             	mov    %rax,%rdx
  804210e444:	48 01 c7             	add    %rax,%rdi
  804210e447:	be 00 00 00 00       	mov    $0x0,%esi
            err += ((uint8_t *)rsdt)[i];
  804210e44c:	40 02 32             	add    (%rdx),%sil
        for (i = 0; i < rsdt->h.Length; i++) {
  804210e44f:	48 83 c2 01          	add    $0x1,%rdx
  804210e453:	48 39 fa             	cmp    %rdi,%rdx
  804210e456:	75 f4                	jne    804210e44c <acpi_find_table+0x17d>
        if (err) {
  804210e458:	40 84 f6             	test   %sil,%sil
  804210e45b:	0f 85 a8 00 00 00    	jne    804210e509 <acpi_find_table+0x23a>
        if (!rsdp->Revision) {
  804210e461:	80 7b 0f 00          	cmpb   $0x0,0xf(%rbx)
  804210e465:	0f 85 f2 00 00 00    	jne    804210e55d <acpi_find_table+0x28e>
            if (strncmp(rsdt->h.Signature, "RSDT", 4)) {
  804210e46b:	ba 04 00 00 00       	mov    $0x4,%edx
  804210e470:	48 be 56 fe 11 42 80 	movabs $0x804211fe56,%rsi
  804210e477:	00 00 00 
  804210e47a:	48 89 c7             	mov    %rax,%rdi
  804210e47d:	48 b8 b7 0b 11 42 80 	movabs $0x8042110bb7,%rax
  804210e484:	00 00 00 
  804210e487:	ff d0                	call   *%rax
  804210e489:	85 c0                	test   %eax,%eax
  804210e48b:	0f 85 a2 00 00 00    	jne    804210e533 <acpi_find_table+0x264>
            rsdt_len = (rsdt->h.Length - sizeof(RSDT)) / 4;
  804210e491:	48 a1 58 76 00 43 80 	movabs 0x8043007658,%rax
  804210e498:	00 00 00 
  804210e49b:	8b 40 04             	mov    0x4(%rax),%eax
  804210e49e:	48 83 e8 24          	sub    $0x24,%rax
  804210e4a2:	48 c1 e8 02          	shr    $0x2,%rax
  804210e4a6:	48 a3 48 76 00 43 80 	movabs %rax,0x8043007648
  804210e4ad:	00 00 00 
  804210e4b0:	e9 4b fe ff ff       	jmp    804210e300 <acpi_find_table+0x31>
                panic("Invalid RSDP\n");
  804210e4b5:	48 ba 48 fe 11 42 80 	movabs $0x804211fe48,%rdx
  804210e4bc:	00 00 00 
  804210e4bf:	be 6e 00 00 00       	mov    $0x6e,%esi
  804210e4c4:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210e4cb:	00 00 00 
  804210e4ce:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e4d3:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210e4da:	00 00 00 
  804210e4dd:	ff d1                	call   *%rcx
                panic("Invalid RSDP\n");
  804210e4df:	48 ba 48 fe 11 42 80 	movabs $0x804211fe48,%rdx
  804210e4e6:	00 00 00 
  804210e4e9:	be 77 00 00 00       	mov    $0x77,%esi
  804210e4ee:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210e4f5:	00 00 00 
  804210e4f8:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e4fd:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210e504:	00 00 00 
  804210e507:	ff d1                	call   *%rcx
            panic("Invalid RSDP\n");
  804210e509:	48 ba 48 fe 11 42 80 	movabs $0x804211fe48,%rdx
  804210e510:	00 00 00 
  804210e513:	be 82 00 00 00       	mov    $0x82,%esi
  804210e518:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210e51f:	00 00 00 
  804210e522:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e527:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210e52e:	00 00 00 
  804210e531:	ff d1                	call   *%rcx
                panic("Invalid RSDT\n");
  804210e533:	48 ba 5b fe 11 42 80 	movabs $0x804211fe5b,%rdx
  804210e53a:	00 00 00 
  804210e53d:	be 86 00 00 00       	mov    $0x86,%esi
  804210e542:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210e549:	00 00 00 
  804210e54c:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e551:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210e558:	00 00 00 
  804210e55b:	ff d1                	call   *%rcx
            if (strncmp(rsdt->h.Signature, "XSDT", 4)) {
  804210e55d:	ba 04 00 00 00       	mov    $0x4,%edx
  804210e562:	48 be 69 fe 11 42 80 	movabs $0x804211fe69,%rsi
  804210e569:	00 00 00 
  804210e56c:	48 89 c7             	mov    %rax,%rdi
  804210e56f:	48 b8 b7 0b 11 42 80 	movabs $0x8042110bb7,%rax
  804210e576:	00 00 00 
  804210e579:	ff d0                	call   *%rax
  804210e57b:	85 c0                	test   %eax,%eax
  804210e57d:	75 24                	jne    804210e5a3 <acpi_find_table+0x2d4>
            rsdt_len = (rsdt->h.Length - sizeof(RSDT)) / 8;
  804210e57f:	48 a1 58 76 00 43 80 	movabs 0x8043007658,%rax
  804210e586:	00 00 00 
  804210e589:	8b 40 04             	mov    0x4(%rax),%eax
  804210e58c:	48 83 e8 24          	sub    $0x24,%rax
  804210e590:	48 c1 e8 03          	shr    $0x3,%rax
  804210e594:	48 a3 48 76 00 43 80 	movabs %rax,0x8043007648
  804210e59b:	00 00 00 
  804210e59e:	e9 5d fd ff ff       	jmp    804210e300 <acpi_find_table+0x31>
                panic("Invalid RSDT\n");
  804210e5a3:	48 ba 5b fe 11 42 80 	movabs $0x804211fe5b,%rdx
  804210e5aa:	00 00 00 
  804210e5ad:	be 8b 00 00 00       	mov    $0x8b,%esi
  804210e5b2:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210e5b9:	00 00 00 
  804210e5bc:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e5c1:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210e5c8:	00 00 00 
  804210e5cb:	ff d1                	call   *%rcx
        if (!strncmp(head->Signature, sign, 4)) {
  804210e5cd:	ba 04 00 00 00       	mov    $0x4,%edx
  804210e5d2:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804210e5d6:	48 89 df             	mov    %rbx,%rdi
  804210e5d9:	48 b8 b7 0b 11 42 80 	movabs $0x8042110bb7,%rax
  804210e5e0:	00 00 00 
  804210e5e3:	ff d0                	call   *%rax
  804210e5e5:	85 c0                	test   %eax,%eax
  804210e5e7:	0f 84 c6 00 00 00    	je     804210e6b3 <acpi_find_table+0x3e4>
    for (i = 0; i < rsdt_len; i++) {
  804210e5ed:	49 83 c4 01          	add    $0x1,%r12
  804210e5f1:	48 b8 48 76 00 43 80 	movabs $0x8043007648,%rax
  804210e5f8:	00 00 00 
  804210e5fb:	4c 3b 20             	cmp    (%rax),%r12
  804210e5fe:	0f 83 aa 00 00 00    	jae    804210e6ae <acpi_find_table+0x3df>
        memcpy(&fadt_pa, (uint8_t *)rsdt->PointerToOtherSDT + i * rsdt_entsz, rsdt_entsz);
  804210e604:	49 8b 17             	mov    (%r15),%rdx
  804210e607:	49 8b 4d 00          	mov    0x0(%r13),%rcx
  804210e60b:	48 89 d0             	mov    %rdx,%rax
  804210e60e:	49 0f af c4          	imul   %r12,%rax
  804210e612:	48 8d 74 01 24       	lea    0x24(%rcx,%rax,1),%rsi
  804210e617:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210e61b:	41 ff d6             	call   *%r14
        head = mmio_map_region(fadt_pa, sizeof(ACPISDTHeader));
  804210e61e:	be 24 00 00 00       	mov    $0x24,%esi
  804210e623:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210e627:	48 b8 0b a0 10 42 80 	movabs $0x804210a00b,%rax
  804210e62e:	00 00 00 
  804210e631:	ff d0                	call   *%rax
  804210e633:	48 89 c6             	mov    %rax,%rsi
        head = mmio_remap_last_region(fadt_pa, head, sizeof(ACPISDTHeader), rsdt->h.Length);
  804210e636:	49 8b 45 00          	mov    0x0(%r13),%rax
  804210e63a:	8b 48 04             	mov    0x4(%rax),%ecx
  804210e63d:	ba 24 00 00 00       	mov    $0x24,%edx
  804210e642:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210e646:	48 b8 20 a1 10 42 80 	movabs $0x804210a120,%rax
  804210e64d:	00 00 00 
  804210e650:	ff d0                	call   *%rax
  804210e652:	48 89 c3             	mov    %rax,%rbx
        for (size_t i = 0; i < head->Length; i++) {
  804210e655:	8b 40 04             	mov    0x4(%rax),%eax
  804210e658:	89 c6                	mov    %eax,%esi
  804210e65a:	85 c0                	test   %eax,%eax
  804210e65c:	0f 84 6b ff ff ff    	je     804210e5cd <acpi_find_table+0x2fe>
  804210e662:	48 89 d8             	mov    %rbx,%rax
  804210e665:	48 01 de             	add    %rbx,%rsi
  804210e668:	b9 00 00 00 00       	mov    $0x0,%ecx
            err += ((uint8_t *)head)[i];
  804210e66d:	02 08                	add    (%rax),%cl
        for (size_t i = 0; i < head->Length; i++) {
  804210e66f:	48 83 c0 01          	add    $0x1,%rax
  804210e673:	48 39 f0             	cmp    %rsi,%rax
  804210e676:	75 f5                	jne    804210e66d <acpi_find_table+0x39e>
        if (err) {
  804210e678:	84 c9                	test   %cl,%cl
  804210e67a:	0f 84 4d ff ff ff    	je     804210e5cd <acpi_find_table+0x2fe>
            panic("Invalid ACPI table '%.4s'", head->Signature);
  804210e680:	48 89 d9             	mov    %rbx,%rcx
  804210e683:	48 ba 6e fe 11 42 80 	movabs $0x804211fe6e,%rdx
  804210e68a:	00 00 00 
  804210e68d:	be 99 00 00 00       	mov    $0x99,%esi
  804210e692:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210e699:	00 00 00 
  804210e69c:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e6a1:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210e6a8:	00 00 00 
  804210e6ab:	41 ff d0             	call   *%r8
    return NULL;
  804210e6ae:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  804210e6b3:	48 89 d8             	mov    %rbx,%rax
  804210e6b6:	48 83 c4 28          	add    $0x28,%rsp
  804210e6ba:	5b                   	pop    %rbx
  804210e6bb:	41 5c                	pop    %r12
  804210e6bd:	41 5d                	pop    %r13
  804210e6bf:	41 5e                	pop    %r14
  804210e6c1:	41 5f                	pop    %r15
  804210e6c3:	5d                   	pop    %rbp
  804210e6c4:	c3                   	ret

000000804210e6c5 <hpet_handle_interrupts_tim0>:
    hpetReg->TIM1_COMP = hpet_get_main_cnt() + Peta / hpetFemto / 2 * 3;
    hpetReg->TIM1_COMP = Peta / hpetFemto / 2 * 3;
    pic_irq_unmask(IRQ_CLOCK);
}
void
hpet_handle_interrupts_tim0(void) {
  804210e6c5:	f3 0f 1e fa          	endbr64
  804210e6c9:	55                   	push   %rbp
  804210e6ca:	48 89 e5             	mov    %rsp,%rbp
    pic_send_eoi(IRQ_TIMER);
  804210e6cd:	bf 00 00 00 00       	mov    $0x0,%edi
  804210e6d2:	48 b8 f2 ce 10 42 80 	movabs $0x804210cef2,%rax
  804210e6d9:	00 00 00 
  804210e6dc:	ff d0                	call   *%rax
}
  804210e6de:	5d                   	pop    %rbp
  804210e6df:	c3                   	ret

000000804210e6e0 <hpet_handle_interrupts_tim1>:

void
hpet_handle_interrupts_tim1(void) {
  804210e6e0:	f3 0f 1e fa          	endbr64
  804210e6e4:	55                   	push   %rbp
  804210e6e5:	48 89 e5             	mov    %rsp,%rbp
    pic_send_eoi(IRQ_CLOCK);
  804210e6e8:	bf 08 00 00 00       	mov    $0x8,%edi
  804210e6ed:	48 b8 f2 ce 10 42 80 	movabs $0x804210cef2,%rax
  804210e6f4:	00 00 00 
  804210e6f7:	ff d0                	call   *%rax
}
  804210e6f9:	5d                   	pop    %rbp
  804210e6fa:	c3                   	ret

000000804210e6fb <hpet_cpu_frequency>:

/* Calculate CPU frequency in Hz with the help with HPET timer.
 * HINT Use hpet_get_main_cnt function and do not forget about
 * about pause instruction. */
uint64_t
hpet_cpu_frequency(void) {
  804210e6fb:	f3 0f 1e fa          	endbr64
    return hpetReg->MAIN_CNT;
  804210e6ff:	48 b8 78 76 00 43 80 	movabs $0x8043007678,%rax
  804210e706:	00 00 00 
  804210e709:	48 8b 08             	mov    (%rax),%rcx
  804210e70c:	48 8b b1 f0 00 00 00 	mov    0xf0(%rcx),%rsi
    asm volatile("rdtsc"
  804210e713:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804210e715:	48 c1 e2 20          	shl    $0x20,%rdx
  804210e719:	89 c0                	mov    %eax,%eax
  804210e71b:	48 89 d7             	mov    %rdx,%rdi
  804210e71e:	48 09 c7             	or     %rax,%rdi

    // LAB 5: Your code here
    uint64_t first = hpet_get_main_cnt();
    uint64_t first_tsc = read_tsc();
    uint64_t next = first;
    uint64_t eps = hpetFreq / 10;
  804210e721:	48 b8 68 76 00 43 80 	movabs $0x8043007668,%rax
  804210e728:	00 00 00 
  804210e72b:	4c 8b 00             	mov    (%rax),%r8
  804210e72e:	48 ba cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rdx
  804210e735:	cc cc cc 
  804210e738:	4c 89 c0             	mov    %r8,%rax
  804210e73b:	48 f7 e2             	mul    %rdx
  804210e73e:	48 c1 ea 03          	shr    $0x3,%rdx
    while (next - first < eps) {
  804210e742:	49 83 f8 09          	cmp    $0x9,%r8
  804210e746:	76 0f                	jbe    804210e757 <hpet_cpu_frequency+0x5c>
    return hpetReg->MAIN_CNT;
  804210e748:	48 8b 81 f0 00 00 00 	mov    0xf0(%rcx),%rax
    while (next - first < eps) {
  804210e74f:	48 29 f0             	sub    %rsi,%rax
  804210e752:	48 39 d0             	cmp    %rdx,%rax
  804210e755:	72 f1                	jb     804210e748 <hpet_cpu_frequency+0x4d>
    asm volatile("rdtsc"
  804210e757:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804210e759:	48 c1 e2 20          	shl    $0x20,%rdx
  804210e75d:	89 c0                	mov    %eax,%eax
  804210e75f:	48 09 c2             	or     %rax,%rdx
        next = hpet_get_main_cnt();
    }
    uint64_t next_tsc = read_tsc();
    cpu_freq = (next_tsc - first_tsc) * 10;
  804210e762:	48 89 d0             	mov    %rdx,%rax
  804210e765:	48 29 f8             	sub    %rdi,%rax
  804210e768:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  804210e76c:	48 01 c0             	add    %rax,%rax
    return cpu_freq;
}
  804210e76f:	c3                   	ret

000000804210e770 <hpet_enable_interrupts_tim1>:
hpet_enable_interrupts_tim1(void) {
  804210e770:	f3 0f 1e fa          	endbr64
  804210e774:	55                   	push   %rbp
  804210e775:	48 89 e5             	mov    %rsp,%rbp
    hpetReg->GEN_CONF |= HPET_LEG_RT_CNF;
  804210e778:	48 b8 78 76 00 43 80 	movabs $0x8043007678,%rax
  804210e77f:	00 00 00 
  804210e782:	48 8b 08             	mov    (%rax),%rcx
  804210e785:	48 8b 41 10          	mov    0x10(%rcx),%rax
  804210e789:	48 83 c8 02          	or     $0x2,%rax
  804210e78d:	48 89 41 10          	mov    %rax,0x10(%rcx)
    hpetReg->TIM1_CONF = (IRQ_CLOCK << 9);
  804210e791:	48 c7 81 20 01 00 00 	movq   $0x1000,0x120(%rcx)
  804210e798:	00 10 00 00 
    hpetReg->TIM1_CONF |= HPET_TN_TYPE_CNF | HPET_TN_INT_ENB_CNF | HPET_TN_VAL_SET_CNF;
  804210e79c:	48 8b 81 20 01 00 00 	mov    0x120(%rcx),%rax
  804210e7a3:	48 83 c8 4c          	or     $0x4c,%rax
  804210e7a7:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
    return hpetReg->MAIN_CNT;
  804210e7ae:	48 8b b1 f0 00 00 00 	mov    0xf0(%rcx),%rsi
    hpetReg->TIM1_COMP = hpet_get_main_cnt() + Peta / hpetFemto / 2 * 3;
  804210e7b5:	48 bf 70 76 00 43 80 	movabs $0x8043007670,%rdi
  804210e7bc:	00 00 00 
  804210e7bf:	48 b8 00 40 63 52 bf 	movabs $0x1c6bf52634000,%rax
  804210e7c6:	c6 01 00 
  804210e7c9:	ba 00 00 00 00       	mov    $0x0,%edx
  804210e7ce:	48 f7 37             	divq   (%rdi)
  804210e7d1:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
  804210e7d5:	48 01 c6             	add    %rax,%rsi
  804210e7d8:	48 89 b1 28 01 00 00 	mov    %rsi,0x128(%rcx)
    hpetReg->TIM1_COMP = Peta / hpetFemto / 2 * 3;
  804210e7df:	48 89 81 28 01 00 00 	mov    %rax,0x128(%rcx)
    pic_irq_unmask(IRQ_CLOCK);
  804210e7e6:	bf 08 00 00 00       	mov    $0x8,%edi
  804210e7eb:	48 b8 a0 ce 10 42 80 	movabs $0x804210cea0,%rax
  804210e7f2:	00 00 00 
  804210e7f5:	ff d0                	call   *%rax
}
  804210e7f7:	5d                   	pop    %rbp
  804210e7f8:	c3                   	ret

000000804210e7f9 <hpet_enable_interrupts_tim0>:
hpet_enable_interrupts_tim0(void) {
  804210e7f9:	f3 0f 1e fa          	endbr64
  804210e7fd:	55                   	push   %rbp
  804210e7fe:	48 89 e5             	mov    %rsp,%rbp
    hpetReg->GEN_CONF |= HPET_LEG_RT_CNF;
  804210e801:	48 b8 78 76 00 43 80 	movabs $0x8043007678,%rax
  804210e808:	00 00 00 
  804210e80b:	48 8b 08             	mov    (%rax),%rcx
  804210e80e:	48 8b 41 10          	mov    0x10(%rcx),%rax
  804210e812:	48 83 c8 02          	or     $0x2,%rax
  804210e816:	48 89 41 10          	mov    %rax,0x10(%rcx)
    hpetReg->TIM0_CONF = (IRQ_TIMER << 9); 
  804210e81a:	48 c7 81 00 01 00 00 	movq   $0x0,0x100(%rcx)
  804210e821:	00 00 00 00 
    hpetReg->TIM0_CONF |= HPET_TN_TYPE_CNF | HPET_TN_INT_ENB_CNF | HPET_TN_VAL_SET_CNF;
  804210e825:	48 8b 81 00 01 00 00 	mov    0x100(%rcx),%rax
  804210e82c:	48 83 c8 4c          	or     $0x4c,%rax
  804210e830:	48 89 81 00 01 00 00 	mov    %rax,0x100(%rcx)
    return hpetReg->MAIN_CNT;
  804210e837:	48 8b b1 f0 00 00 00 	mov    0xf0(%rcx),%rsi
    hpetReg->TIM0_COMP = hpet_get_main_cnt() + Peta / hpetFemto / 2;
  804210e83e:	48 bf 70 76 00 43 80 	movabs $0x8043007670,%rdi
  804210e845:	00 00 00 
  804210e848:	48 b8 00 40 63 52 bf 	movabs $0x1c6bf52634000,%rax
  804210e84f:	c6 01 00 
  804210e852:	ba 00 00 00 00       	mov    $0x0,%edx
  804210e857:	48 f7 37             	divq   (%rdi)
  804210e85a:	48 01 c6             	add    %rax,%rsi
  804210e85d:	48 89 b1 08 01 00 00 	mov    %rsi,0x108(%rcx)
    hpetReg->TIM0_COMP = Peta / hpetFemto / 2;
  804210e864:	48 89 81 08 01 00 00 	mov    %rax,0x108(%rcx)
    pic_irq_unmask(IRQ_TIMER);
  804210e86b:	bf 00 00 00 00       	mov    $0x0,%edi
  804210e870:	48 b8 a0 ce 10 42 80 	movabs $0x804210cea0,%rax
  804210e877:	00 00 00 
  804210e87a:	ff d0                	call   *%rax
}
  804210e87c:	5d                   	pop    %rbp
  804210e87d:	c3                   	ret

000000804210e87e <get_mcfg>:
get_mcfg(void) {
  804210e87e:	f3 0f 1e fa          	endbr64
    if (!kmcfg) {
  804210e882:	48 b8 60 76 00 43 80 	movabs $0x8043007660,%rax
  804210e889:	00 00 00 
  804210e88c:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210e890:	74 0b                	je     804210e89d <get_mcfg+0x1f>
}
  804210e892:	48 a1 60 76 00 43 80 	movabs 0x8043007660,%rax
  804210e899:	00 00 00 
  804210e89c:	c3                   	ret
get_mcfg(void) {
  804210e89d:	55                   	push   %rbp
  804210e89e:	48 89 e5             	mov    %rsp,%rbp
  804210e8a1:	41 54                	push   %r12
  804210e8a3:	53                   	push   %rbx
        struct AddressSpace *as = switch_address_space(&kspace);
  804210e8a4:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210e8ab:	00 00 00 
  804210e8ae:	49 bc ac 5b 10 42 80 	movabs $0x8042105bac,%r12
  804210e8b5:	00 00 00 
  804210e8b8:	41 ff d4             	call   *%r12
  804210e8bb:	48 89 c3             	mov    %rax,%rbx
        kmcfg = acpi_find_table("MCFG");
  804210e8be:	48 bf 88 fe 11 42 80 	movabs $0x804211fe88,%rdi
  804210e8c5:	00 00 00 
  804210e8c8:	48 b8 cf e2 10 42 80 	movabs $0x804210e2cf,%rax
  804210e8cf:	00 00 00 
  804210e8d2:	ff d0                	call   *%rax
  804210e8d4:	48 a3 60 76 00 43 80 	movabs %rax,0x8043007660
  804210e8db:	00 00 00 
        switch_address_space(as);
  804210e8de:	48 89 df             	mov    %rbx,%rdi
  804210e8e1:	41 ff d4             	call   *%r12
}
  804210e8e4:	48 a1 60 76 00 43 80 	movabs 0x8043007660,%rax
  804210e8eb:	00 00 00 
  804210e8ee:	5b                   	pop    %rbx
  804210e8ef:	41 5c                	pop    %r12
  804210e8f1:	5d                   	pop    %rbp
  804210e8f2:	c3                   	ret

000000804210e8f3 <make_fs_args>:
make_fs_args(char *ustack_top) {
  804210e8f3:	f3 0f 1e fa          	endbr64
  804210e8f7:	55                   	push   %rbp
  804210e8f8:	48 89 e5             	mov    %rsp,%rbp
  804210e8fb:	41 57                	push   %r15
  804210e8fd:	41 56                	push   %r14
  804210e8ff:	41 55                	push   %r13
  804210e901:	41 54                	push   %r12
  804210e903:	53                   	push   %rbx
  804210e904:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp
  804210e90b:	48 89 fb             	mov    %rdi,%rbx
    MCFG *mcfg = get_mcfg();
  804210e90e:	48 b8 7e e8 10 42 80 	movabs $0x804210e87e,%rax
  804210e915:	00 00 00 
  804210e918:	ff d0                	call   *%rax
    if (!mcfg) {
  804210e91a:	48 85 c0             	test   %rax,%rax
  804210e91d:	0f 84 e5 01 00 00    	je     804210eb08 <make_fs_args+0x215>
  804210e923:	49 89 c4             	mov    %rax,%r12
    char *argv[MAX_SEGMENTS + 3] = {0};
  804210e926:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
  804210e92d:	b9 12 00 00 00       	mov    $0x12,%ecx
  804210e932:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e937:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    ustack_top -= 3;
  804210e93a:	48 83 eb 03          	sub    $0x3,%rbx
    argv[0] = ustack_top;
  804210e93e:	48 89 9d 38 ff ff ff 	mov    %rbx,-0xc8(%rbp)
    nosan_memcpy(argv[0], "fs", 3);
  804210e945:	ba 03 00 00 00       	mov    $0x3,%edx
  804210e94a:	48 be a3 fe 11 42 80 	movabs $0x804211fea3,%rsi
  804210e951:	00 00 00 
  804210e954:	48 89 df             	mov    %rbx,%rdi
  804210e957:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210e95e:	00 00 00 
  804210e961:	ff d0                	call   *%rax
    int nent = (mcfg->h.Length - sizeof(MCFG)) / sizeof(CSBAA);
  804210e963:	41 8b 44 24 04       	mov    0x4(%r12),%eax
  804210e968:	48 83 e8 2c          	sub    $0x2c,%rax
  804210e96c:	48 c1 e8 04          	shr    $0x4,%rax
    if (nent > MAX_SEGMENTS)
  804210e970:	41 be 10 00 00 00    	mov    $0x10,%r14d
  804210e976:	44 39 f0             	cmp    %r14d,%eax
  804210e979:	44 0f 4e f0          	cmovle %eax,%r14d
    for (int i = 0; i < nent; i++) {
  804210e97d:	85 c0                	test   %eax,%eax
  804210e97f:	0f 8e 9c 00 00 00    	jle    804210ea21 <make_fs_args+0x12e>
  804210e985:	49 83 c4 2c          	add    $0x2c,%r12
  804210e989:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        snprintf(arg, sizeof(arg) - 1, "ecam=%llx:%04x:%02x:%02x",
  804210e98f:	49 bf 0d 09 11 42 80 	movabs $0x804211090d,%r15
  804210e996:	00 00 00 
  804210e999:	45 0f b6 4c 24 0a    	movzbl 0xa(%r12),%r9d
  804210e99f:	45 0f b7 44 24 08    	movzwl 0x8(%r12),%r8d
  804210e9a5:	49 8b 0c 24          	mov    (%r12),%rcx
  804210e9a9:	48 83 ec 08          	sub    $0x8,%rsp
  804210e9ad:	41 0f b6 44 24 0b    	movzbl 0xb(%r12),%eax
  804210e9b3:	50                   	push   %rax
  804210e9b4:	48 ba a6 fe 11 42 80 	movabs $0x804211fea6,%rdx
  804210e9bb:	00 00 00 
  804210e9be:	be 3f 00 00 00       	mov    $0x3f,%esi
  804210e9c3:	48 8d bd a8 fe ff ff 	lea    -0x158(%rbp),%rdi
  804210e9ca:	b8 00 00 00 00       	mov    $0x0,%eax
  804210e9cf:	41 ff d7             	call   *%r15
        int len = strlen(arg) + 1;
  804210e9d2:	48 8d bd a8 fe ff ff 	lea    -0x158(%rbp),%rdi
  804210e9d9:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  804210e9e0:	00 00 00 
  804210e9e3:	ff d0                	call   *%rax
  804210e9e5:	8d 50 01             	lea    0x1(%rax),%edx
        ustack_top -= len;
  804210e9e8:	48 63 d2             	movslq %edx,%rdx
  804210e9eb:	48 29 d3             	sub    %rdx,%rbx
        nosan_memcpy(ustack_top, arg, len);
  804210e9ee:	48 8d b5 a8 fe ff ff 	lea    -0x158(%rbp),%rsi
  804210e9f5:	48 89 df             	mov    %rbx,%rdi
  804210e9f8:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210e9ff:	00 00 00 
  804210ea02:	ff d0                	call   *%rax
        argv[i + 1] = ustack_top;
  804210ea04:	4a 89 9c ed 40 ff ff 	mov    %rbx,-0xc0(%rbp,%r13,8)
  804210ea0b:	ff 
    for (int i = 0; i < nent; i++) {
  804210ea0c:	49 83 c5 01          	add    $0x1,%r13
  804210ea10:	49 83 c4 10          	add    $0x10,%r12
  804210ea14:	48 83 c4 10          	add    $0x10,%rsp
  804210ea18:	45 39 ee             	cmp    %r13d,%r14d
  804210ea1b:	0f 8f 78 ff ff ff    	jg     804210e999 <make_fs_args+0xa6>
    snprintf(arg, sizeof(arg) - 1, "tscfreq=%llx", (long long)tsc_calibrate());
  804210ea21:	48 b8 3c 0f 11 42 80 	movabs $0x8042110f3c,%rax
  804210ea28:	00 00 00 
  804210ea2b:	ff d0                	call   *%rax
  804210ea2d:	48 89 c1             	mov    %rax,%rcx
  804210ea30:	48 ba bf fe 11 42 80 	movabs $0x804211febf,%rdx
  804210ea37:	00 00 00 
  804210ea3a:	be 3f 00 00 00       	mov    $0x3f,%esi
  804210ea3f:	48 8d bd f8 fe ff ff 	lea    -0x108(%rbp),%rdi
  804210ea46:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ea4b:	49 b8 0d 09 11 42 80 	movabs $0x804211090d,%r8
  804210ea52:	00 00 00 
  804210ea55:	41 ff d0             	call   *%r8
    int len = strlen(arg) + 1;
  804210ea58:	48 8d bd f8 fe ff ff 	lea    -0x108(%rbp),%rdi
  804210ea5f:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  804210ea66:	00 00 00 
  804210ea69:	ff d0                	call   *%rax
  804210ea6b:	8d 50 01             	lea    0x1(%rax),%edx
    ustack_top -= len;
  804210ea6e:	48 63 d2             	movslq %edx,%rdx
  804210ea71:	48 29 d3             	sub    %rdx,%rbx
    nosan_memcpy(ustack_top, arg, len);
  804210ea74:	48 8d b5 f8 fe ff ff 	lea    -0x108(%rbp),%rsi
  804210ea7b:	48 89 df             	mov    %rbx,%rdi
  804210ea7e:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  804210ea85:	00 00 00 
  804210ea88:	41 ff d4             	call   *%r12
    argv[nent + 1] = ustack_top;
  804210ea8b:	41 8d 46 01          	lea    0x1(%r14),%eax
  804210ea8f:	48 98                	cltq
  804210ea91:	48 89 9c c5 38 ff ff 	mov    %rbx,-0xc8(%rbp,%rax,8)
  804210ea98:	ff 
    ustack_top = (char *)((uintptr_t)ustack_top & ~(2 * sizeof(void *) - 1));
  804210ea99:	48 83 e3 f0          	and    $0xfffffffffffffff0,%rbx
    ustack_top -= (nent + 3) * sizeof(void *);
  804210ea9d:	41 8d 56 03          	lea    0x3(%r14),%edx
  804210eaa1:	48 63 d2             	movslq %edx,%rdx
  804210eaa4:	48 c1 e2 03          	shl    $0x3,%rdx
  804210eaa8:	48 29 d3             	sub    %rdx,%rbx
    nosan_memcpy(ustack_top, argv, (nent + 3) * sizeof(argv[0]));
  804210eaab:	48 8d b5 38 ff ff ff 	lea    -0xc8(%rbp),%rsi
  804210eab2:	48 89 df             	mov    %rbx,%rdi
  804210eab5:	41 ff d4             	call   *%r12
    char **argv_arg = (char **)ustack_top;
  804210eab8:	48 89 9d f0 fe ff ff 	mov    %rbx,-0x110(%rbp)
    long argc_arg = nent + 2;
  804210eabf:	41 83 c6 02          	add    $0x2,%r14d
  804210eac3:	4d 63 f6             	movslq %r14d,%r14
  804210eac6:	4c 89 b5 e8 fe ff ff 	mov    %r14,-0x118(%rbp)
    ustack_top -= sizeof(void *);
  804210eacd:	48 8d 7b f8          	lea    -0x8(%rbx),%rdi
    nosan_memcpy(ustack_top, &argv_arg, sizeof(argv_arg));
  804210ead1:	ba 08 00 00 00       	mov    $0x8,%edx
  804210ead6:	48 8d b5 f0 fe ff ff 	lea    -0x110(%rbp),%rsi
  804210eadd:	41 ff d4             	call   *%r12
    ustack_top -= sizeof(void *);
  804210eae0:	48 83 eb 10          	sub    $0x10,%rbx
    nosan_memcpy(ustack_top, &argc_arg, sizeof(argc_arg));
  804210eae4:	ba 08 00 00 00       	mov    $0x8,%edx
  804210eae9:	48 8d b5 e8 fe ff ff 	lea    -0x118(%rbp),%rsi
  804210eaf0:	48 89 df             	mov    %rbx,%rdi
  804210eaf3:	41 ff d4             	call   *%r12
    return (uintptr_t)ustack_top;
  804210eaf6:	48 89 d8             	mov    %rbx,%rax
}
  804210eaf9:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  804210eafd:	5b                   	pop    %rbx
  804210eafe:	41 5c                	pop    %r12
  804210eb00:	41 5d                	pop    %r13
  804210eb02:	41 5e                	pop    %r14
  804210eb04:	41 5f                	pop    %r15
  804210eb06:	5d                   	pop    %rbp
  804210eb07:	c3                   	ret
        cprintf("MCFG table is absent!");
  804210eb08:	48 bf 8d fe 11 42 80 	movabs $0x804211fe8d,%rdi
  804210eb0f:	00 00 00 
  804210eb12:	b8 00 00 00 00       	mov    $0x0,%eax
  804210eb17:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210eb1e:	00 00 00 
  804210eb21:	ff d2                	call   *%rdx
        return (uintptr_t)ustack_top;
  804210eb23:	48 89 d8             	mov    %rbx,%rax
  804210eb26:	eb d1                	jmp    804210eaf9 <make_fs_args+0x206>

000000804210eb28 <get_fadt>:
get_fadt(void) {
  804210eb28:	f3 0f 1e fa          	endbr64
  804210eb2c:	55                   	push   %rbp
  804210eb2d:	48 89 e5             	mov    %rsp,%rbp
    fadt = acpi_find_table("FACP");
  804210eb30:	48 bf cc fe 11 42 80 	movabs $0x804211fecc,%rdi
  804210eb37:	00 00 00 
  804210eb3a:	48 b8 cf e2 10 42 80 	movabs $0x804210e2cf,%rax
  804210eb41:	00 00 00 
  804210eb44:	ff d0                	call   *%rax
}
  804210eb46:	5d                   	pop    %rbp
  804210eb47:	c3                   	ret

000000804210eb48 <acpi_enable>:
acpi_enable(void) {
  804210eb48:	f3 0f 1e fa          	endbr64
  804210eb4c:	55                   	push   %rbp
  804210eb4d:	48 89 e5             	mov    %rsp,%rbp
    FADT *fadt = get_fadt();
  804210eb50:	48 b8 28 eb 10 42 80 	movabs $0x804210eb28,%rax
  804210eb57:	00 00 00 
  804210eb5a:	ff d0                	call   *%rax
  804210eb5c:	48 89 c1             	mov    %rax,%rcx
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804210eb5f:	0f b6 40 34          	movzbl 0x34(%rax),%eax
  804210eb63:	8b 51 30             	mov    0x30(%rcx),%edx
  804210eb66:	ee                   	out    %al,(%dx)
    while ((inw(fadt->PM1aControlBlock) & 1) == 0) /* nothing */
  804210eb67:	8b 51 40             	mov    0x40(%rcx),%edx
    asm volatile("inw %w1,%0"
  804210eb6a:	66 ed                	in     (%dx),%ax
  804210eb6c:	a8 01                	test   $0x1,%al
  804210eb6e:	74 fa                	je     804210eb6a <acpi_enable+0x22>
}
  804210eb70:	5d                   	pop    %rbp
  804210eb71:	c3                   	ret

000000804210eb72 <get_hpet>:
get_hpet(void) {
  804210eb72:	f3 0f 1e fa          	endbr64
  804210eb76:	55                   	push   %rbp
  804210eb77:	48 89 e5             	mov    %rsp,%rbp
    hpet = acpi_find_table("HPET");
  804210eb7a:	48 bf d1 fe 11 42 80 	movabs $0x804211fed1,%rdi
  804210eb81:	00 00 00 
  804210eb84:	48 b8 cf e2 10 42 80 	movabs $0x804210e2cf,%rax
  804210eb8b:	00 00 00 
  804210eb8e:	ff d0                	call   *%rax
}
  804210eb90:	5d                   	pop    %rbp
  804210eb91:	c3                   	ret

000000804210eb92 <hpet_register>:
hpet_register(void) {
  804210eb92:	f3 0f 1e fa          	endbr64
  804210eb96:	55                   	push   %rbp
  804210eb97:	48 89 e5             	mov    %rsp,%rbp
    HPET *hpet_timer = get_hpet();
  804210eb9a:	48 b8 72 eb 10 42 80 	movabs $0x804210eb72,%rax
  804210eba1:	00 00 00 
  804210eba4:	ff d0                	call   *%rax
    if (!hpet_timer->address.address) panic("hpet is unavailable\n");
  804210eba6:	48 8b 78 2c          	mov    0x2c(%rax),%rdi
  804210ebaa:	48 85 ff             	test   %rdi,%rdi
  804210ebad:	74 13                	je     804210ebc2 <hpet_register+0x30>
    return mmio_map_region(paddr, sizeof(HPETRegister));
  804210ebaf:	be 00 04 00 00       	mov    $0x400,%esi
  804210ebb4:	48 b8 0b a0 10 42 80 	movabs $0x804210a00b,%rax
  804210ebbb:	00 00 00 
  804210ebbe:	ff d0                	call   *%rax
}
  804210ebc0:	5d                   	pop    %rbp
  804210ebc1:	c3                   	ret
    if (!hpet_timer->address.address) panic("hpet is unavailable\n");
  804210ebc2:	48 ba d6 fe 11 42 80 	movabs $0x804211fed6,%rdx
  804210ebc9:	00 00 00 
  804210ebcc:	be 08 01 00 00       	mov    $0x108,%esi
  804210ebd1:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210ebd8:	00 00 00 
  804210ebdb:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ebe0:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210ebe7:	00 00 00 
  804210ebea:	ff d1                	call   *%rcx

000000804210ebec <hpet_init>:
hpet_init() {
  804210ebec:	f3 0f 1e fa          	endbr64
    if (hpetReg == NULL) {
  804210ebf0:	48 b8 78 76 00 43 80 	movabs $0x8043007678,%rax
  804210ebf7:	00 00 00 
  804210ebfa:	48 83 38 00          	cmpq   $0x0,(%rax)
  804210ebfe:	74 01                	je     804210ec01 <hpet_init+0x15>
  804210ec00:	c3                   	ret
hpet_init() {
  804210ec01:	55                   	push   %rbp
  804210ec02:	48 89 e5             	mov    %rsp,%rbp
    asm volatile("inb %w1,%0"
  804210ec05:	ba 70 00 00 00       	mov    $0x70,%edx
  804210ec0a:	ec                   	in     (%dx),%al
    outb(CMOS_CMD, inb(CMOS_CMD) | CMOS_NMI_LOCK);
  804210ec0b:	83 c8 80             	or     $0xffffff80,%eax
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804210ec0e:	ee                   	out    %al,(%dx)
        hpetReg = hpet_register();
  804210ec0f:	48 b8 92 eb 10 42 80 	movabs $0x804210eb92,%rax
  804210ec16:	00 00 00 
  804210ec19:	ff d0                	call   *%rax
  804210ec1b:	48 89 c1             	mov    %rax,%rcx
  804210ec1e:	48 a3 78 76 00 43 80 	movabs %rax,0x8043007678
  804210ec25:	00 00 00 
        uint64_t cap = hpetReg->GCAP_ID;
  804210ec28:	48 8b 10             	mov    (%rax),%rdx
        hpetFemto = (uintptr_t)(cap >> 32);
  804210ec2b:	48 89 d6             	mov    %rdx,%rsi
  804210ec2e:	48 c1 ee 20          	shr    $0x20,%rsi
  804210ec32:	48 89 f0             	mov    %rsi,%rax
  804210ec35:	48 a3 70 76 00 43 80 	movabs %rax,0x8043007670
  804210ec3c:	00 00 00 
        if (!(cap & HPET_LEG_RT_CAP)) panic("HPET has no LegacyReplacement mode");
  804210ec3f:	f6 c6 80             	test   $0x80,%dh
  804210ec42:	74 34                	je     804210ec78 <hpet_init+0x8c>
        hpetFreq = (1 * Peta) / hpetFemto;
  804210ec44:	48 b8 00 80 c6 a4 7e 	movabs $0x38d7ea4c68000,%rax
  804210ec4b:	8d 03 00 
  804210ec4e:	ba 00 00 00 00       	mov    $0x0,%edx
  804210ec53:	48 f7 f6             	div    %rsi
  804210ec56:	48 a3 68 76 00 43 80 	movabs %rax,0x8043007668
  804210ec5d:	00 00 00 
        hpetReg->GEN_CONF |= HPET_ENABLE_CNF;
  804210ec60:	48 8b 41 10          	mov    0x10(%rcx),%rax
  804210ec64:	48 83 c8 01          	or     $0x1,%rax
  804210ec68:	48 89 41 10          	mov    %rax,0x10(%rcx)
    asm volatile("inb %w1,%0"
  804210ec6c:	ba 70 00 00 00       	mov    $0x70,%edx
  804210ec71:	ec                   	in     (%dx),%al
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  804210ec72:	83 e0 7f             	and    $0x7f,%eax
  804210ec75:	ee                   	out    %al,(%dx)
}
  804210ec76:	5d                   	pop    %rbp
  804210ec77:	c3                   	ret
        if (!(cap & HPET_LEG_RT_CAP)) panic("HPET has no LegacyReplacement mode");
  804210ec78:	48 ba 30 14 12 42 80 	movabs $0x8042121430,%rdx
  804210ec7f:	00 00 00 
  804210ec82:	be 3a 01 00 00       	mov    $0x13a,%esi
  804210ec87:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210ec8e:	00 00 00 
  804210ec91:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ec96:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  804210ec9d:	00 00 00 
  804210eca0:	ff d1                	call   *%rcx

000000804210eca2 <hpet_print_struct>:
hpet_print_struct(void) {
  804210eca2:	f3 0f 1e fa          	endbr64
  804210eca6:	55                   	push   %rbp
  804210eca7:	48 89 e5             	mov    %rsp,%rbp
  804210ecaa:	41 54                	push   %r12
  804210ecac:	53                   	push   %rbx
    HPET *hpet = get_hpet();
  804210ecad:	48 b8 72 eb 10 42 80 	movabs $0x804210eb72,%rax
  804210ecb4:	00 00 00 
  804210ecb7:	ff d0                	call   *%rax
    assert(hpet != NULL);
  804210ecb9:	48 85 c0             	test   %rax,%rax
  804210ecbc:	0f 84 da 01 00 00    	je     804210ee9c <hpet_print_struct+0x1fa>
  804210ecc2:	48 89 c3             	mov    %rax,%rbx
    cprintf("signature = %s\n", (hpet->h).Signature);
  804210ecc5:	48 89 c6             	mov    %rax,%rsi
  804210ecc8:	48 bf f8 fe 11 42 80 	movabs $0x804211fef8,%rdi
  804210eccf:	00 00 00 
  804210ecd2:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ecd7:	49 bc 70 cf 10 42 80 	movabs $0x804210cf70,%r12
  804210ecde:	00 00 00 
  804210ece1:	41 ff d4             	call   *%r12
    cprintf("length = %08x\n", (hpet->h).Length);
  804210ece4:	8b 73 04             	mov    0x4(%rbx),%esi
  804210ece7:	48 bf 08 ff 11 42 80 	movabs $0x804211ff08,%rdi
  804210ecee:	00 00 00 
  804210ecf1:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ecf6:	41 ff d4             	call   *%r12
    cprintf("revision = %08x\n", (hpet->h).Revision);
  804210ecf9:	0f b6 73 08          	movzbl 0x8(%rbx),%esi
  804210ecfd:	48 bf 2c ff 11 42 80 	movabs $0x804211ff2c,%rdi
  804210ed04:	00 00 00 
  804210ed07:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ed0c:	41 ff d4             	call   *%r12
    cprintf("checksum = %08x\n", (hpet->h).Checksum);
  804210ed0f:	0f b6 73 09          	movzbl 0x9(%rbx),%esi
  804210ed13:	48 bf 17 ff 11 42 80 	movabs $0x804211ff17,%rdi
  804210ed1a:	00 00 00 
  804210ed1d:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ed22:	41 ff d4             	call   *%r12
    cprintf("oem_revision = %08x\n", (hpet->h).OEMRevision);
  804210ed25:	8b 73 18             	mov    0x18(%rbx),%esi
  804210ed28:	48 bf 28 ff 11 42 80 	movabs $0x804211ff28,%rdi
  804210ed2f:	00 00 00 
  804210ed32:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ed37:	41 ff d4             	call   *%r12
    cprintf("creator_id = %08x\n", (hpet->h).CreatorID);
  804210ed3a:	8b 73 1c             	mov    0x1c(%rbx),%esi
  804210ed3d:	48 bf 3d ff 11 42 80 	movabs $0x804211ff3d,%rdi
  804210ed44:	00 00 00 
  804210ed47:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ed4c:	41 ff d4             	call   *%r12
    cprintf("creator_revision = %08x\n", (hpet->h).CreatorRevision);
  804210ed4f:	8b 73 20             	mov    0x20(%rbx),%esi
  804210ed52:	48 bf 50 ff 11 42 80 	movabs $0x804211ff50,%rdi
  804210ed59:	00 00 00 
  804210ed5c:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ed61:	41 ff d4             	call   *%r12
    cprintf("hardware_rev_id = %08x\n", hpet->hardware_rev_id);
  804210ed64:	0f b6 73 24          	movzbl 0x24(%rbx),%esi
  804210ed68:	48 bf 69 ff 11 42 80 	movabs $0x804211ff69,%rdi
  804210ed6f:	00 00 00 
  804210ed72:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ed77:	41 ff d4             	call   *%r12
    cprintf("comparator_count = %08x\n", hpet->comparator_count);
  804210ed7a:	0f b6 73 25          	movzbl 0x25(%rbx),%esi
  804210ed7e:	83 e6 1f             	and    $0x1f,%esi
  804210ed81:	48 bf 81 ff 11 42 80 	movabs $0x804211ff81,%rdi
  804210ed88:	00 00 00 
  804210ed8b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ed90:	41 ff d4             	call   *%r12
    cprintf("counter_size = %08x\n", hpet->counter_size);
  804210ed93:	0f b6 73 25          	movzbl 0x25(%rbx),%esi
  804210ed97:	40 c0 ee 05          	shr    $0x5,%sil
  804210ed9b:	83 e6 01             	and    $0x1,%esi
  804210ed9e:	48 bf 9a ff 11 42 80 	movabs $0x804211ff9a,%rdi
  804210eda5:	00 00 00 
  804210eda8:	b8 00 00 00 00       	mov    $0x0,%eax
  804210edad:	41 ff d4             	call   *%r12
    cprintf("reserved = %08x\n", hpet->reserved);
  804210edb0:	0f b6 73 25          	movzbl 0x25(%rbx),%esi
  804210edb4:	40 c0 ee 06          	shr    $0x6,%sil
  804210edb8:	83 e6 01             	and    $0x1,%esi
  804210edbb:	48 bf af ff 11 42 80 	movabs $0x804211ffaf,%rdi
  804210edc2:	00 00 00 
  804210edc5:	b8 00 00 00 00       	mov    $0x0,%eax
  804210edca:	41 ff d4             	call   *%r12
    cprintf("legacy_replacement = %08x\n", hpet->legacy_replacement);
  804210edcd:	0f b6 73 25          	movzbl 0x25(%rbx),%esi
  804210edd1:	40 c0 ee 07          	shr    $0x7,%sil
  804210edd5:	40 0f b6 f6          	movzbl %sil,%esi
  804210edd9:	48 bf c0 ff 11 42 80 	movabs $0x804211ffc0,%rdi
  804210ede0:	00 00 00 
  804210ede3:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ede8:	41 ff d4             	call   *%r12
    cprintf("pci_vendor_id = %08x\n", hpet->pci_vendor_id);
  804210edeb:	0f b7 73 26          	movzwl 0x26(%rbx),%esi
  804210edef:	48 bf db ff 11 42 80 	movabs $0x804211ffdb,%rdi
  804210edf6:	00 00 00 
  804210edf9:	b8 00 00 00 00       	mov    $0x0,%eax
  804210edfe:	41 ff d4             	call   *%r12
    cprintf("hpet_number = %08x\n", hpet->hpet_number);
  804210ee01:	0f b6 73 34          	movzbl 0x34(%rbx),%esi
  804210ee05:	48 bf f1 ff 11 42 80 	movabs $0x804211fff1,%rdi
  804210ee0c:	00 00 00 
  804210ee0f:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ee14:	41 ff d4             	call   *%r12
    cprintf("minimum_tick = %08x\n", hpet->minimum_tick);
  804210ee17:	0f b7 73 35          	movzwl 0x35(%rbx),%esi
  804210ee1b:	48 bf 05 00 12 42 80 	movabs $0x8042120005,%rdi
  804210ee22:	00 00 00 
  804210ee25:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ee2a:	41 ff d4             	call   *%r12
    cprintf("address_structure:\n");
  804210ee2d:	48 bf 1a 00 12 42 80 	movabs $0x804212001a,%rdi
  804210ee34:	00 00 00 
  804210ee37:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ee3c:	41 ff d4             	call   *%r12
    cprintf("address_space_id = %08x\n", (hpet->address).address_space_id);
  804210ee3f:	0f b6 73 28          	movzbl 0x28(%rbx),%esi
  804210ee43:	48 bf 2e 00 12 42 80 	movabs $0x804212002e,%rdi
  804210ee4a:	00 00 00 
  804210ee4d:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ee52:	41 ff d4             	call   *%r12
    cprintf("register_bit_width = %08x\n", (hpet->address).register_bit_width);
  804210ee55:	0f b6 73 29          	movzbl 0x29(%rbx),%esi
  804210ee59:	48 bf 47 00 12 42 80 	movabs $0x8042120047,%rdi
  804210ee60:	00 00 00 
  804210ee63:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ee68:	41 ff d4             	call   *%r12
    cprintf("register_bit_offset = %08x\n", (hpet->address).register_bit_offset);
  804210ee6b:	0f b6 73 2a          	movzbl 0x2a(%rbx),%esi
  804210ee6f:	48 bf 62 00 12 42 80 	movabs $0x8042120062,%rdi
  804210ee76:	00 00 00 
  804210ee79:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ee7e:	41 ff d4             	call   *%r12
    cprintf("address = %08lx\n", (unsigned long)(hpet->address).address);
  804210ee81:	48 8b 73 2c          	mov    0x2c(%rbx),%rsi
  804210ee85:	48 bf 7e 00 12 42 80 	movabs $0x804212007e,%rdi
  804210ee8c:	00 00 00 
  804210ee8f:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ee94:	41 ff d4             	call   *%r12
}
  804210ee97:	5b                   	pop    %rbx
  804210ee98:	41 5c                	pop    %r12
  804210ee9a:	5d                   	pop    %rbp
  804210ee9b:	c3                   	ret
    assert(hpet != NULL);
  804210ee9c:	48 b9 eb fe 11 42 80 	movabs $0x804211feeb,%rcx
  804210eea3:	00 00 00 
  804210eea6:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210eead:	00 00 00 
  804210eeb0:	be 12 01 00 00       	mov    $0x112,%esi
  804210eeb5:	48 bf 3b fe 11 42 80 	movabs $0x804211fe3b,%rdi
  804210eebc:	00 00 00 
  804210eebf:	b8 00 00 00 00       	mov    $0x0,%eax
  804210eec4:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210eecb:	00 00 00 
  804210eece:	41 ff d0             	call   *%r8

000000804210eed1 <hpet_print_reg>:
hpet_print_reg(void) {
  804210eed1:	f3 0f 1e fa          	endbr64
  804210eed5:	55                   	push   %rbp
  804210eed6:	48 89 e5             	mov    %rsp,%rbp
  804210eed9:	41 54                	push   %r12
  804210eedb:	53                   	push   %rbx
    cprintf("GCAP_ID = %016lx\n", (unsigned long)hpetReg->GCAP_ID);
  804210eedc:	49 bc 78 76 00 43 80 	movabs $0x8043007678,%r12
  804210eee3:	00 00 00 
  804210eee6:	49 8b 04 24          	mov    (%r12),%rax
  804210eeea:	48 8b 30             	mov    (%rax),%rsi
  804210eeed:	48 bf 8f 00 12 42 80 	movabs $0x804212008f,%rdi
  804210eef4:	00 00 00 
  804210eef7:	b8 00 00 00 00       	mov    $0x0,%eax
  804210eefc:	48 bb 70 cf 10 42 80 	movabs $0x804210cf70,%rbx
  804210ef03:	00 00 00 
  804210ef06:	ff d3                	call   *%rbx
    cprintf("GEN_CONF = %016lx\n", (unsigned long)hpetReg->GEN_CONF);
  804210ef08:	49 8b 04 24          	mov    (%r12),%rax
  804210ef0c:	48 8b 70 10          	mov    0x10(%rax),%rsi
  804210ef10:	48 bf a1 00 12 42 80 	movabs $0x80421200a1,%rdi
  804210ef17:	00 00 00 
  804210ef1a:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ef1f:	ff d3                	call   *%rbx
    cprintf("GINTR_STA = %016lx\n", (unsigned long)hpetReg->GINTR_STA);
  804210ef21:	49 8b 04 24          	mov    (%r12),%rax
  804210ef25:	48 8b 70 20          	mov    0x20(%rax),%rsi
  804210ef29:	48 bf b4 00 12 42 80 	movabs $0x80421200b4,%rdi
  804210ef30:	00 00 00 
  804210ef33:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ef38:	ff d3                	call   *%rbx
    cprintf("MAIN_CNT = %016lx\n", (unsigned long)hpetReg->MAIN_CNT);
  804210ef3a:	49 8b 04 24          	mov    (%r12),%rax
  804210ef3e:	48 8b b0 f0 00 00 00 	mov    0xf0(%rax),%rsi
  804210ef45:	48 bf c8 00 12 42 80 	movabs $0x80421200c8,%rdi
  804210ef4c:	00 00 00 
  804210ef4f:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ef54:	ff d3                	call   *%rbx
    cprintf("TIM0_CONF = %016lx\n", (unsigned long)hpetReg->TIM0_CONF);
  804210ef56:	49 8b 04 24          	mov    (%r12),%rax
  804210ef5a:	48 8b b0 00 01 00 00 	mov    0x100(%rax),%rsi
  804210ef61:	48 bf db 00 12 42 80 	movabs $0x80421200db,%rdi
  804210ef68:	00 00 00 
  804210ef6b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ef70:	ff d3                	call   *%rbx
    cprintf("TIM0_COMP = %016lx\n", (unsigned long)hpetReg->TIM0_COMP);
  804210ef72:	49 8b 04 24          	mov    (%r12),%rax
  804210ef76:	48 8b b0 08 01 00 00 	mov    0x108(%rax),%rsi
  804210ef7d:	48 bf ef 00 12 42 80 	movabs $0x80421200ef,%rdi
  804210ef84:	00 00 00 
  804210ef87:	b8 00 00 00 00       	mov    $0x0,%eax
  804210ef8c:	ff d3                	call   *%rbx
    cprintf("TIM0_FSB = %016lx\n", (unsigned long)hpetReg->TIM0_FSB);
  804210ef8e:	49 8b 04 24          	mov    (%r12),%rax
  804210ef92:	48 8b b0 10 01 00 00 	mov    0x110(%rax),%rsi
  804210ef99:	48 bf 03 01 12 42 80 	movabs $0x8042120103,%rdi
  804210efa0:	00 00 00 
  804210efa3:	b8 00 00 00 00       	mov    $0x0,%eax
  804210efa8:	ff d3                	call   *%rbx
    cprintf("TIM1_CONF = %016lx\n", (unsigned long)hpetReg->TIM1_CONF);
  804210efaa:	49 8b 04 24          	mov    (%r12),%rax
  804210efae:	48 8b b0 20 01 00 00 	mov    0x120(%rax),%rsi
  804210efb5:	48 bf 16 01 12 42 80 	movabs $0x8042120116,%rdi
  804210efbc:	00 00 00 
  804210efbf:	b8 00 00 00 00       	mov    $0x0,%eax
  804210efc4:	ff d3                	call   *%rbx
    cprintf("TIM1_COMP = %016lx\n", (unsigned long)hpetReg->TIM1_COMP);
  804210efc6:	49 8b 04 24          	mov    (%r12),%rax
  804210efca:	48 8b b0 28 01 00 00 	mov    0x128(%rax),%rsi
  804210efd1:	48 bf 2a 01 12 42 80 	movabs $0x804212012a,%rdi
  804210efd8:	00 00 00 
  804210efdb:	b8 00 00 00 00       	mov    $0x0,%eax
  804210efe0:	ff d3                	call   *%rbx
    cprintf("TIM1_FSB = %016lx\n", (unsigned long)hpetReg->TIM1_FSB);
  804210efe2:	49 8b 04 24          	mov    (%r12),%rax
  804210efe6:	48 8b b0 30 01 00 00 	mov    0x130(%rax),%rsi
  804210efed:	48 bf 3e 01 12 42 80 	movabs $0x804212013e,%rdi
  804210eff4:	00 00 00 
  804210eff7:	b8 00 00 00 00       	mov    $0x0,%eax
  804210effc:	ff d3                	call   *%rbx
    cprintf("TIM2_CONF = %016lx\n", (unsigned long)hpetReg->TIM2_CONF);
  804210effe:	49 8b 04 24          	mov    (%r12),%rax
  804210f002:	48 8b b0 40 01 00 00 	mov    0x140(%rax),%rsi
  804210f009:	48 bf 51 01 12 42 80 	movabs $0x8042120151,%rdi
  804210f010:	00 00 00 
  804210f013:	b8 00 00 00 00       	mov    $0x0,%eax
  804210f018:	ff d3                	call   *%rbx
    cprintf("TIM2_COMP = %016lx\n", (unsigned long)hpetReg->TIM2_COMP);
  804210f01a:	49 8b 04 24          	mov    (%r12),%rax
  804210f01e:	48 8b b0 48 01 00 00 	mov    0x148(%rax),%rsi
  804210f025:	48 bf 65 01 12 42 80 	movabs $0x8042120165,%rdi
  804210f02c:	00 00 00 
  804210f02f:	b8 00 00 00 00       	mov    $0x0,%eax
  804210f034:	ff d3                	call   *%rbx
    cprintf("TIM2_FSB = %016lx\n", (unsigned long)hpetReg->TIM2_FSB);
  804210f036:	49 8b 04 24          	mov    (%r12),%rax
  804210f03a:	48 8b b0 50 01 00 00 	mov    0x150(%rax),%rsi
  804210f041:	48 bf 79 01 12 42 80 	movabs $0x8042120179,%rdi
  804210f048:	00 00 00 
  804210f04b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210f050:	ff d3                	call   *%rbx
}
  804210f052:	5b                   	pop    %rbx
  804210f053:	41 5c                	pop    %r12
  804210f055:	5d                   	pop    %rbp
  804210f056:	c3                   	ret

000000804210f057 <hpet_get_main_cnt>:
hpet_get_main_cnt(void) {
  804210f057:	f3 0f 1e fa          	endbr64
    return hpetReg->MAIN_CNT;
  804210f05b:	48 a1 78 76 00 43 80 	movabs 0x8043007678,%rax
  804210f062:	00 00 00 
  804210f065:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
}
  804210f06c:	c3                   	ret

000000804210f06d <pmtimer_get_timeval>:

uint32_t
pmtimer_get_timeval(void) {
  804210f06d:	f3 0f 1e fa          	endbr64
  804210f071:	55                   	push   %rbp
  804210f072:	48 89 e5             	mov    %rsp,%rbp
    FADT *fadt = get_fadt();
  804210f075:	48 b8 28 eb 10 42 80 	movabs $0x804210eb28,%rax
  804210f07c:	00 00 00 
  804210f07f:	ff d0                	call   *%rax
    asm volatile("inl %w1,%0"
  804210f081:	8b 50 4c             	mov    0x4c(%rax),%edx
  804210f084:	ed                   	in     (%dx),%eax
    return inl(fadt->PMTimerBlock);
}
  804210f085:	5d                   	pop    %rbp
  804210f086:	c3                   	ret

000000804210f087 <pmtimer_cpu_frequency>:

/* Calculate CPU frequency in Hz with the help with ACPI PowerManagement timer.
 * HINT Use pmtimer_get_timeval function and do not forget that ACPI PM timer
 *      can be 24-bit or 32-bit. */
uint64_t
pmtimer_cpu_frequency(void) {
  804210f087:	f3 0f 1e fa          	endbr64
  804210f08b:	55                   	push   %rbp
  804210f08c:	48 89 e5             	mov    %rsp,%rbp
  804210f08f:	41 56                	push   %r14
  804210f091:	41 55                	push   %r13
  804210f093:	41 54                	push   %r12
  804210f095:	53                   	push   %rbx
    static uint64_t cpu_freq;

    // LAB 5: Your code here
    uint32_t first = pmtimer_get_timeval();
  804210f096:	48 b8 6d f0 10 42 80 	movabs $0x804210f06d,%rax
  804210f09d:	00 00 00 
  804210f0a0:	ff d0                	call   *%rax
  804210f0a2:	89 c3                	mov    %eax,%ebx
    asm volatile("rdtsc"
  804210f0a4:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804210f0a6:	48 c1 e2 20          	shl    $0x20,%rdx
  804210f0aa:	89 c0                	mov    %eax,%eax
  804210f0ac:	48 09 c2             	or     %rax,%rdx
  804210f0af:	49 89 d6             	mov    %rdx,%r14
    uint64_t first_tsc = read_tsc();
    uint32_t next = first;
    uint64_t d = 0;
    uint64_t eps = PM_FREQ / 10;
    while (d < eps) {
        next = pmtimer_get_timeval();
  804210f0b2:	49 bc 6d f0 10 42 80 	movabs $0x804210f06d,%r12
  804210f0b9:	00 00 00 
        if (first - next <= 0xFFFFFF) {
            d = next - first + 0xFFFFFF;
  804210f0bc:	41 bd ff ff ff 00    	mov    $0xffffff,%r13d
  804210f0c2:	41 29 dd             	sub    %ebx,%r13d
  804210f0c5:	eb 11                	jmp    804210f0d8 <pmtimer_cpu_frequency+0x51>
        } else if (first - next > 0) {
  804210f0c7:	39 c3                	cmp    %eax,%ebx
  804210f0c9:	74 0d                	je     804210f0d8 <pmtimer_cpu_frequency+0x51>
            d = next - first + 0xFFFFFFFF;
  804210f0cb:	29 d8                	sub    %ebx,%eax
  804210f0cd:	8d 40 ff             	lea    -0x1(%rax),%eax
    while (d < eps) {
  804210f0d0:	48 3d 41 76 05 00    	cmp    $0x57641,%rax
  804210f0d6:	77 16                	ja     804210f0ee <pmtimer_cpu_frequency+0x67>
        next = pmtimer_get_timeval();
  804210f0d8:	41 ff d4             	call   *%r12
        if (first - next <= 0xFFFFFF) {
  804210f0db:	89 da                	mov    %ebx,%edx
  804210f0dd:	29 c2                	sub    %eax,%edx
  804210f0df:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
  804210f0e5:	77 e0                	ja     804210f0c7 <pmtimer_cpu_frequency+0x40>
            d = next - first + 0xFFFFFF;
  804210f0e7:	41 8d 44 05 00       	lea    0x0(%r13,%rax,1),%eax
  804210f0ec:	eb e2                	jmp    804210f0d0 <pmtimer_cpu_frequency+0x49>
    asm volatile("rdtsc"
  804210f0ee:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804210f0f0:	48 c1 e2 20          	shl    $0x20,%rdx
  804210f0f4:	89 c0                	mov    %eax,%eax
  804210f0f6:	48 09 c2             	or     %rax,%rdx
        } else {
            d = next - first;
        }
    }
    uint64_t next_tsc = read_tsc();
    cpu_freq = (next_tsc - first_tsc) * 10;
  804210f0f9:	4c 29 f2             	sub    %r14,%rdx
  804210f0fc:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  804210f100:	48 01 c0             	add    %rax,%rax
    return cpu_freq;
  804210f103:	5b                   	pop    %rbx
  804210f104:	41 5c                	pop    %r12
  804210f106:	41 5d                	pop    %r13
  804210f108:	41 5e                	pop    %r14
  804210f10a:	5d                   	pop    %rbp
  804210f10b:	c3                   	ret

000000804210f10c <sched_halt>:
}

/* Halt this CPU when there is nothing to do. Wait until the
 * timer interrupt wakes it up. This function never returns */
_Noreturn void
sched_halt(void) {
  804210f10c:	f3 0f 1e fa          	endbr64

    /* For debugging and testing purposes, if there are no runnable
     * environments in the system, then drop into the kernel monitor */
    int i;
    for (i = 0; i < NENV; i++)
  804210f110:	48 a1 68 64 00 43 80 	movabs 0x8043006468,%rax
  804210f117:	00 00 00 
  804210f11a:	48 8d 90 d4 00 00 00 	lea    0xd4(%rax),%rdx
  804210f121:	b9 00 00 00 00       	mov    $0x0,%ecx
        if (envs[i].env_status == ENV_RUNNABLE ||
  804210f126:	8b 02                	mov    (%rdx),%eax
  804210f128:	83 e8 02             	sub    $0x2,%eax
  804210f12b:	83 f8 01             	cmp    $0x1,%eax
  804210f12e:	76 49                	jbe    804210f179 <sched_halt+0x6d>
    for (i = 0; i < NENV; i++)
  804210f130:	83 c1 01             	add    $0x1,%ecx
  804210f133:	48 81 c2 30 01 00 00 	add    $0x130,%rdx
  804210f13a:	81 f9 00 04 00 00    	cmp    $0x400,%ecx
  804210f140:	75 e4                	jne    804210f126 <sched_halt+0x1a>
sched_halt(void) {
  804210f142:	55                   	push   %rbp
  804210f143:	48 89 e5             	mov    %rsp,%rbp
  804210f146:	53                   	push   %rbx
  804210f147:	48 83 ec 08          	sub    $0x8,%rsp
            envs[i].env_status == ENV_RUNNING) break;
    if (i == NENV) {
        cprintf("No runnable environments in the system!\n");
  804210f14b:	48 bf 58 14 12 42 80 	movabs $0x8042121458,%rdi
  804210f152:	00 00 00 
  804210f155:	b8 00 00 00 00       	mov    $0x0,%eax
  804210f15a:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210f161:	00 00 00 
  804210f164:	ff d2                	call   *%rdx
        for (;;) monitor(NULL);
  804210f166:	48 bb 4a 46 10 42 80 	movabs $0x804210464a,%rbx
  804210f16d:	00 00 00 
  804210f170:	bf 00 00 00 00       	mov    $0x0,%edi
  804210f175:	ff d3                	call   *%rbx
  804210f177:	eb f7                	jmp    804210f170 <sched_halt+0x64>
    }

    /* Mark that no environment is running on CPU */
    curenv = NULL;
  804210f179:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210f180:	00 00 00 
  804210f183:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* Reset stack pointer, enable interrupts and then halt */
    asm volatile(
  804210f18a:	48 a1 84 76 00 43 80 	movabs 0x8043007684,%rax
  804210f191:	00 00 00 
  804210f194:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  804210f19b:	48 89 c4             	mov    %rax,%rsp
  804210f19e:	6a 00                	push   $0x0
  804210f1a0:	6a 00                	push   $0x0
  804210f1a2:	fb                   	sti
  804210f1a3:	f4                   	hlt
            "pushq $0\n"
            "sti\n"
            "hlt\n" ::"a"(cpu_ts.ts_rsp0));

    /* Unreachable */
    for (;;)
  804210f1a4:	eb fe                	jmp    804210f1a4 <sched_halt+0x98>

000000804210f1a6 <sched_yield>:
sched_yield(void) {
  804210f1a6:	f3 0f 1e fa          	endbr64
  804210f1aa:	55                   	push   %rbp
  804210f1ab:	48 89 e5             	mov    %rsp,%rbp
	int id = curenv - envs;
  804210f1ae:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210f1b5:	00 00 00 
  804210f1b8:	4c 8b 00             	mov    (%rax),%r8
  804210f1bb:	48 a1 68 64 00 43 80 	movabs 0x8043006468,%rax
  804210f1c2:	00 00 00 
	if (curenv == NULL) {
  804210f1c5:	4d 85 c0             	test   %r8,%r8
  804210f1c8:	0f 84 8a 00 00 00    	je     804210f258 <sched_yield+0xb2>
	int id = curenv - envs;
  804210f1ce:	4d 89 c1             	mov    %r8,%r9
  804210f1d1:	49 29 c1             	sub    %rax,%r9
  804210f1d4:	49 c1 f9 04          	sar    $0x4,%r9
  804210f1d8:	48 ba 1b ca 6b 28 af 	movabs $0x86bca1af286bca1b,%rdx
  804210f1df:	a1 bc 86 
  804210f1e2:	4c 0f af ca          	imul   %rdx,%r9
		for (int i = id + 1; i < NENV + id; i++) {
  804210f1e6:	41 8d 71 01          	lea    0x1(%r9),%esi
  804210f1ea:	41 81 c1 ff 03 00 00 	add    $0x3ff,%r9d
			if (envs[i % NENV].env_status == ENV_RUNNABLE) {
  804210f1f1:	89 f1                	mov    %esi,%ecx
  804210f1f3:	c1 f9 1f             	sar    $0x1f,%ecx
  804210f1f6:	c1 e9 16             	shr    $0x16,%ecx
  804210f1f9:	8d 14 0e             	lea    (%rsi,%rcx,1),%edx
  804210f1fc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  804210f202:	29 ca                	sub    %ecx,%edx
  804210f204:	48 63 d2             	movslq %edx,%rdx
  804210f207:	48 8d 0c d2          	lea    (%rdx,%rdx,8),%rcx
  804210f20b:	48 8d 3c 4a          	lea    (%rdx,%rcx,2),%rdi
  804210f20f:	48 c1 e7 04          	shl    $0x4,%rdi
  804210f213:	48 01 c7             	add    %rax,%rdi
  804210f216:	83 bf d4 00 00 00 02 	cmpl   $0x2,0xd4(%rdi)
  804210f21d:	74 65                	je     804210f284 <sched_yield+0xde>
		for (int i = id + 1; i < NENV + id; i++) {
  804210f21f:	83 c6 01             	add    $0x1,%esi
  804210f222:	44 39 ce             	cmp    %r9d,%esi
  804210f225:	7e ca                	jle    804210f1f1 <sched_yield+0x4b>
		if (curenv->env_status == ENV_RUNNING) {
  804210f227:	41 83 b8 d4 00 00 00 	cmpl   $0x3,0xd4(%r8)
  804210f22e:	03 
  804210f22f:	74 5f                	je     804210f290 <sched_yield+0xea>
    cprintf("Halt\n");
  804210f231:	48 bf 95 01 12 42 80 	movabs $0x8042120195,%rdi
  804210f238:	00 00 00 
  804210f23b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210f240:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804210f247:	00 00 00 
  804210f24a:	ff d2                	call   *%rdx
    sched_halt();
  804210f24c:	48 b8 0c f1 10 42 80 	movabs $0x804210f10c,%rax
  804210f253:	00 00 00 
  804210f256:	ff d0                	call   *%rax
  804210f258:	48 89 c7             	mov    %rax,%rdi
  804210f25b:	48 05 00 c0 04 00    	add    $0x4c000,%rax
			if (envs[i].env_status == ENV_RUNNABLE) {
  804210f261:	83 bf d4 00 00 00 02 	cmpl   $0x2,0xd4(%rdi)
  804210f268:	74 0e                	je     804210f278 <sched_yield+0xd2>
		for (int i = 0; i < NENV; i++) {
  804210f26a:	48 81 c7 30 01 00 00 	add    $0x130,%rdi
  804210f271:	48 39 c7             	cmp    %rax,%rdi
  804210f274:	75 eb                	jne    804210f261 <sched_yield+0xbb>
  804210f276:	eb b9                	jmp    804210f231 <sched_yield+0x8b>
				env_run(&envs[i]);
  804210f278:	48 b8 be c8 10 42 80 	movabs $0x804210c8be,%rax
  804210f27f:	00 00 00 
  804210f282:	ff d0                	call   *%rax
				env_run(&envs[i % NENV]);
  804210f284:	48 b8 be c8 10 42 80 	movabs $0x804210c8be,%rax
  804210f28b:	00 00 00 
  804210f28e:	ff d0                	call   *%rax
				env_run(curenv);
  804210f290:	4c 89 c7             	mov    %r8,%rdi
  804210f293:	48 b8 be c8 10 42 80 	movabs $0x804210c8be,%rax
  804210f29a:	00 00 00 
  804210f29d:	ff d0                	call   *%rax

000000804210f29f <syscall>:
       return region_maxref(&curenv->address_space, addr, size) - region_maxref(&curenv->address_space, addr2, size2);
    }

    /* Dispatches to the correct kernel function, passing the arguments. */
    uintptr_t
    syscall(uintptr_t syscallno, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6) {
  804210f29f:	f3 0f 1e fa          	endbr64
  804210f2a3:	55                   	push   %rbp
  804210f2a4:	48 89 e5             	mov    %rsp,%rbp
  804210f2a7:	41 57                	push   %r15
  804210f2a9:	41 56                	push   %r14
  804210f2ab:	41 55                	push   %r13
  804210f2ad:	41 54                	push   %r12
  804210f2af:	53                   	push   %rbx
  804210f2b0:	48 83 ec 28          	sub    $0x28,%rsp
    // LAB 9: Your code here
    // LAB 10: Your code here
    // LAB 11: Your code here
    // LAB 12: Your code here

        switch (syscallno) {
  804210f2b4:	48 83 ff 10          	cmp    $0x10,%rdi
  804210f2b8:	0f 87 40 07 00 00    	ja     804210f9fe <syscall+0x75f>
  804210f2be:	49 89 f4             	mov    %rsi,%r12
  804210f2c1:	49 89 d5             	mov    %rdx,%r13
  804210f2c4:	49 89 cf             	mov    %rcx,%r15
  804210f2c7:	4d 89 c6             	mov    %r8,%r14
  804210f2ca:	4c 89 cb             	mov    %r9,%rbx
  804210f2cd:	48 ba 20 1e 12 42 80 	movabs $0x8042121e20,%rdx
  804210f2d4:	00 00 00 
  804210f2d7:	3e ff 24 fa          	notrack jmp *(%rdx,%rdi,8)
        case SYS_cputs:
            return sys_cputs((const char *)a1, (int)a2);
  804210f2db:	49 63 dd             	movslq %r13d,%rbx
  804210f2de:	49 89 f5             	mov    %rsi,%r13
        user_mem_assert(curenv, s, len, PROT_R);
  804210f2e1:	b9 04 00 00 00       	mov    $0x4,%ecx
  804210f2e6:	48 89 da             	mov    %rbx,%rdx
  804210f2e9:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210f2f0:	00 00 00 
  804210f2f3:	48 8b 38             	mov    (%rax),%rdi
  804210f2f6:	48 b8 2a 78 10 42 80 	movabs $0x804210782a,%rax
  804210f2fd:	00 00 00 
  804210f300:	ff d0                	call   *%rax
        while (len > 0) {
  804210f302:	48 85 db             	test   %rbx,%rbx
  804210f305:	74 6e                	je     804210f375 <syscall+0xd6>
            nosan_memcpy(cputs_buf, (void *)s, len_cpy);
  804210f307:	49 be 00 77 00 43 80 	movabs $0x8043007700,%r14
  804210f30e:	00 00 00 
  804210f311:	49 bf 62 0d 11 42 80 	movabs $0x8042110d62,%r15
  804210f318:	00 00 00 
            int len_cpy = MIN(len, CPUTS_BUF_SIZE);
  804210f31b:	41 bc 00 04 00 00    	mov    $0x400,%r12d
  804210f321:	4c 39 e3             	cmp    %r12,%rbx
  804210f324:	4c 0f 46 e3          	cmovbe %rbx,%r12
  804210f328:	44 89 65 bc          	mov    %r12d,-0x44(%rbp)
            nosan_memcpy(cputs_buf, (void *)s, len_cpy);
  804210f32c:	4d 63 e4             	movslq %r12d,%r12
  804210f32f:	4c 89 e2             	mov    %r12,%rdx
  804210f332:	4c 89 ee             	mov    %r13,%rsi
  804210f335:	4c 89 f7             	mov    %r14,%rdi
  804210f338:	41 ff d7             	call   *%r15
            cprintf("%.*s", len_cpy, cputs_buf);
  804210f33b:	4c 89 f2             	mov    %r14,%rdx
  804210f33e:	8b 75 bc             	mov    -0x44(%rbp),%esi
  804210f341:	48 bf 9b 01 12 42 80 	movabs $0x804212019b,%rdi
  804210f348:	00 00 00 
  804210f34b:	b8 00 00 00 00       	mov    $0x0,%eax
  804210f350:	48 b9 70 cf 10 42 80 	movabs $0x804210cf70,%rcx
  804210f357:	00 00 00 
  804210f35a:	ff d1                	call   *%rcx
            s += len_cpy;
  804210f35c:	4d 01 e5             	add    %r12,%r13
        while (len > 0) {
  804210f35f:	4c 29 e3             	sub    %r12,%rbx
  804210f362:	75 b7                	jne    804210f31b <syscall+0x7c>
  804210f364:	eb 0f                	jmp    804210f375 <syscall+0xd6>
        return cons_getc();
  804210f366:	48 b8 85 0b 10 42 80 	movabs $0x8042100b85,%rax
  804210f36d:	00 00 00 
  804210f370:	ff d0                	call   *%rax
        case SYS_cgetc:
            return sys_cgetc();
  804210f372:	48 63 d8             	movslq %eax,%rbx
        case SYS_ipc_recv:
            return sys_ipc_recv((uintptr_t)a1, (uintptr_t)a2);
        case SYS_gettime: return sys_gettime();
        }
        return -E_NO_SYS;
    }
  804210f375:	48 89 d8             	mov    %rbx,%rax
  804210f378:	48 83 c4 28          	add    $0x28,%rsp
  804210f37c:	5b                   	pop    %rbx
  804210f37d:	41 5c                	pop    %r12
  804210f37f:	41 5d                	pop    %r13
  804210f381:	41 5e                	pop    %r14
  804210f383:	41 5f                	pop    %r15
  804210f385:	5d                   	pop    %rbp
  804210f386:	c3                   	ret
            return sys_getenvid();
  804210f387:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210f38e:	00 00 00 
  804210f391:	48 63 98 c8 00 00 00 	movslq 0xc8(%rax),%rbx
  804210f398:	eb db                	jmp    804210f375 <syscall+0xd6>
        int res = envid2env(envid, &env, 1);
  804210f39a:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f39f:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f3a3:	44 89 e7             	mov    %r12d,%edi
  804210f3a6:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f3ad:	00 00 00 
  804210f3b0:	ff d0                	call   *%rax
        if (res < 0) {
  804210f3b2:	85 c0                	test   %eax,%eax
  804210f3b4:	78 15                	js     804210f3cb <syscall+0x12c>
        env_destroy(env);
  804210f3b6:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210f3ba:	48 b8 e4 c7 10 42 80 	movabs $0x804210c7e4,%rax
  804210f3c1:	00 00 00 
  804210f3c4:	ff d0                	call   *%rax
        return 0;
  804210f3c6:	b8 00 00 00 00       	mov    $0x0,%eax
            return sys_env_destroy((envid_t)a1);
  804210f3cb:	48 63 d8             	movslq %eax,%rbx
  804210f3ce:	eb a5                	jmp    804210f375 <syscall+0xd6>
    int res = envid2env(envid, &env, 1);
  804210f3d0:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f3d5:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f3d9:	44 89 e7             	mov    %r12d,%edi
  804210f3dc:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f3e3:	00 00 00 
  804210f3e6:	ff d0                	call   *%rax
    if (res < 0) {
  804210f3e8:	85 c0                	test   %eax,%eax
  804210f3ea:	78 71                	js     804210f45d <syscall+0x1be>
    if (addr + size > MAX_USER_ADDRESS || (addr & CLASS_MASK(0)) != 0) {
  804210f3ec:	4b 8d 44 3d 00       	lea    0x0(%r13,%r15,1),%rax
  804210f3f1:	48 ba 00 00 00 00 80 	movabs $0x8000000000,%rdx
  804210f3f8:	00 00 00 
  804210f3fb:	48 39 c2             	cmp    %rax,%rdx
  804210f3fe:	72 65                	jb     804210f465 <syscall+0x1c6>
  804210f400:	41 f7 c5 ff 0f 00 00 	test   $0xfff,%r13d
  804210f407:	75 63                	jne    804210f46c <syscall+0x1cd>
            return sys_alloc_region((envid_t)a1, (uintptr_t)a2, (size_t)a3, (int)a4);
  804210f409:	45 89 f1             	mov    %r14d,%r9d
    if ((perm & (~(PROT_ALL | ALLOC_ONE | ALLOC_ZERO))) != 0) {
  804210f40c:	41 f7 c6 00 f0 cf ff 	test   $0xffcff000,%r14d
  804210f413:	75 5e                	jne    804210f473 <syscall+0x1d4>
        perm |= ALLOC_ZERO;
  804210f415:	44 89 f0             	mov    %r14d,%eax
  804210f418:	0d 00 00 10 00       	or     $0x100000,%eax
  804210f41d:	41 f7 c6 00 00 30 00 	test   $0x300000,%r14d
  804210f424:	44 0f 44 c8          	cmove  %eax,%r9d
    res = map_region(&env->address_space, addr, NULL, 0, size, PROT_LAZY | PROT_USER_ | perm);
  804210f428:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210f42c:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804210f433:	41 80 c9 a0          	or     $0xa0,%r9b
  804210f437:	4d 89 f8             	mov    %r15,%r8
  804210f43a:	b9 00 00 00 00       	mov    $0x0,%ecx
  804210f43f:	ba 00 00 00 00       	mov    $0x0,%edx
  804210f444:	4c 89 ee             	mov    %r13,%rsi
  804210f447:	48 b8 59 be 10 42 80 	movabs $0x804210be59,%rax
  804210f44e:	00 00 00 
  804210f451:	ff d0                	call   *%rax
    if (res < 0) {
  804210f453:	85 c0                	test   %eax,%eax
  804210f455:	ba 00 00 00 00       	mov    $0x0,%edx
  804210f45a:	0f 4f c2             	cmovg  %edx,%eax
            return sys_alloc_region((envid_t)a1, (uintptr_t)a2, (size_t)a3, (int)a4);
  804210f45d:	48 63 d8             	movslq %eax,%rbx
  804210f460:	e9 10 ff ff ff       	jmp    804210f375 <syscall+0xd6>
        return -E_INVAL;
  804210f465:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f46a:	eb f1                	jmp    804210f45d <syscall+0x1be>
  804210f46c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f471:	eb ea                	jmp    804210f45d <syscall+0x1be>
        return -E_INVAL;
  804210f473:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f478:	eb e3                	jmp    804210f45d <syscall+0x1be>
        int res = envid2env(srcenvid, &srcenv, 1);
  804210f47a:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f47f:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  804210f483:	44 89 e7             	mov    %r12d,%edi
  804210f486:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f48d:	00 00 00 
  804210f490:	ff d0                	call   *%rax
        if (res < 0) {
  804210f492:	85 c0                	test   %eax,%eax
  804210f494:	0f 88 8c 00 00 00    	js     804210f526 <syscall+0x287>
        res = envid2env(dstenvid, &dstenv, 1);
  804210f49a:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f49f:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f4a3:	44 89 ff             	mov    %r15d,%edi
  804210f4a6:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f4ad:	00 00 00 
  804210f4b0:	ff d0                	call   *%rax
        if (res < 0) {
  804210f4b2:	85 c0                	test   %eax,%eax
  804210f4b4:	78 70                	js     804210f526 <syscall+0x287>
        if (srcva + size > MAX_USER_ADDRESS || (srcva & CLASS_MASK(0)) != 0 || dstva + size > MAX_USER_ADDRESS || (dstva & CLASS_MASK(0)) != 0) {
  804210f4b6:	49 8d 44 1d 00       	lea    0x0(%r13,%rbx,1),%rax
  804210f4bb:	48 ba 00 00 00 00 80 	movabs $0x8000000000,%rdx
  804210f4c2:	00 00 00 
  804210f4c5:	48 39 c2             	cmp    %rax,%rdx
  804210f4c8:	72 64                	jb     804210f52e <syscall+0x28f>
  804210f4ca:	4a 8d 04 33          	lea    (%rbx,%r14,1),%rax
  804210f4ce:	48 39 c2             	cmp    %rax,%rdx
  804210f4d1:	72 62                	jb     804210f535 <syscall+0x296>
  804210f4d3:	4c 89 e8             	mov    %r13,%rax
  804210f4d6:	4c 09 f0             	or     %r14,%rax
  804210f4d9:	a9 ff 0f 00 00       	test   $0xfff,%eax
  804210f4de:	75 5c                	jne    804210f53c <syscall+0x29d>
        if ((perm & (~PROT_ALL)) != 0) {
  804210f4e0:	81 7d 10 ff 0f 00 00 	cmpl   $0xfff,0x10(%rbp)
  804210f4e7:	77 5a                	ja     804210f543 <syscall+0x2a4>
        res = map_region(&dstenv->address_space, dstva, &srcenv->address_space, srcva, size, PROT_USER_ | perm);
  804210f4e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804210f4ed:	48 8d 90 e8 00 00 00 	lea    0xe8(%rax),%rdx
  804210f4f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210f4f8:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804210f4ff:	44 8b 4d 10          	mov    0x10(%rbp),%r9d
  804210f503:	41 83 c9 20          	or     $0x20,%r9d
  804210f507:	49 89 d8             	mov    %rbx,%r8
  804210f50a:	4c 89 e9             	mov    %r13,%rcx
  804210f50d:	4c 89 f6             	mov    %r14,%rsi
  804210f510:	48 b8 59 be 10 42 80 	movabs $0x804210be59,%rax
  804210f517:	00 00 00 
  804210f51a:	ff d0                	call   *%rax
        if (res < 0) {
  804210f51c:	85 c0                	test   %eax,%eax
  804210f51e:	ba 00 00 00 00       	mov    $0x0,%edx
  804210f523:	0f 4f c2             	cmovg  %edx,%eax
            return sys_map_region((envid_t)a1, (uintptr_t)a2, (envid_t)a3, (uintptr_t)a4, (size_t)a5, (int)a6);
  804210f526:	48 63 d8             	movslq %eax,%rbx
  804210f529:	e9 47 fe ff ff       	jmp    804210f375 <syscall+0xd6>
            return -E_INVAL;
  804210f52e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f533:	eb f1                	jmp    804210f526 <syscall+0x287>
  804210f535:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f53a:	eb ea                	jmp    804210f526 <syscall+0x287>
  804210f53c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f541:	eb e3                	jmp    804210f526 <syscall+0x287>
            return -E_INVAL;
  804210f543:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f548:	eb dc                	jmp    804210f526 <syscall+0x287>
            return sys_unmap_region((envid_t)a1, (uintptr_t)a2, (size_t)a3);
  804210f54a:	89 f7                	mov    %esi,%edi
        if (va + size >= MAX_USER_ADDRESS || (va & CLASS_MASK(0)) != 0)
  804210f54c:	49 8d 44 0d 00       	lea    0x0(%r13,%rcx,1),%rax
  804210f551:	48 c1 e8 27          	shr    $0x27,%rax
  804210f555:	75 4c                	jne    804210f5a3 <syscall+0x304>
  804210f557:	41 f7 c5 ff 0f 00 00 	test   $0xfff,%r13d
  804210f55e:	75 4a                	jne    804210f5aa <syscall+0x30b>
        int result = envid2env(envid, &env, 1);
  804210f560:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f565:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f569:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f570:	00 00 00 
  804210f573:	ff d0                	call   *%rax
        if (result < 0)
  804210f575:	85 c0                	test   %eax,%eax
  804210f577:	78 22                	js     804210f59b <syscall+0x2fc>
        unmap_region(&env->address_space, va, size);
  804210f579:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210f57d:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804210f584:	4c 89 fa             	mov    %r15,%rdx
  804210f587:	4c 89 ee             	mov    %r13,%rsi
  804210f58a:	48 b8 54 87 10 42 80 	movabs $0x8042108754,%rax
  804210f591:	00 00 00 
  804210f594:	ff d0                	call   *%rax
        return 0;
  804210f596:	b8 00 00 00 00       	mov    $0x0,%eax
            return sys_unmap_region((envid_t)a1, (uintptr_t)a2, (size_t)a3);
  804210f59b:	48 63 d8             	movslq %eax,%rbx
  804210f59e:	e9 d2 fd ff ff       	jmp    804210f375 <syscall+0xd6>
            return -E_INVAL;
  804210f5a3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f5a8:	eb f1                	jmp    804210f59b <syscall+0x2fc>
  804210f5aa:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f5af:	eb ea                	jmp    804210f59b <syscall+0x2fc>
    int res = envid2env(envid, &env, 1);
  804210f5b1:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f5b6:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f5ba:	44 89 ef             	mov    %r13d,%edi
  804210f5bd:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f5c4:	00 00 00 
  804210f5c7:	ff d0                	call   *%rax
    if (res < 0) {
  804210f5c9:	85 c0                	test   %eax,%eax
  804210f5cb:	78 68                	js     804210f635 <syscall+0x396>
    if (env->env_type != ENV_TYPE_FS) {
  804210f5cd:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210f5d1:	83 bf d0 00 00 00 03 	cmpl   $0x3,0xd0(%rdi)
  804210f5d8:	75 63                	jne    804210f63d <syscall+0x39e>
    if (va + size > MAX_USER_ADDRESS || (va & CLASS_MASK(0)) != 0) {
  804210f5da:	4b 8d 04 37          	lea    (%r15,%r14,1),%rax
  804210f5de:	48 ba 00 00 00 00 80 	movabs $0x8000000000,%rdx
  804210f5e5:	00 00 00 
  804210f5e8:	48 39 c2             	cmp    %rax,%rdx
  804210f5eb:	72 57                	jb     804210f644 <syscall+0x3a5>
    if ((pa & CLASS_MASK(0)) != 0 || (size & CLASS_MASK(0)) != 0) {
  804210f5ed:	4c 89 f8             	mov    %r15,%rax
  804210f5f0:	4c 09 f0             	or     %r14,%rax
  804210f5f3:	4c 09 e0             	or     %r12,%rax
  804210f5f6:	a9 ff 0f 00 00       	test   $0xfff,%eax
  804210f5fb:	75 4e                	jne    804210f64b <syscall+0x3ac>
   if ((perm & (~PROT_ALL)) != 0) {
  804210f5fd:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  804210f603:	77 4d                	ja     804210f652 <syscall+0x3b3>
    res = map_physical_region(&env->address_space, va, pa, size, perm | MAP_USER_MMIO | PROT_USER_);
  804210f605:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
  804210f60c:	41 89 d8             	mov    %ebx,%r8d
  804210f60f:	41 81 c8 20 00 40 00 	or     $0x400020,%r8d
  804210f616:	4c 89 f1             	mov    %r14,%rcx
  804210f619:	4c 89 e2             	mov    %r12,%rdx
  804210f61c:	4c 89 fe             	mov    %r15,%rsi
  804210f61f:	48 b8 17 9c 10 42 80 	movabs $0x8042109c17,%rax
  804210f626:	00 00 00 
  804210f629:	ff d0                	call   *%rax
    if (res < 0) {
  804210f62b:	85 c0                	test   %eax,%eax
  804210f62d:	ba 00 00 00 00       	mov    $0x0,%edx
  804210f632:	0f 4f c2             	cmovg  %edx,%eax
            return sys_map_physical_region(a1, (envid_t)a2, a3, (size_t)a4, (int)a5);
  804210f635:	48 63 d8             	movslq %eax,%rbx
  804210f638:	e9 38 fd ff ff       	jmp    804210f375 <syscall+0xd6>
        return -E_BAD_ENV;
  804210f63d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804210f642:	eb f1                	jmp    804210f635 <syscall+0x396>
        return -E_INVAL;
  804210f644:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f649:	eb ea                	jmp    804210f635 <syscall+0x396>
        return -E_INVAL;
  804210f64b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f650:	eb e3                	jmp    804210f635 <syscall+0x396>
        return -E_INVAL;
  804210f652:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f657:	eb dc                	jmp    804210f635 <syscall+0x396>
      if (!curenv) {
  804210f659:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210f660:	00 00 00 
  804210f663:	48 85 c0             	test   %rax,%rax
  804210f666:	74 3d                	je     804210f6a5 <syscall+0x406>
       return region_maxref(&curenv->address_space, addr, size) - region_maxref(&curenv->address_space, addr2, size2);
  804210f668:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804210f66f:	4c 89 ea             	mov    %r13,%rdx
  804210f672:	49 bc 78 76 10 42 80 	movabs $0x8042107678,%r12
  804210f679:	00 00 00 
  804210f67c:	41 ff d4             	call   *%r12
  804210f67f:	89 c3                	mov    %eax,%ebx
  804210f681:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210f688:	00 00 00 
  804210f68b:	48 8d b8 e8 00 00 00 	lea    0xe8(%rax),%rdi
  804210f692:	4c 89 f2             	mov    %r14,%rdx
  804210f695:	4c 89 fe             	mov    %r15,%rsi
  804210f698:	41 ff d4             	call   *%r12
  804210f69b:	29 c3                	sub    %eax,%ebx
            return sys_region_refs((uintptr_t)a1, (size_t)a2, (uintptr_t)a3, (size_t)a4);
  804210f69d:	48 63 db             	movslq %ebx,%rbx
  804210f6a0:	e9 d0 fc ff ff       	jmp    804210f375 <syscall+0xd6>
           return -E_BAD_ENV;
  804210f6a5:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
  804210f6aa:	eb f1                	jmp    804210f69d <syscall+0x3fe>
        int result = env_alloc(&new_env, curenv->env_id, ENV_TYPE_USER); 
  804210f6ac:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210f6b3:	00 00 00 
  804210f6b6:	8b b0 c8 00 00 00    	mov    0xc8(%rax),%esi
  804210f6bc:	ba 02 00 00 00       	mov    $0x2,%edx
  804210f6c1:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  804210f6c5:	48 b8 14 c4 10 42 80 	movabs $0x804210c414,%rax
  804210f6cc:	00 00 00 
  804210f6cf:	ff d0                	call   *%rax
        if (result < 0) {
  804210f6d1:	85 c0                	test   %eax,%eax
  804210f6d3:	78 34                	js     804210f709 <syscall+0x46a>
        new_env->env_status = ENV_NOT_RUNNABLE; 
  804210f6d5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804210f6d9:	c7 82 d4 00 00 00 04 	movl   $0x4,0xd4(%rdx)
  804210f6e0:	00 00 00 
        new_env->env_tf = curenv->env_tf;
  804210f6e3:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210f6ea:	00 00 00 
  804210f6ed:	48 8b 30             	mov    (%rax),%rsi
  804210f6f0:	b9 18 00 00 00       	mov    $0x18,%ecx
  804210f6f5:	48 89 d7             	mov    %rdx,%rdi
  804210f6f8:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
        new_env->env_tf.tf_regs.reg_rax = 0;
  804210f6fb:	48 c7 42 70 00 00 00 	movq   $0x0,0x70(%rdx)
  804210f702:	00 
        return new_env->env_id;
  804210f703:	8b 82 c8 00 00 00    	mov    0xc8(%rdx),%eax
            return sys_exofork();
  804210f709:	48 63 d8             	movslq %eax,%rbx
  804210f70c:	e9 64 fc ff ff       	jmp    804210f375 <syscall+0xd6>
        int result = envid2env(envid, &env, 1);
  804210f711:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f716:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f71a:	44 89 e7             	mov    %r12d,%edi
  804210f71d:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f724:	00 00 00 
  804210f727:	ff d0                	call   *%rax
        if (result < 0){
  804210f729:	85 c0                	test   %eax,%eax
  804210f72b:	78 1b                	js     804210f748 <syscall+0x4a9>
        if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE){
  804210f72d:	41 8d 45 fe          	lea    -0x2(%r13),%eax
  804210f731:	a9 fd ff ff ff       	test   $0xfffffffd,%eax
  804210f736:	75 18                	jne    804210f750 <syscall+0x4b1>
        env->env_status = status;
  804210f738:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210f73c:	44 89 a8 d4 00 00 00 	mov    %r13d,0xd4(%rax)
        return 0;
  804210f743:	b8 00 00 00 00       	mov    $0x0,%eax
            return sys_env_set_status((envid_t)a1, (int)a2);
  804210f748:	48 63 d8             	movslq %eax,%rbx
  804210f74b:	e9 25 fc ff ff       	jmp    804210f375 <syscall+0xd6>
            return -E_INVAL;
  804210f750:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f755:	eb f1                	jmp    804210f748 <syscall+0x4a9>
    int res = envid2env(envid, &env, 1);
  804210f757:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f75c:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f760:	44 89 e7             	mov    %r12d,%edi
  804210f763:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f76a:	00 00 00 
  804210f76d:	ff d0                	call   *%rax
    if (res < 0) {
  804210f76f:	85 c0                	test   %eax,%eax
  804210f771:	78 78                	js     804210f7eb <syscall+0x54c>
    user_mem_assert(curenv, tf, sizeof(*tf), PROT_R);
  804210f773:	b9 04 00 00 00       	mov    $0x4,%ecx
  804210f778:	ba c0 00 00 00       	mov    $0xc0,%edx
  804210f77d:	4c 89 ee             	mov    %r13,%rsi
  804210f780:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210f787:	00 00 00 
  804210f78a:	48 8b 38             	mov    (%rax),%rdi
  804210f78d:	48 b8 2a 78 10 42 80 	movabs $0x804210782a,%rax
  804210f794:	00 00 00 
  804210f797:	ff d0                	call   *%rax
    nosan_memcpy(&env->env_tf, tf, sizeof(*tf));
  804210f799:	ba c0 00 00 00       	mov    $0xc0,%edx
  804210f79e:	4c 89 ee             	mov    %r13,%rsi
  804210f7a1:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804210f7a5:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804210f7ac:	00 00 00 
  804210f7af:	ff d0                	call   *%rax
    env->env_tf.tf_ds |= 3;
  804210f7b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210f7b5:	66 83 88 80 00 00 00 	orw    $0x3,0x80(%rax)
  804210f7bc:	03 
    env->env_tf.tf_es |= 3;
  804210f7bd:	66 83 48 78 03       	orw    $0x3,0x78(%rax)
    env->env_tf.tf_ss |= 3;
  804210f7c2:	66 83 88 b8 00 00 00 	orw    $0x3,0xb8(%rax)
  804210f7c9:	03 
    env->env_tf.tf_cs |= 3;
  804210f7ca:	66 83 88 a0 00 00 00 	orw    $0x3,0xa0(%rax)
  804210f7d1:	03 
    env->env_tf.tf_rflags &= ~FL_IOPL_MASK;
  804210f7d2:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  804210f7d9:	80 e6 cf             	and    $0xcf,%dh
  804210f7dc:	80 ce 02             	or     $0x2,%dh
  804210f7df:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
    return 0;
  804210f7e6:	b8 00 00 00 00       	mov    $0x0,%eax
            return sys_env_set_trapframe((envid_t)a1, (struct Trapframe *)a2);
  804210f7eb:	48 63 d8             	movslq %eax,%rbx
  804210f7ee:	e9 82 fb ff ff       	jmp    804210f375 <syscall+0xd6>
        int result = envid2env(envid, &env, 1);
  804210f7f3:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f7f8:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f7fc:	44 89 e7             	mov    %r12d,%edi
  804210f7ff:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f806:	00 00 00 
  804210f809:	ff d0                	call   *%rax
        if (result < 0){
  804210f80b:	85 c0                	test   %eax,%eax
  804210f80d:	78 10                	js     804210f81f <syscall+0x580>
        env->env_pgfault_upcall = func;
  804210f80f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210f813:	4c 89 a8 00 01 00 00 	mov    %r13,0x100(%rax)
        return 0;
  804210f81a:	b8 00 00 00 00       	mov    $0x0,%eax
            return sys_env_set_pgfault_upcall((envid_t)a1, (void *)a2);
  804210f81f:	48 63 d8             	movslq %eax,%rbx
  804210f822:	e9 4e fb ff ff       	jmp    804210f375 <syscall+0xd6>
        sched_yield();
  804210f827:	48 b8 a6 f1 10 42 80 	movabs $0x804210f1a6,%rax
  804210f82e:	00 00 00 
  804210f831:	ff d0                	call   *%rax
    int result = envid2env(envid, &env, 0);
  804210f833:	ba 00 00 00 00       	mov    $0x0,%edx
  804210f838:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
  804210f83c:	44 89 e7             	mov    %r12d,%edi
  804210f83f:	48 b8 81 c2 10 42 80 	movabs $0x804210c281,%rax
  804210f846:	00 00 00 
  804210f849:	ff d0                	call   *%rax
    if (result < 0){
  804210f84b:	85 c0                	test   %eax,%eax
  804210f84d:	0f 88 16 01 00 00    	js     804210f969 <syscall+0x6ca>
    if (!env->env_ipc_recving){
  804210f853:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210f857:	80 b8 08 01 00 00 00 	cmpb   $0x0,0x108(%rax)
  804210f85e:	0f 84 0d 01 00 00    	je     804210f971 <syscall+0x6d2>
    if (srcva < MAX_USER_ADDRESS) {
  804210f864:	4c 89 f9             	mov    %r15,%rcx
  804210f867:	48 c1 e9 27          	shr    $0x27,%rcx
  804210f86b:	0f 85 b7 00 00 00    	jne    804210f928 <syscall+0x689>
        if ((srcva & CLASS_MASK(0)) != 0){
  804210f871:	41 f7 c7 ff 0f 00 00 	test   $0xfff,%r15d
  804210f878:	0f 85 fa 00 00 00    	jne    804210f978 <syscall+0x6d9>
        while (size & ~CLASS_MASK(class)){
  804210f87e:	49 81 fe ff 0f 00 00 	cmp    $0xfff,%r14
  804210f885:	76 1b                	jbe    804210f8a2 <syscall+0x603>
  804210f887:	b9 0d 00 00 00       	mov    $0xd,%ecx
  804210f88c:	ba 01 00 00 00       	mov    $0x1,%edx
  804210f891:	48 89 d0             	mov    %rdx,%rax
  804210f894:	48 d3 e0             	shl    %cl,%rax
  804210f897:	48 f7 d8             	neg    %rax
  804210f89a:	83 c1 01             	add    $0x1,%ecx
  804210f89d:	4c 85 f0             	test   %r14,%rax
  804210f8a0:	75 ef                	jne    804210f891 <syscall+0x5f2>
            return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (uintptr_t)a3, (size_t)a4, (int)a5);
  804210f8a2:	89 d9                	mov    %ebx,%ecx
        user_mem_assert(curenv, (void *)srcva, size, perm);
  804210f8a4:	4c 89 f2             	mov    %r14,%rdx
  804210f8a7:	4c 89 fe             	mov    %r15,%rsi
  804210f8aa:	48 b8 70 64 00 43 80 	movabs $0x8043006470,%rax
  804210f8b1:	00 00 00 
  804210f8b4:	48 8b 38             	mov    (%rax),%rdi
  804210f8b7:	48 b8 2a 78 10 42 80 	movabs $0x804210782a,%rax
  804210f8be:	00 00 00 
  804210f8c1:	ff d0                	call   *%rax
        if ((perm & (~PROT_ALL)) != 0){
  804210f8c3:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  804210f8c9:	0f 87 b0 00 00 00    	ja     804210f97f <syscall+0x6e0>
        if (env->env_ipc_dstva < MAX_USER_ADDRESS){
  804210f8cf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804210f8d3:	48 8b b2 10 01 00 00 	mov    0x110(%rdx),%rsi
  804210f8da:	48 89 f0             	mov    %rsi,%rax
  804210f8dd:	48 c1 e8 27          	shr    $0x27,%rax
  804210f8e1:	74 0c                	je     804210f8ef <syscall+0x650>
        env->env_ipc_perm = perm;
  804210f8e3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804210f8e7:	89 98 28 01 00 00    	mov    %ebx,0x128(%rax)
  804210f8ed:	eb 43                	jmp    804210f932 <syscall+0x693>
            result = map_region(&env->address_space, env->env_ipc_dstva, &curenv->address_space, srcva, size, perm | PROT_USER_);
  804210f8ef:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210f8f6:	00 00 00 
  804210f8f9:	48 05 e8 00 00 00    	add    $0xe8,%rax
  804210f8ff:	48 8d ba e8 00 00 00 	lea    0xe8(%rdx),%rdi
  804210f906:	41 89 d9             	mov    %ebx,%r9d
  804210f909:	41 83 c9 20          	or     $0x20,%r9d
  804210f90d:	4d 89 f0             	mov    %r14,%r8
  804210f910:	4c 89 f9             	mov    %r15,%rcx
  804210f913:	48 89 c2             	mov    %rax,%rdx
  804210f916:	48 b8 59 be 10 42 80 	movabs $0x804210be59,%rax
  804210f91d:	00 00 00 
  804210f920:	ff d0                	call   *%rax
            if (result < 0){
  804210f922:	85 c0                	test   %eax,%eax
  804210f924:	79 bd                	jns    804210f8e3 <syscall+0x644>
  804210f926:	eb 41                	jmp    804210f969 <syscall+0x6ca>
        env->env_ipc_perm = 0;
  804210f928:	c7 80 28 01 00 00 00 	movl   $0x0,0x128(%rax)
  804210f92f:	00 00 00 
    env->env_ipc_recving = 0;
  804210f932:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804210f936:	c6 82 08 01 00 00 00 	movb   $0x0,0x108(%rdx)
    env->env_ipc_from = curenv->env_id;
  804210f93d:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210f944:	00 00 00 
  804210f947:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  804210f94d:	89 82 24 01 00 00    	mov    %eax,0x124(%rdx)
            return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (uintptr_t)a3, (size_t)a4, (int)a5);
  804210f953:	44 89 aa 20 01 00 00 	mov    %r13d,0x120(%rdx)
    env->env_status = ENV_RUNNABLE;
  804210f95a:	c7 82 d4 00 00 00 02 	movl   $0x2,0xd4(%rdx)
  804210f961:	00 00 00 
        return 0;
  804210f964:	b8 00 00 00 00       	mov    $0x0,%eax
            return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (uintptr_t)a3, (size_t)a4, (int)a5);
  804210f969:	48 63 d8             	movslq %eax,%rbx
  804210f96c:	e9 04 fa ff ff       	jmp    804210f375 <syscall+0xd6>
        return -E_IPC_NOT_RECV;
  804210f971:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  804210f976:	eb f1                	jmp    804210f969 <syscall+0x6ca>
            return -E_INVAL;
  804210f978:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f97d:	eb ea                	jmp    804210f969 <syscall+0x6ca>
            return -E_INVAL;
  804210f97f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804210f984:	eb e3                	jmp    804210f969 <syscall+0x6ca>
        if (dstva < MAX_USER_ADDRESS && (maxsize == 0 || (maxsize & CLASS_MASK(0)) != 0)) {
  804210f986:	48 89 f0             	mov    %rsi,%rax
  804210f989:	48 c1 e8 27          	shr    $0x27,%rax
  804210f98d:	75 1e                	jne    804210f9ad <syscall+0x70e>
  804210f98f:	4d 85 ed             	test   %r13,%r13
  804210f992:	74 76                	je     804210fa0a <syscall+0x76b>
        if (dstva < MAX_USER_ADDRESS && (dstva & CLASS_MASK(0)) != 0) {
  804210f994:	48 89 f0             	mov    %rsi,%rax
  804210f997:	4c 09 e8             	or     %r13,%rax
  804210f99a:	a9 ff 0f 00 00       	test   $0xfff,%eax
  804210f99f:	74 0c                	je     804210f9ad <syscall+0x70e>
            return sys_ipc_recv((uintptr_t)a1, (uintptr_t)a2);
  804210f9a1:	48 c7 c3 fd ff ff ff 	mov    $0xfffffffffffffffd,%rbx
  804210f9a8:	e9 c8 f9 ff ff       	jmp    804210f375 <syscall+0xd6>
        curenv->env_ipc_recving = true;
  804210f9ad:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210f9b4:	00 00 00 
  804210f9b7:	c6 80 08 01 00 00 01 	movb   $0x1,0x108(%rax)
        curenv->env_ipc_dstva = dstva;
  804210f9be:	4c 89 a0 10 01 00 00 	mov    %r12,0x110(%rax)
        curenv->env_ipc_maxsz = maxsize;
  804210f9c5:	4c 89 a8 18 01 00 00 	mov    %r13,0x118(%rax)
        curenv->env_status = ENV_NOT_RUNNABLE;
  804210f9cc:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  804210f9d3:	00 00 00 
        curenv->env_tf.tf_regs.reg_rax = 0;
  804210f9d6:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  804210f9dd:	00 
        sched_yield();
  804210f9de:	48 b8 a6 f1 10 42 80 	movabs $0x804210f1a6,%rax
  804210f9e5:	00 00 00 
  804210f9e8:	ff d0                	call   *%rax
    return gettime();
  804210f9ea:	48 b8 66 ca 10 42 80 	movabs $0x804210ca66,%rax
  804210f9f1:	00 00 00 
  804210f9f4:	ff d0                	call   *%rax
        case SYS_gettime: return sys_gettime();
  804210f9f6:	48 63 d8             	movslq %eax,%rbx
  804210f9f9:	e9 77 f9 ff ff       	jmp    804210f375 <syscall+0xd6>
        switch (syscallno) {
  804210f9fe:	48 c7 c3 f7 ff ff ff 	mov    $0xfffffffffffffff7,%rbx
  804210fa05:	e9 6b f9 ff ff       	jmp    804210f375 <syscall+0xd6>
            return sys_ipc_recv((uintptr_t)a1, (uintptr_t)a2);
  804210fa0a:	48 c7 c3 fd ff ff ff 	mov    $0xfffffffffffffffd,%rbx
  804210fa11:	e9 5f f9 ff ff       	jmp    804210f375 <syscall+0xd6>

000000804210fa16 <load_kernel_dwarf_info>:
#include <kern/pmap.h>
#include <kern/env.h>
#include <inc/uefi.h>

void
load_kernel_dwarf_info(struct Dwarf_Addrs *addrs) {
  804210fa16:	f3 0f 1e fa          	endbr64
    addrs->aranges_begin = (uint8_t *)(uefi_lp->DebugArangesStart);
  804210fa1a:	48 b9 00 30 14 42 80 	movabs $0x8042143000,%rcx
  804210fa21:	00 00 00 
  804210fa24:	48 8b 11             	mov    (%rcx),%rdx
  804210fa27:	48 8b 72 58          	mov    0x58(%rdx),%rsi
  804210fa2b:	48 89 77 10          	mov    %rsi,0x10(%rdi)
    addrs->aranges_end = (uint8_t *)(uefi_lp->DebugArangesEnd);
  804210fa2f:	48 8b 72 60          	mov    0x60(%rdx),%rsi
  804210fa33:	48 89 77 18          	mov    %rsi,0x18(%rdi)
    addrs->abbrev_begin = (uint8_t *)(uefi_lp->DebugAbbrevStart);
  804210fa37:	48 8b 52 68          	mov    0x68(%rdx),%rdx
  804210fa3b:	48 89 17             	mov    %rdx,(%rdi)
    addrs->abbrev_end = (uint8_t *)(uefi_lp->DebugAbbrevEnd);
  804210fa3e:	48 8b 11             	mov    (%rcx),%rdx
  804210fa41:	48 8b 4a 70          	mov    0x70(%rdx),%rcx
  804210fa45:	48 89 4f 08          	mov    %rcx,0x8(%rdi)
    addrs->info_begin = (uint8_t *)(uefi_lp->DebugInfoStart);
  804210fa49:	48 8b 4a 78          	mov    0x78(%rdx),%rcx
  804210fa4d:	48 89 4f 20          	mov    %rcx,0x20(%rdi)
    addrs->info_end = (uint8_t *)(uefi_lp->DebugInfoEnd);
  804210fa51:	48 8b 8a 80 00 00 00 	mov    0x80(%rdx),%rcx
  804210fa58:	48 89 4f 28          	mov    %rcx,0x28(%rdi)
    addrs->line_begin = (uint8_t *)(uefi_lp->DebugLineStart);
  804210fa5c:	48 8b 8a 88 00 00 00 	mov    0x88(%rdx),%rcx
  804210fa63:	48 89 4f 30          	mov    %rcx,0x30(%rdi)
    addrs->line_end = (uint8_t *)(uefi_lp->DebugLineEnd);
  804210fa67:	48 8b 8a 90 00 00 00 	mov    0x90(%rdx),%rcx
  804210fa6e:	48 89 4f 38          	mov    %rcx,0x38(%rdi)
    addrs->str_begin = (uint8_t *)(uefi_lp->DebugStrStart);
  804210fa72:	48 8b 8a 98 00 00 00 	mov    0x98(%rdx),%rcx
  804210fa79:	48 89 4f 40          	mov    %rcx,0x40(%rdi)
    addrs->str_end = (uint8_t *)(uefi_lp->DebugStrEnd);
  804210fa7d:	48 8b 8a a0 00 00 00 	mov    0xa0(%rdx),%rcx
  804210fa84:	48 89 4f 48          	mov    %rcx,0x48(%rdi)
    addrs->pubnames_begin = (uint8_t *)(uefi_lp->DebugPubnamesStart);
  804210fa88:	48 8b 8a a8 00 00 00 	mov    0xa8(%rdx),%rcx
  804210fa8f:	48 89 4f 50          	mov    %rcx,0x50(%rdi)
    addrs->pubnames_end = (uint8_t *)(uefi_lp->DebugPubnamesEnd);
  804210fa93:	48 8b 8a b0 00 00 00 	mov    0xb0(%rdx),%rcx
  804210fa9a:	48 89 4f 58          	mov    %rcx,0x58(%rdi)
    addrs->pubtypes_begin = (uint8_t *)(uefi_lp->DebugPubtypesStart);
  804210fa9e:	48 8b 8a b8 00 00 00 	mov    0xb8(%rdx),%rcx
  804210faa5:	48 89 4f 60          	mov    %rcx,0x60(%rdi)
    addrs->pubtypes_end = (uint8_t *)(uefi_lp->DebugPubtypesEnd);
  804210faa9:	48 8b 92 c0 00 00 00 	mov    0xc0(%rdx),%rdx
  804210fab0:	48 89 57 68          	mov    %rdx,0x68(%rdi)
}
  804210fab4:	c3                   	ret

000000804210fab5 <load_user_dwarf_info>:

void
load_user_dwarf_info(struct Dwarf_Addrs *addrs) {
  804210fab5:	f3 0f 1e fa          	endbr64
  804210fab9:	55                   	push   %rbp
  804210faba:	48 89 e5             	mov    %rsp,%rbp
  804210fabd:	41 57                	push   %r15
  804210fabf:	41 56                	push   %r14
  804210fac1:	41 55                	push   %r13
  804210fac3:	41 54                	push   %r12
  804210fac5:	53                   	push   %rbx
  804210fac6:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
    assert(curenv);
  804210facd:	48 a1 70 64 00 43 80 	movabs 0x8043006470,%rax
  804210fad4:	00 00 00 
  804210fad7:	48 85 c0             	test   %rax,%rax
  804210fada:	0f 84 60 01 00 00    	je     804210fc40 <load_user_dwarf_info+0x18b>

    uint8_t *binary = curenv->binary;
  804210fae0:	4c 8b a8 e0 00 00 00 	mov    0xe0(%rax),%r13
    assert(curenv->binary);
  804210fae7:	4d 85 ed             	test   %r13,%r13
  804210faea:	0f 84 80 01 00 00    	je     804210fc70 <load_user_dwarf_info+0x1bb>
    struct {
        const uint8_t **end;
        const uint8_t **start;
        const char *name;
    } sections[] = {
            {&addrs->aranges_end, &addrs->aranges_begin, ".debug_aranges"},
  804210faf0:	48 8d 47 18          	lea    0x18(%rdi),%rax
  804210faf4:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  804210fafb:	48 8d 47 10          	lea    0x10(%rdi),%rax
  804210faff:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
    } sections[] = {
  804210fb06:	48 b8 bd 01 12 42 80 	movabs $0x80421201bd,%rax
  804210fb0d:	00 00 00 
  804210fb10:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
            {&addrs->abbrev_end, &addrs->abbrev_begin, ".debug_abbrev"},
  804210fb17:	48 8d 47 08          	lea    0x8(%rdi),%rax
  804210fb1b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    } sections[] = {
  804210fb22:	48 89 bd 48 ff ff ff 	mov    %rdi,-0xb8(%rbp)
  804210fb29:	48 b8 cc 01 12 42 80 	movabs $0x80421201cc,%rax
  804210fb30:	00 00 00 
  804210fb33:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
            {&addrs->info_end, &addrs->info_begin, ".debug_info"},
  804210fb3a:	48 8d 47 28          	lea    0x28(%rdi),%rax
  804210fb3e:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  804210fb45:	48 8d 47 20          	lea    0x20(%rdi),%rax
  804210fb49:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
    } sections[] = {
  804210fb50:	48 b8 da 01 12 42 80 	movabs $0x80421201da,%rax
  804210fb57:	00 00 00 
  804210fb5a:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
            {&addrs->line_end, &addrs->line_begin, ".debug_line"},
  804210fb61:	48 8d 47 38          	lea    0x38(%rdi),%rax
  804210fb65:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  804210fb6c:	48 8d 47 30          	lea    0x30(%rdi),%rax
  804210fb70:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    } sections[] = {
  804210fb77:	48 b8 e6 01 12 42 80 	movabs $0x80421201e6,%rax
  804210fb7e:	00 00 00 
  804210fb81:	48 89 45 80          	mov    %rax,-0x80(%rbp)
            {&addrs->str_end, &addrs->str_begin, ".debug_str"},
  804210fb85:	48 8d 47 48          	lea    0x48(%rdi),%rax
  804210fb89:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  804210fb8d:	48 8d 47 40          	lea    0x40(%rdi),%rax
  804210fb91:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    } sections[] = {
  804210fb95:	48 b8 f2 01 12 42 80 	movabs $0x80421201f2,%rax
  804210fb9c:	00 00 00 
  804210fb9f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
            {&addrs->pubnames_end, &addrs->pubnames_begin, ".debug_pubnames"},
  804210fba3:	48 8d 47 58          	lea    0x58(%rdi),%rax
  804210fba7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  804210fbab:	48 8d 47 50          	lea    0x50(%rdi),%rax
  804210fbaf:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    } sections[] = {
  804210fbb3:	48 b8 fd 01 12 42 80 	movabs $0x80421201fd,%rax
  804210fbba:	00 00 00 
  804210fbbd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
            {&addrs->pubtypes_end, &addrs->pubtypes_begin, ".debug_pubtypes"},
  804210fbc1:	48 8d 47 68          	lea    0x68(%rdi),%rax
  804210fbc5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  804210fbc9:	48 8d 47 60          	lea    0x60(%rdi),%rax
  804210fbcd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    } sections[] = {
  804210fbd1:	48 b8 0d 02 12 42 80 	movabs $0x804212020d,%rax
  804210fbd8:	00 00 00 
  804210fbdb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    };

    memset(addrs, 0, sizeof(*addrs));
  804210fbdf:	ba 70 00 00 00       	mov    $0x70,%edx
  804210fbe4:	be 00 00 00 00       	mov    $0x0,%esi
  804210fbe9:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  804210fbf0:	00 00 00 
  804210fbf3:	ff d0                	call   *%rax

    /* Load debug sections from curenv->binary elf image */
    // LAB 8: Your code here
    (void)sections;
    struct Elf *elf = (struct Elf *)(binary);
    assert(elf->e_magic != ELF_MAGIC);
  804210fbf5:	41 81 7d 00 7f 45 4c 	cmpl   $0x464c457f,0x0(%r13)
  804210fbfc:	46 
  804210fbfd:	0f 84 a2 00 00 00    	je     804210fca5 <load_user_dwarf_info+0x1f0>

    struct Secthdr *section_headers = (struct Secthdr *)(binary + elf->e_shoff);
  804210fc03:	4d 89 ec             	mov    %r13,%r12
  804210fc06:	4d 03 65 28          	add    0x28(%r13),%r12
    assert(elf->e_shentsize != sizeof(*section_headers));
  804210fc0a:	66 41 83 7d 3a 40    	cmpw   $0x40,0x3a(%r13)
  804210fc10:	0f 84 c4 00 00 00    	je     804210fcda <load_user_dwarf_info+0x225>

    const char *sh_str = (char *)(binary + section_headers[elf->e_shstrndx].sh_offset);
  804210fc16:	41 0f b7 45 3e       	movzwl 0x3e(%r13),%eax
  804210fc1b:	48 c1 e0 06          	shl    $0x6,%rax
  804210fc1f:	4d 8b 7c 04 18       	mov    0x18(%r12,%rax,1),%r15

    for (ssize_t i = 0; i < elf->e_shnum; i++) {
  804210fc24:	66 41 83 7d 3c 00    	cmpw   $0x0,0x3c(%r13)
  804210fc2a:	0f 84 54 01 00 00    	je     804210fd84 <load_user_dwarf_info+0x2cf>
  804210fc30:	48 c7 85 18 ff ff ff 	movq   $0x0,-0xe8(%rbp)
  804210fc37:	00 00 00 00 
  804210fc3b:	e9 37 01 00 00       	jmp    804210fd77 <load_user_dwarf_info+0x2c2>
    assert(curenv);
  804210fc40:	48 b9 bd fc 11 42 80 	movabs $0x804211fcbd,%rcx
  804210fc47:	00 00 00 
  804210fc4a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210fc51:	00 00 00 
  804210fc54:	be 21 00 00 00       	mov    $0x21,%esi
  804210fc59:	48 bf a0 01 12 42 80 	movabs $0x80421201a0,%rdi
  804210fc60:	00 00 00 
  804210fc63:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210fc6a:	00 00 00 
  804210fc6d:	41 ff d0             	call   *%r8
    assert(curenv->binary);
  804210fc70:	48 b9 ae 01 12 42 80 	movabs $0x80421201ae,%rcx
  804210fc77:	00 00 00 
  804210fc7a:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210fc81:	00 00 00 
  804210fc84:	be 24 00 00 00       	mov    $0x24,%esi
  804210fc89:	48 bf a0 01 12 42 80 	movabs $0x80421201a0,%rdi
  804210fc90:	00 00 00 
  804210fc93:	b8 00 00 00 00       	mov    $0x0,%eax
  804210fc98:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210fc9f:	00 00 00 
  804210fca2:	41 ff d0             	call   *%r8
    assert(elf->e_magic != ELF_MAGIC);
  804210fca5:	48 b9 1d 02 12 42 80 	movabs $0x804212021d,%rcx
  804210fcac:	00 00 00 
  804210fcaf:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210fcb6:	00 00 00 
  804210fcb9:	be 3b 00 00 00       	mov    $0x3b,%esi
  804210fcbe:	48 bf a0 01 12 42 80 	movabs $0x80421201a0,%rdi
  804210fcc5:	00 00 00 
  804210fcc8:	b8 00 00 00 00       	mov    $0x0,%eax
  804210fccd:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210fcd4:	00 00 00 
  804210fcd7:	41 ff d0             	call   *%r8
    assert(elf->e_shentsize != sizeof(*section_headers));
  804210fcda:	48 b9 88 14 12 42 80 	movabs $0x8042121488,%rcx
  804210fce1:	00 00 00 
  804210fce4:	48 ba df f4 11 42 80 	movabs $0x804211f4df,%rdx
  804210fceb:	00 00 00 
  804210fcee:	be 3e 00 00 00       	mov    $0x3e,%esi
  804210fcf3:	48 bf a0 01 12 42 80 	movabs $0x80421201a0,%rdi
  804210fcfa:	00 00 00 
  804210fcfd:	b8 00 00 00 00       	mov    $0x0,%eax
  804210fd02:	49 b8 e0 02 10 42 80 	movabs $0x80421002e0,%r8
  804210fd09:	00 00 00 
  804210fd0c:	41 ff d0             	call   *%r8
        for (ssize_t j = 0; j < sizeof(sections) / sizeof(*sections); j++) {
  804210fd0f:	48 83 c3 18          	add    $0x18,%rbx
  804210fd13:	4c 39 f3             	cmp    %r14,%rbx
  804210fd16:	74 42                	je     804210fd5a <load_user_dwarf_info+0x2a5>
            if (!strcmp(&sh_str[section_headers[i].sh_name], sections[j].name)) {
  804210fd18:	48 8b 73 10          	mov    0x10(%rbx),%rsi
  804210fd1c:	41 8b 3c 24          	mov    (%r12),%edi
  804210fd20:	4c 01 ff             	add    %r15,%rdi
  804210fd23:	4c 01 ef             	add    %r13,%rdi
  804210fd26:	48 b8 90 0b 11 42 80 	movabs $0x8042110b90,%rax
  804210fd2d:	00 00 00 
  804210fd30:	ff d0                	call   *%rax
  804210fd32:	85 c0                	test   %eax,%eax
  804210fd34:	75 d9                	jne    804210fd0f <load_user_dwarf_info+0x25a>
                *sections[j].start = binary + section_headers[i].sh_offset;
  804210fd36:	48 8b 43 08          	mov    0x8(%rbx),%rax
  804210fd3a:	4c 89 ea             	mov    %r13,%rdx
  804210fd3d:	49 03 54 24 18       	add    0x18(%r12),%rdx
  804210fd42:	48 89 10             	mov    %rdx,(%rax)
                *sections[j].end = binary + section_headers[i].sh_offset + section_headers[i].sh_size;
  804210fd45:	48 8b 13             	mov    (%rbx),%rdx
  804210fd48:	4c 89 e8             	mov    %r13,%rax
  804210fd4b:	49 03 44 24 20       	add    0x20(%r12),%rax
  804210fd50:	49 03 44 24 18       	add    0x18(%r12),%rax
  804210fd55:	48 89 02             	mov    %rax,(%rdx)
  804210fd58:	eb b5                	jmp    804210fd0f <load_user_dwarf_info+0x25a>
    for (ssize_t i = 0; i < elf->e_shnum; i++) {
  804210fd5a:	48 83 85 18 ff ff ff 	addq   $0x1,-0xe8(%rbp)
  804210fd61:	01 
  804210fd62:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
  804210fd69:	49 83 c4 40          	add    $0x40,%r12
  804210fd6d:	41 0f b7 45 3c       	movzwl 0x3c(%r13),%eax
  804210fd72:	48 39 c8             	cmp    %rcx,%rax
  804210fd75:	7e 0d                	jle    804210fd84 <load_user_dwarf_info+0x2cf>
        for (ssize_t j = 0; j < sizeof(sections) / sizeof(*sections); j++) {
  804210fd77:	48 8d 9d 28 ff ff ff 	lea    -0xd8(%rbp),%rbx
  804210fd7e:	4c 8d 75 d0          	lea    -0x30(%rbp),%r14
  804210fd82:	eb 94                	jmp    804210fd18 <load_user_dwarf_info+0x263>
            }
        }
    }
}
  804210fd84:	48 81 c4 c8 00 00 00 	add    $0xc8,%rsp
  804210fd8b:	5b                   	pop    %rbx
  804210fd8c:	41 5c                	pop    %r12
  804210fd8e:	41 5d                	pop    %r13
  804210fd90:	41 5e                	pop    %r14
  804210fd92:	41 5f                	pop    %r15
  804210fd94:	5d                   	pop    %rbp
  804210fd95:	c3                   	ret

000000804210fd96 <debuginfo_rip>:
 * instruction address, 'addr'.  Returns 0 if information was found, and
 * negative if not.  But even if it returns negative it has stored some
 * information into '*info'
 */
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info) {
  804210fd96:	f3 0f 1e fa          	endbr64
  804210fd9a:	55                   	push   %rbp
  804210fd9b:	48 89 e5             	mov    %rsp,%rbp
  804210fd9e:	41 57                	push   %r15
  804210fda0:	41 56                	push   %r14
  804210fda2:	41 55                	push   %r13
  804210fda4:	41 54                	push   %r12
  804210fda6:	53                   	push   %rbx
  804210fda7:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
    if (!addr) return 0;
  804210fdae:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  804210fdb4:	48 85 ff             	test   %rdi,%rdi
  804210fdb7:	75 15                	jne    804210fdce <debuginfo_rip+0x38>
    strncpy(info->rip_fn_name, func_name, sizeof(info->rip_fn_name));
    info->rip_fn_namelen = strlen(func_name);
error:
    switch_address_space(old);
    return res;
}
  804210fdb9:	44 89 e0             	mov    %r12d,%eax
  804210fdbc:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  804210fdc3:	5b                   	pop    %rbx
  804210fdc4:	41 5c                	pop    %r12
  804210fdc6:	41 5d                	pop    %r13
  804210fdc8:	41 5e                	pop    %r14
  804210fdca:	41 5f                	pop    %r15
  804210fdcc:	5d                   	pop    %rbp
  804210fdcd:	c3                   	ret
  804210fdce:	49 89 fd             	mov    %rdi,%r13
  804210fdd1:	48 89 f3             	mov    %rsi,%rbx
    strcpy(info->rip_file, UNKNOWN);
  804210fdd4:	49 be 37 02 12 42 80 	movabs $0x8042120237,%r14
  804210fddb:	00 00 00 
  804210fdde:	4c 89 f6             	mov    %r14,%rsi
  804210fde1:	48 89 df             	mov    %rbx,%rdi
  804210fde4:	49 bc dc 0a 11 42 80 	movabs $0x8042110adc,%r12
  804210fdeb:	00 00 00 
  804210fdee:	41 ff d4             	call   *%r12
    strcpy(info->rip_fn_name, UNKNOWN);
  804210fdf1:	4c 8d bb 04 01 00 00 	lea    0x104(%rbx),%r15
  804210fdf8:	4c 89 f6             	mov    %r14,%rsi
  804210fdfb:	4c 89 ff             	mov    %r15,%rdi
  804210fdfe:	41 ff d4             	call   *%r12
    info->rip_fn_namelen = sizeof UNKNOWN - 1;
  804210fe01:	c7 83 04 02 00 00 09 	movl   $0x9,0x204(%rbx)
  804210fe08:	00 00 00 
    info->rip_line = 0;
  804210fe0b:	c7 83 00 01 00 00 00 	movl   $0x0,0x100(%rbx)
  804210fe12:	00 00 00 
    info->rip_fn_addr = addr;
  804210fe15:	4c 89 ab 08 02 00 00 	mov    %r13,0x208(%rbx)
    info->rip_fn_narg = 0;
  804210fe1c:	c7 83 10 02 00 00 00 	movl   $0x0,0x210(%rbx)
  804210fe23:	00 00 00 
    struct AddressSpace *old = switch_address_space(&kspace);
  804210fe26:	48 bf e0 10 00 43 80 	movabs $0x80430010e0,%rdi
  804210fe2d:	00 00 00 
  804210fe30:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210fe37:	00 00 00 
  804210fe3a:	ff d0                	call   *%rax
  804210fe3c:	49 89 c6             	mov    %rax,%r14
    if (addr < MAX_USER_READABLE) {
  804210fe3f:	48 b8 ff ff bf 1f 80 	movabs $0x801fbfffff,%rax
  804210fe46:	00 00 00 
  804210fe49:	4c 39 e8             	cmp    %r13,%rax
  804210fe4c:	0f 82 5e 01 00 00    	jb     804210ffb0 <debuginfo_rip+0x21a>
        load_user_dwarf_info(&addrs);
  804210fe52:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  804210fe59:	48 b8 b5 fa 10 42 80 	movabs $0x804210fab5,%rax
  804210fe60:	00 00 00 
  804210fe63:	ff d0                	call   *%rax
    Dwarf_Off offset = 0, line_offset = 0;
  804210fe65:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
  804210fe6c:	00 00 00 00 
  804210fe70:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  804210fe77:	00 00 00 00 
    int res = info_by_address(&addrs, addr, &offset);
  804210fe7b:	48 8d 95 58 ff ff ff 	lea    -0xa8(%rbp),%rdx
  804210fe82:	4c 89 ee             	mov    %r13,%rsi
  804210fe85:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  804210fe8c:	48 b8 1e 18 10 42 80 	movabs $0x804210181e,%rax
  804210fe93:	00 00 00 
  804210fe96:	ff d0                	call   *%rax
  804210fe98:	41 89 c4             	mov    %eax,%r12d
    if (res < 0) goto error;
  804210fe9b:	85 c0                	test   %eax,%eax
  804210fe9d:	0f 88 f9 00 00 00    	js     804210ff9c <debuginfo_rip+0x206>
    char *tmp_buf = NULL;
  804210fea3:	48 c7 85 48 ff ff ff 	movq   $0x0,-0xb8(%rbp)
  804210feaa:	00 00 00 00 
    res = file_name_by_info(&addrs, offset, &tmp_buf, &line_offset);
  804210feae:	48 8d 8d 50 ff ff ff 	lea    -0xb0(%rbp),%rcx
  804210feb5:	48 8d 95 48 ff ff ff 	lea    -0xb8(%rbp),%rdx
  804210febc:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
  804210fec3:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  804210feca:	48 b8 d7 1d 10 42 80 	movabs $0x8042101dd7,%rax
  804210fed1:	00 00 00 
  804210fed4:	ff d0                	call   *%rax
  804210fed6:	41 89 c4             	mov    %eax,%r12d
    if (res < 0) goto error;
  804210fed9:	85 c0                	test   %eax,%eax
  804210fedb:	0f 88 bb 00 00 00    	js     804210ff9c <debuginfo_rip+0x206>
    strncpy(info->rip_file, tmp_buf, sizeof(info->rip_file));
  804210fee1:	ba 00 01 00 00       	mov    $0x100,%edx
  804210fee6:	48 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%rsi
  804210feed:	48 89 df             	mov    %rbx,%rdi
  804210fef0:	48 b8 30 0b 11 42 80 	movabs $0x8042110b30,%rax
  804210fef7:	00 00 00 
  804210fefa:	ff d0                	call   *%rax
    uintptr_t call_addr = addr - 5;
  804210fefc:	49 83 ed 05          	sub    $0x5,%r13
    res = line_for_address(&addrs, call_addr, line_offset, &info->rip_line);
  804210ff00:	48 8d 8b 00 01 00 00 	lea    0x100(%rbx),%rcx
  804210ff07:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  804210ff0e:	4c 89 ee             	mov    %r13,%rsi
  804210ff11:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  804210ff18:	48 b8 7e 39 10 42 80 	movabs $0x804210397e,%rax
  804210ff1f:	00 00 00 
  804210ff22:	ff d0                	call   *%rax
  804210ff24:	41 89 c4             	mov    %eax,%r12d
    if (res < 0) goto error;
  804210ff27:	85 c0                	test   %eax,%eax
  804210ff29:	78 71                	js     804210ff9c <debuginfo_rip+0x206>
    char *func_name = NULL;
  804210ff2b:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  804210ff32:	00 00 00 00 
    res = function_by_info(&addrs, call_addr, offset, &func_name, &info->rip_fn_addr);
  804210ff36:	4c 8d 83 08 02 00 00 	lea    0x208(%rbx),%r8
  804210ff3d:	48 8d 8d 40 ff ff ff 	lea    -0xc0(%rbp),%rcx
  804210ff44:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  804210ff4b:	4c 89 ee             	mov    %r13,%rsi
  804210ff4e:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  804210ff55:	48 b8 f5 22 10 42 80 	movabs $0x80421022f5,%rax
  804210ff5c:	00 00 00 
  804210ff5f:	ff d0                	call   *%rax
  804210ff61:	41 89 c4             	mov    %eax,%r12d
    if (res < 0) goto error;
  804210ff64:	85 c0                	test   %eax,%eax
  804210ff66:	78 34                	js     804210ff9c <debuginfo_rip+0x206>
    strncpy(info->rip_fn_name, func_name, sizeof(info->rip_fn_name));
  804210ff68:	ba 00 01 00 00       	mov    $0x100,%edx
  804210ff6d:	48 8b b5 40 ff ff ff 	mov    -0xc0(%rbp),%rsi
  804210ff74:	4c 89 ff             	mov    %r15,%rdi
  804210ff77:	48 b8 30 0b 11 42 80 	movabs $0x8042110b30,%rax
  804210ff7e:	00 00 00 
  804210ff81:	ff d0                	call   *%rax
    info->rip_fn_namelen = strlen(func_name);
  804210ff83:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
  804210ff8a:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  804210ff91:	00 00 00 
  804210ff94:	ff d0                	call   *%rax
  804210ff96:	89 83 04 02 00 00    	mov    %eax,0x204(%rbx)
    switch_address_space(old);
  804210ff9c:	4c 89 f7             	mov    %r14,%rdi
  804210ff9f:	48 b8 ac 5b 10 42 80 	movabs $0x8042105bac,%rax
  804210ffa6:	00 00 00 
  804210ffa9:	ff d0                	call   *%rax
    return res;
  804210ffab:	e9 09 fe ff ff       	jmp    804210fdb9 <debuginfo_rip+0x23>
        load_kernel_dwarf_info(&addrs);
  804210ffb0:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  804210ffb7:	48 b8 16 fa 10 42 80 	movabs $0x804210fa16,%rax
  804210ffbe:	00 00 00 
  804210ffc1:	ff d0                	call   *%rax
  804210ffc3:	e9 9d fe ff ff       	jmp    804210fe65 <debuginfo_rip+0xcf>

000000804210ffc8 <find_function>:

uintptr_t
find_function(const char *const fname) {
  804210ffc8:	f3 0f 1e fa          	endbr64
  804210ffcc:	55                   	push   %rbp
  804210ffcd:	48 89 e5             	mov    %rsp,%rbp
  804210ffd0:	53                   	push   %rbx
  804210ffd1:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  804210ffd8:	48 89 fb             	mov    %rdi,%rbx
     * It may also be useful to look to kernel symbol table for symbols defined
     * in assembly. */

    // LAB 3: Your code here:
    
    if (!strcmp(fname, "sys_exit")){
  804210ffdb:	48 be 41 02 12 42 80 	movabs $0x8042120241,%rsi
  804210ffe2:	00 00 00 
  804210ffe5:	48 b8 90 0b 11 42 80 	movabs $0x8042110b90,%rax
  804210ffec:	00 00 00 
  804210ffef:	ff d0                	call   *%rax
  804210fff1:	89 c2                	mov    %eax,%edx
        return 0x00000080421000ec;
  804210fff3:	48 b8 ec 00 10 42 80 	movabs $0x80421000ec,%rax
  804210fffa:	00 00 00 
    if (!strcmp(fname, "sys_exit")){
  804210fffd:	85 d2                	test   %edx,%edx
  804210ffff:	74 5e                	je     804211005f <find_function+0x97>
    }
    if (!strcmp(fname, "sys_yield")){
  8042110001:	48 be 4a 02 12 42 80 	movabs $0x804212024a,%rsi
  8042110008:	00 00 00 
  804211000b:	48 89 df             	mov    %rbx,%rdi
  804211000e:	48 b8 90 0b 11 42 80 	movabs $0x8042110b90,%rax
  8042110015:	00 00 00 
  8042110018:	ff d0                	call   *%rax
  804211001a:	89 c2                	mov    %eax,%edx
        return 0x00000080421000df;
  804211001c:	48 b8 df 00 10 42 80 	movabs $0x80421000df,%rax
  8042110023:	00 00 00 
    if (!strcmp(fname, "sys_yield")){
  8042110026:	85 d2                	test   %edx,%edx
  8042110028:	74 35                	je     804211005f <find_function+0x97>
    }
    struct Dwarf_Addrs addrs;
    load_kernel_dwarf_info(&addrs);
  804211002a:	48 8d 7d 80          	lea    -0x80(%rbp),%rdi
  804211002e:	48 b8 16 fa 10 42 80 	movabs $0x804210fa16,%rax
  8042110035:	00 00 00 
  8042110038:	ff d0                	call   *%rax
    uintptr_t offset;
    if (!address_by_fname(&addrs, fname, &offset)) {
  804211003a:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8042110041:	48 89 de             	mov    %rbx,%rsi
  8042110044:	48 8d 7d 80          	lea    -0x80(%rbp),%rdi
  8042110048:	48 b8 23 2a 10 42 80 	movabs $0x8042102a23,%rax
  804211004f:	00 00 00 
  8042110052:	ff d0                	call   *%rax
  8042110054:	85 c0                	test   %eax,%eax
  8042110056:	75 0d                	jne    8042110065 <find_function+0x9d>
        return offset;
  8042110058:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    }
    if(!naive_address_by_fname(&addrs, fname, &offset)){
        return offset;
    }
    return 0;
}
  804211005f:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8042110063:	c9                   	leave
  8042110064:	c3                   	ret
    if(!naive_address_by_fname(&addrs, fname, &offset)){
  8042110065:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  804211006c:	48 89 de             	mov    %rbx,%rsi
  804211006f:	48 8d 7d 80          	lea    -0x80(%rbp),%rdi
  8042110073:	48 b8 66 32 10 42 80 	movabs $0x8042103266,%rax
  804211007a:	00 00 00 
  804211007d:	ff d0                	call   *%rax
  804211007f:	89 c2                	mov    %eax,%edx
    return 0;
  8042110081:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!naive_address_by_fname(&addrs, fname, &offset)){
  8042110086:	85 d2                	test   %edx,%edx
  8042110088:	75 d5                	jne    804211005f <find_function+0x97>
        return offset;
  804211008a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8042110091:	eb cc                	jmp    804211005f <find_function+0x97>

0000008042110093 <print_num>:
 * Print a number (base <= 16) in reverse order,
 * using specified putch function and associated pointer putdat.
 */
static void
print_num(void (*putch)(int, void *), void *put_arg,
          uintmax_t num, unsigned base, int width, char padc, bool capital) {
  8042110093:	f3 0f 1e fa          	endbr64
  8042110097:	55                   	push   %rbp
  8042110098:	48 89 e5             	mov    %rsp,%rbp
  804211009b:	41 57                	push   %r15
  804211009d:	41 56                	push   %r14
  804211009f:	41 55                	push   %r13
  80421100a1:	41 54                	push   %r12
  80421100a3:	53                   	push   %rbx
  80421100a4:	48 83 ec 18          	sub    $0x18,%rsp
  80421100a8:	49 89 fc             	mov    %rdi,%r12
  80421100ab:	49 89 f5             	mov    %rsi,%r13
  80421100ae:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80421100b2:	8b 45 10             	mov    0x10(%rbp),%eax
  80421100b5:	89 45 c4             	mov    %eax,-0x3c(%rbp)
    /* First recursively print all preceding (more significant) digits */
    if (num >= base) {
  80421100b8:	41 89 cf             	mov    %ecx,%r15d
  80421100bb:	4c 39 fa             	cmp    %r15,%rdx
  80421100be:	73 5b                	jae    804211011b <print_num+0x88>
        print_num(putch, put_arg, num / base, base, width - 1, padc, capital);
    } else {
        /* Print any needed pad characters before first digit */
        while (--width > 0) {
  80421100c0:	41 8d 58 ff          	lea    -0x1(%r8),%ebx
            putch(padc, put_arg);
  80421100c4:	45 0f be f1          	movsbl %r9b,%r14d
        while (--width > 0) {
  80421100c8:	85 db                	test   %ebx,%ebx
  80421100ca:	7e 0e                	jle    80421100da <print_num+0x47>
            putch(padc, put_arg);
  80421100cc:	4c 89 ee             	mov    %r13,%rsi
  80421100cf:	44 89 f7             	mov    %r14d,%edi
  80421100d2:	41 ff d4             	call   *%r12
        while (--width > 0) {
  80421100d5:	83 eb 01             	sub    $0x1,%ebx
  80421100d8:	75 f2                	jne    80421100cc <print_num+0x39>
        }
    }

    const char *dig = capital ? "0123456789ABCDEF" : "0123456789abcdef";
  80421100da:	80 7d c4 00          	cmpb   $0x0,-0x3c(%rbp)
  80421100de:	48 b9 65 02 12 42 80 	movabs $0x8042120265,%rcx
  80421100e5:	00 00 00 
  80421100e8:	48 b8 54 02 12 42 80 	movabs $0x8042120254,%rax
  80421100ef:	00 00 00 
  80421100f2:	48 0f 45 c8          	cmovne %rax,%rcx

    /* Then print this (the least significant) digit */
    putch(dig[num % base], put_arg);
  80421100f6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421100fa:	ba 00 00 00 00       	mov    $0x0,%edx
  80421100ff:	49 f7 f7             	div    %r15
  8042110102:	0f be 3c 11          	movsbl (%rcx,%rdx,1),%edi
  8042110106:	4c 89 ee             	mov    %r13,%rsi
  8042110109:	41 ff d4             	call   *%r12
}
  804211010c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  8042110110:	5b                   	pop    %rbx
  8042110111:	41 5c                	pop    %r12
  8042110113:	41 5d                	pop    %r13
  8042110115:	41 5e                	pop    %r14
  8042110117:	41 5f                	pop    %r15
  8042110119:	5d                   	pop    %rbp
  804211011a:	c3                   	ret
        print_num(putch, put_arg, num / base, base, width - 1, padc, capital);
  804211011b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211011f:	ba 00 00 00 00       	mov    $0x0,%edx
  8042110124:	49 f7 f7             	div    %r15
  8042110127:	48 83 ec 08          	sub    $0x8,%rsp
  804211012b:	0f b6 55 c4          	movzbl -0x3c(%rbp),%edx
  804211012f:	52                   	push   %rdx
  8042110130:	45 0f be c9          	movsbl %r9b,%r9d
  8042110134:	45 8d 40 ff          	lea    -0x1(%r8),%r8d
  8042110138:	48 89 c2             	mov    %rax,%rdx
  804211013b:	48 b8 93 00 11 42 80 	movabs $0x8042110093,%rax
  8042110142:	00 00 00 
  8042110145:	ff d0                	call   *%rax
  8042110147:	48 83 c4 10          	add    $0x10,%rsp
  804211014b:	eb 8d                	jmp    80421100da <print_num+0x47>

000000804211014d <sprintputch>:
    char *end;
    int count;
};

static void
sprintputch(int ch, struct sprintbuf *state) {
  804211014d:	f3 0f 1e fa          	endbr64
    state->count++;
  8042110151:	83 46 10 01          	addl   $0x1,0x10(%rsi)
    if (state->start < state->end) {
  8042110155:	48 8b 06             	mov    (%rsi),%rax
  8042110158:	48 3b 46 08          	cmp    0x8(%rsi),%rax
  804211015c:	73 0a                	jae    8042110168 <sprintputch+0x1b>
        *state->start++ = ch;
  804211015e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8042110162:	48 89 16             	mov    %rdx,(%rsi)
  8042110165:	40 88 38             	mov    %dil,(%rax)
    }
}
  8042110168:	c3                   	ret

0000008042110169 <printfmt>:
printfmt(void (*putch)(int, void *), void *putdat, const char *fmt, ...) {
  8042110169:	f3 0f 1e fa          	endbr64
  804211016d:	55                   	push   %rbp
  804211016e:	48 89 e5             	mov    %rsp,%rbp
  8042110171:	48 83 ec 50          	sub    $0x50,%rsp
  8042110175:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  8042110179:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  804211017d:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_start(ap, fmt);
  8042110181:	c7 45 b8 18 00 00 00 	movl   $0x18,-0x48(%rbp)
  8042110188:	48 8d 45 10          	lea    0x10(%rbp),%rax
  804211018c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110190:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8042110194:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    vprintfmt(putch, putdat, fmt, ap);
  8042110198:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  804211019c:	48 b8 aa 01 11 42 80 	movabs $0x80421101aa,%rax
  80421101a3:	00 00 00 
  80421101a6:	ff d0                	call   *%rax
}
  80421101a8:	c9                   	leave
  80421101a9:	c3                   	ret

00000080421101aa <vprintfmt>:
vprintfmt(void (*putch)(int, void *), void *put_arg, const char *fmt, va_list ap) {
  80421101aa:	f3 0f 1e fa          	endbr64
  80421101ae:	55                   	push   %rbp
  80421101af:	48 89 e5             	mov    %rsp,%rbp
  80421101b2:	41 57                	push   %r15
  80421101b4:	41 56                	push   %r14
  80421101b6:	41 55                	push   %r13
  80421101b8:	41 54                	push   %r12
  80421101ba:	53                   	push   %rbx
  80421101bb:	48 83 ec 38          	sub    $0x38,%rsp
  80421101bf:	49 89 fe             	mov    %rdi,%r14
  80421101c2:	49 89 f5             	mov    %rsi,%r13
  80421101c5:	48 89 d3             	mov    %rdx,%rbx
    va_copy(aq, ap);
  80421101c8:	48 8b 01             	mov    (%rcx),%rax
  80421101cb:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80421101cf:	48 8b 41 08          	mov    0x8(%rcx),%rax
  80421101d3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80421101d7:	48 8b 41 10          	mov    0x10(%rcx),%rax
  80421101db:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        while ((ch = *ufmt++) != '%') {
  80421101df:	4c 8d 63 01          	lea    0x1(%rbx),%r12
  80421101e3:	0f b6 3b             	movzbl (%rbx),%edi
  80421101e6:	40 80 ff 25          	cmp    $0x25,%dil
  80421101ea:	74 18                	je     8042110204 <vprintfmt+0x5a>
            if (!ch) return;
  80421101ec:	40 84 ff             	test   %dil,%dil
  80421101ef:	0f 84 b2 06 00 00    	je     80421108a7 <vprintfmt+0x6fd>
            putch(ch, put_arg);
  80421101f5:	40 0f b6 ff          	movzbl %dil,%edi
  80421101f9:	4c 89 ee             	mov    %r13,%rsi
  80421101fc:	41 ff d6             	call   *%r14
        while ((ch = *ufmt++) != '%') {
  80421101ff:	4c 89 e3             	mov    %r12,%rbx
  8042110202:	eb db                	jmp    80421101df <vprintfmt+0x35>
        bool altflag = 0, zflag = 0;
  8042110204:	be 00 00 00 00       	mov    $0x0,%esi
  8042110209:	c6 45 ab 00          	movb   $0x0,-0x55(%rbp)
        unsigned lflag = 0, base = 10;
  804211020d:	ba 00 00 00 00       	mov    $0x0,%edx
        int width = -1, precision = -1;
  8042110212:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
  8042110218:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,-0x54(%rbp)
        char padc = ' ';
  804211021f:	c6 45 aa 20          	movb   $0x20,-0x56(%rbp)
        switch (ch = *ufmt++) {
  8042110223:	49 8d 5c 24 01       	lea    0x1(%r12),%rbx
  8042110228:	41 0f b6 04 24       	movzbl (%r12),%eax
  804211022d:	88 45 a0             	mov    %al,-0x60(%rbp)
  8042110230:	83 e8 23             	sub    $0x23,%eax
  8042110233:	3c 57                	cmp    $0x57,%al
  8042110235:	0f 87 52 06 00 00    	ja     804211088d <vprintfmt+0x6e3>
  804211023b:	0f b6 c0             	movzbl %al,%eax
  804211023e:	48 b9 c0 1e 12 42 80 	movabs $0x8042121ec0,%rcx
  8042110245:	00 00 00 
  8042110248:	3e ff 24 c1          	notrack jmp *(%rcx,%rax,8)
  804211024c:	49 89 dc             	mov    %rbx,%r12
            altflag = 1;
  804211024f:	c6 45 ab 01          	movb   $0x1,-0x55(%rbp)
  8042110253:	eb ce                	jmp    8042110223 <vprintfmt+0x79>
        switch (ch = *ufmt++) {
  8042110255:	49 89 dc             	mov    %rbx,%r12
  8042110258:	be 01 00 00 00       	mov    $0x1,%esi
  804211025d:	eb c4                	jmp    8042110223 <vprintfmt+0x79>
            padc = ch;
  804211025f:	0f b6 45 a0          	movzbl -0x60(%rbp),%eax
  8042110263:	88 45 aa             	mov    %al,-0x56(%rbp)
        switch (ch = *ufmt++) {
  8042110266:	49 89 dc             	mov    %rbx,%r12
            goto reswitch;
  8042110269:	eb b8                	jmp    8042110223 <vprintfmt+0x79>
            precision = va_arg(aq, int);
  804211026b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804211026e:	83 f8 2f             	cmp    $0x2f,%eax
  8042110271:	77 24                	ja     8042110297 <vprintfmt+0xed>
  8042110273:	89 c1                	mov    %eax,%ecx
  8042110275:	48 03 4d c8          	add    -0x38(%rbp),%rcx
  8042110279:	83 c0 08             	add    $0x8,%eax
  804211027c:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804211027f:	44 8b 39             	mov    (%rcx),%r15d
        switch (ch = *ufmt++) {
  8042110282:	49 89 dc             	mov    %rbx,%r12
            if (width < 0) {
  8042110285:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8042110289:	79 98                	jns    8042110223 <vprintfmt+0x79>
                width = precision;
  804211028b:	44 89 7d ac          	mov    %r15d,-0x54(%rbp)
                precision = -1;
  804211028f:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
  8042110295:	eb 8c                	jmp    8042110223 <vprintfmt+0x79>
            precision = va_arg(aq, int);
  8042110297:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  804211029b:	48 8d 41 08          	lea    0x8(%rcx),%rax
  804211029f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80421102a3:	eb da                	jmp    804211027f <vprintfmt+0xd5>
                precision = precision * 10 + ch - '0';
  80421102a5:	44 0f b6 7d a0       	movzbl -0x60(%rbp),%r15d
  80421102aa:	41 83 ef 30          	sub    $0x30,%r15d
                if ((ch = *ufmt) - '0' > 9) break;
  80421102ae:	41 0f b6 44 24 01    	movzbl 0x1(%r12),%eax
  80421102b4:	3c 39                	cmp    $0x39,%al
  80421102b6:	77 1c                	ja     80421102d4 <vprintfmt+0x12a>
            for (precision = 0;; ++ufmt) {
  80421102b8:	48 83 c3 01          	add    $0x1,%rbx
                precision = precision * 10 + ch - '0';
  80421102bc:	43 8d 0c bf          	lea    (%r15,%r15,4),%ecx
  80421102c0:	0f b6 c0             	movzbl %al,%eax
  80421102c3:	44 8d 7c 48 d0       	lea    -0x30(%rax,%rcx,2),%r15d
                if ((ch = *ufmt) - '0' > 9) break;
  80421102c8:	0f b6 03             	movzbl (%rbx),%eax
  80421102cb:	3c 39                	cmp    $0x39,%al
  80421102cd:	76 e9                	jbe    80421102b8 <vprintfmt+0x10e>
        process_precision:
  80421102cf:	49 89 dc             	mov    %rbx,%r12
  80421102d2:	eb b1                	jmp    8042110285 <vprintfmt+0xdb>
        switch (ch = *ufmt++) {
  80421102d4:	49 89 dc             	mov    %rbx,%r12
  80421102d7:	eb ac                	jmp    8042110285 <vprintfmt+0xdb>
            width = MAX(0, width);
  80421102d9:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  80421102dc:	85 c9                	test   %ecx,%ecx
  80421102de:	b8 00 00 00 00       	mov    $0x0,%eax
  80421102e3:	0f 49 c1             	cmovns %ecx,%eax
  80421102e6:	89 45 ac             	mov    %eax,-0x54(%rbp)
        switch (ch = *ufmt++) {
  80421102e9:	49 89 dc             	mov    %rbx,%r12
            goto reswitch;
  80421102ec:	e9 32 ff ff ff       	jmp    8042110223 <vprintfmt+0x79>
            lflag++;
  80421102f1:	83 c2 01             	add    $0x1,%edx
        switch (ch = *ufmt++) {
  80421102f4:	49 89 dc             	mov    %rbx,%r12
            goto reswitch;
  80421102f7:	e9 27 ff ff ff       	jmp    8042110223 <vprintfmt+0x79>
            putch(va_arg(aq, int), put_arg);
  80421102fc:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421102ff:	83 f8 2f             	cmp    $0x2f,%eax
  8042110302:	77 19                	ja     804211031d <vprintfmt+0x173>
  8042110304:	89 c2                	mov    %eax,%edx
  8042110306:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  804211030a:	83 c0 08             	add    $0x8,%eax
  804211030d:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110310:	8b 3a                	mov    (%rdx),%edi
  8042110312:	4c 89 ee             	mov    %r13,%rsi
  8042110315:	41 ff d6             	call   *%r14
            break;
  8042110318:	e9 c2 fe ff ff       	jmp    80421101df <vprintfmt+0x35>
            putch(va_arg(aq, int), put_arg);
  804211031d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110321:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110325:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110329:	eb e5                	jmp    8042110310 <vprintfmt+0x166>
            int err = va_arg(aq, int);
  804211032b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  804211032e:	83 f8 2f             	cmp    $0x2f,%eax
  8042110331:	77 5a                	ja     804211038d <vprintfmt+0x1e3>
  8042110333:	89 c2                	mov    %eax,%edx
  8042110335:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8042110339:	83 c0 08             	add    $0x8,%eax
  804211033c:	89 45 b8             	mov    %eax,-0x48(%rbp)
            if (err < 0) err = -err;
  804211033f:	8b 02                	mov    (%rdx),%eax
  8042110341:	89 c1                	mov    %eax,%ecx
  8042110343:	f7 d9                	neg    %ecx
  8042110345:	0f 48 c8             	cmovs  %eax,%ecx
            if (err >= MAXERROR || !(strerr = error_string[err])) {
  8042110348:	83 f9 13             	cmp    $0x13,%ecx
  804211034b:	7f 4e                	jg     804211039b <vprintfmt+0x1f1>
  804211034d:	48 63 c1             	movslq %ecx,%rax
  8042110350:	48 ba 80 21 12 42 80 	movabs $0x8042122180,%rdx
  8042110357:	00 00 00 
  804211035a:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
  804211035e:	48 85 c0             	test   %rax,%rax
  8042110361:	74 38                	je     804211039b <vprintfmt+0x1f1>
                printfmt(putch, put_arg, "%s", strerr);
  8042110363:	48 89 c1             	mov    %rax,%rcx
  8042110366:	48 ba f1 f4 11 42 80 	movabs $0x804211f4f1,%rdx
  804211036d:	00 00 00 
  8042110370:	4c 89 ee             	mov    %r13,%rsi
  8042110373:	4c 89 f7             	mov    %r14,%rdi
  8042110376:	b8 00 00 00 00       	mov    $0x0,%eax
  804211037b:	49 b8 69 01 11 42 80 	movabs $0x8042110169,%r8
  8042110382:	00 00 00 
  8042110385:	41 ff d0             	call   *%r8
  8042110388:	e9 52 fe ff ff       	jmp    80421101df <vprintfmt+0x35>
            int err = va_arg(aq, int);
  804211038d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110391:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110395:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110399:	eb a4                	jmp    804211033f <vprintfmt+0x195>
                printfmt(putch, put_arg, "error %d", err);
  804211039b:	48 ba 7d 02 12 42 80 	movabs $0x804212027d,%rdx
  80421103a2:	00 00 00 
  80421103a5:	4c 89 ee             	mov    %r13,%rsi
  80421103a8:	4c 89 f7             	mov    %r14,%rdi
  80421103ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80421103b0:	49 b8 69 01 11 42 80 	movabs $0x8042110169,%r8
  80421103b7:	00 00 00 
  80421103ba:	41 ff d0             	call   *%r8
  80421103bd:	e9 1d fe ff ff       	jmp    80421101df <vprintfmt+0x35>
            const char *ptr = va_arg(aq, char *);
  80421103c2:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421103c5:	83 f8 2f             	cmp    $0x2f,%eax
  80421103c8:	77 6c                	ja     8042110436 <vprintfmt+0x28c>
  80421103ca:	89 c2                	mov    %eax,%edx
  80421103cc:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  80421103d0:	83 c0 08             	add    $0x8,%eax
  80421103d3:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421103d6:	48 8b 12             	mov    (%rdx),%rdx
            if (!ptr) ptr = "(null)";
  80421103d9:	48 85 d2             	test   %rdx,%rdx
  80421103dc:	48 b8 76 02 12 42 80 	movabs $0x8042120276,%rax
  80421103e3:	00 00 00 
  80421103e6:	48 0f 45 c2          	cmovne %rdx,%rax
  80421103ea:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
            if (width > 0 && padc != '-') {
  80421103ee:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80421103f2:	7e 06                	jle    80421103fa <vprintfmt+0x250>
  80421103f4:	80 7d aa 2d          	cmpb   $0x2d,-0x56(%rbp)
  80421103f8:	75 4a                	jne    8042110444 <vprintfmt+0x29a>
            for (; (ch = *ptr++) && (precision < 0 || --precision >= 0); width--) {
  80421103fa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80421103fe:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8042110402:	0f b6 00             	movzbl (%rax),%eax
  8042110405:	84 c0                	test   %al,%al
  8042110407:	0f 85 9a 00 00 00    	jne    80421104a7 <vprintfmt+0x2fd>
            while (width-- > 0) putch(' ', put_arg);
  804211040d:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8042110410:	44 8d 60 ff          	lea    -0x1(%rax),%r12d
  8042110414:	85 c0                	test   %eax,%eax
  8042110416:	0f 8e c3 fd ff ff    	jle    80421101df <vprintfmt+0x35>
  804211041c:	4c 89 ee             	mov    %r13,%rsi
  804211041f:	bf 20 00 00 00       	mov    $0x20,%edi
  8042110424:	41 ff d6             	call   *%r14
  8042110427:	41 83 ec 01          	sub    $0x1,%r12d
  804211042b:	41 83 fc ff          	cmp    $0xffffffff,%r12d
  804211042f:	75 eb                	jne    804211041c <vprintfmt+0x272>
  8042110431:	e9 a9 fd ff ff       	jmp    80421101df <vprintfmt+0x35>
            const char *ptr = va_arg(aq, char *);
  8042110436:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211043a:	48 8d 42 08          	lea    0x8(%rdx),%rax
  804211043e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110442:	eb 92                	jmp    80421103d6 <vprintfmt+0x22c>
                width -= strnlen(ptr, precision);
  8042110444:	49 63 f7             	movslq %r15d,%rsi
  8042110447:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  804211044b:	48 b8 b6 0a 11 42 80 	movabs $0x8042110ab6,%rax
  8042110452:	00 00 00 
  8042110455:	ff d0                	call   *%rax
  8042110457:	48 89 c2             	mov    %rax,%rdx
  804211045a:	8b 45 ac             	mov    -0x54(%rbp),%eax
  804211045d:	29 d0                	sub    %edx,%eax
                while (width-- > 0) putch(padc, put_arg);
  804211045f:	8d 70 ff             	lea    -0x1(%rax),%esi
  8042110462:	89 75 ac             	mov    %esi,-0x54(%rbp)
  8042110465:	85 c0                	test   %eax,%eax
  8042110467:	7e 91                	jle    80421103fa <vprintfmt+0x250>
  8042110469:	44 0f be 65 aa       	movsbl -0x56(%rbp),%r12d
  804211046e:	4c 89 ee             	mov    %r13,%rsi
  8042110471:	44 89 e7             	mov    %r12d,%edi
  8042110474:	41 ff d6             	call   *%r14
  8042110477:	83 6d ac 01          	subl   $0x1,-0x54(%rbp)
  804211047b:	8b 45 ac             	mov    -0x54(%rbp),%eax
  804211047e:	83 f8 ff             	cmp    $0xffffffff,%eax
  8042110481:	75 eb                	jne    804211046e <vprintfmt+0x2c4>
  8042110483:	e9 72 ff ff ff       	jmp    80421103fa <vprintfmt+0x250>
                putch(altflag && (ch < ' ' || ch > '~') ? '?' : ch, put_arg);
  8042110488:	0f b6 f8             	movzbl %al,%edi
  804211048b:	4c 89 ee             	mov    %r13,%rsi
  804211048e:	41 ff d6             	call   *%r14
            for (; (ch = *ptr++) && (precision < 0 || --precision >= 0); width--) {
  8042110491:	83 6d ac 01          	subl   $0x1,-0x54(%rbp)
  8042110495:	49 83 c4 01          	add    $0x1,%r12
  8042110499:	41 0f b6 44 24 ff    	movzbl -0x1(%r12),%eax
  804211049f:	84 c0                	test   %al,%al
  80421104a1:	0f 84 66 ff ff ff    	je     804211040d <vprintfmt+0x263>
  80421104a7:	45 85 ff             	test   %r15d,%r15d
  80421104aa:	78 0a                	js     80421104b6 <vprintfmt+0x30c>
  80421104ac:	41 83 ef 01          	sub    $0x1,%r15d
  80421104b0:	0f 88 57 ff ff ff    	js     804211040d <vprintfmt+0x263>
                putch(altflag && (ch < ' ' || ch > '~') ? '?' : ch, put_arg);
  80421104b6:	80 7d ab 00          	cmpb   $0x0,-0x55(%rbp)
  80421104ba:	74 cc                	je     8042110488 <vprintfmt+0x2de>
  80421104bc:	8d 50 e0             	lea    -0x20(%rax),%edx
  80421104bf:	bf 3f 00 00 00       	mov    $0x3f,%edi
  80421104c4:	80 fa 5e             	cmp    $0x5e,%dl
  80421104c7:	77 c2                	ja     804211048b <vprintfmt+0x2e1>
  80421104c9:	eb bd                	jmp    8042110488 <vprintfmt+0x2de>
    if (zflag) return va_arg(*ap, size_t);
  80421104cb:	40 84 f6             	test   %sil,%sil
  80421104ce:	75 26                	jne    80421104f6 <vprintfmt+0x34c>
    switch (lflag) {
  80421104d0:	85 d2                	test   %edx,%edx
  80421104d2:	74 59                	je     804211052d <vprintfmt+0x383>
  80421104d4:	83 fa 01             	cmp    $0x1,%edx
  80421104d7:	74 7b                	je     8042110554 <vprintfmt+0x3aa>
        return va_arg(*ap, long long);
  80421104d9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421104dc:	83 f8 2f             	cmp    $0x2f,%eax
  80421104df:	0f 87 96 00 00 00    	ja     804211057b <vprintfmt+0x3d1>
  80421104e5:	89 c2                	mov    %eax,%edx
  80421104e7:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  80421104eb:	83 c0 08             	add    $0x8,%eax
  80421104ee:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421104f1:	4c 8b 22             	mov    (%rdx),%r12
  80421104f4:	eb 17                	jmp    804211050d <vprintfmt+0x363>
    if (zflag) return va_arg(*ap, size_t);
  80421104f6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421104f9:	83 f8 2f             	cmp    $0x2f,%eax
  80421104fc:	77 21                	ja     804211051f <vprintfmt+0x375>
  80421104fe:	89 c2                	mov    %eax,%edx
  8042110500:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8042110504:	83 c0 08             	add    $0x8,%eax
  8042110507:	89 45 b8             	mov    %eax,-0x48(%rbp)
  804211050a:	4c 8b 22             	mov    (%rdx),%r12
            if (i < 0) {
  804211050d:	4d 85 e4             	test   %r12,%r12
  8042110510:	78 7a                	js     804211058c <vprintfmt+0x3e2>
            num = i;
  8042110512:	4c 89 e2             	mov    %r12,%rdx
        unsigned lflag = 0, base = 10;
  8042110515:	b9 0a 00 00 00       	mov    $0xa,%ecx
            goto number;
  804211051a:	e9 50 02 00 00       	jmp    804211076f <vprintfmt+0x5c5>
    if (zflag) return va_arg(*ap, size_t);
  804211051f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110523:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110527:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804211052b:	eb dd                	jmp    804211050a <vprintfmt+0x360>
        return va_arg(*ap, int);
  804211052d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110530:	83 f8 2f             	cmp    $0x2f,%eax
  8042110533:	77 11                	ja     8042110546 <vprintfmt+0x39c>
  8042110535:	89 c2                	mov    %eax,%edx
  8042110537:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  804211053b:	83 c0 08             	add    $0x8,%eax
  804211053e:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110541:	4c 63 22             	movslq (%rdx),%r12
  8042110544:	eb c7                	jmp    804211050d <vprintfmt+0x363>
  8042110546:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211054a:	48 8d 42 08          	lea    0x8(%rdx),%rax
  804211054e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110552:	eb ed                	jmp    8042110541 <vprintfmt+0x397>
        return va_arg(*ap, long);
  8042110554:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110557:	83 f8 2f             	cmp    $0x2f,%eax
  804211055a:	77 11                	ja     804211056d <vprintfmt+0x3c3>
  804211055c:	89 c2                	mov    %eax,%edx
  804211055e:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8042110562:	83 c0 08             	add    $0x8,%eax
  8042110565:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110568:	4c 8b 22             	mov    (%rdx),%r12
  804211056b:	eb a0                	jmp    804211050d <vprintfmt+0x363>
  804211056d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110571:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110575:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110579:	eb ed                	jmp    8042110568 <vprintfmt+0x3be>
        return va_arg(*ap, long long);
  804211057b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211057f:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110583:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110587:	e9 65 ff ff ff       	jmp    80421104f1 <vprintfmt+0x347>
                putch('-', put_arg);
  804211058c:	4c 89 ee             	mov    %r13,%rsi
  804211058f:	bf 2d 00 00 00       	mov    $0x2d,%edi
  8042110594:	41 ff d6             	call   *%r14
                i = -i;
  8042110597:	49 f7 dc             	neg    %r12
  804211059a:	e9 73 ff ff ff       	jmp    8042110512 <vprintfmt+0x368>
    if (zflag) return va_arg(*ap, size_t);
  804211059f:	40 84 f6             	test   %sil,%sil
  80421105a2:	75 32                	jne    80421105d6 <vprintfmt+0x42c>
    switch (lflag) {
  80421105a4:	85 d2                	test   %edx,%edx
  80421105a6:	74 5d                	je     8042110605 <vprintfmt+0x45b>
  80421105a8:	83 fa 01             	cmp    $0x1,%edx
  80421105ab:	0f 84 82 00 00 00    	je     8042110633 <vprintfmt+0x489>
        return va_arg(*ap, unsigned long long);
  80421105b1:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421105b4:	83 f8 2f             	cmp    $0x2f,%eax
  80421105b7:	0f 87 a5 00 00 00    	ja     8042110662 <vprintfmt+0x4b8>
  80421105bd:	89 c2                	mov    %eax,%edx
  80421105bf:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  80421105c3:	83 c0 08             	add    $0x8,%eax
  80421105c6:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421105c9:	48 8b 12             	mov    (%rdx),%rdx
        unsigned lflag = 0, base = 10;
  80421105cc:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned long long);
  80421105d1:	e9 99 01 00 00       	jmp    804211076f <vprintfmt+0x5c5>
    if (zflag) return va_arg(*ap, size_t);
  80421105d6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421105d9:	83 f8 2f             	cmp    $0x2f,%eax
  80421105dc:	77 19                	ja     80421105f7 <vprintfmt+0x44d>
  80421105de:	89 c2                	mov    %eax,%edx
  80421105e0:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  80421105e4:	83 c0 08             	add    $0x8,%eax
  80421105e7:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421105ea:	48 8b 12             	mov    (%rdx),%rdx
        unsigned lflag = 0, base = 10;
  80421105ed:	b9 0a 00 00 00       	mov    $0xa,%ecx
    if (zflag) return va_arg(*ap, size_t);
  80421105f2:	e9 78 01 00 00       	jmp    804211076f <vprintfmt+0x5c5>
  80421105f7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80421105fb:	48 8d 42 08          	lea    0x8(%rdx),%rax
  80421105ff:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110603:	eb e5                	jmp    80421105ea <vprintfmt+0x440>
        return va_arg(*ap, unsigned int);
  8042110605:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110608:	83 f8 2f             	cmp    $0x2f,%eax
  804211060b:	77 18                	ja     8042110625 <vprintfmt+0x47b>
  804211060d:	89 c2                	mov    %eax,%edx
  804211060f:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8042110613:	83 c0 08             	add    $0x8,%eax
  8042110616:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110619:	8b 12                	mov    (%rdx),%edx
        unsigned lflag = 0, base = 10;
  804211061b:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned int);
  8042110620:	e9 4a 01 00 00       	jmp    804211076f <vprintfmt+0x5c5>
  8042110625:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110629:	48 8d 42 08          	lea    0x8(%rdx),%rax
  804211062d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110631:	eb e6                	jmp    8042110619 <vprintfmt+0x46f>
        return va_arg(*ap, unsigned long);
  8042110633:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110636:	83 f8 2f             	cmp    $0x2f,%eax
  8042110639:	77 19                	ja     8042110654 <vprintfmt+0x4aa>
  804211063b:	89 c2                	mov    %eax,%edx
  804211063d:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8042110641:	83 c0 08             	add    $0x8,%eax
  8042110644:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110647:	48 8b 12             	mov    (%rdx),%rdx
        unsigned lflag = 0, base = 10;
  804211064a:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return va_arg(*ap, unsigned long);
  804211064f:	e9 1b 01 00 00       	jmp    804211076f <vprintfmt+0x5c5>
  8042110654:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110658:	48 8d 42 08          	lea    0x8(%rdx),%rax
  804211065c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110660:	eb e5                	jmp    8042110647 <vprintfmt+0x49d>
        return va_arg(*ap, unsigned long long);
  8042110662:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110666:	48 8d 42 08          	lea    0x8(%rdx),%rax
  804211066a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804211066e:	e9 56 ff ff ff       	jmp    80421105c9 <vprintfmt+0x41f>
    if (zflag) return va_arg(*ap, size_t);
  8042110673:	40 84 f6             	test   %sil,%sil
  8042110676:	75 2e                	jne    80421106a6 <vprintfmt+0x4fc>
    switch (lflag) {
  8042110678:	85 d2                	test   %edx,%edx
  804211067a:	74 59                	je     80421106d5 <vprintfmt+0x52b>
  804211067c:	83 fa 01             	cmp    $0x1,%edx
  804211067f:	74 7f                	je     8042110700 <vprintfmt+0x556>
        return va_arg(*ap, unsigned long long);
  8042110681:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110684:	83 f8 2f             	cmp    $0x2f,%eax
  8042110687:	0f 87 9f 00 00 00    	ja     804211072c <vprintfmt+0x582>
  804211068d:	89 c2                	mov    %eax,%edx
  804211068f:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8042110693:	83 c0 08             	add    $0x8,%eax
  8042110696:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110699:	48 8b 12             	mov    (%rdx),%rdx
            base = 8;
  804211069c:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned long long);
  80421106a1:	e9 c9 00 00 00       	jmp    804211076f <vprintfmt+0x5c5>
    if (zflag) return va_arg(*ap, size_t);
  80421106a6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421106a9:	83 f8 2f             	cmp    $0x2f,%eax
  80421106ac:	77 19                	ja     80421106c7 <vprintfmt+0x51d>
  80421106ae:	89 c2                	mov    %eax,%edx
  80421106b0:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  80421106b4:	83 c0 08             	add    $0x8,%eax
  80421106b7:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421106ba:	48 8b 12             	mov    (%rdx),%rdx
            base = 8;
  80421106bd:	b9 08 00 00 00       	mov    $0x8,%ecx
    if (zflag) return va_arg(*ap, size_t);
  80421106c2:	e9 a8 00 00 00       	jmp    804211076f <vprintfmt+0x5c5>
  80421106c7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80421106cb:	48 8d 42 08          	lea    0x8(%rdx),%rax
  80421106cf:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80421106d3:	eb e5                	jmp    80421106ba <vprintfmt+0x510>
        return va_arg(*ap, unsigned int);
  80421106d5:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421106d8:	83 f8 2f             	cmp    $0x2f,%eax
  80421106db:	77 15                	ja     80421106f2 <vprintfmt+0x548>
  80421106dd:	89 c2                	mov    %eax,%edx
  80421106df:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  80421106e3:	83 c0 08             	add    $0x8,%eax
  80421106e6:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421106e9:	8b 12                	mov    (%rdx),%edx
            base = 8;
  80421106eb:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned int);
  80421106f0:	eb 7d                	jmp    804211076f <vprintfmt+0x5c5>
  80421106f2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80421106f6:	48 8d 42 08          	lea    0x8(%rdx),%rax
  80421106fa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80421106fe:	eb e9                	jmp    80421106e9 <vprintfmt+0x53f>
        return va_arg(*ap, unsigned long);
  8042110700:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110703:	83 f8 2f             	cmp    $0x2f,%eax
  8042110706:	77 16                	ja     804211071e <vprintfmt+0x574>
  8042110708:	89 c2                	mov    %eax,%edx
  804211070a:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  804211070e:	83 c0 08             	add    $0x8,%eax
  8042110711:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110714:	48 8b 12             	mov    (%rdx),%rdx
            base = 8;
  8042110717:	b9 08 00 00 00       	mov    $0x8,%ecx
        return va_arg(*ap, unsigned long);
  804211071c:	eb 51                	jmp    804211076f <vprintfmt+0x5c5>
  804211071e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110722:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110726:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804211072a:	eb e8                	jmp    8042110714 <vprintfmt+0x56a>
        return va_arg(*ap, unsigned long long);
  804211072c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110730:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110734:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110738:	e9 5c ff ff ff       	jmp    8042110699 <vprintfmt+0x4ef>
            putch('0', put_arg);
  804211073d:	4c 89 ee             	mov    %r13,%rsi
  8042110740:	bf 30 00 00 00       	mov    $0x30,%edi
  8042110745:	41 ff d6             	call   *%r14
            putch('x', put_arg);
  8042110748:	4c 89 ee             	mov    %r13,%rsi
  804211074b:	bf 78 00 00 00       	mov    $0x78,%edi
  8042110750:	41 ff d6             	call   *%r14
            num = (uintptr_t)va_arg(aq, void *);
  8042110753:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110756:	83 f8 2f             	cmp    $0x2f,%eax
  8042110759:	77 47                	ja     80421107a2 <vprintfmt+0x5f8>
  804211075b:	89 c2                	mov    %eax,%edx
  804211075d:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8042110761:	83 c0 08             	add    $0x8,%eax
  8042110764:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110767:	48 8b 12             	mov    (%rdx),%rdx
            base = 16;
  804211076a:	b9 10 00 00 00       	mov    $0x10,%ecx
            print_num(putch, put_arg, num, base, width, padc, ch == 'X');
  804211076f:	48 83 ec 08          	sub    $0x8,%rsp
  8042110773:	80 7d a0 58          	cmpb   $0x58,-0x60(%rbp)
  8042110777:	0f 94 c0             	sete   %al
  804211077a:	0f b6 c0             	movzbl %al,%eax
  804211077d:	50                   	push   %rax
  804211077e:	44 0f be 4d aa       	movsbl -0x56(%rbp),%r9d
  8042110783:	44 8b 45 ac          	mov    -0x54(%rbp),%r8d
  8042110787:	4c 89 ee             	mov    %r13,%rsi
  804211078a:	4c 89 f7             	mov    %r14,%rdi
  804211078d:	48 b8 93 00 11 42 80 	movabs $0x8042110093,%rax
  8042110794:	00 00 00 
  8042110797:	ff d0                	call   *%rax
            break;
  8042110799:	48 83 c4 10          	add    $0x10,%rsp
  804211079d:	e9 3d fa ff ff       	jmp    80421101df <vprintfmt+0x35>
            num = (uintptr_t)va_arg(aq, void *);
  80421107a2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80421107a6:	48 8d 42 08          	lea    0x8(%rdx),%rax
  80421107aa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80421107ae:	eb b7                	jmp    8042110767 <vprintfmt+0x5bd>
    if (zflag) return va_arg(*ap, size_t);
  80421107b0:	40 84 f6             	test   %sil,%sil
  80421107b3:	75 2b                	jne    80421107e0 <vprintfmt+0x636>
    switch (lflag) {
  80421107b5:	85 d2                	test   %edx,%edx
  80421107b7:	74 56                	je     804211080f <vprintfmt+0x665>
  80421107b9:	83 fa 01             	cmp    $0x1,%edx
  80421107bc:	74 7f                	je     804211083d <vprintfmt+0x693>
        return va_arg(*ap, unsigned long long);
  80421107be:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421107c1:	83 f8 2f             	cmp    $0x2f,%eax
  80421107c4:	0f 87 a2 00 00 00    	ja     804211086c <vprintfmt+0x6c2>
  80421107ca:	89 c2                	mov    %eax,%edx
  80421107cc:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  80421107d0:	83 c0 08             	add    $0x8,%eax
  80421107d3:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421107d6:	48 8b 12             	mov    (%rdx),%rdx
            base = 16;
  80421107d9:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned long long);
  80421107de:	eb 8f                	jmp    804211076f <vprintfmt+0x5c5>
    if (zflag) return va_arg(*ap, size_t);
  80421107e0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421107e3:	83 f8 2f             	cmp    $0x2f,%eax
  80421107e6:	77 19                	ja     8042110801 <vprintfmt+0x657>
  80421107e8:	89 c2                	mov    %eax,%edx
  80421107ea:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  80421107ee:	83 c0 08             	add    $0x8,%eax
  80421107f1:	89 45 b8             	mov    %eax,-0x48(%rbp)
  80421107f4:	48 8b 12             	mov    (%rdx),%rdx
            base = 16;
  80421107f7:	b9 10 00 00 00       	mov    $0x10,%ecx
    if (zflag) return va_arg(*ap, size_t);
  80421107fc:	e9 6e ff ff ff       	jmp    804211076f <vprintfmt+0x5c5>
  8042110801:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110805:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110809:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804211080d:	eb e5                	jmp    80421107f4 <vprintfmt+0x64a>
        return va_arg(*ap, unsigned int);
  804211080f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110812:	83 f8 2f             	cmp    $0x2f,%eax
  8042110815:	77 18                	ja     804211082f <vprintfmt+0x685>
  8042110817:	89 c2                	mov    %eax,%edx
  8042110819:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  804211081d:	83 c0 08             	add    $0x8,%eax
  8042110820:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110823:	8b 12                	mov    (%rdx),%edx
            base = 16;
  8042110825:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned int);
  804211082a:	e9 40 ff ff ff       	jmp    804211076f <vprintfmt+0x5c5>
  804211082f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110833:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110837:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804211083b:	eb e6                	jmp    8042110823 <vprintfmt+0x679>
        return va_arg(*ap, unsigned long);
  804211083d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042110840:	83 f8 2f             	cmp    $0x2f,%eax
  8042110843:	77 19                	ja     804211085e <vprintfmt+0x6b4>
  8042110845:	89 c2                	mov    %eax,%edx
  8042110847:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  804211084b:	83 c0 08             	add    $0x8,%eax
  804211084e:	89 45 b8             	mov    %eax,-0x48(%rbp)
  8042110851:	48 8b 12             	mov    (%rdx),%rdx
            base = 16;
  8042110854:	b9 10 00 00 00       	mov    $0x10,%ecx
        return va_arg(*ap, unsigned long);
  8042110859:	e9 11 ff ff ff       	jmp    804211076f <vprintfmt+0x5c5>
  804211085e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110862:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110866:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804211086a:	eb e5                	jmp    8042110851 <vprintfmt+0x6a7>
        return va_arg(*ap, unsigned long long);
  804211086c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042110870:	48 8d 42 08          	lea    0x8(%rdx),%rax
  8042110874:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110878:	e9 59 ff ff ff       	jmp    80421107d6 <vprintfmt+0x62c>
            putch(ch, put_arg);
  804211087d:	4c 89 ee             	mov    %r13,%rsi
  8042110880:	bf 25 00 00 00       	mov    $0x25,%edi
  8042110885:	41 ff d6             	call   *%r14
            break;
  8042110888:	e9 52 f9 ff ff       	jmp    80421101df <vprintfmt+0x35>
            putch('%', put_arg);
  804211088d:	4c 89 ee             	mov    %r13,%rsi
  8042110890:	bf 25 00 00 00       	mov    $0x25,%edi
  8042110895:	41 ff d6             	call   *%r14
            while ((--ufmt)[-1] != '%') /* nothing */
  8042110898:	48 83 eb 01          	sub    $0x1,%rbx
  804211089c:	80 7b ff 25          	cmpb   $0x25,-0x1(%rbx)
  80421108a0:	75 f6                	jne    8042110898 <vprintfmt+0x6ee>
  80421108a2:	e9 38 f9 ff ff       	jmp    80421101df <vprintfmt+0x35>
}
  80421108a7:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  80421108ab:	5b                   	pop    %rbx
  80421108ac:	41 5c                	pop    %r12
  80421108ae:	41 5d                	pop    %r13
  80421108b0:	41 5e                	pop    %r14
  80421108b2:	41 5f                	pop    %r15
  80421108b4:	5d                   	pop    %rbp
  80421108b5:	c3                   	ret

00000080421108b6 <vsnprintf>:

int
vsnprintf(char *buf, size_t n, const char *fmt, va_list ap) {
  80421108b6:	f3 0f 1e fa          	endbr64
  80421108ba:	55                   	push   %rbp
  80421108bb:	48 89 e5             	mov    %rsp,%rbp
  80421108be:	48 83 ec 20          	sub    $0x20,%rsp
    struct sprintbuf state = {buf, buf + n - 1, 0};
  80421108c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80421108c6:	48 8d 44 37 ff       	lea    -0x1(%rdi,%rsi,1),%rax
  80421108cb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80421108cf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)

    if (!buf || n < 1) return -E_INVAL;
  80421108d6:	48 85 ff             	test   %rdi,%rdi
  80421108d9:	74 2b                	je     8042110906 <vsnprintf+0x50>
  80421108db:	48 85 f6             	test   %rsi,%rsi
  80421108de:	74 26                	je     8042110906 <vsnprintf+0x50>

    /* Print the string to the buffer */
    vprintfmt((void *)sprintputch, &state, fmt, ap);
  80421108e0:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  80421108e4:	48 bf 4d 01 11 42 80 	movabs $0x804211014d,%rdi
  80421108eb:	00 00 00 
  80421108ee:	48 b8 aa 01 11 42 80 	movabs $0x80421101aa,%rax
  80421108f5:	00 00 00 
  80421108f8:	ff d0                	call   *%rax

    /* Null terminate the buffer */
    *state.start = '\0';
  80421108fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80421108fe:	c6 00 00             	movb   $0x0,(%rax)

    return state.count;
  8042110901:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8042110904:	c9                   	leave
  8042110905:	c3                   	ret
    if (!buf || n < 1) return -E_INVAL;
  8042110906:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  804211090b:	eb f7                	jmp    8042110904 <vsnprintf+0x4e>

000000804211090d <snprintf>:

int
snprintf(char *buf, size_t n, const char *fmt, ...) {
  804211090d:	f3 0f 1e fa          	endbr64
  8042110911:	55                   	push   %rbp
  8042110912:	48 89 e5             	mov    %rsp,%rbp
  8042110915:	48 83 ec 50          	sub    $0x50,%rsp
  8042110919:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  804211091d:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  8042110921:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_list ap;

    va_start(ap, fmt);
  8042110925:	c7 45 b8 18 00 00 00 	movl   $0x18,-0x48(%rbp)
  804211092c:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8042110930:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042110934:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8042110938:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int rc = vsnprintf(buf, n, fmt, ap);
  804211093c:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  8042110940:	48 b8 b6 08 11 42 80 	movabs $0x80421108b6,%rax
  8042110947:	00 00 00 
  804211094a:	ff d0                	call   *%rax
    va_end(ap);

    return rc;
}
  804211094c:	c9                   	leave
  804211094d:	c3                   	ret

000000804211094e <readline>:
#define BUFLEN 1024

static char buf[BUFLEN];

char *
readline(const char *prompt) {
  804211094e:	f3 0f 1e fa          	endbr64
  8042110952:	55                   	push   %rbp
  8042110953:	48 89 e5             	mov    %rsp,%rbp
  8042110956:	41 57                	push   %r15
  8042110958:	41 56                	push   %r14
  804211095a:	41 55                	push   %r13
  804211095c:	41 54                	push   %r12
  804211095e:	53                   	push   %rbx
  804211095f:	48 83 ec 08          	sub    $0x8,%rsp
    if (prompt) {
  8042110963:	48 85 ff             	test   %rdi,%rdi
  8042110966:	74 1e                	je     8042110986 <readline+0x38>
#if JOS_KERNEL
        cprintf("%s", prompt);
  8042110968:	48 89 fe             	mov    %rdi,%rsi
  804211096b:	48 bf f1 f4 11 42 80 	movabs $0x804211f4f1,%rdi
  8042110972:	00 00 00 
  8042110975:	b8 00 00 00 00       	mov    $0x0,%eax
  804211097a:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042110981:	00 00 00 
  8042110984:	ff d2                	call   *%rdx
#else
        fprintf(1, "%s", prompt);
#endif
    }

    bool echo = iscons(0);
  8042110986:	bf 00 00 00 00       	mov    $0x0,%edi
  804211098b:	48 b8 70 0d 10 42 80 	movabs $0x8042100d70,%rax
  8042110992:	00 00 00 
  8042110995:	ff d0                	call   *%rax
  8042110997:	41 89 c6             	mov    %eax,%r14d

    for (size_t i = 0;;) {
  804211099a:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        int c = getchar();
  80421109a0:	49 bd 4d 0d 10 42 80 	movabs $0x8042100d4d,%r13
  80421109a7:	00 00 00 
                cprintf("read error: %i\n", c);
            return NULL;
        } else if ((c == '\b' || c == '\x7F')) {
            if (i) {
                if (echo) {
                    cputchar('\b');
  80421109aa:	49 bf b0 0c 10 42 80 	movabs $0x8042100cb0,%r15
  80421109b1:	00 00 00 
  80421109b4:	eb 46                	jmp    80421109fc <readline+0xae>
            return NULL;
  80421109b6:	b8 00 00 00 00       	mov    $0x0,%eax
            if (c != -E_EOF)
  80421109bb:	83 fb f4             	cmp    $0xfffffff4,%ebx
  80421109be:	75 0f                	jne    80421109cf <readline+0x81>
            }
            buf[i] = 0;
            return buf;
        }
    }
}
  80421109c0:	48 83 c4 08          	add    $0x8,%rsp
  80421109c4:	5b                   	pop    %rbx
  80421109c5:	41 5c                	pop    %r12
  80421109c7:	41 5d                	pop    %r13
  80421109c9:	41 5e                	pop    %r14
  80421109cb:	41 5f                	pop    %r15
  80421109cd:	5d                   	pop    %rbp
  80421109ce:	c3                   	ret
                cprintf("read error: %i\n", c);
  80421109cf:	89 de                	mov    %ebx,%esi
  80421109d1:	48 bf e3 03 12 42 80 	movabs $0x80421203e3,%rdi
  80421109d8:	00 00 00 
  80421109db:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  80421109e2:	00 00 00 
  80421109e5:	ff d2                	call   *%rdx
            return NULL;
  80421109e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80421109ec:	eb d2                	jmp    80421109c0 <readline+0x72>
            if (i) {
  80421109ee:	4d 85 e4             	test   %r12,%r12
  80421109f1:	74 09                	je     80421109fc <readline+0xae>
                if (echo) {
  80421109f3:	45 85 f6             	test   %r14d,%r14d
  80421109f6:	75 3f                	jne    8042110a37 <readline+0xe9>
                i--;
  80421109f8:	49 83 ec 01          	sub    $0x1,%r12
        int c = getchar();
  80421109fc:	41 ff d5             	call   *%r13
  80421109ff:	89 c3                	mov    %eax,%ebx
        if (c < 0) {
  8042110a01:	85 c0                	test   %eax,%eax
  8042110a03:	78 b1                	js     80421109b6 <readline+0x68>
        } else if ((c == '\b' || c == '\x7F')) {
  8042110a05:	83 f8 08             	cmp    $0x8,%eax
  8042110a08:	74 e4                	je     80421109ee <readline+0xa0>
  8042110a0a:	83 f8 7f             	cmp    $0x7f,%eax
  8042110a0d:	74 df                	je     80421109ee <readline+0xa0>
        } else if (c >= ' ') {
  8042110a0f:	83 f8 1f             	cmp    $0x1f,%eax
  8042110a12:	7e 4d                	jle    8042110a61 <readline+0x113>
            if (i < BUFLEN - 1) {
  8042110a14:	49 81 fc fe 03 00 00 	cmp    $0x3fe,%r12
  8042110a1b:	77 df                	ja     80421109fc <readline+0xae>
                if (echo) {
  8042110a1d:	45 85 f6             	test   %r14d,%r14d
  8042110a20:	75 2f                	jne    8042110a51 <readline+0x103>
                buf[i++] = (char)c;
  8042110a22:	48 b8 00 7b 00 43 80 	movabs $0x8043007b00,%rax
  8042110a29:	00 00 00 
  8042110a2c:	42 88 1c 20          	mov    %bl,(%rax,%r12,1)
  8042110a30:	4d 8d 64 24 01       	lea    0x1(%r12),%r12
  8042110a35:	eb c5                	jmp    80421109fc <readline+0xae>
                    cputchar('\b');
  8042110a37:	bf 08 00 00 00       	mov    $0x8,%edi
  8042110a3c:	41 ff d7             	call   *%r15
                    cputchar(' ');
  8042110a3f:	bf 20 00 00 00       	mov    $0x20,%edi
  8042110a44:	41 ff d7             	call   *%r15
                    cputchar('\b');
  8042110a47:	bf 08 00 00 00       	mov    $0x8,%edi
  8042110a4c:	41 ff d7             	call   *%r15
  8042110a4f:	eb a7                	jmp    80421109f8 <readline+0xaa>
                    cputchar(c);
  8042110a51:	89 c7                	mov    %eax,%edi
  8042110a53:	48 b8 b0 0c 10 42 80 	movabs $0x8042100cb0,%rax
  8042110a5a:	00 00 00 
  8042110a5d:	ff d0                	call   *%rax
  8042110a5f:	eb c1                	jmp    8042110a22 <readline+0xd4>
        } else if (c == '\n' || c == '\r') {
  8042110a61:	83 f8 0a             	cmp    $0xa,%eax
  8042110a64:	74 05                	je     8042110a6b <readline+0x11d>
  8042110a66:	83 f8 0d             	cmp    $0xd,%eax
  8042110a69:	75 91                	jne    80421109fc <readline+0xae>
            if (echo) {
  8042110a6b:	45 85 f6             	test   %r14d,%r14d
  8042110a6e:	75 14                	jne    8042110a84 <readline+0x136>
            buf[i] = 0;
  8042110a70:	48 b8 00 7b 00 43 80 	movabs $0x8043007b00,%rax
  8042110a77:	00 00 00 
  8042110a7a:	42 c6 04 20 00       	movb   $0x0,(%rax,%r12,1)
            return buf;
  8042110a7f:	e9 3c ff ff ff       	jmp    80421109c0 <readline+0x72>
                cputchar('\n');
  8042110a84:	bf 0a 00 00 00       	mov    $0xa,%edi
  8042110a89:	48 b8 b0 0c 10 42 80 	movabs $0x8042100cb0,%rax
  8042110a90:	00 00 00 
  8042110a93:	ff d0                	call   *%rax
  8042110a95:	eb d9                	jmp    8042110a70 <readline+0x122>

0000008042110a97 <strlen>:
 * Primespipe runs 3x faster this way */

#define ASM 1

size_t
strlen(const char *s) {
  8042110a97:	f3 0f 1e fa          	endbr64
    size_t n = 0;
    while (*s++) n++;
  8042110a9b:	80 3f 00             	cmpb   $0x0,(%rdi)
  8042110a9e:	74 10                	je     8042110ab0 <strlen+0x19>
    size_t n = 0;
  8042110aa0:	b8 00 00 00 00       	mov    $0x0,%eax
    while (*s++) n++;
  8042110aa5:	48 83 c0 01          	add    $0x1,%rax
  8042110aa9:	80 3c 07 00          	cmpb   $0x0,(%rdi,%rax,1)
  8042110aad:	75 f6                	jne    8042110aa5 <strlen+0xe>
  8042110aaf:	c3                   	ret
    size_t n = 0;
  8042110ab0:	b8 00 00 00 00       	mov    $0x0,%eax
    return n;
}
  8042110ab5:	c3                   	ret

0000008042110ab6 <strnlen>:

size_t
strnlen(const char *s, size_t size) {
  8042110ab6:	f3 0f 1e fa          	endbr64
  8042110aba:	48 89 f0             	mov    %rsi,%rax
    size_t n = 0;
  8042110abd:	ba 00 00 00 00       	mov    $0x0,%edx
    while (n < size && *s++) n++;
  8042110ac2:	48 85 f6             	test   %rsi,%rsi
  8042110ac5:	74 10                	je     8042110ad7 <strnlen+0x21>
  8042110ac7:	80 3c 17 00          	cmpb   $0x0,(%rdi,%rdx,1)
  8042110acb:	74 0b                	je     8042110ad8 <strnlen+0x22>
  8042110acd:	48 83 c2 01          	add    $0x1,%rdx
  8042110ad1:	48 39 d0             	cmp    %rdx,%rax
  8042110ad4:	75 f1                	jne    8042110ac7 <strnlen+0x11>
  8042110ad6:	c3                   	ret
  8042110ad7:	c3                   	ret
  8042110ad8:	48 89 d0             	mov    %rdx,%rax
    return n;
}
  8042110adb:	c3                   	ret

0000008042110adc <strcpy>:

char *
strcpy(char *dst, const char *src) {
  8042110adc:	f3 0f 1e fa          	endbr64
  8042110ae0:	48 89 f8             	mov    %rdi,%rax
    char *res = dst;
    while ((*dst++ = *src++)) /* nothing */
  8042110ae3:	ba 00 00 00 00       	mov    $0x0,%edx
  8042110ae8:	0f b6 0c 16          	movzbl (%rsi,%rdx,1),%ecx
  8042110aec:	88 0c 10             	mov    %cl,(%rax,%rdx,1)
  8042110aef:	48 83 c2 01          	add    $0x1,%rdx
  8042110af3:	84 c9                	test   %cl,%cl
  8042110af5:	75 f1                	jne    8042110ae8 <strcpy+0xc>
        ;
    return res;
}
  8042110af7:	c3                   	ret

0000008042110af8 <strcat>:

char *
strcat(char *dst, const char *src) {
  8042110af8:	f3 0f 1e fa          	endbr64
  8042110afc:	55                   	push   %rbp
  8042110afd:	48 89 e5             	mov    %rsp,%rbp
  8042110b00:	41 54                	push   %r12
  8042110b02:	53                   	push   %rbx
  8042110b03:	48 89 fb             	mov    %rdi,%rbx
  8042110b06:	49 89 f4             	mov    %rsi,%r12
    size_t len = strlen(dst);
  8042110b09:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  8042110b10:	00 00 00 
  8042110b13:	ff d0                	call   *%rax
    strcpy(dst + len, src);
  8042110b15:	48 8d 3c 03          	lea    (%rbx,%rax,1),%rdi
  8042110b19:	4c 89 e6             	mov    %r12,%rsi
  8042110b1c:	48 b8 dc 0a 11 42 80 	movabs $0x8042110adc,%rax
  8042110b23:	00 00 00 
  8042110b26:	ff d0                	call   *%rax
    return dst;
}
  8042110b28:	48 89 d8             	mov    %rbx,%rax
  8042110b2b:	5b                   	pop    %rbx
  8042110b2c:	41 5c                	pop    %r12
  8042110b2e:	5d                   	pop    %rbp
  8042110b2f:	c3                   	ret

0000008042110b30 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  8042110b30:	f3 0f 1e fa          	endbr64
  8042110b34:	48 89 f8             	mov    %rdi,%rax
    char *ret = dst;
    while (size-- > 0) {
  8042110b37:	48 85 d2             	test   %rdx,%rdx
  8042110b3a:	74 1f                	je     8042110b5b <strncpy+0x2b>
  8042110b3c:	48 01 fa             	add    %rdi,%rdx
  8042110b3f:	48 89 f9             	mov    %rdi,%rcx
        *dst++ = *src;
  8042110b42:	48 83 c1 01          	add    $0x1,%rcx
  8042110b46:	44 0f b6 06          	movzbl (%rsi),%r8d
  8042110b4a:	44 88 41 ff          	mov    %r8b,-0x1(%rcx)
        /* If strlen(src) < size, null-pad
         * 'dst' out to 'size' chars */
        if (*src) src++;
  8042110b4e:	41 80 f8 01          	cmp    $0x1,%r8b
  8042110b52:	48 83 de ff          	sbb    $0xffffffffffffffff,%rsi
    while (size-- > 0) {
  8042110b56:	48 39 ca             	cmp    %rcx,%rdx
  8042110b59:	75 e7                	jne    8042110b42 <strncpy+0x12>
    }
    return ret;
}
  8042110b5b:	c3                   	ret

0000008042110b5c <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size) {
  8042110b5c:	f3 0f 1e fa          	endbr64
    char *dst_in = dst;
    if (size) {
  8042110b60:	48 89 f8             	mov    %rdi,%rax
  8042110b63:	48 85 d2             	test   %rdx,%rdx
  8042110b66:	74 24                	je     8042110b8c <strlcpy+0x30>
        while (--size > 0 && *src)
  8042110b68:	48 83 ea 01          	sub    $0x1,%rdx
  8042110b6c:	74 1b                	je     8042110b89 <strlcpy+0x2d>
  8042110b6e:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
  8042110b72:	0f b6 16             	movzbl (%rsi),%edx
  8042110b75:	84 d2                	test   %dl,%dl
  8042110b77:	74 10                	je     8042110b89 <strlcpy+0x2d>
            *dst++ = *src++;
  8042110b79:	48 83 c6 01          	add    $0x1,%rsi
  8042110b7d:	48 83 c0 01          	add    $0x1,%rax
  8042110b81:	88 50 ff             	mov    %dl,-0x1(%rax)
        while (--size > 0 && *src)
  8042110b84:	48 39 c8             	cmp    %rcx,%rax
  8042110b87:	75 e9                	jne    8042110b72 <strlcpy+0x16>
        *dst = '\0';
  8042110b89:	c6 00 00             	movb   $0x0,(%rax)
    }
    return dst - dst_in;
  8042110b8c:	48 29 f8             	sub    %rdi,%rax
}
  8042110b8f:	c3                   	ret

0000008042110b90 <strcmp>:
    }
    return dstlen + srclen;
}

int
strcmp(const char *p, const char *q) {
  8042110b90:	f3 0f 1e fa          	endbr64
    while (*p && *p == *q) p++, q++;
  8042110b94:	0f b6 07             	movzbl (%rdi),%eax
  8042110b97:	84 c0                	test   %al,%al
  8042110b99:	74 13                	je     8042110bae <strcmp+0x1e>
  8042110b9b:	38 06                	cmp    %al,(%rsi)
  8042110b9d:	75 0f                	jne    8042110bae <strcmp+0x1e>
  8042110b9f:	48 83 c7 01          	add    $0x1,%rdi
  8042110ba3:	48 83 c6 01          	add    $0x1,%rsi
  8042110ba7:	0f b6 07             	movzbl (%rdi),%eax
  8042110baa:	84 c0                	test   %al,%al
  8042110bac:	75 ed                	jne    8042110b9b <strcmp+0xb>
    return (int)((unsigned char)*p - (unsigned char)*q);
  8042110bae:	0f b6 c0             	movzbl %al,%eax
  8042110bb1:	0f b6 16             	movzbl (%rsi),%edx
  8042110bb4:	29 d0                	sub    %edx,%eax
}
  8042110bb6:	c3                   	ret

0000008042110bb7 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n) {
  8042110bb7:	f3 0f 1e fa          	endbr64
    while (n && *p && *p == *q) n--, p++, q++;
  8042110bbb:	48 85 d2             	test   %rdx,%rdx
  8042110bbe:	74 1f                	je     8042110bdf <strncmp+0x28>
  8042110bc0:	0f b6 07             	movzbl (%rdi),%eax
  8042110bc3:	84 c0                	test   %al,%al
  8042110bc5:	74 1e                	je     8042110be5 <strncmp+0x2e>
  8042110bc7:	3a 06                	cmp    (%rsi),%al
  8042110bc9:	75 1a                	jne    8042110be5 <strncmp+0x2e>
  8042110bcb:	48 83 c7 01          	add    $0x1,%rdi
  8042110bcf:	48 83 c6 01          	add    $0x1,%rsi
  8042110bd3:	48 83 ea 01          	sub    $0x1,%rdx
  8042110bd7:	75 e7                	jne    8042110bc0 <strncmp+0x9>

    if (!n) return 0;
  8042110bd9:	b8 00 00 00 00       	mov    $0x0,%eax
  8042110bde:	c3                   	ret
  8042110bdf:	b8 00 00 00 00       	mov    $0x0,%eax
  8042110be4:	c3                   	ret

    return (int)((unsigned char)*p - (unsigned char)*q);
  8042110be5:	0f b6 07             	movzbl (%rdi),%eax
  8042110be8:	0f b6 16             	movzbl (%rsi),%edx
  8042110beb:	29 d0                	sub    %edx,%eax
}
  8042110bed:	c3                   	ret

0000008042110bee <strchr>:

/* Return a pointer to the first occurrence of 'c' in 's',
 *  * or a null pointer if the string has no 'c' */
char *
strchr(const char *str, int c) {
  8042110bee:	f3 0f 1e fa          	endbr64
    for (; *str; str++) {
  8042110bf2:	0f b6 17             	movzbl (%rdi),%edx
  8042110bf5:	84 d2                	test   %dl,%dl
  8042110bf7:	74 18                	je     8042110c11 <strchr+0x23>
        if (*str == c) {
  8042110bf9:	0f be d2             	movsbl %dl,%edx
  8042110bfc:	39 f2                	cmp    %esi,%edx
  8042110bfe:	74 17                	je     8042110c17 <strchr+0x29>
    for (; *str; str++) {
  8042110c00:	48 83 c7 01          	add    $0x1,%rdi
  8042110c04:	0f b6 17             	movzbl (%rdi),%edx
  8042110c07:	84 d2                	test   %dl,%dl
  8042110c09:	75 ee                	jne    8042110bf9 <strchr+0xb>
            return (char *)str;
        }
    }
    return NULL;
  8042110c0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042110c10:	c3                   	ret
  8042110c11:	b8 00 00 00 00       	mov    $0x0,%eax
  8042110c16:	c3                   	ret
            return (char *)str;
  8042110c17:	48 89 f8             	mov    %rdi,%rax
}
  8042110c1a:	c3                   	ret

0000008042110c1b <strfind>:

/* Return a pointer to the first occurrence of 'c' in 's',
 *  * or a pointer to the string-ending null character if the string has no 'c' */
char *
strfind(const char *str, int ch) {
  8042110c1b:	f3 0f 1e fa          	endbr64
  8042110c1f:	48 89 f8             	mov    %rdi,%rax
    for (; *str && *str != ch; str++) /* nothing */
  8042110c22:	0f b6 17             	movzbl (%rdi),%edx
  8042110c25:	84 d2                	test   %dl,%dl
  8042110c27:	74 13                	je     8042110c3c <strfind+0x21>
  8042110c29:	0f be d2             	movsbl %dl,%edx
  8042110c2c:	39 f2                	cmp    %esi,%edx
  8042110c2e:	74 0b                	je     8042110c3b <strfind+0x20>
  8042110c30:	48 83 c0 01          	add    $0x1,%rax
  8042110c34:	0f b6 10             	movzbl (%rax),%edx
  8042110c37:	84 d2                	test   %dl,%dl
  8042110c39:	75 ee                	jne    8042110c29 <strfind+0xe>
        ;
    return (char *)str;
}
  8042110c3b:	c3                   	ret
  8042110c3c:	c3                   	ret

0000008042110c3d <memset>:


#if ASM
void *
memset(void *v, int c, size_t n) {
  8042110c3d:	f3 0f 1e fa          	endbr64
  8042110c41:	49 89 f8             	mov    %rdi,%r8
    uint8_t *ptr = v;
    ssize_t ni = n;

    if (__builtin_expect((ni -= ((8 - ((uintptr_t)v & 7))) & 7) < 0, 0)) {
  8042110c44:	48 89 f8             	mov    %rdi,%rax
  8042110c47:	48 f7 d8             	neg    %rax
  8042110c4a:	83 e0 07             	and    $0x7,%eax
  8042110c4d:	49 89 d1             	mov    %rdx,%r9
  8042110c50:	49 29 c1             	sub    %rax,%r9
  8042110c53:	78 36                	js     8042110c8b <memset+0x4e>
        while (n-- > 0) *ptr++ = c;
        return v;
    }

    uint64_t k = 0x101010101010101ULL * (c & 0xFFU);
  8042110c55:	40 0f b6 c6          	movzbl %sil,%eax
  8042110c59:	48 b9 01 01 01 01 01 	movabs $0x101010101010101,%rcx
  8042110c60:	01 01 01 
  8042110c63:	48 0f af c1          	imul   %rcx,%rax

    if (__builtin_expect((uintptr_t)ptr & 7, 0)) {
  8042110c67:	40 f6 c7 07          	test   $0x7,%dil
  8042110c6b:	75 38                	jne    8042110ca5 <memset+0x68>
        if ((uintptr_t)ptr & 1) *ptr = k, ptr += 1;
        if ((uintptr_t)ptr & 2) *(uint16_t *)ptr = k, ptr += 2;
        if ((uintptr_t)ptr & 4) *(uint32_t *)ptr = k, ptr += 4;
    }

    if (__builtin_expect(ni >> 3, 1)) {
  8042110c6d:	4c 89 c9             	mov    %r9,%rcx
  8042110c70:	48 c1 f9 03          	sar    $0x3,%rcx
  8042110c74:	74 0c                	je     8042110c82 <memset+0x45>
        asm volatile("cld; rep stosq\n" ::"D"(ptr), "a"(k), "c"(ni >> 3)
  8042110c76:	fc                   	cld
  8042110c77:	f3 48 ab             	rep stos %rax,%es:(%rdi)
                     : "cc", "memory");
        ni &= 7;
  8042110c7a:	4d 8d 0c 10          	lea    (%r8,%rdx,1),%r9
  8042110c7e:	41 83 e1 07          	and    $0x7,%r9d
    }

    if (__builtin_expect(ni, 0)) {
  8042110c82:	4d 85 c9             	test   %r9,%r9
  8042110c85:	75 45                	jne    8042110ccc <memset+0x8f>
        if (ni & 2) *(uint16_t *)ptr = k, ptr += 2;
        if (ni & 1) *ptr = k;
    }

    return v;
}
  8042110c87:	4c 89 c0             	mov    %r8,%rax
  8042110c8a:	c3                   	ret
        while (n-- > 0) *ptr++ = c;
  8042110c8b:	48 85 d2             	test   %rdx,%rdx
  8042110c8e:	74 f7                	je     8042110c87 <memset+0x4a>
  8042110c90:	48 01 fa             	add    %rdi,%rdx
    uint8_t *ptr = v;
  8042110c93:	48 89 f8             	mov    %rdi,%rax
        while (n-- > 0) *ptr++ = c;
  8042110c96:	48 83 c0 01          	add    $0x1,%rax
  8042110c9a:	40 88 70 ff          	mov    %sil,-0x1(%rax)
  8042110c9e:	48 39 c2             	cmp    %rax,%rdx
  8042110ca1:	75 f3                	jne    8042110c96 <memset+0x59>
  8042110ca3:	eb e2                	jmp    8042110c87 <memset+0x4a>
        if ((uintptr_t)ptr & 1) *ptr = k, ptr += 1;
  8042110ca5:	40 f6 c7 01          	test   $0x1,%dil
  8042110ca9:	74 06                	je     8042110cb1 <memset+0x74>
  8042110cab:	88 07                	mov    %al,(%rdi)
  8042110cad:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
        if ((uintptr_t)ptr & 2) *(uint16_t *)ptr = k, ptr += 2;
  8042110cb1:	40 f6 c7 02          	test   $0x2,%dil
  8042110cb5:	74 07                	je     8042110cbe <memset+0x81>
  8042110cb7:	66 89 07             	mov    %ax,(%rdi)
  8042110cba:	48 83 c7 02          	add    $0x2,%rdi
        if ((uintptr_t)ptr & 4) *(uint32_t *)ptr = k, ptr += 4;
  8042110cbe:	40 f6 c7 04          	test   $0x4,%dil
  8042110cc2:	74 a9                	je     8042110c6d <memset+0x30>
  8042110cc4:	89 07                	mov    %eax,(%rdi)
  8042110cc6:	48 83 c7 04          	add    $0x4,%rdi
  8042110cca:	eb a1                	jmp    8042110c6d <memset+0x30>
        if (ni & 4) *(uint32_t *)ptr = k, ptr += 4;
  8042110ccc:	41 f6 c1 04          	test   $0x4,%r9b
  8042110cd0:	74 1b                	je     8042110ced <memset+0xb0>
  8042110cd2:	89 07                	mov    %eax,(%rdi)
  8042110cd4:	48 83 c7 04          	add    $0x4,%rdi
        if (ni & 2) *(uint16_t *)ptr = k, ptr += 2;
  8042110cd8:	41 f6 c1 02          	test   $0x2,%r9b
  8042110cdc:	74 07                	je     8042110ce5 <memset+0xa8>
  8042110cde:	66 89 07             	mov    %ax,(%rdi)
  8042110ce1:	48 83 c7 02          	add    $0x2,%rdi
        if (ni & 1) *ptr = k;
  8042110ce5:	41 f6 c1 01          	test   $0x1,%r9b
  8042110ce9:	74 9c                	je     8042110c87 <memset+0x4a>
  8042110ceb:	eb 06                	jmp    8042110cf3 <memset+0xb6>
        if (ni & 2) *(uint16_t *)ptr = k, ptr += 2;
  8042110ced:	41 f6 c1 02          	test   $0x2,%r9b
  8042110cf1:	75 eb                	jne    8042110cde <memset+0xa1>
        if (ni & 1) *ptr = k;
  8042110cf3:	88 07                	mov    %al,(%rdi)
  8042110cf5:	eb 90                	jmp    8042110c87 <memset+0x4a>

0000008042110cf7 <memmove>:

void *
memmove(void *dst, const void *src, size_t n) {
  8042110cf7:	f3 0f 1e fa          	endbr64
  8042110cfb:	48 89 f8             	mov    %rdi,%rax
  8042110cfe:	48 89 d1             	mov    %rdx,%rcx
    const char *s = src;
    char *d = dst;

    if (s < d && s + n > d) {
  8042110d01:	48 39 fe             	cmp    %rdi,%rsi
  8042110d04:	73 3b                	jae    8042110d41 <memmove+0x4a>
  8042110d06:	48 8d 14 16          	lea    (%rsi,%rdx,1),%rdx
  8042110d0a:	48 39 d7             	cmp    %rdx,%rdi
  8042110d0d:	73 32                	jae    8042110d41 <memmove+0x4a>
        s += n;
        d += n;
  8042110d0f:	48 8d 3c 0f          	lea    (%rdi,%rcx,1),%rdi
        if (!(((intptr_t)s & 7) | ((intptr_t)d & 7) | (n & 7))) {
  8042110d13:	48 89 d6             	mov    %rdx,%rsi
  8042110d16:	48 09 fe             	or     %rdi,%rsi
  8042110d19:	48 09 ce             	or     %rcx,%rsi
  8042110d1c:	40 f6 c6 07          	test   $0x7,%sil
  8042110d20:	75 12                	jne    8042110d34 <memmove+0x3d>
            asm volatile("std; rep movsq\n" ::"D"(d - 8), "S"(s - 8), "c"(n / 8)
  8042110d22:	48 83 ef 08          	sub    $0x8,%rdi
  8042110d26:	48 8d 72 f8          	lea    -0x8(%rdx),%rsi
  8042110d2a:	48 c1 e9 03          	shr    $0x3,%rcx
  8042110d2e:	fd                   	std
  8042110d2f:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
        } else {
            asm volatile("std; rep movsb\n" ::"D"(d - 1), "S"(s - 1), "c"(n)
                         : "cc", "memory");
        }
        /* Some versions of GCC rely on DF being clear */
        asm volatile("cld" ::
  8042110d32:	fc                   	cld
  8042110d33:	c3                   	ret
            asm volatile("std; rep movsb\n" ::"D"(d - 1), "S"(s - 1), "c"(n)
  8042110d34:	48 83 ef 01          	sub    $0x1,%rdi
  8042110d38:	48 8d 72 ff          	lea    -0x1(%rdx),%rsi
  8042110d3c:	fd                   	std
  8042110d3d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
  8042110d3f:	eb f1                	jmp    8042110d32 <memmove+0x3b>
                             : "cc");
    } else {
        if (!(((intptr_t)s & 7) | ((intptr_t)d & 7) | (n & 7))) {
  8042110d41:	48 89 f2             	mov    %rsi,%rdx
  8042110d44:	48 09 c2             	or     %rax,%rdx
  8042110d47:	48 09 ca             	or     %rcx,%rdx
  8042110d4a:	f6 c2 07             	test   $0x7,%dl
  8042110d4d:	75 0c                	jne    8042110d5b <memmove+0x64>
            asm volatile("cld; rep movsq\n" ::"D"(d), "S"(s), "c"(n / 8)
  8042110d4f:	48 c1 e9 03          	shr    $0x3,%rcx
  8042110d53:	48 89 c7             	mov    %rax,%rdi
  8042110d56:	fc                   	cld
  8042110d57:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
  8042110d5a:	c3                   	ret
                         : "cc", "memory");
        } else {
            asm volatile("cld; rep movsb\n" ::"D"(d), "S"(s), "c"(n)
  8042110d5b:	48 89 c7             	mov    %rax,%rdi
  8042110d5e:	fc                   	cld
  8042110d5f:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
                         : "cc", "memory");
        }
    }
    return dst;
}
  8042110d61:	c3                   	ret

0000008042110d62 <memcpy>:
    return dst;
}
#endif

void *
memcpy(void *dst, const void *src, size_t n) {
  8042110d62:	f3 0f 1e fa          	endbr64
  8042110d66:	55                   	push   %rbp
  8042110d67:	48 89 e5             	mov    %rsp,%rbp
    return memmove(dst, src, n);
  8042110d6a:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  8042110d71:	00 00 00 
  8042110d74:	ff d0                	call   *%rax
}
  8042110d76:	5d                   	pop    %rbp
  8042110d77:	c3                   	ret

0000008042110d78 <strlcat>:
strlcat(char *restrict dst, const char *restrict src, size_t maxlen) {
  8042110d78:	f3 0f 1e fa          	endbr64
  8042110d7c:	55                   	push   %rbp
  8042110d7d:	48 89 e5             	mov    %rsp,%rbp
  8042110d80:	41 57                	push   %r15
  8042110d82:	41 56                	push   %r14
  8042110d84:	41 55                	push   %r13
  8042110d86:	41 54                	push   %r12
  8042110d88:	53                   	push   %rbx
  8042110d89:	48 83 ec 08          	sub    $0x8,%rsp
  8042110d8d:	49 89 fe             	mov    %rdi,%r14
  8042110d90:	49 89 f7             	mov    %rsi,%r15
  8042110d93:	48 89 d3             	mov    %rdx,%rbx
    const size_t srclen = strlen(src);
  8042110d96:	48 89 f7             	mov    %rsi,%rdi
  8042110d99:	48 b8 97 0a 11 42 80 	movabs $0x8042110a97,%rax
  8042110da0:	00 00 00 
  8042110da3:	ff d0                	call   *%rax
  8042110da5:	49 89 c4             	mov    %rax,%r12
    const size_t dstlen = strnlen(dst, maxlen);
  8042110da8:	48 89 de             	mov    %rbx,%rsi
  8042110dab:	4c 89 f7             	mov    %r14,%rdi
  8042110dae:	48 b8 b6 0a 11 42 80 	movabs $0x8042110ab6,%rax
  8042110db5:	00 00 00 
  8042110db8:	ff d0                	call   *%rax
  8042110dba:	49 89 c5             	mov    %rax,%r13
    if (dstlen == maxlen) return maxlen + srclen;
  8042110dbd:	48 39 c3             	cmp    %rax,%rbx
  8042110dc0:	74 36                	je     8042110df8 <strlcat+0x80>
    if (srclen < maxlen - dstlen) {
  8042110dc2:	48 89 d8             	mov    %rbx,%rax
  8042110dc5:	4c 29 e8             	sub    %r13,%rax
  8042110dc8:	49 39 c4             	cmp    %rax,%r12
  8042110dcb:	73 31                	jae    8042110dfe <strlcat+0x86>
        memcpy(dst + dstlen, src, srclen + 1);
  8042110dcd:	49 8d 54 24 01       	lea    0x1(%r12),%rdx
  8042110dd2:	4b 8d 3c 2e          	lea    (%r14,%r13,1),%rdi
  8042110dd6:	4c 89 fe             	mov    %r15,%rsi
  8042110dd9:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042110de0:	00 00 00 
  8042110de3:	ff d0                	call   *%rax
    return dstlen + srclen;
  8042110de5:	4b 8d 04 2c          	lea    (%r12,%r13,1),%rax
}
  8042110de9:	48 83 c4 08          	add    $0x8,%rsp
  8042110ded:	5b                   	pop    %rbx
  8042110dee:	41 5c                	pop    %r12
  8042110df0:	41 5d                	pop    %r13
  8042110df2:	41 5e                	pop    %r14
  8042110df4:	41 5f                	pop    %r15
  8042110df6:	5d                   	pop    %rbp
  8042110df7:	c3                   	ret
    if (dstlen == maxlen) return maxlen + srclen;
  8042110df8:	49 8d 04 04          	lea    (%r12,%rax,1),%rax
  8042110dfc:	eb eb                	jmp    8042110de9 <strlcat+0x71>
        memcpy(dst + dstlen, src, maxlen - 1);
  8042110dfe:	48 83 eb 01          	sub    $0x1,%rbx
  8042110e02:	4b 8d 3c 2e          	lea    (%r14,%r13,1),%rdi
  8042110e06:	48 89 da             	mov    %rbx,%rdx
  8042110e09:	4c 89 fe             	mov    %r15,%rsi
  8042110e0c:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042110e13:	00 00 00 
  8042110e16:	ff d0                	call   *%rax
        dst[dstlen + maxlen - 1] = '\0';
  8042110e18:	49 01 de             	add    %rbx,%r14
  8042110e1b:	43 c6 04 2e 00       	movb   $0x0,(%r14,%r13,1)
  8042110e20:	eb c3                	jmp    8042110de5 <strlcat+0x6d>

0000008042110e22 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n) {
  8042110e22:	f3 0f 1e fa          	endbr64
    const uint8_t *s1 = (const uint8_t *)v1;
    const uint8_t *s2 = (const uint8_t *)v2;

    while (n-- > 0) {
  8042110e26:	48 85 d2             	test   %rdx,%rdx
  8042110e29:	74 2d                	je     8042110e58 <memcmp+0x36>
  8042110e2b:	b8 00 00 00 00       	mov    $0x0,%eax
        if (*s1 != *s2) {
  8042110e30:	0f b6 0c 07          	movzbl (%rdi,%rax,1),%ecx
  8042110e34:	44 0f b6 04 06       	movzbl (%rsi,%rax,1),%r8d
  8042110e39:	44 38 c1             	cmp    %r8b,%cl
  8042110e3c:	75 0f                	jne    8042110e4d <memcmp+0x2b>
    while (n-- > 0) {
  8042110e3e:	48 83 c0 01          	add    $0x1,%rax
  8042110e42:	48 39 c2             	cmp    %rax,%rdx
  8042110e45:	75 e9                	jne    8042110e30 <memcmp+0xe>
            return (int)*s1 - (int)*s2;
        }
        s1++, s2++;
    }

    return 0;
  8042110e47:	b8 00 00 00 00       	mov    $0x0,%eax
  8042110e4c:	c3                   	ret
            return (int)*s1 - (int)*s2;
  8042110e4d:	0f b6 c1             	movzbl %cl,%eax
  8042110e50:	45 0f b6 c0          	movzbl %r8b,%r8d
  8042110e54:	44 29 c0             	sub    %r8d,%eax
  8042110e57:	c3                   	ret
    return 0;
  8042110e58:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8042110e5d:	c3                   	ret

0000008042110e5e <memfind>:

void *
memfind(const void *src, int c, size_t n) {
  8042110e5e:	f3 0f 1e fa          	endbr64
    const void *end = (const char *)src + n;
  8042110e62:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
    for (; src < end; src++) {
  8042110e66:	48 39 c7             	cmp    %rax,%rdi
  8042110e69:	73 0f                	jae    8042110e7a <memfind+0x1c>
        if (*(const unsigned char *)src == (unsigned char)c) break;
  8042110e6b:	40 38 37             	cmp    %sil,(%rdi)
  8042110e6e:	74 0e                	je     8042110e7e <memfind+0x20>
    for (; src < end; src++) {
  8042110e70:	48 83 c7 01          	add    $0x1,%rdi
  8042110e74:	48 39 f8             	cmp    %rdi,%rax
  8042110e77:	75 f2                	jne    8042110e6b <memfind+0xd>
  8042110e79:	c3                   	ret
  8042110e7a:	48 89 f8             	mov    %rdi,%rax
  8042110e7d:	c3                   	ret
  8042110e7e:	48 89 f8             	mov    %rdi,%rax
    }
    return (void *)src;
}
  8042110e81:	c3                   	ret

0000008042110e82 <strtol>:

long
strtol(const char *s, char **endptr, int base) {
  8042110e82:	f3 0f 1e fa          	endbr64
  8042110e86:	49 89 f2             	mov    %rsi,%r10
    /* Gobble initial whitespace */
    while (*s == ' ' || *s == '\t') s++;
  8042110e89:	0f b6 37             	movzbl (%rdi),%esi
  8042110e8c:	40 80 fe 20          	cmp    $0x20,%sil
  8042110e90:	74 06                	je     8042110e98 <strtol+0x16>
  8042110e92:	40 80 fe 09          	cmp    $0x9,%sil
  8042110e96:	75 13                	jne    8042110eab <strtol+0x29>
  8042110e98:	48 83 c7 01          	add    $0x1,%rdi
  8042110e9c:	0f b6 37             	movzbl (%rdi),%esi
  8042110e9f:	40 80 fe 20          	cmp    $0x20,%sil
  8042110ea3:	74 f3                	je     8042110e98 <strtol+0x16>
  8042110ea5:	40 80 fe 09          	cmp    $0x9,%sil
  8042110ea9:	74 ed                	je     8042110e98 <strtol+0x16>

    bool neg = *s == '-';

    /* Plus/minus sign */
    if (*s == '+' || *s == '-') s++;
  8042110eab:	8d 46 d5             	lea    -0x2b(%rsi),%eax
  8042110eae:	83 e0 fd             	and    $0xfffffffd,%eax
  8042110eb1:	3c 01                	cmp    $0x1,%al
  8042110eb3:	48 83 d7 00          	adc    $0x0,%rdi

    /* Hex or octal base prefix */
    if ((!base || base == 16) && (s[0] == '0' && s[1] == 'x')) {
  8042110eb7:	f7 c2 ef ff ff ff    	test   $0xffffffef,%edx
  8042110ebd:	75 0f                	jne    8042110ece <strtol+0x4c>
  8042110ebf:	80 3f 30             	cmpb   $0x30,(%rdi)
  8042110ec2:	74 14                	je     8042110ed8 <strtol+0x56>
        s += 2;
    } else if (!base && s[0] == '0') {
        base = 8;
        s++;
    } else if (!base) {
        base = 10;
  8042110ec4:	85 d2                	test   %edx,%edx
  8042110ec6:	b8 0a 00 00 00       	mov    $0xa,%eax
  8042110ecb:	0f 44 d0             	cmove  %eax,%edx
    }

    /* Digits */
    long val = 0;
  8042110ece:	b8 00 00 00 00       	mov    $0x0,%eax
            break;

        if (dig >= base) break;

        /* We don't properly detect overflow! */
        val = val * base + dig;
  8042110ed3:	4c 63 ca             	movslq %edx,%r9
  8042110ed6:	eb 36                	jmp    8042110f0e <strtol+0x8c>
    if ((!base || base == 16) && (s[0] == '0' && s[1] == 'x')) {
  8042110ed8:	80 7f 01 78          	cmpb   $0x78,0x1(%rdi)
  8042110edc:	74 0f                	je     8042110eed <strtol+0x6b>
    } else if (!base && s[0] == '0') {
  8042110ede:	85 d2                	test   %edx,%edx
  8042110ee0:	75 ec                	jne    8042110ece <strtol+0x4c>
        s++;
  8042110ee2:	48 83 c7 01          	add    $0x1,%rdi
        base = 8;
  8042110ee6:	ba 08 00 00 00       	mov    $0x8,%edx
        s++;
  8042110eeb:	eb e1                	jmp    8042110ece <strtol+0x4c>
        s += 2;
  8042110eed:	48 83 c7 02          	add    $0x2,%rdi
        base = 16;
  8042110ef1:	ba 10 00 00 00       	mov    $0x10,%edx
        s += 2;
  8042110ef6:	eb d6                	jmp    8042110ece <strtol+0x4c>
            dig -= '0';
  8042110ef8:	83 e9 30             	sub    $0x30,%ecx
        if (dig >= base) break;
  8042110efb:	44 0f b6 c1          	movzbl %cl,%r8d
  8042110eff:	41 39 d0             	cmp    %edx,%r8d
  8042110f02:	7d 21                	jge    8042110f25 <strtol+0xa3>
        val = val * base + dig;
  8042110f04:	49 0f af c1          	imul   %r9,%rax
  8042110f08:	0f b6 c9             	movzbl %cl,%ecx
  8042110f0b:	48 01 c8             	add    %rcx,%rax
        uint8_t dig = *s++;
  8042110f0e:	48 83 c7 01          	add    $0x1,%rdi
  8042110f12:	0f b6 4f ff          	movzbl -0x1(%rdi),%ecx
        if (dig - '0' < 10)
  8042110f16:	80 f9 39             	cmp    $0x39,%cl
  8042110f19:	76 dd                	jbe    8042110ef8 <strtol+0x76>
        else if (dig - 'a' < 27)
  8042110f1b:	80 f9 7b             	cmp    $0x7b,%cl
  8042110f1e:	77 05                	ja     8042110f25 <strtol+0xa3>
            dig -= 'a' - 10;
  8042110f20:	83 e9 57             	sub    $0x57,%ecx
  8042110f23:	eb d6                	jmp    8042110efb <strtol+0x79>
    }

    if (endptr) *endptr = (char *)s;
  8042110f25:	4d 85 d2             	test   %r10,%r10
  8042110f28:	74 03                	je     8042110f2d <strtol+0xab>
  8042110f2a:	49 89 3a             	mov    %rdi,(%r10)

    return (neg ? -val : val);
  8042110f2d:	48 89 c2             	mov    %rax,%rdx
  8042110f30:	48 f7 da             	neg    %rdx
  8042110f33:	40 80 fe 2d          	cmp    $0x2d,%sil
  8042110f37:	48 0f 44 c2          	cmove  %rdx,%rax
}
  8042110f3b:	c3                   	ret

0000008042110f3c <tsc_calibrate>:

    return delta;
}

uint64_t
tsc_calibrate(void) {
  8042110f3c:	f3 0f 1e fa          	endbr64
  8042110f40:	55                   	push   %rbp
  8042110f41:	48 89 e5             	mov    %rsp,%rbp
  8042110f44:	41 57                	push   %r15
  8042110f46:	41 56                	push   %r14
  8042110f48:	41 55                	push   %r13
  8042110f4a:	41 54                	push   %r12
  8042110f4c:	53                   	push   %rbx
  8042110f4d:	48 83 ec 18          	sub    $0x18,%rsp
    static uint64_t cpu_freq;

    if (!cpu_freq) {
  8042110f51:	48 a1 00 7f 00 43 80 	movabs 0x8043007f00,%rax
  8042110f58:	00 00 00 
  8042110f5b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8042110f5f:	48 85 c0             	test   %rax,%rax
  8042110f62:	74 50                	je     8042110fb4 <tsc_calibrate+0x78>
            cpu_freq = DEFAULT_FREQ;
            cprintf("Can't calibrate pit timer. Using default frequency\n");
        }
    }

    return cpu_freq * 1000;
  8042110f64:	48 a1 00 7f 00 43 80 	movabs 0x8043007f00,%rax
  8042110f6b:	00 00 00 
  8042110f6e:	48 69 c0 e8 03 00 00 	imul   $0x3e8,%rax,%rax
}
  8042110f75:	48 83 c4 18          	add    $0x18,%rsp
  8042110f79:	5b                   	pop    %rbx
  8042110f7a:	41 5c                	pop    %r12
  8042110f7c:	41 5d                	pop    %r13
  8042110f7e:	41 5e                	pop    %r14
  8042110f80:	41 5f                	pop    %r15
  8042110f82:	5d                   	pop    %rbp
  8042110f83:	c3                   	ret
    uint64_t tsc = 0;
  8042110f84:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    while (count++ < 50000) {
  8042110f88:	bf 01 00 00 00       	mov    $0x1,%edi
  8042110f8d:	e9 8c 00 00 00       	jmp    804211101e <tsc_calibrate+0xe2>
    uint64_t tsc = 0;
  8042110f92:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
    while (count++ < 50000) {
  8042110f96:	bf 01 00 00 00       	mov    $0x1,%edi
  8042110f9b:	e9 d7 00 00 00       	jmp    8042111077 <tsc_calibrate+0x13b>
        for (i = 1; i <= MAX_QUICK_PIT_ITERATIONS; i++) {
  8042110fa0:	41 83 c2 01          	add    $0x1,%r10d
  8042110fa4:	41 83 e8 01          	sub    $0x1,%r8d
  8042110fa8:	41 83 fa 75          	cmp    $0x75,%r10d
  8042110fac:	0f 85 91 00 00 00    	jne    8042111043 <tsc_calibrate+0x107>
  8042110fb2:	eb 16                	jmp    8042110fca <tsc_calibrate+0x8e>
        int i = TIMES;
  8042110fb4:	bb 64 00 00 00       	mov    $0x64,%ebx
    asm volatile("inb %w1,%0"
  8042110fb9:	41 be 61 00 00 00    	mov    $0x61,%r14d
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8042110fbf:	41 bd ff ff ff ff    	mov    $0xffffffff,%r13d
  8042110fc5:	be 42 00 00 00       	mov    $0x42,%esi
        while (--i > 0) {
  8042110fca:	83 eb 01             	sub    $0x1,%ebx
  8042110fcd:	0f 84 37 01 00 00    	je     804211110a <tsc_calibrate+0x1ce>
    asm volatile("inb %w1,%0"
  8042110fd3:	44 89 f2             	mov    %r14d,%edx
  8042110fd6:	ec                   	in     (%dx),%al
    asm volatile("outb %0,%w1" ::"a"(data), "d"(port));
  8042110fd7:	83 e0 fc             	and    $0xfffffffc,%eax
  8042110fda:	83 c8 01             	or     $0x1,%eax
  8042110fdd:	ee                   	out    %al,(%dx)
  8042110fde:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
  8042110fe3:	ba 43 00 00 00       	mov    $0x43,%edx
  8042110fe8:	ee                   	out    %al,(%dx)
  8042110fe9:	44 89 e8             	mov    %r13d,%eax
  8042110fec:	89 f2                	mov    %esi,%edx
  8042110fee:	ee                   	out    %al,(%dx)
  8042110fef:	ee                   	out    %al,(%dx)
    asm volatile("inb %w1,%0"
  8042110ff0:	ec                   	in     (%dx),%al
  8042110ff1:	ec                   	in     (%dx),%al
  8042110ff2:	ec                   	in     (%dx),%al
  8042110ff3:	ec                   	in     (%dx),%al
        if (!pit_verify_msb(val)) break;
  8042110ff4:	3c ff                	cmp    $0xff,%al
  8042110ff6:	75 8c                	jne    8042110f84 <tsc_calibrate+0x48>
    while (count++ < 50000) {
  8042110ff8:	bf 01 00 00 00       	mov    $0x1,%edi
    asm volatile("rdtsc"
  8042110ffd:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  8042110fff:	48 c1 e2 20          	shl    $0x20,%rdx
  8042111003:	89 c0                	mov    %eax,%eax
  8042111005:	48 89 d1             	mov    %rdx,%rcx
  8042111008:	48 09 c1             	or     %rax,%rcx
  804211100b:	83 c7 01             	add    $0x1,%edi
  804211100e:	81 ff 51 c3 00 00    	cmp    $0xc351,%edi
  8042111014:	74 08                	je     804211101e <tsc_calibrate+0xe2>
    asm volatile("inb %w1,%0"
  8042111016:	89 f2                	mov    %esi,%edx
  8042111018:	ec                   	in     (%dx),%al
  8042111019:	ec                   	in     (%dx),%al
        if (!pit_verify_msb(val)) break;
  804211101a:	3c ff                	cmp    $0xff,%al
  804211101c:	74 df                	je     8042110ffd <tsc_calibrate+0xc1>
    asm volatile("rdtsc"
  804211101e:	0f 31                	rdtsc
    if (pit_expect_msb(0xFF, &tsc, &d1)) {
  8042111020:	83 ff 06             	cmp    $0x6,%edi
  8042111023:	7e a5                	jle    8042110fca <tsc_calibrate+0x8e>
    return (uint64_t)lo | ((uint64_t)hi << 32);
  8042111025:	48 c1 e2 20          	shl    $0x20,%rdx
  8042111029:	89 c0                	mov    %eax,%eax
  804211102b:	48 09 c2             	or     %rax,%rdx
  804211102e:	49 89 d1             	mov    %rdx,%r9
    *deltap = read_tsc() - tsc;
  8042111031:	49 89 d3             	mov    %rdx,%r11
  8042111034:	49 29 cb             	sub    %rcx,%r11
  8042111037:	41 b8 fe ff ff ff    	mov    $0xfffffffe,%r8d
        for (i = 1; i <= MAX_QUICK_PIT_ITERATIONS; i++) {
  804211103d:	41 ba 01 00 00 00    	mov    $0x1,%r10d
    asm volatile("inb %w1,%0"
  8042111043:	89 f2                	mov    %esi,%edx
  8042111045:	ec                   	in     (%dx),%al
  8042111046:	ec                   	in     (%dx),%al
        if (!pit_verify_msb(val)) break;
  8042111047:	44 38 c0             	cmp    %r8b,%al
  804211104a:	0f 85 42 ff ff ff    	jne    8042110f92 <tsc_calibrate+0x56>
    while (count++ < 50000) {
  8042111050:	bf 01 00 00 00       	mov    $0x1,%edi
    asm volatile("rdtsc"
  8042111055:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  8042111057:	48 c1 e2 20          	shl    $0x20,%rdx
  804211105b:	89 c0                	mov    %eax,%eax
  804211105d:	48 09 c2             	or     %rax,%rdx
  8042111060:	49 89 d4             	mov    %rdx,%r12
  8042111063:	83 c7 01             	add    $0x1,%edi
  8042111066:	81 ff 51 c3 00 00    	cmp    $0xc351,%edi
  804211106c:	74 09                	je     8042111077 <tsc_calibrate+0x13b>
    asm volatile("inb %w1,%0"
  804211106e:	89 f2                	mov    %esi,%edx
  8042111070:	ec                   	in     (%dx),%al
  8042111071:	ec                   	in     (%dx),%al
        if (!pit_verify_msb(val)) break;
  8042111072:	44 38 c0             	cmp    %r8b,%al
  8042111075:	74 de                	je     8042111055 <tsc_calibrate+0x119>
    asm volatile("rdtsc"
  8042111077:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  8042111079:	48 c1 e2 20          	shl    $0x20,%rdx
  804211107d:	89 c0                	mov    %eax,%eax
  804211107f:	48 09 c2             	or     %rax,%rdx
    *deltap = read_tsc() - tsc;
  8042111082:	4c 29 e2             	sub    %r12,%rdx
  8042111085:	49 89 d7             	mov    %rdx,%r15
            if (!pit_expect_msb(0xFF - i, &delta, &d2)) break;
  8042111088:	83 ff 06             	cmp    $0x6,%edi
  804211108b:	0f 8e 39 ff ff ff    	jle    8042110fca <tsc_calibrate+0x8e>
            delta -= tsc;
  8042111091:	4c 89 e2             	mov    %r12,%rdx
  8042111094:	48 29 ca             	sub    %rcx,%rdx
            if (d1 + d2 >= delta >> 11) continue;
  8042111097:	4b 8d 3c 3b          	lea    (%r11,%r15,1),%rdi
  804211109b:	48 89 d0             	mov    %rdx,%rax
  804211109e:	48 c1 e8 0b          	shr    $0xb,%rax
  80421110a2:	48 39 c7             	cmp    %rax,%rdi
  80421110a5:	0f 83 f5 fe ff ff    	jae    8042110fa0 <tsc_calibrate+0x64>
    asm volatile("inb %w1,%0"
  80421110ab:	49 89 d4             	mov    %rdx,%r12
  80421110ae:	89 f2                	mov    %esi,%edx
  80421110b0:	ec                   	in     (%dx),%al
  80421110b1:	ec                   	in     (%dx),%al
            if (!pit_verify_msb(0xFE - i)) break;
  80421110b2:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  80421110b7:	44 29 d2             	sub    %r10d,%edx
  80421110ba:	38 c2                	cmp    %al,%dl
  80421110bc:	0f 85 08 ff ff ff    	jne    8042110fca <tsc_calibrate+0x8e>
    delta += (long)(d2 - d1) / 2;
  80421110c2:	4c 29 c9             	sub    %r9,%rcx
  80421110c5:	4a 8d 04 39          	lea    (%rcx,%r15,1),%rax
  80421110c9:	48 89 c2             	mov    %rax,%rdx
  80421110cc:	48 c1 ea 3f          	shr    $0x3f,%rdx
  80421110d0:	48 01 d0             	add    %rdx,%rax
  80421110d3:	48 d1 f8             	sar    $1,%rax
  80421110d6:	4c 01 e0             	add    %r12,%rax
    delta *= PIT_TICK_RATE;
  80421110d9:	48 69 c0 de 34 12 00 	imul   $0x1234de,%rax,%rax
    delta /= i * 256 * 1000;
  80421110e0:	41 69 ca 00 e8 03 00 	imul   $0x3e800,%r10d,%ecx
  80421110e7:	48 63 c9             	movslq %ecx,%rcx
            if ((cpu_freq = quick_pit_calibrate())) break;
  80421110ea:	48 39 c8             	cmp    %rcx,%rax
  80421110ed:	0f 82 d7 fe ff ff    	jb     8042110fca <tsc_calibrate+0x8e>
    delta /= i * 256 * 1000;
  80421110f3:	ba 00 00 00 00       	mov    $0x0,%edx
  80421110f8:	48 f7 f1             	div    %rcx
  80421110fb:	48 a3 00 7f 00 43 80 	movabs %rax,0x8043007f00
  8042111102:	00 00 00 
        if (!i) {
  8042111105:	e9 5a fe ff ff       	jmp    8042110f64 <tsc_calibrate+0x28>
            cpu_freq = DEFAULT_FREQ;
  804211110a:	48 b8 00 7f 00 43 80 	movabs $0x8043007f00,%rax
  8042111111:	00 00 00 
  8042111114:	48 c7 00 a0 25 26 00 	movq   $0x2625a0,(%rax)
            cprintf("Can't calibrate pit timer. Using default frequency\n");
  804211111b:	48 bf d8 14 12 42 80 	movabs $0x80421214d8,%rdi
  8042111122:	00 00 00 
  8042111125:	b8 00 00 00 00       	mov    $0x0,%eax
  804211112a:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042111131:	00 00 00 
  8042111134:	ff d2                	call   *%rdx
  8042111136:	e9 29 fe ff ff       	jmp    8042110f64 <tsc_calibrate+0x28>

000000804211113b <print_time>:

void
print_time(unsigned seconds) {
  804211113b:	f3 0f 1e fa          	endbr64
  804211113f:	55                   	push   %rbp
  8042111140:	48 89 e5             	mov    %rsp,%rbp
  8042111143:	89 fe                	mov    %edi,%esi
    cprintf("%u\n", seconds);
  8042111145:	48 bf f3 03 12 42 80 	movabs $0x80421203f3,%rdi
  804211114c:	00 00 00 
  804211114f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111154:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804211115b:	00 00 00 
  804211115e:	ff d2                	call   *%rdx
}
  8042111160:	5d                   	pop    %rbp
  8042111161:	c3                   	ret

0000008042111162 <print_timer_error>:

void
print_timer_error(void) {
  8042111162:	f3 0f 1e fa          	endbr64
  8042111166:	55                   	push   %rbp
  8042111167:	48 89 e5             	mov    %rsp,%rbp
    cprintf("Timer Error\n");
  804211116a:	48 bf f7 03 12 42 80 	movabs $0x80421203f7,%rdi
  8042111171:	00 00 00 
  8042111174:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111179:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  8042111180:	00 00 00 
  8042111183:	ff d2                	call   *%rdx
}
  8042111185:	5d                   	pop    %rbp
  8042111186:	c3                   	ret

0000008042111187 <timer_start>:
static int timer_id = -1;
static uint64_t timer = 0;
static uint64_t freq = 0;

void
timer_start(const char *name) {
  8042111187:	f3 0f 1e fa          	endbr64
  804211118b:	55                   	push   %rbp
  804211118c:	48 89 e5             	mov    %rsp,%rbp
  804211118f:	41 56                	push   %r14
  8042111191:	41 55                	push   %r13
  8042111193:	41 54                	push   %r12
  8042111195:	53                   	push   %rbx
  8042111196:	49 89 fd             	mov    %rdi,%r13
	for (int i = 0; i < MAX_TIMERS; i++) {
  8042111199:	49 bc 80 75 00 43 80 	movabs $0x8043007580,%r12
  80421111a0:	00 00 00 
  80421111a3:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (timertab[i].timer_name) {
			if (!strcmp(timertab[i].timer_name, name)) {
  80421111a8:	49 be 90 0b 11 42 80 	movabs $0x8042110b90,%r14
  80421111af:	00 00 00 
  80421111b2:	eb 0c                	jmp    80421111c0 <timer_start+0x39>
	for (int i = 0; i < MAX_TIMERS; i++) {
  80421111b4:	83 c3 01             	add    $0x1,%ebx
  80421111b7:	49 83 c4 28          	add    $0x28,%r12
  80421111bb:	83 fb 05             	cmp    $0x5,%ebx
  80421111be:	74 5f                	je     804211121f <timer_start+0x98>
		if (timertab[i].timer_name) {
  80421111c0:	49 8b 3c 24          	mov    (%r12),%rdi
  80421111c4:	48 85 ff             	test   %rdi,%rdi
  80421111c7:	74 eb                	je     80421111b4 <timer_start+0x2d>
			if (!strcmp(timertab[i].timer_name, name)) {
  80421111c9:	4c 89 ee             	mov    %r13,%rsi
  80421111cc:	41 ff d6             	call   *%r14
  80421111cf:	85 c0                	test   %eax,%eax
  80421111d1:	75 e1                	jne    80421111b4 <timer_start+0x2d>
				timer_started = 1;
  80421111d3:	48 b8 18 7f 00 43 80 	movabs $0x8043007f18,%rax
  80421111da:	00 00 00 
  80421111dd:	c6 00 01             	movb   $0x1,(%rax)
				timer_id = i;
  80421111e0:	89 d8                	mov    %ebx,%eax
  80421111e2:	a3 a0 38 14 42 80 00 	movabs %eax,0x80421438a0
  80421111e9:	00 00 
    asm volatile("rdtsc"
  80421111eb:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  80421111ed:	48 c1 e2 20          	shl    $0x20,%rdx
  80421111f1:	89 c0                	mov    %eax,%eax
  80421111f3:	48 09 d0             	or     %rdx,%rax
  80421111f6:	48 a3 10 7f 00 43 80 	movabs %rax,0x8043007f10
  80421111fd:	00 00 00 
				timer = read_tsc();
				freq = timertab[timer_id].get_cpu_freq();
  8042111200:	48 63 db             	movslq %ebx,%rbx
  8042111203:	48 8d 14 9b          	lea    (%rbx,%rbx,4),%rdx
  8042111207:	48 b8 80 75 00 43 80 	movabs $0x8043007580,%rax
  804211120e:	00 00 00 
  8042111211:	ff 54 d0 10          	call   *0x10(%rax,%rdx,8)
  8042111215:	48 a3 08 7f 00 43 80 	movabs %rax,0x8043007f08
  804211121c:	00 00 00 
				break;
			}
		}
	}
}
  804211121f:	5b                   	pop    %rbx
  8042111220:	41 5c                	pop    %r12
  8042111222:	41 5d                	pop    %r13
  8042111224:	41 5e                	pop    %r14
  8042111226:	5d                   	pop    %rbp
  8042111227:	c3                   	ret

0000008042111228 <timer_stop>:

void
timer_stop(void) {
  8042111228:	f3 0f 1e fa          	endbr64
  804211122c:	55                   	push   %rbp
  804211122d:	48 89 e5             	mov    %rsp,%rbp
	if (!timer_started) {
  8042111230:	48 b8 18 7f 00 43 80 	movabs $0x8043007f18,%rax
  8042111237:	00 00 00 
  804211123a:	80 38 00             	cmpb   $0x0,(%rax)
  804211123d:	74 69                	je     80421112a8 <timer_stop+0x80>
		print_timer_error();
		return;
	}
	timer_started = 0;
  804211123f:	48 b8 18 7f 00 43 80 	movabs $0x8043007f18,%rax
  8042111246:	00 00 00 
  8042111249:	c6 00 00             	movb   $0x0,(%rax)
	if (timer_id < 0) {
  804211124c:	48 b8 a0 38 14 42 80 	movabs $0x80421438a0,%rax
  8042111253:	00 00 00 
  8042111256:	83 38 00             	cmpl   $0x0,(%rax)
  8042111259:	78 5b                	js     80421112b6 <timer_stop+0x8e>
		print_timer_error();
		return;
	}
	timer_id = -1;
  804211125b:	48 b8 a0 38 14 42 80 	movabs $0x80421438a0,%rax
  8042111262:	00 00 00 
  8042111265:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
    asm volatile("rdtsc"
  804211126b:	0f 31                	rdtsc
    return (uint64_t)lo | ((uint64_t)hi << 32);
  804211126d:	48 c1 e2 20          	shl    $0x20,%rdx
  8042111271:	89 c0                	mov    %eax,%eax
  8042111273:	48 09 c2             	or     %rax,%rdx
	print_time((read_tsc() - timer) / freq);
  8042111276:	48 b8 10 7f 00 43 80 	movabs $0x8043007f10,%rax
  804211127d:	00 00 00 
  8042111280:	48 2b 10             	sub    (%rax),%rdx
  8042111283:	48 89 d0             	mov    %rdx,%rax
  8042111286:	48 b9 08 7f 00 43 80 	movabs $0x8043007f08,%rcx
  804211128d:	00 00 00 
  8042111290:	ba 00 00 00 00       	mov    $0x0,%edx
  8042111295:	48 f7 31             	divq   (%rcx)
  8042111298:	89 c7                	mov    %eax,%edi
  804211129a:	48 b8 3b 11 11 42 80 	movabs $0x804211113b,%rax
  80421112a1:	00 00 00 
  80421112a4:	ff d0                	call   *%rax
}
  80421112a6:	5d                   	pop    %rbp
  80421112a7:	c3                   	ret
		print_timer_error();
  80421112a8:	48 b8 62 11 11 42 80 	movabs $0x8042111162,%rax
  80421112af:	00 00 00 
  80421112b2:	ff d0                	call   *%rax
		return;
  80421112b4:	eb f0                	jmp    80421112a6 <timer_stop+0x7e>
		print_timer_error();
  80421112b6:	48 b8 62 11 11 42 80 	movabs $0x8042111162,%rax
  80421112bd:	00 00 00 
  80421112c0:	ff d0                	call   *%rax
		return;
  80421112c2:	eb e2                	jmp    80421112a6 <timer_stop+0x7e>

00000080421112c4 <timer_cpu_frequency>:

void
timer_cpu_frequency(const char *name) {
  80421112c4:	f3 0f 1e fa          	endbr64
  80421112c8:	55                   	push   %rbp
  80421112c9:	48 89 e5             	mov    %rsp,%rbp
  80421112cc:	41 56                	push   %r14
  80421112ce:	41 55                	push   %r13
  80421112d0:	41 54                	push   %r12
  80421112d2:	53                   	push   %rbx
  80421112d3:	49 89 fd             	mov    %rdi,%r13
	for (int i = 0; i < MAX_TIMERS; i++) {
  80421112d6:	49 bc 80 75 00 43 80 	movabs $0x8043007580,%r12
  80421112dd:	00 00 00 
  80421112e0:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (timertab[i].timer_name) {
			if (!strcmp(timertab[i].timer_name, name)) {
  80421112e5:	49 be 90 0b 11 42 80 	movabs $0x8042110b90,%r14
  80421112ec:	00 00 00 
  80421112ef:	eb 0c                	jmp    80421112fd <timer_cpu_frequency+0x39>
	for (int i = 0; i < MAX_TIMERS; i++) {
  80421112f1:	83 c3 01             	add    $0x1,%ebx
  80421112f4:	49 83 c4 28          	add    $0x28,%r12
  80421112f8:	83 fb 05             	cmp    $0x5,%ebx
  80421112fb:	74 46                	je     8042111343 <timer_cpu_frequency+0x7f>
		if (timertab[i].timer_name) {
  80421112fd:	49 8b 3c 24          	mov    (%r12),%rdi
  8042111301:	48 85 ff             	test   %rdi,%rdi
  8042111304:	74 eb                	je     80421112f1 <timer_cpu_frequency+0x2d>
			if (!strcmp(timertab[i].timer_name, name)) {
  8042111306:	4c 89 ee             	mov    %r13,%rsi
  8042111309:	41 ff d6             	call   *%r14
  804211130c:	85 c0                	test   %eax,%eax
  804211130e:	75 e1                	jne    80421112f1 <timer_cpu_frequency+0x2d>
				cprintf("%lu\n", timertab[i].get_cpu_freq());
  8042111310:	48 63 db             	movslq %ebx,%rbx
  8042111313:	48 8d 14 9b          	lea    (%rbx,%rbx,4),%rdx
  8042111317:	48 b8 80 75 00 43 80 	movabs $0x8043007580,%rax
  804211131e:	00 00 00 
  8042111321:	ff 54 d0 10          	call   *0x10(%rax,%rdx,8)
  8042111325:	48 89 c6             	mov    %rax,%rsi
  8042111328:	48 bf 04 04 12 42 80 	movabs $0x8042120404,%rdi
  804211132f:	00 00 00 
  8042111332:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111337:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804211133e:	00 00 00 
  8042111341:	ff d2                	call   *%rdx
				break;
			}
		}
	}
  8042111343:	5b                   	pop    %rbx
  8042111344:	41 5c                	pop    %r12
  8042111346:	41 5d                	pop    %r13
  8042111348:	41 5e                	pop    %r14
  804211134a:	5d                   	pop    %rbp
  804211134b:	c3                   	ret

000000804211134c <efi_call_in_32bit_mode>:

extern void _efi_call_in_32bit_mode_asm(uint32_t func, efi_registers *efi_reg, void *stack_contents, size_t stack_contents_size);

/* stack_contents_size is 16-byte multiple */
int
efi_call_in_32bit_mode(uint32_t func, efi_registers *efi_reg, void *stack_contents, size_t stack_contents_size, uint32_t *efi_status) {
  804211134c:	f3 0f 1e fa          	endbr64
  8042111350:	55                   	push   %rbp
  8042111351:	48 89 e5             	mov    %rsp,%rbp
  8042111354:	41 54                	push   %r12
  8042111356:	53                   	push   %rbx
  8042111357:	48 89 f3             	mov    %rsi,%rbx

    if (!func || !efi_reg || !stack_contents || (stack_contents_size & 15)) return -E_INVAL;
  804211135a:	85 ff                	test   %edi,%edi
  804211135c:	0f 94 c0             	sete   %al
  804211135f:	48 85 f6             	test   %rsi,%rsi
  8042111362:	40 0f 94 c6          	sete   %sil
  8042111366:	40 08 f0             	or     %sil,%al
  8042111369:	75 44                	jne    80421113af <efi_call_in_32bit_mode+0x63>
  804211136b:	4d 89 c4             	mov    %r8,%r12
  804211136e:	48 85 d2             	test   %rdx,%rdx
  8042111371:	74 3c                	je     80421113af <efi_call_in_32bit_mode+0x63>
  8042111373:	f6 c1 0f             	test   $0xf,%cl
  8042111376:	75 3e                	jne    80421113b6 <efi_call_in_32bit_mode+0x6a>

    /* We need to set up kernel data segments for 32 bit mode
     * before calling asm. */
    asm volatile("movw %%ax,%%es\n\t"
  8042111378:	b8 20 00 00 00       	mov    $0x20,%eax
  804211137d:	8e c0                	mov    %eax,%es
  804211137f:	8e d8                	mov    %eax,%ds
  8042111381:	8e d0                	mov    %eax,%ss
                 "movw %%ax,%%ds\n\t"
                 "movw %%ax,%%ss" ::"a"(GD_KD32));

    _efi_call_in_32bit_mode_asm(func, efi_reg, stack_contents, stack_contents_size);
  8042111383:	48 89 de             	mov    %rbx,%rsi
  8042111386:	48 b8 be 13 11 42 80 	movabs $0x80421113be,%rax
  804211138d:	00 00 00 
  8042111390:	ff d0                	call   *%rax

    /* Restore 64 bit kernel data segments */
    asm volatile("movw %%ax,%%es\n\t"
  8042111392:	b8 10 00 00 00       	mov    $0x10,%eax
  8042111397:	8e c0                	mov    %eax,%es
  8042111399:	8e d8                	mov    %eax,%ds
  804211139b:	8e d0                	mov    %eax,%ss
                 "movw %%ax,%%ds\n\t"
                 "movw %%ax,%%ss" ::"a"(GD_KD));

    *efi_status = (uint32_t)efi_reg->rax;
  804211139d:	48 8b 43 20          	mov    0x20(%rbx),%rax
  80421113a1:	41 89 04 24          	mov    %eax,(%r12)

    return 0;
  80421113a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80421113aa:	5b                   	pop    %rbx
  80421113ab:	41 5c                	pop    %r12
  80421113ad:	5d                   	pop    %rbp
  80421113ae:	c3                   	ret
    if (!func || !efi_reg || !stack_contents || (stack_contents_size & 15)) return -E_INVAL;
  80421113af:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80421113b4:	eb f4                	jmp    80421113aa <efi_call_in_32bit_mode+0x5e>
  80421113b6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80421113bb:	eb ed                	jmp    80421113aa <efi_call_in_32bit_mode+0x5e>
  80421113bd:	90                   	nop

00000080421113be <_efi_call_in_32bit_mode_asm>:
.align 2

.globl _efi_call_in_32bit_mode_asm
.type _efi_call_in_32bit_mode_asm, @function;
_efi_call_in_32bit_mode_asm:
    pushq %rbp
  80421113be:	55                   	push   %rbp
    movq %rsp, %rbp
  80421113bf:	48 89 e5             	mov    %rsp,%rbp
    # Save non-volatile registers
    push %rbx
  80421113c2:	53                   	push   %rbx
    push %r12
  80421113c3:	41 54                	push   %r12
    push %r13
  80421113c5:	41 55                	push   %r13
    push %r14
  80421113c7:	41 56                	push   %r14
    push %r15
  80421113c9:	41 57                	push   %r15

    # save parameters that we will need later
    push %rsi
  80421113cb:	56                   	push   %rsi
    push %rcx
  80421113cc:	51                   	push   %rcx
    # Save %rbp and align to 16-byte boundary
    # efi_reg in %rsi
    # stack_contents into %rdx
    # s_c_s into %rcx
    # s_c_s into %rcx
    push %rbp
  80421113cd:	55                   	push   %rbp

    # Make room for stack contents
    sub %rcx, %rsp
  80421113ce:	48 29 cc             	sub    %rcx,%rsp

    COPY_STACK(%rdx, %rcx, %r8)
  80421113d1:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8

00000080421113d8 <copyloop>:
  80421113d8:	4a 8b 04 02          	mov    (%rdx,%r8,1),%rax
  80421113dc:	4a 89 04 04          	mov    %rax,(%rsp,%r8,1)
  80421113e0:	49 83 c0 08          	add    $0x8,%r8
  80421113e4:	49 39 c8             	cmp    %rcx,%r8
  80421113e7:	75 ef                	jne    80421113d8 <copyloop>

    # Here in long-mode, with high kernel addresses,
    # but with the kernel double-mapped in the bottom 4GB.
    # We now switch to compat mode and call into EFI.
    ENTER_COMPAT_MODE()
  80421113e9:	e8 00 00 00 00       	call   80421113ee <copyloop+0x16>
  80421113ee:	48 81 04 24 11 00 00 	addq   $0x11,(%rsp)
  80421113f5:	00 
  80421113f6:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%rsp)
  80421113fd:	00 
  80421113fe:	cb                   	lret

    # call EFI runtime
    call *%edi
  80421113ff:	ff d7                	call   *%rdi

    ENTER_64BIT_MODE()
  8042111401:	6a 08                	push   $0x8
  8042111403:	e8 00 00 00 00       	call   8042111408 <copyloop+0x30>
  8042111408:	81 04 24 08 00 00 00 	addl   $0x8,(%rsp)
  804211140f:	cb                   	lret

    # load efi_reg into %esi
    mov -48(%rbp), %rsi
  8042111410:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    /* save RAX back */
    mov %rax, 32(%rsi)
  8042111414:	48 89 46 20          	mov    %rax,0x20(%rsi)

    # load s_c_s into %rcx
    mov -56(%rbp), %rcx
  8042111418:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    # discard stack contents
    add %rcx, %rsp
  804211141c:	48 01 cc             	add    %rcx,%rsp
    # restore full 64-bit frame pointer
    # which the 32-bit EFI will have truncated
    # our full %rsp will be restored by EMARF
    pop %rbp
  804211141f:	5d                   	pop    %rbp

    pop %rcx
  8042111420:	59                   	pop    %rcx
    pop %rsi
  8042111421:	5e                   	pop    %rsi
    pop %r15
  8042111422:	41 5f                	pop    %r15
    pop %r14
  8042111424:	41 5e                	pop    %r14
    pop %r13
  8042111426:	41 5d                	pop    %r13
    pop %r12
  8042111428:	41 5c                	pop    %r12
    pop %rbx
  804211142a:	5b                   	pop    %rbx

    leave
  804211142b:	c9                   	leave
    ret
  804211142c:	c3                   	ret

000000804211142d <__spin_initlock>:
    return lock->locked;
}
#endif

void
__spin_initlock(struct spinlock *lk, char *name) {
  804211142d:	f3 0f 1e fa          	endbr64
    lk->locked = 0;
  8042111431:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
#if trace_spinlock
    lk->name = name;
#endif
}
  8042111437:	c3                   	ret

0000008042111438 <spin_lock>:
/* Acquire the lock.
 * Loops (spins) until the lock is acquired.
 * Holding a lock for a long time may cause
 * other CPUs to waste time spinning to acquire it. */
void
spin_lock(struct spinlock *lk) {
  8042111438:	f3 0f 1e fa          	endbr64
    uint32_t result = __atomic_exchange_n(addr, newval, __ATOMIC_ACQ_REL);
  804211143c:	ba 01 00 00 00       	mov    $0x1,%edx
#endif

    /* The xchg is atomic.
     * It also serializes, so that reads after acquire are not
     * reordered before it. */
    while (xchg(&lk->locked, 1)) asm volatile("pause");
  8042111441:	eb 02                	jmp    8042111445 <spin_lock+0xd>
  8042111443:	f3 90                	pause
  8042111445:	89 d0                	mov    %edx,%eax
  8042111447:	87 07                	xchg   %eax,(%rdi)
  8042111449:	85 c0                	test   %eax,%eax
  804211144b:	75 f6                	jne    8042111443 <spin_lock+0xb>

        /* Record info about lock acquisition for debugging. */
#if trace_spinlock
    get_caller_pcs(lk->pcs);
#endif
}
  804211144d:	c3                   	ret

000000804211144e <spin_unlock>:

/* Release the lock. */
void
spin_unlock(struct spinlock *lk) {
  804211144e:	f3 0f 1e fa          	endbr64
  8042111452:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111457:	87 07                	xchg   %eax,(%rdi)
     * Paper says that Intel 64 and IA-32 will not move a load
     * after a store. So lock->locked = 0 would work here.
     * The xchg being asm volatile ensures gcc emits it after
     * the above assignments (and after the critical section). */
    xchg(&lk->locked, 0);
}
  8042111459:	c3                   	ret

000000804211145a <swap_init>:
#define Test 1

extern struct swap swap_info[SWAP_AMOUNT];

void swap_init()
{
  804211145a:	f3 0f 1e fa          	endbr64
  804211145e:	55                   	push   %rbp
  804211145f:	48 89 e5             	mov    %rsp,%rbp
  8042111462:	41 56                	push   %r14
  8042111464:	41 55                	push   %r13
  8042111466:	41 54                	push   %r12
  8042111468:	53                   	push   %rbx
  8042111469:	48 81 ec 80 03 00 00 	sub    $0x380,%rsp
#ifdef Test

    char src[] = "   \n"
  8042111470:	48 be 10 15 12 42 80 	movabs $0x8042121510,%rsi
  8042111477:	00 00 00 
  804211147a:	48 8b 06             	mov    (%rsi),%rax
  804211147d:	48 89 85 a4 fd ff ff 	mov    %rax,-0x25c(%rbp)
  8042111484:	48 a1 44 17 12 42 80 	movabs 0x8042121744,%rax
  804211148b:	00 00 00 
  804211148e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8042111492:	48 8d bd a8 fd ff ff 	lea    -0x258(%rbp),%rdi
  8042111499:	48 c7 c1 fc ff ff ff 	mov    $0xfffffffffffffffc,%rcx
  80421114a0:	48 29 ce             	sub    %rcx,%rsi
  80421114a3:	81 c1 3c 02 00 00    	add    $0x23c,%ecx
  80421114a9:	c1 e9 03             	shr    $0x3,%ecx
  80421114ac:	89 c9                	mov    %ecx,%ecx
  80421114ae:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
                    "   \n"
                    "\n"
                    "     \n"
                    "\n";;

    char dst[LZ4_compressBound(321)];
  80421114b1:	bf 41 01 00 00       	mov    $0x141,%edi
  80421114b6:	48 b8 10 29 11 42 80 	movabs $0x8042112910,%rax
  80421114bd:	00 00 00 
  80421114c0:	ff d0                	call   *%rax
  80421114c2:	48 98                	cltq
  80421114c4:	48 83 c0 0f          	add    $0xf,%rax
  80421114c8:	48 89 c1             	mov    %rax,%rcx
  80421114cb:	48 83 e1 f0          	and    $0xfffffffffffffff0,%rcx
  80421114cf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80421114d5:	48 89 e2             	mov    %rsp,%rdx
  80421114d8:	48 29 c2             	sub    %rax,%rdx
  80421114db:	48 39 d4             	cmp    %rdx,%rsp
  80421114de:	74 12                	je     80421114f2 <swap_init+0x98>
  80421114e0:	48 81 ec 00 10 00 00 	sub    $0x1000,%rsp
  80421114e7:	48 83 8c 24 f8 0f 00 	orq    $0x0,0xff8(%rsp)
  80421114ee:	00 00 
  80421114f0:	eb e9                	jmp    80421114db <swap_init+0x81>
  80421114f2:	48 89 c8             	mov    %rcx,%rax
  80421114f5:	25 ff 0f 00 00       	and    $0xfff,%eax
  80421114fa:	48 29 c4             	sub    %rax,%rsp
  80421114fd:	48 85 c0             	test   %rax,%rax
  8042111500:	74 06                	je     8042111508 <swap_init+0xae>
  8042111502:	48 83 4c 04 f8 00    	orq    $0x0,-0x8(%rsp,%rax,1)
    cprintf("%d\n", LZ4_compressBound(4096));
  8042111508:	bf 00 10 00 00       	mov    $0x1000,%edi
  804211150d:	49 be 10 29 11 42 80 	movabs $0x8042112910,%r14
  8042111514:	00 00 00 
  8042111517:	41 ff d6             	call   *%r14
  804211151a:	89 c6                	mov    %eax,%esi
  804211151c:	49 bd 67 f9 11 42 80 	movabs $0x804211f967,%r13
  8042111523:	00 00 00 
  8042111526:	4c 89 ef             	mov    %r13,%rdi
  8042111529:	b8 00 00 00 00       	mov    $0x0,%eax
  804211152e:	48 bb 70 cf 10 42 80 	movabs $0x804210cf70,%rbx
  8042111535:	00 00 00 
  8042111538:	ff d3                	call   *%rbx
    int cur_size = LZ4_compress_default(src, dst, 321, LZ4_compressBound(321));
  804211153a:	bf 41 01 00 00       	mov    $0x141,%edi
  804211153f:	41 ff d6             	call   *%r14
  8042111542:	89 c1                	mov    %eax,%ecx
  8042111544:	ba 41 01 00 00       	mov    $0x141,%edx
  8042111549:	48 89 e6             	mov    %rsp,%rsi
  804211154c:	48 8d bd a4 fd ff ff 	lea    -0x25c(%rbp),%rdi
  8042111553:	48 b8 6d 5d 11 42 80 	movabs $0x8042115d6d,%rax
  804211155a:	00 00 00 
  804211155d:	ff d0                	call   *%rax
  804211155f:	41 89 c4             	mov    %eax,%r12d
    cprintf("%d\n", LZ4_compressBound(cur_size));
  8042111562:	89 c7                	mov    %eax,%edi
  8042111564:	41 ff d6             	call   *%r14
  8042111567:	89 c6                	mov    %eax,%esi
  8042111569:	4c 89 ef             	mov    %r13,%rdi
  804211156c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111571:	ff d3                	call   *%rbx
    cprintf("%s\n", dst);
  8042111573:	48 89 e6             	mov    %rsp,%rsi
  8042111576:	49 bd 6e f5 11 42 80 	movabs $0x804211f56e,%r13
  804211157d:	00 00 00 
  8042111580:	4c 89 ef             	mov    %r13,%rdi
  8042111583:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111588:	ff d3                	call   *%rbx
    char final[321];
    LZ4_decompress_safe(dst, final, cur_size, 321);
  804211158a:	b9 41 01 00 00       	mov    $0x141,%ecx
  804211158f:	44 89 e2             	mov    %r12d,%edx
  8042111592:	48 8d b5 63 fc ff ff 	lea    -0x39d(%rbp),%rsi
  8042111599:	48 89 e7             	mov    %rsp,%rdi
  804211159c:	48 b8 82 ba 11 42 80 	movabs $0x804211ba82,%rax
  80421115a3:	00 00 00 
  80421115a6:	ff d0                	call   *%rax
    cprintf("%s\n", final);
  80421115a8:	48 8d b5 63 fc ff ff 	lea    -0x39d(%rbp),%rsi
  80421115af:	4c 89 ef             	mov    %r13,%rdi
  80421115b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80421115b7:	ff d3                	call   *%rbx
#endif

}
  80421115b9:	48 8d 65 e0          	lea    -0x20(%rbp),%rsp
  80421115bd:	5b                   	pop    %rbx
  80421115be:	41 5c                	pop    %r12
  80421115c0:	41 5d                	pop    %r13
  80421115c2:	41 5e                	pop    %r14
  80421115c4:	5d                   	pop    %rbp
  80421115c5:	c3                   	ret

00000080421115c6 <swap_shift>:

void swap_shift(int k)
{
  80421115c6:	f3 0f 1e fa          	endbr64
  80421115ca:	55                   	push   %rbp
  80421115cb:	48 89 e5             	mov    %rsp,%rbp
  80421115ce:	41 57                	push   %r15
  80421115d0:	41 56                	push   %r14
  80421115d2:	41 55                	push   %r13
  80421115d4:	41 54                	push   %r12
  80421115d6:	53                   	push   %rbx
  80421115d7:	48 83 ec 08          	sub    $0x8,%rsp
  80421115db:	41 89 fc             	mov    %edi,%r12d
    char * tmp = swap_info[k].buffer;
  80421115de:	48 63 c7             	movslq %edi,%rax
  80421115e1:	48 c1 e0 04          	shl    $0x4,%rax
  80421115e5:	48 ba 60 10 00 43 80 	movabs $0x8043001060,%rdx
  80421115ec:	00 00 00 
  80421115ef:	4c 8b 2c 02          	mov    (%rdx,%rax,1),%r13
    cprintf("%ld\n", (uintptr_t) tmp);
  80421115f3:	4c 89 ee             	mov    %r13,%rsi
  80421115f6:	48 bf 0d 04 12 42 80 	movabs $0x804212040d,%rdi
  80421115fd:	00 00 00 
  8042111600:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111605:	48 ba 70 cf 10 42 80 	movabs $0x804210cf70,%rdx
  804211160c:	00 00 00 
  804211160f:	ff d2                	call   *%rdx
    for (int i = k; i < SWAP_AMOUNT - 1; i++) {
  8042111611:	45 85 e4             	test   %r12d,%r12d
  8042111614:	7f 6b                	jg     8042111681 <swap_shift+0xbb>
  8042111616:	4d 63 e4             	movslq %r12d,%r12
  8042111619:	4c 89 e3             	mov    %r12,%rbx
  804211161c:	48 c1 e3 04          	shl    $0x4,%rbx
  8042111620:	48 b8 60 10 00 43 80 	movabs $0x8043001060,%rax
  8042111627:	00 00 00 
  804211162a:	48 01 c3             	add    %rax,%rbx
        memmove(tmp, swap_info[i + 1].buffer, swap_info[i + 1].size);
  804211162d:	49 bf f7 0c 11 42 80 	movabs $0x8042110cf7,%r15
  8042111634:	00 00 00 
        tmp += swap_info[i + 1].size;
        swap_info[i + 1].buffer = tmp;
        swap_info[i].size = swap_info[i + 1].size;
        cprintf("%ld\n", (uintptr_t) tmp);
  8042111637:	49 be 70 cf 10 42 80 	movabs $0x804210cf70,%r14
  804211163e:	00 00 00 
        memmove(tmp, swap_info[i + 1].buffer, swap_info[i + 1].size);
  8042111641:	48 63 53 18          	movslq 0x18(%rbx),%rdx
  8042111645:	48 8b 73 10          	mov    0x10(%rbx),%rsi
  8042111649:	4c 89 ef             	mov    %r13,%rdi
  804211164c:	41 ff d7             	call   *%r15
        tmp += swap_info[i + 1].size;
  804211164f:	8b 43 18             	mov    0x18(%rbx),%eax
  8042111652:	48 63 d0             	movslq %eax,%rdx
  8042111655:	49 01 d5             	add    %rdx,%r13
        swap_info[i + 1].buffer = tmp;
  8042111658:	4c 89 6b 10          	mov    %r13,0x10(%rbx)
        swap_info[i].size = swap_info[i + 1].size;
  804211165c:	89 43 08             	mov    %eax,0x8(%rbx)
        cprintf("%ld\n", (uintptr_t) tmp);
  804211165f:	4c 89 ee             	mov    %r13,%rsi
  8042111662:	48 bf 0d 04 12 42 80 	movabs $0x804212040d,%rdi
  8042111669:	00 00 00 
  804211166c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111671:	41 ff d6             	call   *%r14
    for (int i = k; i < SWAP_AMOUNT - 1; i++) {
  8042111674:	49 83 c4 01          	add    $0x1,%r12
  8042111678:	48 83 c3 10          	add    $0x10,%rbx
  804211167c:	45 85 e4             	test   %r12d,%r12d
  804211167f:	7e c0                	jle    8042111641 <swap_shift+0x7b>
    }

}
  8042111681:	48 83 c4 08          	add    $0x8,%rsp
  8042111685:	5b                   	pop    %rbx
  8042111686:	41 5c                	pop    %r12
  8042111688:	41 5d                	pop    %r13
  804211168a:	41 5e                	pop    %r14
  804211168c:	41 5f                	pop    %r15
  804211168e:	5d                   	pop    %rbp
  804211168f:	c3                   	ret

0000008042111690 <add_to_lru_list>:


void add_to_lru_list(struct Page *pg)
{
  8042111690:	f3 0f 1e fa          	endbr64
    if (pg == NULL) {
  8042111694:	48 85 ff             	test   %rdi,%rdi
  8042111697:	74 3c                	je     80421116d5 <add_to_lru_list+0x45>
        panic("page NULL");
    }

    if (lru_list->size == 0) {
  8042111699:	48 a1 08 00 00 43 80 	movabs 0x8043000008,%rax
  80421116a0:	00 00 00 
  80421116a3:	83 78 10 00          	cmpl   $0x0,0x10(%rax)
  80421116a7:	75 5a                	jne    8042111703 <add_to_lru_list+0x73>
        lru_list->tail = pg;
  80421116a9:	48 89 78 08          	mov    %rdi,0x8(%rax)
        pg->lru_next = NULL;
  80421116ad:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
  80421116b4:	00 
    }

    if (lru_list->size) {
  80421116b5:	83 78 10 00          	cmpl   $0x0,0x10(%rax)
  80421116b9:	75 48                	jne    8042111703 <add_to_lru_list+0x73>
        pg->lru_next = lru_list->head;
        (lru_list->head)->lru_prev = pg;
    }

    lru_list->head = pg;
  80421116bb:	48 89 38             	mov    %rdi,(%rax)
    pg->lru_prev = NULL;
  80421116be:	48 c7 47 40 00 00 00 	movq   $0x0,0x40(%rdi)
  80421116c5:	00 
    lru_list->size += 1;
  80421116c6:	48 a1 08 00 00 43 80 	movabs 0x8043000008,%rax
  80421116cd:	00 00 00 
  80421116d0:	83 40 10 01          	addl   $0x1,0x10(%rax)
  80421116d4:	c3                   	ret
{
  80421116d5:	55                   	push   %rbp
  80421116d6:	48 89 e5             	mov    %rsp,%rbp
        panic("page NULL");
  80421116d9:	48 ba 12 04 12 42 80 	movabs $0x8042120412,%rdx
  80421116e0:	00 00 00 
  80421116e3:	be 46 00 00 00       	mov    $0x46,%esi
  80421116e8:	48 bf 1c 04 12 42 80 	movabs $0x804212041c,%rdi
  80421116ef:	00 00 00 
  80421116f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80421116f7:	48 b9 e0 02 10 42 80 	movabs $0x80421002e0,%rcx
  80421116fe:	00 00 00 
  8042111701:	ff d1                	call   *%rcx
        pg->lru_next = lru_list->head;
  8042111703:	48 8b 10             	mov    (%rax),%rdx
  8042111706:	48 89 57 48          	mov    %rdx,0x48(%rdi)
        (lru_list->head)->lru_prev = pg;
  804211170a:	48 89 7a 40          	mov    %rdi,0x40(%rdx)
  804211170e:	eb ab                	jmp    80421116bb <add_to_lru_list+0x2b>

0000008042111710 <delete_from_lru_list>:
}


void delete_from_lru_list(struct Page *pg)
{
  8042111710:	f3 0f 1e fa          	endbr64
    //cprintf("TAIL DELETE %0x\n", (int) pg);
    if (lru_list->size == 1) {
  8042111714:	48 a1 08 00 00 43 80 	movabs 0x8043000008,%rax
  804211171b:	00 00 00 
  804211171e:	83 78 10 01          	cmpl   $0x1,0x10(%rax)
  8042111722:	74 38                	je     804211175c <delete_from_lru_list+0x4c>
        lru_list->tail = NULL;
        lru_list->head = NULL;
    } else {
        if (pg->lru_prev != NULL) {
  8042111724:	48 8b 57 40          	mov    0x40(%rdi),%rdx
  8042111728:	48 85 d2             	test   %rdx,%rdx
  804211172b:	74 08                	je     8042111735 <delete_from_lru_list+0x25>
            (pg->lru_prev)->lru_next = NULL;
  804211172d:	48 c7 42 48 00 00 00 	movq   $0x0,0x48(%rdx)
  8042111734:	00 
        }
        lru_list->tail = pg->lru_prev;
  8042111735:	48 8b 57 40          	mov    0x40(%rdi),%rdx
  8042111739:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
    lru_list->size -= 1;
  804211173d:	48 a1 08 00 00 43 80 	movabs 0x8043000008,%rax
  8042111744:	00 00 00 
  8042111747:	83 68 10 01          	subl   $0x1,0x10(%rax)

    pg->lru_next = pg->lru_prev = NULL;
  804211174b:	48 c7 47 40 00 00 00 	movq   $0x0,0x40(%rdi)
  8042111752:	00 
  8042111753:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
  804211175a:	00 
  804211175b:	c3                   	ret
        lru_list->tail = NULL;
  804211175c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8042111763:	00 
        lru_list->head = NULL;
  8042111764:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  804211176b:	eb d0                	jmp    804211173d <delete_from_lru_list+0x2d>

000000804211176d <LZ4_readLE16>:

#endif /* LZ4_FORCE_MEMORY_ACCESS */


static U16 LZ4_readLE16(const void* memPtr)
{
  804211176d:	f3 0f 1e fa          	endbr64
        return LZ4_read16(memPtr);
    } else {
        const BYTE* p = (const BYTE*)memPtr;
        return (U16)((U16)p[0] + (p[1]<<8));
    }
}
  8042111771:	0f b7 07             	movzwl (%rdi),%eax
  8042111774:	c3                   	ret

0000008042111775 <LZ4_renormDictT>:
    workingStream->internal_donotuse.dictCtx = dictCtx;
}


static void LZ4_renormDictT(LZ4_stream_t_internal* LZ4_dict, int nextSize)
{
  8042111775:	f3 0f 1e fa          	endbr64
  8042111779:	89 f0                	mov    %esi,%eax
    assert(nextSize >= 0);
    if (LZ4_dict->currentOffset + (unsigned)nextSize > 0x80000000) {   /* potential ptrdiff_t overflow (32-bits mode) */
  804211177b:	8b b7 00 40 00 00    	mov    0x4000(%rdi),%esi
  8042111781:	01 f0                	add    %esi,%eax
  8042111783:	3d 00 00 00 80       	cmp    $0x80000000,%eax
  8042111788:	76 7e                	jbe    8042111808 <LZ4_renormDictT+0x93>
{
  804211178a:	55                   	push   %rbp
  804211178b:	48 89 e5             	mov    %rsp,%rbp
  804211178e:	53                   	push   %rbx
  804211178f:	49 89 f9             	mov    %rdi,%r9
        /* rescale hash table */
        U32 const delta = LZ4_dict->currentOffset - 64 KB;
  8042111792:	81 ee 00 00 01 00    	sub    $0x10000,%esi
        const BYTE* dictEnd = LZ4_dict->dictionary + LZ4_dict->dictSize;
  8042111798:	4c 8b 97 08 40 00 00 	mov    0x4008(%rdi),%r10
  804211179f:	8b 9f 18 40 00 00    	mov    0x4018(%rdi),%ebx
  80421117a5:	41 89 db             	mov    %ebx,%r11d
        int i;
        DEBUGLOG(4, "LZ4_renormDictT");
        for (i=0; i<LZ4_HASH_SIZE_U32; i++) {
  80421117a8:	48 89 f8             	mov    %rdi,%rax
  80421117ab:	4c 8d 87 00 40 00 00 	lea    0x4000(%rdi),%r8
            if (LZ4_dict->hashTable[i] < delta) LZ4_dict->hashTable[i]=0;
            else LZ4_dict->hashTable[i] -= delta;
  80421117b2:	bf 00 00 00 00       	mov    $0x0,%edi
            if (LZ4_dict->hashTable[i] < delta) LZ4_dict->hashTable[i]=0;
  80421117b7:	8b 08                	mov    (%rax),%ecx
            else LZ4_dict->hashTable[i] -= delta;
  80421117b9:	89 ca                	mov    %ecx,%edx
  80421117bb:	29 f2                	sub    %esi,%edx
  80421117bd:	39 f1                	cmp    %esi,%ecx
  80421117bf:	0f 42 d7             	cmovb  %edi,%edx
  80421117c2:	89 10                	mov    %edx,(%rax)
        for (i=0; i<LZ4_HASH_SIZE_U32; i++) {
  80421117c4:	48 83 c0 04          	add    $0x4,%rax
  80421117c8:	4c 39 c0             	cmp    %r8,%rax
  80421117cb:	75 ea                	jne    80421117b7 <LZ4_renormDictT+0x42>
        }
        LZ4_dict->currentOffset = 64 KB;
  80421117cd:	41 c7 81 00 40 00 00 	movl   $0x10000,0x4000(%r9)
  80421117d4:	00 00 01 00 
        if (LZ4_dict->dictSize > 64 KB) LZ4_dict->dictSize = 64 KB;
  80421117d8:	81 fb 00 00 01 00    	cmp    $0x10000,%ebx
  80421117de:	76 0b                	jbe    80421117eb <LZ4_renormDictT+0x76>
  80421117e0:	41 c7 81 18 40 00 00 	movl   $0x10000,0x4018(%r9)
  80421117e7:	00 00 01 00 
        LZ4_dict->dictionary = dictEnd - LZ4_dict->dictSize;
  80421117eb:	41 8b 91 18 40 00 00 	mov    0x4018(%r9),%edx
  80421117f2:	4c 89 d8             	mov    %r11,%rax
  80421117f5:	48 29 d0             	sub    %rdx,%rax
  80421117f8:	4c 01 d0             	add    %r10,%rax
  80421117fb:	49 89 81 08 40 00 00 	mov    %rax,0x4008(%r9)
    }
}
  8042111802:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8042111806:	c9                   	leave
  8042111807:	c3                   	ret
  8042111808:	c3                   	ret

0000008042111809 <LZ4_wildCopy8>:
{
  8042111809:	f3 0f 1e fa          	endbr64
  804211180d:	55                   	push   %rbp
  804211180e:	48 89 e5             	mov    %rsp,%rbp
  8042111811:	41 56                	push   %r14
  8042111813:	41 55                	push   %r13
  8042111815:	41 54                	push   %r12
  8042111817:	53                   	push   %rbx
  8042111818:	48 89 fb             	mov    %rdi,%rbx
  804211181b:	49 89 f4             	mov    %rsi,%r12
  804211181e:	49 89 d5             	mov    %rdx,%r13
    do { memcpy(d,s,8); d+=8; s+=8; } while (d<e);
  8042111821:	49 be 62 0d 11 42 80 	movabs $0x8042110d62,%r14
  8042111828:	00 00 00 
  804211182b:	ba 08 00 00 00       	mov    $0x8,%edx
  8042111830:	4c 89 e6             	mov    %r12,%rsi
  8042111833:	48 89 df             	mov    %rbx,%rdi
  8042111836:	41 ff d6             	call   *%r14
  8042111839:	48 83 c3 08          	add    $0x8,%rbx
  804211183d:	49 83 c4 08          	add    $0x8,%r12
  8042111841:	4c 39 eb             	cmp    %r13,%rbx
  8042111844:	72 e5                	jb     804211182b <LZ4_wildCopy8+0x22>
}
  8042111846:	5b                   	pop    %rbx
  8042111847:	41 5c                	pop    %r12
  8042111849:	41 5d                	pop    %r13
  804211184b:	41 5e                	pop    %r14
  804211184d:	5d                   	pop    %rbp
  804211184e:	c3                   	ret

000000804211184f <LZ4_wildCopy32>:
{
  804211184f:	f3 0f 1e fa          	endbr64
  8042111853:	55                   	push   %rbp
  8042111854:	48 89 e5             	mov    %rsp,%rbp
  8042111857:	41 56                	push   %r14
  8042111859:	41 55                	push   %r13
  804211185b:	41 54                	push   %r12
  804211185d:	53                   	push   %rbx
  804211185e:	48 89 fb             	mov    %rdi,%rbx
  8042111861:	49 89 f4             	mov    %rsi,%r12
  8042111864:	49 89 d6             	mov    %rdx,%r14
    do { memcpy(d,s,16); memcpy(d+16,s+16,16); d+=32; s+=32; } while (d<e);
  8042111867:	49 bd 62 0d 11 42 80 	movabs $0x8042110d62,%r13
  804211186e:	00 00 00 
  8042111871:	ba 10 00 00 00       	mov    $0x10,%edx
  8042111876:	4c 89 e6             	mov    %r12,%rsi
  8042111879:	48 89 df             	mov    %rbx,%rdi
  804211187c:	41 ff d5             	call   *%r13
  804211187f:	49 8d 74 24 10       	lea    0x10(%r12),%rsi
  8042111884:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
  8042111888:	ba 10 00 00 00       	mov    $0x10,%edx
  804211188d:	41 ff d5             	call   *%r13
  8042111890:	48 83 c3 20          	add    $0x20,%rbx
  8042111894:	49 83 c4 20          	add    $0x20,%r12
  8042111898:	4c 39 f3             	cmp    %r14,%rbx
  804211189b:	72 d4                	jb     8042111871 <LZ4_wildCopy32+0x22>
}
  804211189d:	5b                   	pop    %rbx
  804211189e:	41 5c                	pop    %r12
  80421118a0:	41 5d                	pop    %r13
  80421118a2:	41 5e                	pop    %r14
  80421118a4:	5d                   	pop    %rbp
  80421118a5:	c3                   	ret

00000080421118a6 <LZ4_memcpy_using_offset>:
{
  80421118a6:	f3 0f 1e fa          	endbr64
  80421118aa:	55                   	push   %rbp
  80421118ab:	48 89 e5             	mov    %rsp,%rbp
  80421118ae:	41 56                	push   %r14
  80421118b0:	41 55                	push   %r13
  80421118b2:	41 54                	push   %r12
  80421118b4:	53                   	push   %rbx
  80421118b5:	48 83 ec 10          	sub    $0x10,%rsp
  80421118b9:	49 89 fd             	mov    %rdi,%r13
  80421118bc:	48 89 f3             	mov    %rsi,%rbx
  80421118bf:	49 89 d4             	mov    %rdx,%r12
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421118c2:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
    switch(offset) {
  80421118c8:	48 83 f9 02          	cmp    $0x2,%rcx
  80421118cc:	0f 84 8f 00 00 00    	je     8042111961 <LZ4_memcpy_using_offset+0xbb>
  80421118d2:	49 89 ce             	mov    %rcx,%r14
  80421118d5:	48 83 f9 04          	cmp    $0x4,%rcx
  80421118d9:	0f 84 bc 00 00 00    	je     804211199b <LZ4_memcpy_using_offset+0xf5>
  80421118df:	48 83 f9 01          	cmp    $0x1,%rcx
  80421118e3:	0f 85 dc 00 00 00    	jne    80421119c5 <LZ4_memcpy_using_offset+0x11f>
            memset(v, *srcPtr, 8);
  80421118e9:	0f b6 36             	movzbl (%rsi),%esi
  80421118ec:	ba 08 00 00 00       	mov    $0x8,%edx
  80421118f1:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  80421118f5:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  80421118fc:	00 00 00 
  80421118ff:	ff d0                	call   *%rax
    memcpy(dstPtr, v, 8);
  8042111901:	ba 08 00 00 00       	mov    $0x8,%edx
  8042111906:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  804211190a:	4c 89 ef             	mov    %r13,%rdi
  804211190d:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042111914:	00 00 00 
  8042111917:	ff d0                	call   *%rax
    dstPtr += 8;
  8042111919:	49 8d 5d 08          	lea    0x8(%r13),%rbx
    while (dstPtr < dstEnd) {
  804211191d:	4c 39 e3             	cmp    %r12,%rbx
  8042111920:	73 32                	jae    8042111954 <LZ4_memcpy_using_offset+0xae>
  8042111922:	49 83 ec 09          	sub    $0x9,%r12
  8042111926:	4d 29 ec             	sub    %r13,%r12
  8042111929:	49 c1 ec 03          	shr    $0x3,%r12
  804211192d:	4f 8d 6c e5 10       	lea    0x10(%r13,%r12,8),%r13
        memcpy(dstPtr, v, 8);
  8042111932:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  8042111939:	00 00 00 
  804211193c:	ba 08 00 00 00       	mov    $0x8,%edx
  8042111941:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8042111945:	48 89 df             	mov    %rbx,%rdi
  8042111948:	41 ff d4             	call   *%r12
        dstPtr += 8;
  804211194b:	48 83 c3 08          	add    $0x8,%rbx
    while (dstPtr < dstEnd) {
  804211194f:	4c 39 eb             	cmp    %r13,%rbx
  8042111952:	75 e8                	jne    804211193c <LZ4_memcpy_using_offset+0x96>
}
  8042111954:	48 83 c4 10          	add    $0x10,%rsp
  8042111958:	5b                   	pop    %rbx
  8042111959:	41 5c                	pop    %r12
  804211195b:	41 5d                	pop    %r13
  804211195d:	41 5e                	pop    %r14
  804211195f:	5d                   	pop    %rbp
  8042111960:	c3                   	ret
            memcpy(v, srcPtr, 2);
  8042111961:	ba 02 00 00 00       	mov    $0x2,%edx
  8042111966:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  804211196a:	49 be 62 0d 11 42 80 	movabs $0x8042110d62,%r14
  8042111971:	00 00 00 
  8042111974:	41 ff d6             	call   *%r14
            memcpy(&v[2], srcPtr, 2);
  8042111977:	ba 02 00 00 00       	mov    $0x2,%edx
  804211197c:	48 89 de             	mov    %rbx,%rsi
  804211197f:	48 8d 7d da          	lea    -0x26(%rbp),%rdi
  8042111983:	41 ff d6             	call   *%r14
            memcpy(&v[4], &v[0], 4);
  8042111986:	ba 04 00 00 00       	mov    $0x4,%edx
  804211198b:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  804211198f:	48 8d 7d dc          	lea    -0x24(%rbp),%rdi
  8042111993:	41 ff d6             	call   *%r14
            break;
  8042111996:	e9 66 ff ff ff       	jmp    8042111901 <LZ4_memcpy_using_offset+0x5b>
            memcpy(v, srcPtr, 4);
  804211199b:	ba 04 00 00 00       	mov    $0x4,%edx
  80421119a0:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  80421119a4:	49 be 62 0d 11 42 80 	movabs $0x8042110d62,%r14
  80421119ab:	00 00 00 
  80421119ae:	41 ff d6             	call   *%r14
            memcpy(&v[4], srcPtr, 4);
  80421119b1:	ba 04 00 00 00       	mov    $0x4,%edx
  80421119b6:	48 89 de             	mov    %rbx,%rsi
  80421119b9:	48 8d 7d dc          	lea    -0x24(%rbp),%rdi
  80421119bd:	41 ff d6             	call   *%r14
            break;
  80421119c0:	e9 3c ff ff ff       	jmp    8042111901 <LZ4_memcpy_using_offset+0x5b>
    if (offset < 8) {
  80421119c5:	48 83 f9 07          	cmp    $0x7,%rcx
  80421119c9:	77 6e                	ja     8042111a39 <LZ4_memcpy_using_offset+0x193>
        dstPtr[0] = srcPtr[0];
  80421119cb:	0f b6 06             	movzbl (%rsi),%eax
  80421119ce:	88 07                	mov    %al,(%rdi)
        dstPtr[1] = srcPtr[1];
  80421119d0:	0f b6 46 01          	movzbl 0x1(%rsi),%eax
  80421119d4:	88 47 01             	mov    %al,0x1(%rdi)
        dstPtr[2] = srcPtr[2];
  80421119d7:	0f b6 46 02          	movzbl 0x2(%rsi),%eax
  80421119db:	88 47 02             	mov    %al,0x2(%rdi)
        dstPtr[3] = srcPtr[3];
  80421119de:	0f b6 46 03          	movzbl 0x3(%rsi),%eax
  80421119e2:	88 47 03             	mov    %al,0x3(%rdi)
        srcPtr += inc32table[offset];
  80421119e5:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  80421119ec:	00 00 00 
  80421119ef:	8b 04 88             	mov    (%rax,%rcx,4),%eax
  80421119f2:	48 01 c3             	add    %rax,%rbx
        memcpy(dstPtr+4, srcPtr, 4);
  80421119f5:	48 8d 7f 04          	lea    0x4(%rdi),%rdi
  80421119f9:	ba 04 00 00 00       	mov    $0x4,%edx
  80421119fe:	48 89 de             	mov    %rbx,%rsi
  8042111a01:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042111a08:	00 00 00 
  8042111a0b:	ff d0                	call   *%rax
        srcPtr -= dec64table[offset];
  8042111a0d:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  8042111a14:	00 00 00 
  8042111a17:	4a 63 04 b0          	movslq (%rax,%r14,4),%rax
  8042111a1b:	48 29 c3             	sub    %rax,%rbx
  8042111a1e:	48 89 de             	mov    %rbx,%rsi
        dstPtr += 8;
  8042111a21:	49 8d 7d 08          	lea    0x8(%r13),%rdi
    LZ4_wildCopy8(dstPtr, srcPtr, dstEnd);
  8042111a25:	4c 89 e2             	mov    %r12,%rdx
  8042111a28:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042111a2f:	00 00 00 
  8042111a32:	ff d0                	call   *%rax
            return;
  8042111a34:	e9 1b ff ff ff       	jmp    8042111954 <LZ4_memcpy_using_offset+0xae>
        memcpy(dstPtr, srcPtr, 8);
  8042111a39:	ba 08 00 00 00       	mov    $0x8,%edx
  8042111a3e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042111a45:	00 00 00 
  8042111a48:	ff d0                	call   *%rax
        dstPtr += 8;
  8042111a4a:	49 8d 7d 08          	lea    0x8(%r13),%rdi
        srcPtr += 8;
  8042111a4e:	48 8d 73 08          	lea    0x8(%rbx),%rsi
  8042111a52:	eb d1                	jmp    8042111a25 <LZ4_memcpy_using_offset+0x17f>

0000008042111a54 <LZ4_decompress_safe_withSmallPrefix>:
}

LZ4_FORCE_O2_GCC_PPC64LE
static int LZ4_decompress_safe_withSmallPrefix(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                               size_t prefixSize)
{
  8042111a54:	f3 0f 1e fa          	endbr64
  8042111a58:	55                   	push   %rbp
  8042111a59:	48 89 e5             	mov    %rsp,%rbp
  8042111a5c:	41 57                	push   %r15
  8042111a5e:	41 56                	push   %r14
  8042111a60:	41 55                	push   %r13
  8042111a62:	41 54                	push   %r12
  8042111a64:	53                   	push   %rbx
  8042111a65:	48 83 ec 48          	sub    $0x48,%rsp
  8042111a69:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8042111a6d:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
  8042111a71:	48 89 f0             	mov    %rsi,%rax
  8042111a74:	4c 29 c0             	sub    %r8,%rax
  8042111a77:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (src == NULL) { return -1; }
  8042111a7b:	48 85 ff             	test   %rdi,%rdi
  8042111a7e:	0f 84 d7 06 00 00    	je     804211215b <LZ4_decompress_safe_withSmallPrefix+0x707>
        const BYTE* const iend = ip + srcSize;
  8042111a84:	48 63 c2             	movslq %edx,%rax
  8042111a87:	48 01 f8             	add    %rdi,%rax
  8042111a8a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        BYTE* const oend = op + outputSize;
  8042111a8e:	48 63 c1             	movslq %ecx,%rax
  8042111a91:	48 01 f0             	add    %rsi,%rax
  8042111a94:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  8042111a98:	48 83 e8 20          	sub    $0x20,%rax
  8042111a9c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        if ((endOnInput) && (unlikely(outputSize==0))) {
  8042111aa0:	85 c9                	test   %ecx,%ecx
  8042111aa2:	74 2e                	je     8042111ad2 <LZ4_decompress_safe_withSmallPrefix+0x7e>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  8042111aa4:	85 d2                	test   %edx,%edx
  8042111aa6:	0f 84 b6 06 00 00    	je     8042112162 <LZ4_decompress_safe_withSmallPrefix+0x70e>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  8042111aac:	83 f9 3f             	cmp    $0x3f,%ecx
  8042111aaf:	0f 8e 1a 05 00 00    	jle    8042111fcf <LZ4_decompress_safe_withSmallPrefix+0x57b>
    {   const BYTE* ip = (const BYTE*) src;
  8042111ab5:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  8042111ab9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8042111abd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  8042111ac1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042111ac5:	48 83 e8 11          	sub    $0x11,%rax
  8042111ac9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8042111acd:	e9 3e 01 00 00       	jmp    8042111c10 <LZ4_decompress_safe_withSmallPrefix+0x1bc>
            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
  8042111ad2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042111ad7:	83 fa 01             	cmp    $0x1,%edx
  8042111ada:	0f 85 53 06 00 00    	jne    8042112133 <LZ4_decompress_safe_withSmallPrefix+0x6df>
  8042111ae0:	0f b6 07             	movzbl (%rdi),%eax
  8042111ae3:	f6 d8                	neg    %al
  8042111ae5:	19 c0                	sbb    %eax,%eax
  8042111ae7:	e9 47 06 00 00       	jmp    8042112133 <LZ4_decompress_safe_withSmallPrefix+0x6df>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  8042111aec:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042111af0:	48 8d 50 f1          	lea    -0xf(%rax),%rdx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  8042111af4:	49 39 d5             	cmp    %rdx,%r13
  8042111af7:	0f 83 27 06 00 00    	jae    8042112124 <LZ4_decompress_safe_withSmallPrefix+0x6d0>
  8042111afd:	41 be 00 00 00 00    	mov    $0x0,%r14d
        s = **ip;
  8042111b03:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  8042111b08:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  8042111b0c:	41 01 c6             	add    %eax,%r14d
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  8042111b0f:	4c 39 ea             	cmp    %r13,%rdx
  8042111b12:	74 07                	je     8042111b1b <LZ4_decompress_safe_withSmallPrefix+0xc7>
    } while (s==255);
  8042111b14:	3d ff 00 00 00       	cmp    $0xff,%eax
  8042111b19:	74 e8                	je     8042111b03 <LZ4_decompress_safe_withSmallPrefix+0xaf>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  8042111b1b:	45 89 f6             	mov    %r14d,%r14d
  8042111b1e:	49 83 c6 0f          	add    $0xf,%r14
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  8042111b22:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042111b26:	48 89 f8             	mov    %rdi,%rax
  8042111b29:	4c 01 f0             	add    %r14,%rax
  8042111b2c:	0f 82 10 06 00 00    	jb     8042112142 <LZ4_decompress_safe_withSmallPrefix+0x6ee>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  8042111b32:	4c 89 e8             	mov    %r13,%rax
  8042111b35:	4c 01 f0             	add    %r14,%rax
  8042111b38:	0f 82 09 06 00 00    	jb     8042112147 <LZ4_decompress_safe_withSmallPrefix+0x6f3>
                cpy = op+length;
  8042111b3e:	4e 8d 3c 37          	lea    (%rdi,%r14,1),%r15
                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
  8042111b42:	4c 39 7d 98          	cmp    %r15,-0x68(%rbp)
  8042111b46:	0f 82 0c 03 00 00    	jb     8042111e58 <LZ4_decompress_safe_withSmallPrefix+0x404>
  8042111b4c:	4b 8d 5c 35 00       	lea    0x0(%r13,%r14,1),%rbx
  8042111b51:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042111b55:	48 83 e8 20          	sub    $0x20,%rax
  8042111b59:	48 39 d8             	cmp    %rbx,%rax
  8042111b5c:	0f 82 fe 02 00 00    	jb     8042111e60 <LZ4_decompress_safe_withSmallPrefix+0x40c>
                    LZ4_wildCopy32(op, ip, cpy);
  8042111b62:	4c 89 fa             	mov    %r15,%rdx
  8042111b65:	4c 89 ee             	mov    %r13,%rsi
  8042111b68:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  8042111b6f:	00 00 00 
  8042111b72:	ff d0                	call   *%rax
                ip += length; op = cpy;
  8042111b74:	e9 df 00 00 00       	jmp    8042111c58 <LZ4_decompress_safe_withSmallPrefix+0x204>
                if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  8042111b79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042111b7d:	49 39 c6             	cmp    %rax,%r14
  8042111b80:	0f 82 a1 05 00 00    	jb     8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  8042111b86:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042111b8a:	48 8d 70 fc          	lea    -0x4(%rax),%rsi
  8042111b8e:	b8 00 00 00 00       	mov    $0x0,%eax
        s = **ip;
  8042111b93:	0f b6 13             	movzbl (%rbx),%edx
        (*ip)++;
  8042111b96:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  8042111b9a:	01 d0                	add    %edx,%eax
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  8042111b9c:	48 39 f3             	cmp    %rsi,%rbx
  8042111b9f:	0f 83 82 05 00 00    	jae    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
    } while (s==255);
  8042111ba5:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  8042111bab:	74 e6                	je     8042111b93 <LZ4_decompress_safe_withSmallPrefix+0x13f>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  8042111bad:	41 89 c4             	mov    %eax,%r12d
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
  8042111bb0:	4b 8d 44 27 0f       	lea    0xf(%r15,%r12,1),%rax
  8042111bb5:	4c 39 f8             	cmp    %r15,%rax
  8042111bb8:	0f 82 69 05 00 00    	jb     8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
                length += MINMATCH;
  8042111bbe:	49 83 c4 13          	add    $0x13,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  8042111bc2:	4b 8d 14 27          	lea    (%r15,%r12,1),%rdx
  8042111bc6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042111bca:	48 83 e8 40          	sub    $0x40,%rax
  8042111bce:	48 39 c2             	cmp    %rax,%rdx
  8042111bd1:	72 15                	jb     8042111be8 <LZ4_decompress_safe_withSmallPrefix+0x194>
  8042111bd3:	49 89 cd             	mov    %rcx,%r13
  8042111bd6:	e9 c5 04 00 00       	jmp    80421120a0 <LZ4_decompress_safe_withSmallPrefix+0x64c>
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  8042111bdb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042111bdf:	49 39 c6             	cmp    %rax,%r14
  8042111be2:	0f 82 3f 05 00 00    	jb     8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
            cpy = op + length;
  8042111be8:	4b 8d 04 27          	lea    (%r15,%r12,1),%rax
  8042111bec:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<16)) {
  8042111bf0:	48 83 f9 0f          	cmp    $0xf,%rcx
  8042111bf4:	0f 86 f9 00 00 00    	jbe    8042111cf3 <LZ4_decompress_safe_withSmallPrefix+0x29f>
                LZ4_wildCopy32(op, match, cpy);
  8042111bfa:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8042111bfe:	4c 89 f6             	mov    %r14,%rsi
  8042111c01:	4c 89 ff             	mov    %r15,%rdi
  8042111c04:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  8042111c0b:	00 00 00 
  8042111c0e:	ff d0                	call   *%rax
            token = *ip++;
  8042111c10:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  8042111c14:	44 0f b6 23          	movzbl (%rbx),%r12d
  8042111c18:	41 0f b6 cc          	movzbl %r12b,%ecx
            length = token >> ML_BITS;  /* literal length */
  8042111c1c:	89 c8                	mov    %ecx,%eax
  8042111c1e:	c1 e8 04             	shr    $0x4,%eax
  8042111c21:	41 89 c6             	mov    %eax,%r14d
            if (length == RUN_MASK) {
  8042111c24:	83 f8 0f             	cmp    $0xf,%eax
  8042111c27:	0f 84 bf fe ff ff    	je     8042111aec <LZ4_decompress_safe_withSmallPrefix+0x98>
                cpy = op+length;
  8042111c2d:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042111c31:	4e 8d 3c 37          	lea    (%rdi,%r14,1),%r15
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  8042111c35:	4c 39 6d a0          	cmp    %r13,-0x60(%rbp)
  8042111c39:	0f 82 29 02 00 00    	jb     8042111e68 <LZ4_decompress_safe_withSmallPrefix+0x414>
                    memcpy(op, ip, 16);
  8042111c3f:	ba 10 00 00 00       	mov    $0x10,%edx
  8042111c44:	4c 89 ee             	mov    %r13,%rsi
  8042111c47:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042111c4e:	00 00 00 
  8042111c51:	ff d0                	call   *%rax
                ip += length; op = cpy;
  8042111c53:	4b 8d 5c 35 00       	lea    0x0(%r13,%r14,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  8042111c58:	48 89 df             	mov    %rbx,%rdi
  8042111c5b:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  8042111c62:	00 00 00 
  8042111c65:	ff d0                	call   *%rax
  8042111c67:	0f b7 c8             	movzwl %ax,%ecx
  8042111c6a:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  8042111c6e:	4d 89 fe             	mov    %r15,%r14
  8042111c71:	49 29 ce             	sub    %rcx,%r14
            length = token & ML_MASK;
  8042111c74:	41 83 e4 0f          	and    $0xf,%r12d
            if (length == ML_MASK) {
  8042111c78:	49 83 fc 0f          	cmp    $0xf,%r12
  8042111c7c:	0f 84 f7 fe ff ff    	je     8042111b79 <LZ4_decompress_safe_withSmallPrefix+0x125>
                length += MINMATCH;
  8042111c82:	49 83 c4 04          	add    $0x4,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  8042111c86:	4b 8d 34 27          	lea    (%r15,%r12,1),%rsi
  8042111c8a:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  8042111c8e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042111c92:	48 83 e8 40          	sub    $0x40,%rax
  8042111c96:	48 39 c6             	cmp    %rax,%rsi
  8042111c99:	0f 83 53 02 00 00    	jae    8042111ef2 <LZ4_decompress_safe_withSmallPrefix+0x49e>
                    if (offset >= 8) {
  8042111c9f:	48 83 f9 07          	cmp    $0x7,%rcx
  8042111ca3:	0f 86 32 ff ff ff    	jbe    8042111bdb <LZ4_decompress_safe_withSmallPrefix+0x187>
  8042111ca9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042111cad:	49 39 c6             	cmp    %rax,%r14
  8042111cb0:	0f 82 25 ff ff ff    	jb     8042111bdb <LZ4_decompress_safe_withSmallPrefix+0x187>
                        memcpy(op, match, 8);
  8042111cb6:	ba 08 00 00 00       	mov    $0x8,%edx
  8042111cbb:	4c 89 f6             	mov    %r14,%rsi
  8042111cbe:	4c 89 ff             	mov    %r15,%rdi
  8042111cc1:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  8042111cc8:	00 00 00 
  8042111ccb:	41 ff d4             	call   *%r12
                        memcpy(op+8, match+8, 8);
  8042111cce:	49 8d 76 08          	lea    0x8(%r14),%rsi
  8042111cd2:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  8042111cd6:	ba 08 00 00 00       	mov    $0x8,%edx
  8042111cdb:	41 ff d4             	call   *%r12
                        memcpy(op+16, match+16, 2);
  8042111cde:	49 8d 76 10          	lea    0x10(%r14),%rsi
  8042111ce2:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  8042111ce6:	ba 02 00 00 00       	mov    $0x2,%edx
  8042111ceb:	41 ff d4             	call   *%r12
                        continue;
  8042111cee:	e9 1d ff ff ff       	jmp    8042111c10 <LZ4_decompress_safe_withSmallPrefix+0x1bc>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  8042111cf3:	48 89 c2             	mov    %rax,%rdx
  8042111cf6:	4c 89 f6             	mov    %r14,%rsi
  8042111cf9:	4c 89 ff             	mov    %r15,%rdi
  8042111cfc:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  8042111d03:	00 00 00 
  8042111d06:	ff d0                	call   *%rax
  8042111d08:	e9 03 ff ff ff       	jmp    8042111c10 <LZ4_decompress_safe_withSmallPrefix+0x1bc>
                    memcpy(op + 0, match + 0, 8);
  8042111d0d:	ba 08 00 00 00       	mov    $0x8,%edx
  8042111d12:	4c 89 f6             	mov    %r14,%rsi
  8042111d15:	4c 89 ff             	mov    %r15,%rdi
  8042111d18:	49 bd 62 0d 11 42 80 	movabs $0x8042110d62,%r13
  8042111d1f:	00 00 00 
  8042111d22:	41 ff d5             	call   *%r13
                    memcpy(op + 8, match + 8, 8);
  8042111d25:	49 8d 76 08          	lea    0x8(%r14),%rsi
  8042111d29:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  8042111d2d:	ba 08 00 00 00       	mov    $0x8,%edx
  8042111d32:	41 ff d5             	call   *%r13
                    memcpy(op +16, match +16, 2);
  8042111d35:	49 8d 76 10          	lea    0x10(%r14),%rsi
  8042111d39:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  8042111d3d:	ba 02 00 00 00       	mov    $0x2,%edx
  8042111d42:	41 ff d5             	call   *%r13
                    op += length + MINMATCH;
  8042111d45:	4f 8d 7c 27 04       	lea    0x4(%r15,%r12,1),%r15
            token = *ip++;
  8042111d4a:	4c 8d 73 03          	lea    0x3(%rbx),%r14
  8042111d4e:	44 0f b6 63 02       	movzbl 0x2(%rbx),%r12d
  8042111d53:	41 0f b6 d4          	movzbl %r12b,%edx
            length = token >> ML_BITS;  /* literal length */
  8042111d57:	89 d0                	mov    %edx,%eax
  8042111d59:	c1 e8 04             	shr    $0x4,%eax
  8042111d5c:	89 c3                	mov    %eax,%ebx
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  8042111d5e:	83 f8 0f             	cmp    $0xf,%eax
  8042111d61:	74 26                	je     8042111d89 <LZ4_decompress_safe_withSmallPrefix+0x335>
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  8042111d63:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042111d67:	49 39 c6             	cmp    %rax,%r14
  8042111d6a:	0f 83 d9 00 00 00    	jae    8042111e49 <LZ4_decompress_safe_withSmallPrefix+0x3f5>
  8042111d70:	4c 39 7d 98          	cmp    %r15,-0x68(%rbp)
  8042111d74:	0f 83 ac 02 00 00    	jae    8042112026 <LZ4_decompress_safe_withSmallPrefix+0x5d2>
  8042111d7a:	89 55 a0             	mov    %edx,-0x60(%rbp)
  8042111d7d:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  8042111d81:	4d 89 f5             	mov    %r14,%r13
  8042111d84:	49 89 de             	mov    %rbx,%r14
  8042111d87:	eb 56                	jmp    8042111ddf <LZ4_decompress_safe_withSmallPrefix+0x38b>
  8042111d89:	89 55 a0             	mov    %edx,-0x60(%rbp)
  8042111d8c:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  8042111d90:	4d 89 f5             	mov    %r14,%r13
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  8042111d93:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042111d97:	48 8d 48 f1          	lea    -0xf(%rax),%rcx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  8042111d9b:	49 39 cd             	cmp    %rcx,%r13
  8042111d9e:	0f 83 a8 03 00 00    	jae    804211214c <LZ4_decompress_safe_withSmallPrefix+0x6f8>
  8042111da4:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  8042111da9:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  8042111dae:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  8042111db2:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  8042111db4:	4c 39 e9             	cmp    %r13,%rcx
  8042111db7:	74 07                	je     8042111dc0 <LZ4_decompress_safe_withSmallPrefix+0x36c>
    } while (s==255);
  8042111db9:	3d ff 00 00 00       	cmp    $0xff,%eax
  8042111dbe:	74 e9                	je     8042111da9 <LZ4_decompress_safe_withSmallPrefix+0x355>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  8042111dc0:	89 d2                	mov    %edx,%edx
  8042111dc2:	4c 8d 72 0f          	lea    0xf(%rdx),%r14
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  8042111dc6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042111dca:	4c 01 f0             	add    %r14,%rax
  8042111dcd:	0f 82 7e 03 00 00    	jb     8042112151 <LZ4_decompress_safe_withSmallPrefix+0x6fd>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  8042111dd3:	4c 89 e8             	mov    %r13,%rax
  8042111dd6:	4c 01 f0             	add    %r14,%rax
  8042111dd9:	0f 82 77 03 00 00    	jb     8042112156 <LZ4_decompress_safe_withSmallPrefix+0x702>
            cpy = op+length;
  8042111ddf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042111de3:	4e 8d 3c 30          	lea    (%rax,%r14,1),%r15
  8042111de7:	4c 89 eb             	mov    %r13,%rbx
            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
  8042111dea:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042111dee:	48 83 e8 0c          	sub    $0xc,%rax
  8042111df2:	4c 39 f8             	cmp    %r15,%rax
  8042111df5:	72 11                	jb     8042111e08 <LZ4_decompress_safe_withSmallPrefix+0x3b4>
  8042111df7:	4e 8d 24 33          	lea    (%rbx,%r14,1),%r12
  8042111dfb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042111dff:	48 83 e8 08          	sub    $0x8,%rax
  8042111e03:	4c 39 e0             	cmp    %r12,%rax
  8042111e06:	73 6b                	jae    8042111e73 <LZ4_decompress_safe_withSmallPrefix+0x41f>
                    if ((endOnInput) && ((ip+length != iend) || (cpy > oend))) { goto _output_error; }
  8042111e08:	4a 8d 04 33          	lea    (%rbx,%r14,1),%rax
  8042111e0c:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8042111e10:	0f 85 11 03 00 00    	jne    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
  8042111e16:	4c 39 7d b0          	cmp    %r15,-0x50(%rbp)
  8042111e1a:	0f 82 07 03 00 00    	jb     8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  8042111e20:	4c 89 f2             	mov    %r14,%rdx
  8042111e23:	48 89 de             	mov    %rbx,%rsi
  8042111e26:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  8042111e2a:	48 89 df             	mov    %rbx,%rdi
  8042111e2d:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  8042111e34:	00 00 00 
  8042111e37:	ff d0                	call   *%rax
                op += length;
  8042111e39:	48 89 d8             	mov    %rbx,%rax
  8042111e3c:	4c 01 f0             	add    %r14,%rax
            return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
  8042111e3f:	8b 4d 90             	mov    -0x70(%rbp),%ecx
  8042111e42:	29 c8                	sub    %ecx,%eax
  8042111e44:	e9 ea 02 00 00       	jmp    8042112133 <LZ4_decompress_safe_withSmallPrefix+0x6df>
  8042111e49:	89 55 a0             	mov    %edx,-0x60(%rbp)
  8042111e4c:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  8042111e50:	4d 89 f5             	mov    %r14,%r13
  8042111e53:	49 89 de             	mov    %rbx,%r14
  8042111e56:	eb 87                	jmp    8042111ddf <LZ4_decompress_safe_withSmallPrefix+0x38b>
  8042111e58:	89 4d a0             	mov    %ecx,-0x60(%rbp)
  8042111e5b:	4c 89 eb             	mov    %r13,%rbx
  8042111e5e:	eb 8a                	jmp    8042111dea <LZ4_decompress_safe_withSmallPrefix+0x396>
  8042111e60:	89 4d a0             	mov    %ecx,-0x60(%rbp)
  8042111e63:	4c 89 eb             	mov    %r13,%rbx
  8042111e66:	eb 82                	jmp    8042111dea <LZ4_decompress_safe_withSmallPrefix+0x396>
            token = *ip++;
  8042111e68:	89 4d a0             	mov    %ecx,-0x60(%rbp)
  8042111e6b:	4c 89 eb             	mov    %r13,%rbx
  8042111e6e:	e9 77 ff ff ff       	jmp    8042111dea <LZ4_decompress_safe_withSmallPrefix+0x396>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  8042111e73:	4c 89 fa             	mov    %r15,%rdx
  8042111e76:	48 89 de             	mov    %rbx,%rsi
  8042111e79:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042111e7d:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042111e84:	00 00 00 
  8042111e87:	ff d0                	call   *%rax
            offset = LZ4_readLE16(ip); ip+=2;
  8042111e89:	4c 89 e7             	mov    %r12,%rdi
  8042111e8c:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  8042111e93:	00 00 00 
  8042111e96:	ff d0                	call   *%rax
  8042111e98:	44 0f b7 e8          	movzwl %ax,%r13d
  8042111e9c:	49 8d 5c 24 02       	lea    0x2(%r12),%rbx
            match = op - offset;
  8042111ea1:	4d 89 fe             	mov    %r15,%r14
  8042111ea4:	4d 29 ee             	sub    %r13,%r14
            length = token & ML_MASK;
  8042111ea7:	44 8b 65 a0          	mov    -0x60(%rbp),%r12d
  8042111eab:	41 83 e4 0f          	and    $0xf,%r12d
  8042111eaf:	e9 d1 01 00 00       	jmp    8042112085 <LZ4_decompress_safe_withSmallPrefix+0x631>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  8042111eb4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042111eb8:	48 8d 48 fc          	lea    -0x4(%rax),%rcx
  8042111ebc:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  8042111ec1:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  8042111ec4:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  8042111ec8:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  8042111eca:	48 39 cb             	cmp    %rcx,%rbx
  8042111ecd:	0f 83 54 02 00 00    	jae    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
    } while (s==255);
  8042111ed3:	3d ff 00 00 00       	cmp    $0xff,%eax
  8042111ed8:	74 e7                	je     8042111ec1 <LZ4_decompress_safe_withSmallPrefix+0x46d>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  8042111eda:	41 89 d4             	mov    %edx,%r12d
  8042111edd:	49 83 c4 0f          	add    $0xf,%r12
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
  8042111ee1:	4c 89 f8             	mov    %r15,%rax
  8042111ee4:	4c 01 e0             	add    %r12,%rax
  8042111ee7:	0f 83 a2 01 00 00    	jae    804211208f <LZ4_decompress_safe_withSmallPrefix+0x63b>
  8042111eed:	e9 35 02 00 00       	jmp    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
  8042111ef2:	49 89 cd             	mov    %rcx,%r13
  8042111ef5:	e9 99 01 00 00       	jmp    8042112093 <LZ4_decompress_safe_withSmallPrefix+0x63f>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042111efa:	41 c7 07 00 00 00 00 	movl   $0x0,(%r15)
                op[0] = match[0];
  8042111f01:	41 0f b6 06          	movzbl (%r14),%eax
  8042111f05:	41 88 07             	mov    %al,(%r15)
                op[1] = match[1];
  8042111f08:	41 0f b6 46 01       	movzbl 0x1(%r14),%eax
  8042111f0d:	41 88 47 01          	mov    %al,0x1(%r15)
                op[2] = match[2];
  8042111f11:	41 0f b6 46 02       	movzbl 0x2(%r14),%eax
  8042111f16:	41 88 47 02          	mov    %al,0x2(%r15)
                op[3] = match[3];
  8042111f1a:	41 0f b6 46 03       	movzbl 0x3(%r14),%eax
  8042111f1f:	41 88 47 03          	mov    %al,0x3(%r15)
                match += inc32table[offset];
  8042111f23:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  8042111f2a:	00 00 00 
  8042111f2d:	42 8b 04 a8          	mov    (%rax,%r13,4),%eax
  8042111f31:	49 01 c6             	add    %rax,%r14
                memcpy(op+4, match, 4);
  8042111f34:	49 8d 7f 04          	lea    0x4(%r15),%rdi
  8042111f38:	ba 04 00 00 00       	mov    $0x4,%edx
  8042111f3d:	4c 89 f6             	mov    %r14,%rsi
  8042111f40:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042111f47:	00 00 00 
  8042111f4a:	ff d0                	call   *%rax
                match -= dec64table[offset];
  8042111f4c:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  8042111f53:	00 00 00 
  8042111f56:	4a 63 04 a8          	movslq (%rax,%r13,4),%rax
  8042111f5a:	49 29 c6             	sub    %rax,%r14
  8042111f5d:	4d 89 f5             	mov    %r14,%r13
  8042111f60:	e9 68 01 00 00       	jmp    80421120cd <LZ4_decompress_safe_withSmallPrefix+0x679>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
  8042111f65:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8042111f69:	48 8d 41 fb          	lea    -0x5(%rcx),%rax
  8042111f6d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042111f71:	48 39 f0             	cmp    %rsi,%rax
  8042111f74:	0f 82 ad 01 00 00    	jb     8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
  8042111f7a:	4c 8d 61 f9          	lea    -0x7(%rcx),%r12
                if (op < oCopyLimit) {
  8042111f7e:	4d 39 e6             	cmp    %r12,%r14
  8042111f81:	72 29                	jb     8042111fac <LZ4_decompress_safe_withSmallPrefix+0x558>
                while (op < cpy) { *op++ = *match++; }
  8042111f83:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042111f87:	48 89 f1             	mov    %rsi,%rcx
  8042111f8a:	4c 29 f1             	sub    %r14,%rcx
  8042111f8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042111f92:	49 39 f6             	cmp    %rsi,%r14
  8042111f95:	73 44                	jae    8042111fdb <LZ4_decompress_safe_withSmallPrefix+0x587>
  8042111f97:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  8042111f9d:	41 88 14 06          	mov    %dl,(%r14,%rax,1)
  8042111fa1:	48 83 c0 01          	add    $0x1,%rax
  8042111fa5:	48 39 c8             	cmp    %rcx,%rax
  8042111fa8:	75 ed                	jne    8042111f97 <LZ4_decompress_safe_withSmallPrefix+0x543>
  8042111faa:	eb 2f                	jmp    8042111fdb <LZ4_decompress_safe_withSmallPrefix+0x587>
                    LZ4_wildCopy8(op, match, oCopyLimit);
  8042111fac:	4c 89 e2             	mov    %r12,%rdx
  8042111faf:	4c 89 ee             	mov    %r13,%rsi
  8042111fb2:	4c 89 f7             	mov    %r14,%rdi
  8042111fb5:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042111fbc:	00 00 00 
  8042111fbf:	ff d0                	call   *%rax
                    match += oCopyLimit - op;
  8042111fc1:	4c 89 e0             	mov    %r12,%rax
  8042111fc4:	4c 29 f0             	sub    %r14,%rax
  8042111fc7:	49 01 c5             	add    %rax,%r13
                    op = oCopyLimit;
  8042111fca:	4d 89 e6             	mov    %r12,%r14
  8042111fcd:	eb b4                	jmp    8042111f83 <LZ4_decompress_safe_withSmallPrefix+0x52f>
    {   const BYTE* ip = (const BYTE*) src;
  8042111fcf:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  8042111fd3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8042111fd7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            token = *ip++;
  8042111fdb:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  8042111fdf:	44 0f b6 23          	movzbl (%rbx),%r12d
  8042111fe3:	41 0f b6 c4          	movzbl %r12b,%eax
  8042111fe7:	89 45 a0             	mov    %eax,-0x60(%rbp)
            length = token >> ML_BITS;  /* literal length */
  8042111fea:	c1 e8 04             	shr    $0x4,%eax
  8042111fed:	41 89 c6             	mov    %eax,%r14d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  8042111ff0:	83 f8 0f             	cmp    $0xf,%eax
  8042111ff3:	0f 84 9a fd ff ff    	je     8042111d93 <LZ4_decompress_safe_withSmallPrefix+0x33f>
        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
  8042111ff9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042111ffd:	48 83 e8 10          	sub    $0x10,%rax
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  8042112001:	49 39 c5             	cmp    %rax,%r13
  8042112004:	0f 83 d5 fd ff ff    	jae    8042111ddf <LZ4_decompress_safe_withSmallPrefix+0x38b>
  804211200a:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211200e:	48 39 75 98          	cmp    %rsi,-0x68(%rbp)
  8042112012:	0f 82 c7 fd ff ff    	jb     8042111ddf <LZ4_decompress_safe_withSmallPrefix+0x38b>
  8042112018:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  804211201c:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
  8042112020:	4c 89 f3             	mov    %r14,%rbx
  8042112023:	4d 89 ee             	mov    %r13,%r14
                memcpy(op, ip, endOnInput ? 16 : 8);
  8042112026:	ba 10 00 00 00       	mov    $0x10,%edx
  804211202b:	4c 89 f6             	mov    %r14,%rsi
  804211202e:	4c 89 ff             	mov    %r15,%rdi
  8042112031:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042112038:	00 00 00 
  804211203b:	ff d0                	call   *%rax
                op += length; ip += length;
  804211203d:	49 01 df             	add    %rbx,%r15
  8042112040:	4c 01 f3             	add    %r14,%rbx
                length = token & ML_MASK; /* match length */
  8042112043:	41 83 e4 0f          	and    $0xf,%r12d
                offset = LZ4_readLE16(ip); ip += 2;
  8042112047:	48 89 df             	mov    %rbx,%rdi
  804211204a:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  8042112051:	00 00 00 
  8042112054:	ff d0                	call   *%rax
  8042112056:	0f b7 c0             	movzwl %ax,%eax
                match = op - offset;
  8042112059:	4d 89 fe             	mov    %r15,%r14
  804211205c:	49 29 c6             	sub    %rax,%r14
                if ( (length != ML_MASK)
  804211205f:	49 83 fc 0f          	cmp    $0xf,%r12
  8042112063:	0f 95 c1             	setne  %cl
                     && (offset >= 8)
  8042112066:	48 83 f8 07          	cmp    $0x7,%rax
  804211206a:	0f 97 c2             	seta   %dl
                     && (dict==withPrefix64k || match >= lowPrefix) ) {
  804211206d:	84 d1                	test   %dl,%cl
  804211206f:	74 0d                	je     804211207e <LZ4_decompress_safe_withSmallPrefix+0x62a>
  8042112071:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042112075:	49 39 ce             	cmp    %rcx,%r14
  8042112078:	0f 83 8f fc ff ff    	jae    8042111d0d <LZ4_decompress_safe_withSmallPrefix+0x2b9>
                offset = LZ4_readLE16(ip); ip += 2;
  804211207e:	49 89 c5             	mov    %rax,%r13
  8042112081:	48 83 c3 02          	add    $0x2,%rbx
            if (length == ML_MASK) {
  8042112085:	49 83 fc 0f          	cmp    $0xf,%r12
  8042112089:	0f 84 25 fe ff ff    	je     8042111eb4 <LZ4_decompress_safe_withSmallPrefix+0x460>
            length += MINMATCH;
  804211208f:	49 83 c4 04          	add    $0x4,%r12
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
  8042112093:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042112097:	49 39 c6             	cmp    %rax,%r14
  804211209a:	0f 82 87 00 00 00    	jb     8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
            cpy = op + length;
  80421120a0:	4b 8d 04 27          	lea    (%r15,%r12,1),%rax
  80421120a4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<8)) {
  80421120a8:	49 83 fd 07          	cmp    $0x7,%r13
  80421120ac:	0f 86 48 fe ff ff    	jbe    8042111efa <LZ4_decompress_safe_withSmallPrefix+0x4a6>
                memcpy(op, match, 8);
  80421120b2:	ba 08 00 00 00       	mov    $0x8,%edx
  80421120b7:	4c 89 f6             	mov    %r14,%rsi
  80421120ba:	4c 89 ff             	mov    %r15,%rdi
  80421120bd:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421120c4:	00 00 00 
  80421120c7:	ff d0                	call   *%rax
                match += 8;
  80421120c9:	4d 8d 6e 08          	lea    0x8(%r14),%r13
            op += 8;
  80421120cd:	4d 8d 77 08          	lea    0x8(%r15),%r14
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  80421120d1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80421120d5:	48 83 e8 0c          	sub    $0xc,%rax
  80421120d9:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80421120dd:	48 39 c8             	cmp    %rcx,%rax
  80421120e0:	0f 82 7f fe ff ff    	jb     8042111f65 <LZ4_decompress_safe_withSmallPrefix+0x511>
                memcpy(op, match, 8);
  80421120e6:	ba 08 00 00 00       	mov    $0x8,%edx
  80421120eb:	4c 89 ee             	mov    %r13,%rsi
  80421120ee:	4c 89 f7             	mov    %r14,%rdi
  80421120f1:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421120f8:	00 00 00 
  80421120fb:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  80421120fd:	49 83 fc 10          	cmp    $0x10,%r12
  8042112101:	0f 86 d4 fe ff ff    	jbe    8042111fdb <LZ4_decompress_safe_withSmallPrefix+0x587>
  8042112107:	49 8d 75 08          	lea    0x8(%r13),%rsi
  804211210b:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211210f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8042112113:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211211a:	00 00 00 
  804211211d:	ff d0                	call   *%rax
  804211211f:	e9 b7 fe ff ff       	jmp    8042111fdb <LZ4_decompress_safe_withSmallPrefix+0x587>
            token = *ip++;
  8042112124:	4c 89 eb             	mov    %r13,%rbx
        return (int) (-(((const char*)ip)-src))-1;
  8042112127:	48 89 d8             	mov    %rbx,%rax
  804211212a:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  804211212e:	48 29 c8             	sub    %rcx,%rax
  8042112131:	f7 d0                	not    %eax
                                  endOnInputSize, decode_full_block, noDict,
                                  (BYTE*)dest-prefixSize, NULL, 0);
}
  8042112133:	48 83 c4 48          	add    $0x48,%rsp
  8042112137:	5b                   	pop    %rbx
  8042112138:	41 5c                	pop    %r12
  804211213a:	41 5d                	pop    %r13
  804211213c:	41 5e                	pop    %r14
  804211213e:	41 5f                	pop    %r15
  8042112140:	5d                   	pop    %rbp
  8042112141:	c3                   	ret
  8042112142:	4c 89 eb             	mov    %r13,%rbx
  8042112145:	eb e0                	jmp    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
  8042112147:	4c 89 eb             	mov    %r13,%rbx
  804211214a:	eb db                	jmp    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
            token = *ip++;
  804211214c:	4c 89 eb             	mov    %r13,%rbx
  804211214f:	eb d6                	jmp    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
  8042112151:	4c 89 eb             	mov    %r13,%rbx
  8042112154:	eb d1                	jmp    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
  8042112156:	4c 89 eb             	mov    %r13,%rbx
  8042112159:	eb cc                	jmp    8042112127 <LZ4_decompress_safe_withSmallPrefix+0x6d3>
    if (src == NULL) { return -1; }
  804211215b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042112160:	eb d1                	jmp    8042112133 <LZ4_decompress_safe_withSmallPrefix+0x6df>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  8042112162:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
  8042112167:	eb ca                	jmp    8042112133 <LZ4_decompress_safe_withSmallPrefix+0x6df>

0000008042112169 <LZ4_decompress_fast_extDict>:
}

LZ4_FORCE_O2_GCC_PPC64LE
static int LZ4_decompress_fast_extDict(const char* source, char* dest, int originalSize,
                                       const void* dictStart, size_t dictSize)
{
  8042112169:	f3 0f 1e fa          	endbr64
  804211216d:	55                   	push   %rbp
  804211216e:	48 89 e5             	mov    %rsp,%rbp
  8042112171:	41 57                	push   %r15
  8042112173:	41 56                	push   %r14
  8042112175:	41 55                	push   %r13
  8042112177:	41 54                	push   %r12
  8042112179:	53                   	push   %rbx
  804211217a:	48 83 ec 38          	sub    $0x38,%rsp
  804211217e:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8042112182:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
    if (src == NULL) { return -1; }
  8042112186:	48 85 ff             	test   %rdi,%rdi
  8042112189:	0f 84 29 07 00 00    	je     80421128b8 <LZ4_decompress_fast_extDict+0x74f>
        BYTE* const oend = op + outputSize;
  804211218f:	48 63 c2             	movslq %edx,%rax
  8042112192:	48 01 f0             	add    %rsi,%rax
  8042112195:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        const BYTE* const dictEnd = (dictStart == NULL) ? NULL : dictStart + dictSize;
  8042112199:	4a 8d 04 01          	lea    (%rcx,%r8,1),%rax
  804211219d:	48 85 c9             	test   %rcx,%rcx
  80421121a0:	48 0f 44 c1          	cmove  %rcx,%rax
  80421121a4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
  80421121a8:	85 d2                	test   %edx,%edx
  80421121aa:	74 1a                	je     80421121c6 <LZ4_decompress_fast_extDict+0x5d>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  80421121ac:	83 fa 3f             	cmp    $0x3f,%edx
  80421121af:	0f 8e d3 05 00 00    	jle    8042112788 <LZ4_decompress_fast_extDict+0x61f>
    {   const BYTE* ip = (const BYTE*) src;
  80421121b5:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  80421121b9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80421121bd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80421121c1:	e9 aa 01 00 00       	jmp    8042112370 <LZ4_decompress_fast_extDict+0x207>
        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
  80421121c6:	80 3f 01             	cmpb   $0x1,(%rdi)
  80421121c9:	19 c0                	sbb    %eax,%eax
  80421121cb:	83 e0 02             	and    $0x2,%eax
  80421121ce:	83 e8 01             	sub    $0x1,%eax
  80421121d1:	e9 d3 06 00 00       	jmp    80421128a9 <LZ4_decompress_fast_extDict+0x740>
                    op += copySize;
  80421121d6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80421121da:	e9 91 01 00 00       	jmp    8042112370 <LZ4_decompress_fast_extDict+0x207>
  80421121df:	bb 00 00 00 00       	mov    $0x0,%ebx
        s = **ip;
  80421121e4:	41 0f b6 06          	movzbl (%r14),%eax
        (*ip)++;
  80421121e8:	49 83 c6 01          	add    $0x1,%r14
        length += s;
  80421121ec:	01 c3                	add    %eax,%ebx
    } while (s==255);
  80421121ee:	3d ff 00 00 00       	cmp    $0xff,%eax
  80421121f3:	74 ef                	je     80421121e4 <LZ4_decompress_fast_extDict+0x7b>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  80421121f5:	89 db                	mov    %ebx,%ebx
  80421121f7:	48 83 c3 0f          	add    $0xf,%rbx
                cpy = op+length;
  80421121fb:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  80421121ff:	4c 8d 2c 1f          	lea    (%rdi,%rbx,1),%r13
                    if (cpy>oend-8) { goto safe_literal_copy; }
  8042112203:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042112207:	48 83 e8 08          	sub    $0x8,%rax
  804211220b:	4c 39 e8             	cmp    %r13,%rax
  804211220e:	0f 82 58 03 00 00    	jb     804211256c <LZ4_decompress_fast_extDict+0x403>
                    LZ4_wildCopy8(op, ip, cpy); /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
  8042112214:	4c 89 ea             	mov    %r13,%rdx
  8042112217:	4c 89 f6             	mov    %r14,%rsi
  804211221a:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042112221:	00 00 00 
  8042112224:	ff d0                	call   *%rax
                ip += length; op = cpy;
  8042112226:	4c 01 f3             	add    %r14,%rbx
  8042112229:	e9 89 01 00 00       	jmp    80421123b7 <LZ4_decompress_fast_extDict+0x24e>
                    if (length > 8) { memcpy(op+8, ip+8, 8); }
  804211222e:	48 8d 73 09          	lea    0x9(%rbx),%rsi
  8042112232:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042112236:	48 83 c7 08          	add    $0x8,%rdi
  804211223a:	ba 08 00 00 00       	mov    $0x8,%edx
  804211223f:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042112246:	00 00 00 
  8042112249:	ff d0                	call   *%rax
  804211224b:	e9 63 01 00 00       	jmp    80421123b3 <LZ4_decompress_fast_extDict+0x24a>
  8042112250:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        s = **ip;
  8042112256:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  8042112259:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211225d:	41 01 c4             	add    %eax,%r12d
    } while (s==255);
  8042112260:	3d ff 00 00 00       	cmp    $0xff,%eax
  8042112265:	74 ef                	je     8042112256 <LZ4_decompress_fast_extDict+0xed>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  8042112267:	45 89 e4             	mov    %r12d,%r12d
                length += MINMATCH;
  804211226a:	49 83 c4 13          	add    $0x13,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211226e:	4b 8d 54 25 00       	lea    0x0(%r13,%r12,1),%rdx
  8042112273:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042112277:	48 83 e8 40          	sub    $0x40,%rax
  804211227b:	48 39 c2             	cmp    %rax,%rdx
  804211227e:	73 50                	jae    80421122d0 <LZ4_decompress_fast_extDict+0x167>
            if ((dict==usingExtDict) && (match < lowPrefix)) {
  8042112280:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042112284:	49 39 f7             	cmp    %rsi,%r15
  8042112287:	0f 83 ba 00 00 00    	jae    8042112347 <LZ4_decompress_fast_extDict+0x1de>
                if (unlikely(op+length > oend-LASTLITERALS)) {
  804211228d:	4b 8d 4c 25 00       	lea    0x0(%r13,%r12,1),%rcx
  8042112292:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8042112296:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211229a:	48 83 e8 05          	sub    $0x5,%rax
  804211229e:	48 39 c8             	cmp    %rcx,%rax
  80421122a1:	0f 82 f6 05 00 00    	jb     804211289d <LZ4_decompress_fast_extDict+0x734>
                if (length <= (size_t)(lowPrefix-match)) {
  80421122a7:	4c 29 fe             	sub    %r15,%rsi
  80421122aa:	49 89 f6             	mov    %rsi,%r14
  80421122ad:	4c 39 e6             	cmp    %r12,%rsi
  80421122b0:	72 26                	jb     80421122d8 <LZ4_decompress_fast_extDict+0x16f>
                    memmove(op, dictEnd - (lowPrefix-match), length);
  80421122b2:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80421122b6:	4c 29 f6             	sub    %r14,%rsi
  80421122b9:	4c 89 e2             	mov    %r12,%rdx
  80421122bc:	4c 89 ef             	mov    %r13,%rdi
  80421122bf:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  80421122c6:	00 00 00 
  80421122c9:	ff d0                	call   *%rax
                    op += length;
  80421122cb:	e9 a0 00 00 00       	jmp    8042112370 <LZ4_decompress_fast_extDict+0x207>
  80421122d0:	49 89 ce             	mov    %rcx,%r14
  80421122d3:	e9 69 05 00 00       	jmp    8042112841 <LZ4_decompress_fast_extDict+0x6d8>
                    size_t const restSize = length - copySize;
  80421122d8:	4d 89 e7             	mov    %r12,%r15
  80421122db:	49 29 f7             	sub    %rsi,%r15
                    memcpy(op, dictEnd - copySize, copySize);
  80421122de:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80421122e2:	4c 29 f6             	sub    %r14,%rsi
  80421122e5:	4c 89 f2             	mov    %r14,%rdx
  80421122e8:	4c 89 ef             	mov    %r13,%rdi
  80421122eb:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421122f2:	00 00 00 
  80421122f5:	ff d0                	call   *%rax
                    op += copySize;
  80421122f7:	4b 8d 7c 35 00       	lea    0x0(%r13,%r14,1),%rdi
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
  80421122fc:	48 89 f8             	mov    %rdi,%rax
  80421122ff:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042112303:	48 29 c8             	sub    %rcx,%rax
  8042112306:	4c 39 f8             	cmp    %r15,%rax
  8042112309:	72 15                	jb     8042112320 <LZ4_decompress_fast_extDict+0x1b7>
                        memcpy(op, lowPrefix, restSize);
  804211230b:	4c 89 fa             	mov    %r15,%rdx
  804211230e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042112312:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042112319:	00 00 00 
  804211231c:	ff d0                	call   *%rax
                        op += restSize;
  804211231e:	eb 50                	jmp    8042112370 <LZ4_decompress_fast_extDict+0x207>
                        while (op < endOfMatch) { *op++ = *copyFrom++; }
  8042112320:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042112324:	48 39 c7             	cmp    %rax,%rdi
  8042112327:	0f 83 a9 fe ff ff    	jae    80421121d6 <LZ4_decompress_fast_extDict+0x6d>
  804211232d:	4d 89 fc             	mov    %r15,%r12
  8042112330:	b8 00 00 00 00       	mov    $0x0,%eax
  8042112335:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  8042112339:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  804211233c:	48 83 c0 01          	add    $0x1,%rax
  8042112340:	4c 39 e0             	cmp    %r12,%rax
  8042112343:	75 f0                	jne    8042112335 <LZ4_decompress_fast_extDict+0x1cc>
  8042112345:	eb 29                	jmp    8042112370 <LZ4_decompress_fast_extDict+0x207>
            cpy = op + length;
  8042112347:	4b 8d 44 25 00       	lea    0x0(%r13,%r12,1),%rax
  804211234c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<16)) {
  8042112350:	48 83 f9 0f          	cmp    $0xf,%rcx
  8042112354:	0f 86 f9 00 00 00    	jbe    8042112453 <LZ4_decompress_fast_extDict+0x2ea>
                LZ4_wildCopy32(op, match, cpy);
  804211235a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211235e:	4c 89 fe             	mov    %r15,%rsi
  8042112361:	4c 89 ef             	mov    %r13,%rdi
  8042112364:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211236b:	00 00 00 
  804211236e:	ff d0                	call   *%rax
            token = *ip++;
  8042112370:	4c 8d 73 01          	lea    0x1(%rbx),%r14
  8042112374:	44 0f b6 23          	movzbl (%rbx),%r12d
            length = token >> ML_BITS;  /* literal length */
  8042112378:	4d 89 e7             	mov    %r12,%r15
  804211237b:	49 c1 ef 04          	shr    $0x4,%r15
  804211237f:	41 83 e7 0f          	and    $0xf,%r15d
            if (length == RUN_MASK) {
  8042112383:	49 83 ff 0f          	cmp    $0xf,%r15
  8042112387:	0f 84 52 fe ff ff    	je     80421121df <LZ4_decompress_fast_extDict+0x76>
                cpy = op+length;
  804211238d:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042112391:	4e 8d 2c 3f          	lea    (%rdi,%r15,1),%r13
                    memcpy(op, ip, 8);
  8042112395:	ba 08 00 00 00       	mov    $0x8,%edx
  804211239a:	4c 89 f6             	mov    %r14,%rsi
  804211239d:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421123a4:	00 00 00 
  80421123a7:	ff d0                	call   *%rax
                    if (length > 8) { memcpy(op+8, ip+8, 8); }
  80421123a9:	49 83 ff 08          	cmp    $0x8,%r15
  80421123ad:	0f 87 7b fe ff ff    	ja     804211222e <LZ4_decompress_fast_extDict+0xc5>
                ip += length; op = cpy;
  80421123b3:	4b 8d 1c 3e          	lea    (%r14,%r15,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  80421123b7:	48 89 df             	mov    %rbx,%rdi
  80421123ba:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  80421123c1:	00 00 00 
  80421123c4:	ff d0                	call   *%rax
  80421123c6:	0f b7 c8             	movzwl %ax,%ecx
  80421123c9:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  80421123cd:	4d 89 ef             	mov    %r13,%r15
  80421123d0:	49 29 cf             	sub    %rcx,%r15
            length = token & ML_MASK;
  80421123d3:	41 83 e4 0f          	and    $0xf,%r12d
            if (length == ML_MASK) {
  80421123d7:	49 83 fc 0f          	cmp    $0xf,%r12
  80421123db:	0f 84 6f fe ff ff    	je     8042112250 <LZ4_decompress_fast_extDict+0xe7>
                length += MINMATCH;
  80421123e1:	49 83 c4 04          	add    $0x4,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  80421123e5:	4b 8d 54 25 00       	lea    0x0(%r13,%r12,1),%rdx
  80421123ea:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80421123ee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80421123f2:	48 83 e8 40          	sub    $0x40,%rax
  80421123f6:	48 39 c2             	cmp    %rax,%rdx
  80421123f9:	0f 83 bb 01 00 00    	jae    80421125ba <LZ4_decompress_fast_extDict+0x451>
                    if (offset >= 8) {
  80421123ff:	48 83 f9 07          	cmp    $0x7,%rcx
  8042112403:	0f 86 77 fe ff ff    	jbe    8042112280 <LZ4_decompress_fast_extDict+0x117>
  8042112409:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211240d:	49 39 c7             	cmp    %rax,%r15
  8042112410:	0f 82 6a fe ff ff    	jb     8042112280 <LZ4_decompress_fast_extDict+0x117>
                        memcpy(op, match, 8);
  8042112416:	ba 08 00 00 00       	mov    $0x8,%edx
  804211241b:	4c 89 fe             	mov    %r15,%rsi
  804211241e:	4c 89 ef             	mov    %r13,%rdi
  8042112421:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  8042112428:	00 00 00 
  804211242b:	41 ff d4             	call   *%r12
                        memcpy(op+8, match+8, 8);
  804211242e:	49 8d 77 08          	lea    0x8(%r15),%rsi
  8042112432:	49 8d 7d 08          	lea    0x8(%r13),%rdi
  8042112436:	ba 08 00 00 00       	mov    $0x8,%edx
  804211243b:	41 ff d4             	call   *%r12
                        memcpy(op+16, match+16, 2);
  804211243e:	49 8d 77 10          	lea    0x10(%r15),%rsi
  8042112442:	49 8d 7d 10          	lea    0x10(%r13),%rdi
  8042112446:	ba 02 00 00 00       	mov    $0x2,%edx
  804211244b:	41 ff d4             	call   *%r12
                        continue;
  804211244e:	e9 1d ff ff ff       	jmp    8042112370 <LZ4_decompress_fast_extDict+0x207>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  8042112453:	48 89 c2             	mov    %rax,%rdx
  8042112456:	4c 89 fe             	mov    %r15,%rsi
  8042112459:	4c 89 ef             	mov    %r13,%rdi
  804211245c:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  8042112463:	00 00 00 
  8042112466:	ff d0                	call   *%rax
  8042112468:	e9 03 ff ff ff       	jmp    8042112370 <LZ4_decompress_fast_extDict+0x207>
                    memcpy(op + 0, match + 0, 8);
  804211246d:	ba 08 00 00 00       	mov    $0x8,%edx
  8042112472:	4c 89 fe             	mov    %r15,%rsi
  8042112475:	4c 89 ef             	mov    %r13,%rdi
  8042112478:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211247f:	00 00 00 
  8042112482:	ff d0                	call   *%rax
                    memcpy(op + 8, match + 8, 8);
  8042112484:	49 8d 77 08          	lea    0x8(%r15),%rsi
  8042112488:	49 8d 7d 08          	lea    0x8(%r13),%rdi
  804211248c:	ba 08 00 00 00       	mov    $0x8,%edx
  8042112491:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042112498:	00 00 00 
  804211249b:	ff d0                	call   *%rax
                    memcpy(op +16, match +16, 2);
  804211249d:	49 8d 77 10          	lea    0x10(%r15),%rsi
  80421124a1:	49 8d 7d 10          	lea    0x10(%r13),%rdi
  80421124a5:	ba 02 00 00 00       	mov    $0x2,%edx
  80421124aa:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421124b1:	00 00 00 
  80421124b4:	ff d0                	call   *%rax
                    op += length + MINMATCH;
  80421124b6:	4f 8d 6c 25 04       	lea    0x4(%r13,%r12,1),%r13
            token = *ip++;
  80421124bb:	4c 8d 63 03          	lea    0x3(%rbx),%r12
  80421124bf:	44 0f b6 7b 02       	movzbl 0x2(%rbx),%r15d
  80421124c4:	41 0f b6 c7          	movzbl %r15b,%eax
            length = token >> ML_BITS;  /* literal length */
  80421124c8:	89 c3                	mov    %eax,%ebx
  80421124ca:	c1 eb 04             	shr    $0x4,%ebx
  80421124cd:	89 db                	mov    %ebx,%ebx
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  80421124cf:	4d 39 ee             	cmp    %r13,%r14
  80421124d2:	72 6e                	jb     8042112542 <LZ4_decompress_fast_extDict+0x3d9>
  80421124d4:	48 83 fb 08          	cmp    $0x8,%rbx
  80421124d8:	0f 86 f3 02 00 00    	jbe    80421127d1 <LZ4_decompress_fast_extDict+0x668>
  80421124de:	4c 89 6d c8          	mov    %r13,-0x38(%rbp)
  80421124e2:	4d 89 e6             	mov    %r12,%r14
  80421124e5:	41 89 c4             	mov    %eax,%r12d
            if (length == RUN_MASK) {
  80421124e8:	48 83 fb 0f          	cmp    $0xf,%rbx
  80421124ec:	74 60                	je     804211254e <LZ4_decompress_fast_extDict+0x3e5>
            cpy = op+length;
  80421124ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421124f2:	4c 8d 2c 18          	lea    (%rax,%rbx,1),%r13
                 || ((!endOnInput) && (cpy>oend-WILDCOPYLENGTH)) )
  80421124f6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80421124fa:	48 83 e8 08          	sub    $0x8,%rax
  80421124fe:	4c 39 e8             	cmp    %r13,%rax
  8042112501:	72 69                	jb     804211256c <LZ4_decompress_fast_extDict+0x403>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  8042112503:	4c 89 ea             	mov    %r13,%rdx
  8042112506:	4c 89 f6             	mov    %r14,%rsi
  8042112509:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211250d:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042112514:	00 00 00 
  8042112517:	ff d0                	call   *%rax
                ip += length; op = cpy;
  8042112519:	4c 01 f3             	add    %r14,%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211251c:	48 89 df             	mov    %rbx,%rdi
  804211251f:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  8042112526:	00 00 00 
  8042112529:	ff d0                	call   *%rax
  804211252b:	44 0f b7 f0          	movzwl %ax,%r14d
  804211252f:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  8042112533:	4d 89 ef             	mov    %r13,%r15
  8042112536:	4d 29 f7             	sub    %r14,%r15
            length = token & ML_MASK;
  8042112539:	41 83 e4 0f          	and    $0xf,%r12d
  804211253d:	e9 f1 02 00 00       	jmp    8042112833 <LZ4_decompress_fast_extDict+0x6ca>
  8042112542:	4c 89 6d c8          	mov    %r13,-0x38(%rbp)
  8042112546:	4d 89 e6             	mov    %r12,%r14
  8042112549:	41 89 c4             	mov    %eax,%r12d
  804211254c:	eb 9a                	jmp    80421124e8 <LZ4_decompress_fast_extDict+0x37f>
  804211254e:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  8042112553:	41 0f b6 06          	movzbl (%r14),%eax
        (*ip)++;
  8042112557:	49 83 c6 01          	add    $0x1,%r14
        length += s;
  804211255b:	01 c2                	add    %eax,%edx
    } while (s==255);
  804211255d:	3d ff 00 00 00       	cmp    $0xff,%eax
  8042112562:	74 ef                	je     8042112553 <LZ4_decompress_fast_extDict+0x3ea>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  8042112564:	89 d2                	mov    %edx,%edx
  8042112566:	48 8d 5a 0f          	lea    0xf(%rdx),%rbx
                if (error == initial_error) { goto _output_error; }
  804211256a:	eb 82                	jmp    80421124ee <LZ4_decompress_fast_extDict+0x385>
                    if ((!endOnInput) && (cpy != oend)) { goto _output_error; }
  804211256c:	4c 39 6d c0          	cmp    %r13,-0x40(%rbp)
  8042112570:	0f 85 24 03 00 00    	jne    804211289a <LZ4_decompress_fast_extDict+0x731>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  8042112576:	48 89 da             	mov    %rbx,%rdx
  8042112579:	4c 89 f6             	mov    %r14,%rsi
  804211257c:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042112580:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  8042112587:	00 00 00 
  804211258a:	ff d0                	call   *%rax
                ip += length;
  804211258c:	49 8d 04 1e          	lea    (%r14,%rbx,1),%rax
            return (int) (((const char*)ip)-src);   /* Nb of input bytes read */
  8042112590:	8b 55 a8             	mov    -0x58(%rbp),%edx
  8042112593:	29 d0                	sub    %edx,%eax
  8042112595:	e9 0f 03 00 00       	jmp    80421128a9 <LZ4_decompress_fast_extDict+0x740>
  804211259a:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211259f:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  80421125a2:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  80421125a6:	01 c2                	add    %eax,%edx
    } while (s==255);
  80421125a8:	3d ff 00 00 00       	cmp    $0xff,%eax
  80421125ad:	74 f0                	je     804211259f <LZ4_decompress_fast_extDict+0x436>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  80421125af:	89 d2                	mov    %edx,%edx
  80421125b1:	4c 8d 62 0f          	lea    0xf(%rdx),%r12
                if (error != ok) goto _output_error;
  80421125b5:	e9 83 02 00 00       	jmp    804211283d <LZ4_decompress_fast_extDict+0x6d4>
  80421125ba:	49 89 ce             	mov    %rcx,%r14
  80421125bd:	e9 7f 02 00 00       	jmp    8042112841 <LZ4_decompress_fast_extDict+0x6d8>
                    size_t const restSize = length - copySize;
  80421125c2:	4d 89 e7             	mov    %r12,%r15
  80421125c5:	49 29 d7             	sub    %rdx,%r15
                    memcpy(op, dictEnd - copySize, copySize);
  80421125c8:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80421125cc:	48 29 d6             	sub    %rdx,%rsi
  80421125cf:	4c 89 ef             	mov    %r13,%rdi
  80421125d2:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421125d9:	00 00 00 
  80421125dc:	ff d0                	call   *%rax
                    op += copySize;
  80421125de:	4b 8d 7c 35 00       	lea    0x0(%r13,%r14,1),%rdi
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
  80421125e3:	48 89 f8             	mov    %rdi,%rax
  80421125e6:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80421125ea:	48 29 c8             	sub    %rcx,%rax
  80421125ed:	4c 39 f8             	cmp    %r15,%rax
  80421125f0:	73 2a                	jae    804211261c <LZ4_decompress_fast_extDict+0x4b3>
                        while (op < endOfMatch) *op++ = *copyFrom++;
  80421125f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421125f6:	48 39 c7             	cmp    %rax,%rdi
  80421125f9:	0f 83 92 02 00 00    	jae    8042112891 <LZ4_decompress_fast_extDict+0x728>
  80421125ff:	4d 89 fc             	mov    %r15,%r12
  8042112602:	b8 00 00 00 00       	mov    $0x0,%eax
  8042112607:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  804211260b:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  804211260e:	48 83 c0 01          	add    $0x1,%rax
  8042112612:	4c 39 e0             	cmp    %r12,%rax
  8042112615:	75 f0                	jne    8042112607 <LZ4_decompress_fast_extDict+0x49e>
  8042112617:	e9 78 01 00 00       	jmp    8042112794 <LZ4_decompress_fast_extDict+0x62b>
                        memcpy(op, lowPrefix, restSize);
  804211261c:	4c 89 fa             	mov    %r15,%rdx
  804211261f:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042112623:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211262a:	00 00 00 
  804211262d:	ff d0                	call   *%rax
                        op += restSize;
  804211262f:	e9 60 01 00 00       	jmp    8042112794 <LZ4_decompress_fast_extDict+0x62b>
            cpy = op + length;
  8042112634:	4b 8d 44 25 00       	lea    0x0(%r13,%r12,1),%rax
  8042112639:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<8)) {
  804211263d:	49 83 fe 07          	cmp    $0x7,%r14
  8042112641:	76 72                	jbe    80421126b5 <LZ4_decompress_fast_extDict+0x54c>
                memcpy(op, match, 8);
  8042112643:	ba 08 00 00 00       	mov    $0x8,%edx
  8042112648:	4c 89 fe             	mov    %r15,%rsi
  804211264b:	4c 89 ef             	mov    %r13,%rdi
  804211264e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042112655:	00 00 00 
  8042112658:	ff d0                	call   *%rax
                match += 8;
  804211265a:	49 83 c7 08          	add    $0x8,%r15
            op += 8;
  804211265e:	4d 8d 75 08          	lea    0x8(%r13),%r14
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  8042112662:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042112666:	48 83 e8 0c          	sub    $0xc,%rax
  804211266a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211266e:	48 39 d0             	cmp    %rdx,%rax
  8042112671:	0f 82 a8 00 00 00    	jb     804211271f <LZ4_decompress_fast_extDict+0x5b6>
                memcpy(op, match, 8);
  8042112677:	ba 08 00 00 00       	mov    $0x8,%edx
  804211267c:	4c 89 fe             	mov    %r15,%rsi
  804211267f:	4c 89 f7             	mov    %r14,%rdi
  8042112682:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042112689:	00 00 00 
  804211268c:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211268e:	49 83 fc 10          	cmp    $0x10,%r12
  8042112692:	0f 86 fc 00 00 00    	jbe    8042112794 <LZ4_decompress_fast_extDict+0x62b>
  8042112698:	49 8d 77 08          	lea    0x8(%r15),%rsi
  804211269c:	49 8d 7d 10          	lea    0x10(%r13),%rdi
  80421126a0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80421126a4:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  80421126ab:	00 00 00 
  80421126ae:	ff d0                	call   *%rax
  80421126b0:	e9 df 00 00 00       	jmp    8042112794 <LZ4_decompress_fast_extDict+0x62b>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421126b5:	41 c7 45 00 00 00 00 	movl   $0x0,0x0(%r13)
  80421126bc:	00 
                op[0] = match[0];
  80421126bd:	41 0f b6 07          	movzbl (%r15),%eax
  80421126c1:	41 88 45 00          	mov    %al,0x0(%r13)
                op[1] = match[1];
  80421126c5:	41 0f b6 47 01       	movzbl 0x1(%r15),%eax
  80421126ca:	41 88 45 01          	mov    %al,0x1(%r13)
                op[2] = match[2];
  80421126ce:	41 0f b6 47 02       	movzbl 0x2(%r15),%eax
  80421126d3:	41 88 45 02          	mov    %al,0x2(%r13)
                op[3] = match[3];
  80421126d7:	41 0f b6 47 03       	movzbl 0x3(%r15),%eax
  80421126dc:	41 88 45 03          	mov    %al,0x3(%r13)
                match += inc32table[offset];
  80421126e0:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  80421126e7:	00 00 00 
  80421126ea:	42 8b 04 b0          	mov    (%rax,%r14,4),%eax
  80421126ee:	49 01 c7             	add    %rax,%r15
                memcpy(op+4, match, 4);
  80421126f1:	49 8d 7d 04          	lea    0x4(%r13),%rdi
  80421126f5:	ba 04 00 00 00       	mov    $0x4,%edx
  80421126fa:	4c 89 fe             	mov    %r15,%rsi
  80421126fd:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042112704:	00 00 00 
  8042112707:	ff d0                	call   *%rax
                match -= dec64table[offset];
  8042112709:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  8042112710:	00 00 00 
  8042112713:	4a 63 04 b0          	movslq (%rax,%r14,4),%rax
  8042112717:	49 29 c7             	sub    %rax,%r15
  804211271a:	e9 3f ff ff ff       	jmp    804211265e <LZ4_decompress_fast_extDict+0x4f5>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
  804211271f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8042112723:	48 8d 42 fb          	lea    -0x5(%rdx),%rax
  8042112727:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211272b:	48 39 f0             	cmp    %rsi,%rax
  804211272e:	0f 82 69 01 00 00    	jb     804211289d <LZ4_decompress_fast_extDict+0x734>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
  8042112734:	4c 8d 62 f9          	lea    -0x7(%rdx),%r12
                if (op < oCopyLimit) {
  8042112738:	4d 39 e6             	cmp    %r12,%r14
  804211273b:	72 28                	jb     8042112765 <LZ4_decompress_fast_extDict+0x5fc>
                while (op < cpy) { *op++ = *match++; }
  804211273d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042112741:	49 39 c6             	cmp    %rax,%r14
  8042112744:	73 4e                	jae    8042112794 <LZ4_decompress_fast_extDict+0x62b>
  8042112746:	4c 29 f0             	sub    %r14,%rax
  8042112749:	48 89 c1             	mov    %rax,%rcx
  804211274c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042112751:	41 0f b6 14 07       	movzbl (%r15,%rax,1),%edx
  8042112756:	41 88 14 06          	mov    %dl,(%r14,%rax,1)
  804211275a:	48 83 c0 01          	add    $0x1,%rax
  804211275e:	48 39 c8             	cmp    %rcx,%rax
  8042112761:	75 ee                	jne    8042112751 <LZ4_decompress_fast_extDict+0x5e8>
  8042112763:	eb 2f                	jmp    8042112794 <LZ4_decompress_fast_extDict+0x62b>
                    LZ4_wildCopy8(op, match, oCopyLimit);
  8042112765:	4c 89 e2             	mov    %r12,%rdx
  8042112768:	4c 89 fe             	mov    %r15,%rsi
  804211276b:	4c 89 f7             	mov    %r14,%rdi
  804211276e:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042112775:	00 00 00 
  8042112778:	ff d0                	call   *%rax
                    match += oCopyLimit - op;
  804211277a:	4c 89 e0             	mov    %r12,%rax
  804211277d:	4c 29 f0             	sub    %r14,%rax
  8042112780:	49 01 c7             	add    %rax,%r15
                    op = oCopyLimit;
  8042112783:	4d 89 e6             	mov    %r12,%r14
  8042112786:	eb b5                	jmp    804211273d <LZ4_decompress_fast_extDict+0x5d4>
    {   const BYTE* ip = (const BYTE*) src;
  8042112788:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211278c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042112790:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  8042112794:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042112798:	48 83 e8 1a          	sub    $0x1a,%rax
            token = *ip++;
  804211279c:	4c 8d 73 01          	lea    0x1(%rbx),%r14
  80421127a0:	44 0f b6 3b          	movzbl (%rbx),%r15d
  80421127a4:	45 0f b6 e7          	movzbl %r15b,%r12d
            length = token >> ML_BITS;  /* literal length */
  80421127a8:	44 89 e3             	mov    %r12d,%ebx
  80421127ab:	c1 eb 04             	shr    $0x4,%ebx
  80421127ae:	89 db                	mov    %ebx,%ebx
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  80421127b0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80421127b4:	48 39 d0             	cmp    %rdx,%rax
  80421127b7:	0f 82 2b fd ff ff    	jb     80421124e8 <LZ4_decompress_fast_extDict+0x37f>
  80421127bd:	48 83 fb 08          	cmp    $0x8,%rbx
  80421127c1:	0f 87 21 fd ff ff    	ja     80421124e8 <LZ4_decompress_fast_extDict+0x37f>
  80421127c7:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
  80421127cb:	4d 89 f4             	mov    %r14,%r12
  80421127ce:	49 89 c6             	mov    %rax,%r14
                memcpy(op, ip, endOnInput ? 16 : 8);
  80421127d1:	ba 08 00 00 00       	mov    $0x8,%edx
  80421127d6:	4c 89 e6             	mov    %r12,%rsi
  80421127d9:	4c 89 ef             	mov    %r13,%rdi
  80421127dc:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421127e3:	00 00 00 
  80421127e6:	ff d0                	call   *%rax
                op += length; ip += length;
  80421127e8:	49 01 dd             	add    %rbx,%r13
  80421127eb:	4c 01 e3             	add    %r12,%rbx
                length = token & ML_MASK; /* match length */
  80421127ee:	4d 89 fc             	mov    %r15,%r12
  80421127f1:	41 83 e4 0f          	and    $0xf,%r12d
                offset = LZ4_readLE16(ip); ip += 2;
  80421127f5:	48 89 df             	mov    %rbx,%rdi
  80421127f8:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  80421127ff:	00 00 00 
  8042112802:	ff d0                	call   *%rax
  8042112804:	0f b7 c0             	movzwl %ax,%eax
                match = op - offset;
  8042112807:	4d 89 ef             	mov    %r13,%r15
  804211280a:	49 29 c7             	sub    %rax,%r15
                if ( (length != ML_MASK)
  804211280d:	49 83 fc 0f          	cmp    $0xf,%r12
  8042112811:	0f 95 c1             	setne  %cl
                     && (offset >= 8)
  8042112814:	48 83 f8 07          	cmp    $0x7,%rax
  8042112818:	0f 97 c2             	seta   %dl
                     && (dict==withPrefix64k || match >= lowPrefix) ) {
  804211281b:	84 d1                	test   %dl,%cl
  804211281d:	74 0d                	je     804211282c <LZ4_decompress_fast_extDict+0x6c3>
  804211281f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8042112823:	49 39 d7             	cmp    %rdx,%r15
  8042112826:	0f 83 41 fc ff ff    	jae    804211246d <LZ4_decompress_fast_extDict+0x304>
                offset = LZ4_readLE16(ip); ip += 2;
  804211282c:	49 89 c6             	mov    %rax,%r14
  804211282f:	48 83 c3 02          	add    $0x2,%rbx
            if (length == ML_MASK) {
  8042112833:	49 83 fc 0f          	cmp    $0xf,%r12
  8042112837:	0f 84 5d fd ff ff    	je     804211259a <LZ4_decompress_fast_extDict+0x431>
            length += MINMATCH;
  804211283d:	49 83 c4 04          	add    $0x4,%r12
            if ((dict==usingExtDict) && (match < lowPrefix)) {
  8042112841:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8042112845:	49 39 d7             	cmp    %rdx,%r15
  8042112848:	0f 83 e6 fd ff ff    	jae    8042112634 <LZ4_decompress_fast_extDict+0x4cb>
                if (unlikely(op+length > oend-LASTLITERALS)) {
  804211284e:	4b 8d 4c 25 00       	lea    0x0(%r13,%r12,1),%rcx
  8042112853:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8042112857:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211285b:	48 83 e8 05          	sub    $0x5,%rax
  804211285f:	48 39 c8             	cmp    %rcx,%rax
  8042112862:	72 39                	jb     804211289d <LZ4_decompress_fast_extDict+0x734>
                if (length <= (size_t)(lowPrefix-match)) {
  8042112864:	4c 29 fa             	sub    %r15,%rdx
  8042112867:	49 89 d6             	mov    %rdx,%r14
  804211286a:	4c 39 e2             	cmp    %r12,%rdx
  804211286d:	0f 82 4f fd ff ff    	jb     80421125c2 <LZ4_decompress_fast_extDict+0x459>
                    memmove(op, dictEnd - (lowPrefix-match), length);
  8042112873:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042112877:	48 29 d6             	sub    %rdx,%rsi
  804211287a:	4c 89 e2             	mov    %r12,%rdx
  804211287d:	4c 89 ef             	mov    %r13,%rdi
  8042112880:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  8042112887:	00 00 00 
  804211288a:	ff d0                	call   *%rax
                    op += length;
  804211288c:	e9 03 ff ff ff       	jmp    8042112794 <LZ4_decompress_fast_extDict+0x62b>
                    op += copySize;
  8042112891:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8042112895:	e9 fa fe ff ff       	jmp    8042112794 <LZ4_decompress_fast_extDict+0x62b>
  804211289a:	4c 89 f3             	mov    %r14,%rbx
        return (int) (-(((const char*)ip)-src))-1;
  804211289d:	48 89 d8             	mov    %rbx,%rax
  80421128a0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80421128a4:	48 29 d0             	sub    %rdx,%rax
  80421128a7:	f7 d0                	not    %eax
    return LZ4_decompress_generic(source, dest, 0, originalSize,
                                  endOnOutputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest, (const BYTE*)dictStart, dictSize);
}
  80421128a9:	48 83 c4 38          	add    $0x38,%rsp
  80421128ad:	5b                   	pop    %rbx
  80421128ae:	41 5c                	pop    %r12
  80421128b0:	41 5d                	pop    %r13
  80421128b2:	41 5e                	pop    %r14
  80421128b4:	41 5f                	pop    %r15
  80421128b6:	5d                   	pop    %rbp
  80421128b7:	c3                   	ret
    if (src == NULL) { return -1; }
  80421128b8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80421128bd:	eb ea                	jmp    80421128a9 <LZ4_decompress_fast_extDict+0x740>

00000080421128bf <LZ4_NbCommonBytes>:
{
  80421128bf:	f3 0f 1e fa          	endbr64
            return (unsigned)__builtin_ctzll((U64)val) >> 3;
  80421128c3:	31 c0                	xor    %eax,%eax
  80421128c5:	f3 48 0f bc c7       	tzcnt  %rdi,%rax
  80421128ca:	c1 e8 03             	shr    $0x3,%eax
}
  80421128cd:	c3                   	ret

00000080421128ce <LZ4_hash5>:
{
  80421128ce:	f3 0f 1e fa          	endbr64
    const U32 hashLog = (tableType == byU16) ? LZ4_HASHLOG+1 : LZ4_HASHLOG;
  80421128d2:	83 fe 03             	cmp    $0x3,%esi
  80421128d5:	0f 94 c0             	sete   %al
  80421128d8:	0f b6 c0             	movzbl %al,%eax
        return (U32)(((sequence << 24) * prime5bytes) >> (64 - hashLog));
  80421128db:	48 ba 00 00 00 bb dc 	movabs $0xcf1bbcdcbb000000,%rdx
  80421128e2:	bc 1b cf 
  80421128e5:	48 0f af fa          	imul   %rdx,%rdi
  80421128e9:	b9 34 00 00 00       	mov    $0x34,%ecx
  80421128ee:	29 c1                	sub    %eax,%ecx
  80421128f0:	48 d3 ef             	shr    %cl,%rdi
  80421128f3:	48 89 f8             	mov    %rdi,%rax
}
  80421128f6:	c3                   	ret

00000080421128f7 <LZ4_versionNumber>:
int LZ4_versionNumber (void) { return LZ4_VERSION_NUMBER; }
  80421128f7:	f3 0f 1e fa          	endbr64
  80421128fb:	b8 96 2a 00 00       	mov    $0x2a96,%eax
  8042112900:	c3                   	ret

0000008042112901 <LZ4_versionString>:
const char* LZ4_versionString(void) { return LZ4_VERSION_STRING; }
  8042112901:	f3 0f 1e fa          	endbr64
  8042112905:	48 b8 28 04 12 42 80 	movabs $0x8042120428,%rax
  804211290c:	00 00 00 
  804211290f:	c3                   	ret

0000008042112910 <LZ4_compressBound>:
int LZ4_compressBound(int isize)  { return LZ4_COMPRESSBOUND(isize); }
  8042112910:	f3 0f 1e fa          	endbr64
  8042112914:	b8 00 00 00 00       	mov    $0x0,%eax
  8042112919:	81 ff 00 00 00 7e    	cmp    $0x7e000000,%edi
  804211291f:	77 1e                	ja     804211293f <LZ4_compressBound+0x2f>
  8042112921:	48 63 c7             	movslq %edi,%rax
  8042112924:	48 69 c0 81 80 80 80 	imul   $0xffffffff80808081,%rax,%rax
  804211292b:	48 c1 e8 20          	shr    $0x20,%rax
  804211292f:	01 f8                	add    %edi,%eax
  8042112931:	c1 f8 07             	sar    $0x7,%eax
  8042112934:	89 fa                	mov    %edi,%edx
  8042112936:	c1 fa 1f             	sar    $0x1f,%edx
  8042112939:	29 d0                	sub    %edx,%eax
  804211293b:	8d 44 07 10          	lea    0x10(%rdi,%rax,1),%eax
  804211293f:	c3                   	ret

0000008042112940 <LZ4_sizeofState>:
int LZ4_sizeofState() { return LZ4_STREAMSIZE; }
  8042112940:	f3 0f 1e fa          	endbr64
  8042112944:	b8 20 40 00 00       	mov    $0x4020,%eax
  8042112949:	c3                   	ret

000000804211294a <LZ4_compress_fast_extState_fastReset>:
{
  804211294a:	f3 0f 1e fa          	endbr64
  804211294e:	55                   	push   %rbp
  804211294f:	48 89 e5             	mov    %rsp,%rbp
  8042112952:	41 57                	push   %r15
  8042112954:	41 56                	push   %r14
  8042112956:	41 55                	push   %r13
  8042112958:	41 54                	push   %r12
  804211295a:	53                   	push   %rbx
  804211295b:	48 83 ec 78          	sub    $0x78,%rsp
  804211295f:	49 89 ff             	mov    %rdi,%r15
  8042112962:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8042112966:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  804211296a:	41 89 cc             	mov    %ecx,%r12d
  804211296d:	45 89 c5             	mov    %r8d,%r13d
    if (acceleration < 1) acceleration = ACCELERATION_DEFAULT;
  8042112970:	45 85 c9             	test   %r9d,%r9d
  8042112973:	b8 01 00 00 00       	mov    $0x1,%eax
  8042112978:	41 0f 4f c1          	cmovg  %r9d,%eax
  804211297c:	89 c3                	mov    %eax,%ebx
    if (dstCapacity >= LZ4_compressBound(srcSize)) {
  804211297e:	89 cf                	mov    %ecx,%edi
  8042112980:	48 b8 10 29 11 42 80 	movabs $0x8042112910,%rax
  8042112987:	00 00 00 
  804211298a:	ff d0                	call   *%rax
  804211298c:	44 39 e8             	cmp    %r13d,%eax
  804211298f:	0f 8f 0f 0f 00 00    	jg     80421138a4 <LZ4_compress_fast_extState_fastReset+0xf5a>
        if (srcSize < LZ4_64Klimit) {
  8042112995:	41 81 fc 0a 00 01 00 	cmp    $0x1000a,%r12d
  804211299c:	0f 8f a4 09 00 00    	jg     8042113346 <LZ4_compress_fast_extState_fastReset+0x9fc>
    if (cctx->dirty) {
  80421129a2:	66 41 83 bf 04 40 00 	cmpw   $0x0,0x4004(%r15)
  80421129a9:	00 00 
  80421129ab:	0f 85 7f 01 00 00    	jne    8042112b30 <LZ4_compress_fast_extState_fastReset+0x1e6>
    if (cctx->tableType != clearedTable) {
  80421129b1:	41 0f b7 87 06 40 00 	movzwl 0x4006(%r15),%eax
  80421129b8:	00 
  80421129b9:	66 85 c0             	test   %ax,%ax
  80421129bc:	74 4e                	je     8042112a0c <LZ4_compress_fast_extState_fastReset+0xc2>
        if (cctx->tableType != tableType
  80421129be:	66 83 f8 03          	cmp    $0x3,%ax
  80421129c2:	75 1a                	jne    80421129de <LZ4_compress_fast_extState_fastReset+0x94>
            || ((tableType == byU16) && cctx->currentOffset + (unsigned)inputSize >= 0xFFFFU)
  80421129c4:	44 89 e0             	mov    %r12d,%eax
  80421129c7:	41 03 87 00 40 00 00 	add    0x4000(%r15),%eax
            || inputSize >= 4 KB)
  80421129ce:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  80421129d3:	77 09                	ja     80421129de <LZ4_compress_fast_extState_fastReset+0x94>
  80421129d5:	41 81 fc ff 0f 00 00 	cmp    $0xfff,%r12d
  80421129dc:	7e 2e                	jle    8042112a0c <LZ4_compress_fast_extState_fastReset+0xc2>
            MEM_INIT(cctx->hashTable, 0, LZ4_HASHTABLESIZE);
  80421129de:	ba 00 40 00 00       	mov    $0x4000,%edx
  80421129e3:	be 00 00 00 00       	mov    $0x0,%esi
  80421129e8:	4c 89 ff             	mov    %r15,%rdi
  80421129eb:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  80421129f2:	00 00 00 
  80421129f5:	ff d0                	call   *%rax
            cctx->currentOffset = 0;
  80421129f7:	41 c7 87 00 40 00 00 	movl   $0x0,0x4000(%r15)
  80421129fe:	00 00 00 00 
            cctx->tableType = clearedTable;
  8042112a02:	66 41 c7 87 06 40 00 	movw   $0x0,0x4006(%r15)
  8042112a09:	00 00 00 
    cctx->dictCtx = NULL;
  8042112a0c:	49 c7 87 10 40 00 00 	movq   $0x0,0x4010(%r15)
  8042112a13:	00 00 00 00 
    cctx->dictionary = NULL;
  8042112a17:	49 c7 87 08 40 00 00 	movq   $0x0,0x4008(%r15)
  8042112a1e:	00 00 00 00 
    cctx->dictSize = 0;
  8042112a22:	41 c7 87 18 40 00 00 	movl   $0x0,0x4018(%r15)
  8042112a29:	00 00 00 00 
            if (ctx->currentOffset) {
  8042112a2d:	41 8b 97 00 40 00 00 	mov    0x4000(%r15),%edx
  8042112a34:	85 d2                	test   %edx,%edx
  8042112a36:	0f 84 e3 04 00 00    	je     8042112f1f <LZ4_compress_fast_extState_fastReset+0x5d5>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042112a3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042112a41:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042112a48:	0f 87 35 0e 00 00    	ja     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
            dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;
  8042112a4e:	41 8b 87 18 40 00 00 	mov    0x4018(%r15),%eax
    const BYTE* const iend = ip + inputSize;
  8042112a55:	49 63 cc             	movslq %r12d,%rcx
  8042112a58:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
  8042112a5c:	49 8d 34 0a          	lea    (%r10,%rcx,1),%rsi
  8042112a60:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042112a64:	42 8d 0c 20          	lea    (%rax,%r12,1),%ecx
  8042112a68:	41 89 8f 18 40 00 00 	mov    %ecx,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  8042112a6f:	42 8d 0c 22          	lea    (%rdx,%r12,1),%ecx
  8042112a73:	41 89 8f 00 40 00 00 	mov    %ecx,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042112a7a:	66 41 c7 87 06 40 00 	movw   $0x3,0x4006(%r15)
  8042112a81:	00 03 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  8042112a84:	41 83 fc 0c          	cmp    $0xc,%r12d
  8042112a88:	0f 8e fd 03 00 00    	jle    8042112e8b <LZ4_compress_fast_extState_fastReset+0x541>
    const BYTE* base = (const BYTE*) source - startIndex;
  8042112a8e:	89 d1                	mov    %edx,%ecx
  8042112a90:	4d 89 d4             	mov    %r10,%r12
  8042112a93:	49 29 cc             	sub    %rcx,%r12
    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
  8042112a96:	89 d1                	mov    %edx,%ecx
  8042112a98:	29 c1                	sub    %eax,%ecx
  8042112a9a:	89 4d 98             	mov    %ecx,-0x68(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042112a9d:	48 8d 46 f5          	lea    -0xb(%rsi),%rax
  8042112aa1:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042112aa5:	48 8d 46 fb          	lea    -0x5(%rsi),%rax
  8042112aa9:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112ab0:	41 69 02 b1 79 37 9e 	imul   $0x9e3779b1,(%r10),%eax
  8042112ab7:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042112aba:	89 c0                	mov    %eax,%eax
  8042112abc:	66 41 89 14 47       	mov    %dx,(%r15,%rax,2)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042112ac1:	4d 8d 6a 01          	lea    0x1(%r10),%r13
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112ac5:	41 69 42 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r10),%eax
  8042112acc:	9e 
  8042112acd:	c1 e8 13             	shr    $0x13,%eax
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042112ad0:	c1 e3 06             	shl    $0x6,%ebx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042112ad3:	8d 73 01             	lea    0x1(%rbx),%esi
  8042112ad6:	89 75 80             	mov    %esi,-0x80(%rbp)
  8042112ad9:	c1 fb 06             	sar    $0x6,%ebx
  8042112adc:	41 89 de             	mov    %ebx,%r14d
  8042112adf:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  8042112ae3:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
  8042112ae7:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
  8042112aeb:	4d 89 e7             	mov    %r12,%r15
  8042112aee:	45 89 f4             	mov    %r14d,%r12d
                U32 const current = (U32)(forwardIp - base);
  8042112af1:	4d 89 e8             	mov    %r13,%r8
  8042112af4:	4d 29 f8             	sub    %r15,%r8
        return hashTable[h];
  8042112af7:	89 c0                	mov    %eax,%eax
  8042112af9:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
  8042112afd:	49 8d 34 46          	lea    (%r14,%rax,2),%rsi
  8042112b01:	0f b7 1e             	movzwl (%rsi),%ebx
  8042112b04:	44 0f b7 cb          	movzwl %bx,%r9d
                forwardIp += step;
  8042112b08:	49 8d 4d 01          	lea    0x1(%r13),%rcx
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042112b0c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042112b10:	48 39 c8             	cmp    %rcx,%rax
  8042112b13:	0f 82 8d 03 00 00    	jb     8042112ea6 <LZ4_compress_fast_extState_fastReset+0x55c>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042112b19:	44 89 e2             	mov    %r12d,%edx
  8042112b1c:	8b 7d 80             	mov    -0x80(%rbp),%edi
  8042112b1f:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
  8042112b23:	49 89 c2             	mov    %rax,%r10
  8042112b26:	44 89 65 90          	mov    %r12d,-0x70(%rbp)
  8042112b2a:	44 8b 65 98          	mov    -0x68(%rbp),%r12d
  8042112b2e:	eb 52                	jmp    8042112b82 <LZ4_compress_fast_extState_fastReset+0x238>
        MEM_INIT(cctx, 0, sizeof(LZ4_stream_t_internal));
  8042112b30:	ba 20 40 00 00       	mov    $0x4020,%edx
  8042112b35:	be 00 00 00 00       	mov    $0x0,%esi
  8042112b3a:	4c 89 ff             	mov    %r15,%rdi
  8042112b3d:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042112b44:	00 00 00 
  8042112b47:	ff d0                	call   *%rax
        return;
  8042112b49:	e9 df fe ff ff       	jmp    8042112a2d <LZ4_compress_fast_extState_fastReset+0xe3>
                U32 const current = (U32)(forwardIp - base);
  8042112b4e:	49 89 c8             	mov    %rcx,%r8
  8042112b51:	4d 29 f8             	sub    %r15,%r8
        return hashTable[h];
  8042112b54:	89 c0                	mov    %eax,%eax
  8042112b56:	49 8d 34 46          	lea    (%r14,%rax,2),%rsi
  8042112b5a:	0f b7 1e             	movzwl (%rsi),%ebx
  8042112b5d:	44 0f b7 cb          	movzwl %bx,%r9d
                forwardIp += step;
  8042112b61:	48 63 c2             	movslq %edx,%rax
  8042112b64:	48 01 c8             	add    %rcx,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042112b67:	44 8d 5f 01          	lea    0x1(%rdi),%r11d
  8042112b6b:	c1 ff 06             	sar    $0x6,%edi
  8042112b6e:	89 fa                	mov    %edi,%edx
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042112b70:	49 89 cd             	mov    %rcx,%r13
  8042112b73:	49 39 c2             	cmp    %rax,%r10
  8042112b76:	0f 82 26 03 00 00    	jb     8042112ea2 <LZ4_compress_fast_extState_fastReset+0x558>
  8042112b7c:	44 89 df             	mov    %r11d,%edi
  8042112b7f:	48 89 c1             	mov    %rax,%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112b82:	69 01 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%eax
  8042112b88:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042112b8b:	66 44 89 06          	mov    %r8w,(%rsi)
                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */
  8042112b8f:	45 39 e1             	cmp    %r12d,%r9d
  8042112b92:	72 ba                	jb     8042112b4e <LZ4_compress_fast_extState_fastReset+0x204>
                    match = base + matchIndex;
  8042112b94:	0f b7 db             	movzwl %bx,%ebx
  8042112b97:	4c 01 fb             	add    %r15,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042112b9a:	8b 33                	mov    (%rbx),%esi
  8042112b9c:	41 39 75 00          	cmp    %esi,0x0(%r13)
  8042112ba0:	75 ac                	jne    8042112b4e <LZ4_compress_fast_extState_fastReset+0x204>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042112ba2:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
  8042112ba6:	44 8b 65 90          	mov    -0x70(%rbp),%r12d
  8042112baa:	4d 39 ea             	cmp    %r13,%r10
  8042112bad:	73 10                	jae    8042112bbf <LZ4_compress_fast_extState_fastReset+0x275>
  8042112baf:	48 39 5d c0          	cmp    %rbx,-0x40(%rbp)
  8042112bb3:	73 0a                	jae    8042112bbf <LZ4_compress_fast_extState_fastReset+0x275>
  8042112bb5:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042112bb9:	41 38 45 ff          	cmp    %al,-0x1(%r13)
  8042112bbd:	74 72                	je     8042112c31 <LZ4_compress_fast_extState_fastReset+0x2e7>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042112bbf:	4c 89 ea             	mov    %r13,%rdx
  8042112bc2:	4c 29 d2             	sub    %r10,%rdx
            token = op++;
  8042112bc5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042112bc9:	48 8d 78 01          	lea    0x1(%rax),%rdi
            if (litLength >= RUN_MASK) {
  8042112bcd:	83 fa 0e             	cmp    $0xe,%edx
  8042112bd0:	77 7b                	ja     8042112c4d <LZ4_compress_fast_extState_fastReset+0x303>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042112bd2:	89 d0                	mov    %edx,%eax
  8042112bd4:	c1 e0 04             	shl    $0x4,%eax
  8042112bd7:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8042112bdb:	88 01                	mov    %al,(%rcx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042112bdd:	89 d2                	mov    %edx,%edx
  8042112bdf:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
  8042112be3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8042112be7:	48 89 c2             	mov    %rax,%rdx
  8042112bea:	4c 89 d6             	mov    %r10,%rsi
  8042112bed:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042112bf4:	00 00 00 
  8042112bf7:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042112bf9:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8042112bfd:	48 8d 70 f4          	lea    -0xc(%rax),%rsi
  8042112c01:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042112c05:	48 8d 70 f8          	lea    -0x8(%rax),%rsi
  8042112c09:	48 89 b5 70 ff ff ff 	mov    %rsi,-0x90(%rbp)
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042112c10:	48 83 e8 06          	sub    $0x6,%rax
  8042112c14:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
                op += matchCode / 255;
  8042112c1b:	48 89 d8             	mov    %rbx,%rax
  8042112c1e:	4c 89 fb             	mov    %r15,%rbx
  8042112c21:	4c 8b 7d b0          	mov    -0x50(%rbp),%r15
  8042112c25:	44 89 a5 64 ff ff ff 	mov    %r12d,-0x9c(%rbp)
  8042112c2c:	e9 e8 00 00 00       	jmp    8042112d19 <LZ4_compress_fast_extState_fastReset+0x3cf>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042112c31:	49 83 ed 01          	sub    $0x1,%r13
  8042112c35:	48 83 eb 01          	sub    $0x1,%rbx
  8042112c39:	4d 39 ea             	cmp    %r13,%r10
  8042112c3c:	73 81                	jae    8042112bbf <LZ4_compress_fast_extState_fastReset+0x275>
  8042112c3e:	48 39 5d c0          	cmp    %rbx,-0x40(%rbp)
  8042112c42:	0f 82 6d ff ff ff    	jb     8042112bb5 <LZ4_compress_fast_extState_fastReset+0x26b>
  8042112c48:	e9 72 ff ff ff       	jmp    8042112bbf <LZ4_compress_fast_extState_fastReset+0x275>
                int len = (int)(litLength - RUN_MASK);
  8042112c4d:	8d 42 f1             	lea    -0xf(%rdx),%eax
                *token = (RUN_MASK<<ML_BITS);
  8042112c50:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8042112c54:	c6 01 f0             	movb   $0xf0,(%rcx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042112c57:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042112c5c:	7e 14                	jle    8042112c72 <LZ4_compress_fast_extState_fastReset+0x328>
  8042112c5e:	48 83 c7 01          	add    $0x1,%rdi
  8042112c62:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042112c66:	2d ff 00 00 00       	sub    $0xff,%eax
  8042112c6b:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042112c70:	7f ec                	jg     8042112c5e <LZ4_compress_fast_extState_fastReset+0x314>
                *op++ = (BYTE)len;
  8042112c72:	88 07                	mov    %al,(%rdi)
  8042112c74:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042112c78:	e9 60 ff ff ff       	jmp    8042112bdd <LZ4_compress_fast_extState_fastReset+0x293>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042112c7d:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042112c80:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042112c87:	00 00 00 
  8042112c8a:	ff d0                	call   *%rax
  8042112c8c:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042112c8f:	44 89 e0             	mov    %r12d,%eax
  8042112c92:	4d 8d 6c 05 04       	lea    0x4(%r13,%rax,1),%r13
            if (matchCode >= ML_MASK) {
  8042112c97:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042112c9b:	0f 87 63 01 00 00    	ja     8042112e04 <LZ4_compress_fast_extState_fastReset+0x4ba>
                *token += (BYTE)(matchCode);
  8042112ca1:	45 00 27             	add    %r12b,(%r15)
  8042112ca4:	4d 89 f7             	mov    %r14,%r15
        if (ip >= mflimitPlusOne) break;
  8042112ca7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042112cab:	49 39 c5             	cmp    %rax,%r13
  8042112cae:	0f 83 e5 01 00 00    	jae    8042112e99 <LZ4_compress_fast_extState_fastReset+0x54f>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112cb4:	41 69 45 fe b1 79 37 	imul   $0x9e3779b1,-0x2(%r13),%eax
  8042112cbb:	9e 
  8042112cbc:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042112cbf:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042112cc1:	49 8d 55 fe          	lea    -0x2(%r13),%rdx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042112cc5:	48 29 da             	sub    %rbx,%rdx
  8042112cc8:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8042112ccc:	66 89 14 41          	mov    %dx,(%rcx,%rax,2)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112cd0:	41 69 45 00 b1 79 37 	imul   $0x9e3779b1,0x0(%r13),%eax
  8042112cd7:	9e 
  8042112cd8:	c1 e8 13             	shr    $0x13,%eax
        return hashTable[h];
  8042112cdb:	89 c0                	mov    %eax,%eax
  8042112cdd:	48 8d 0c 41          	lea    (%rcx,%rax,2),%rcx
  8042112ce1:	0f b7 11             	movzwl (%rcx),%edx
                match = base + matchIndex;
  8042112ce4:	0f b7 c2             	movzwl %dx,%eax
  8042112ce7:	48 01 d8             	add    %rbx,%rax
            U32 const current = (U32)(ip-base);
  8042112cea:	4c 89 ee             	mov    %r13,%rsi
  8042112ced:	48 29 de             	sub    %rbx,%rsi
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042112cf0:	66 89 31             	mov    %si,(%rcx)
        return hashTable[h];
  8042112cf3:	0f b7 d2             	movzwl %dx,%edx
            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)
  8042112cf6:	8b 75 98             	mov    -0x68(%rbp),%esi
  8042112cf9:	39 f2                	cmp    %esi,%edx
  8042112cfb:	0f 82 65 01 00 00    	jb     8042112e66 <LZ4_compress_fast_extState_fastReset+0x51c>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042112d01:	8b 30                	mov    (%rax),%esi
  8042112d03:	41 39 75 00          	cmp    %esi,0x0(%r13)
  8042112d07:	0f 85 59 01 00 00    	jne    8042112e66 <LZ4_compress_fast_extState_fastReset+0x51c>
                token=op++;
  8042112d0d:	49 8d 7f 01          	lea    0x1(%r15),%rdi
  8042112d11:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
                *token=0;
  8042112d15:	41 c6 07 00          	movb   $0x0,(%r15)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042112d19:	4c 89 ea             	mov    %r13,%rdx
  8042112d1c:	48 29 c2             	sub    %rax,%rdx
  8042112d1f:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042112d23:	66 89 11             	mov    %dx,(%rcx)
  8042112d26:	4c 8d 71 02          	lea    0x2(%rcx),%r14
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042112d2a:	49 8d 75 04          	lea    0x4(%r13),%rsi
  8042112d2e:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042112d32:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042112d36:	48 39 ce             	cmp    %rcx,%rsi
  8042112d39:	73 5b                	jae    8042112d96 <LZ4_compress_fast_extState_fastReset+0x44c>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042112d3b:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042112d3f:	49 8b 7d 04          	mov    0x4(%r13),%rdi
        if (!diff) {
  8042112d43:	48 39 d7             	cmp    %rdx,%rdi
  8042112d46:	0f 85 31 ff ff ff    	jne    8042112c7d <LZ4_compress_fast_extState_fastReset+0x333>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042112d4c:	4d 8d 65 0c          	lea    0xc(%r13),%r12
  8042112d50:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042112d54:	49 39 cc             	cmp    %rcx,%r12
  8042112d57:	73 45                	jae    8042112d9e <LZ4_compress_fast_extState_fastReset+0x454>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042112d59:	48 8b 10             	mov    (%rax),%rdx
  8042112d5c:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042112d60:	48 39 d7             	cmp    %rdx,%rdi
  8042112d63:	74 1e                	je     8042112d83 <LZ4_compress_fast_extState_fastReset+0x439>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042112d65:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042112d68:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042112d6f:	00 00 00 
  8042112d72:	ff d0                	call   *%rax
  8042112d74:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  8042112d78:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042112d7b:	41 29 c4             	sub    %eax,%r12d
  8042112d7e:	e9 0c ff ff ff       	jmp    8042112c8f <LZ4_compress_fast_extState_fastReset+0x345>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042112d83:	49 83 c4 08          	add    $0x8,%r12
  8042112d87:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042112d8b:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  8042112d8f:	49 39 fc             	cmp    %rdi,%r12
  8042112d92:	72 c5                	jb     8042112d59 <LZ4_compress_fast_extState_fastReset+0x40f>
  8042112d94:	eb 08                	jmp    8042112d9e <LZ4_compress_fast_extState_fastReset+0x454>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042112d96:	48 83 c0 04          	add    $0x4,%rax
  8042112d9a:	4c 8b 65 b0          	mov    -0x50(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042112d9e:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
  8042112da5:	49 39 f4             	cmp    %rsi,%r12
  8042112da8:	73 08                	jae    8042112db2 <LZ4_compress_fast_extState_fastReset+0x468>
  8042112daa:	8b 30                	mov    (%rax),%esi
  8042112dac:	41 39 34 24          	cmp    %esi,(%r12)
  8042112db0:	74 3e                	je     8042112df0 <LZ4_compress_fast_extState_fastReset+0x4a6>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042112db2:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
  8042112db9:	49 39 fc             	cmp    %rdi,%r12
  8042112dbc:	73 0a                	jae    8042112dc8 <LZ4_compress_fast_extState_fastReset+0x47e>
  8042112dbe:	0f b7 30             	movzwl (%rax),%esi
  8042112dc1:	66 41 39 34 24       	cmp    %si,(%r12)
  8042112dc6:	74 32                	je     8042112dfa <LZ4_compress_fast_extState_fastReset+0x4b0>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042112dc8:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
  8042112dcf:	49 39 cc             	cmp    %rcx,%r12
  8042112dd2:	73 11                	jae    8042112de5 <LZ4_compress_fast_extState_fastReset+0x49b>
  8042112dd4:	41 0f b6 34 24       	movzbl (%r12),%esi
  8042112dd9:	40 38 30             	cmp    %sil,(%rax)
  8042112ddc:	0f 94 c0             	sete   %al
  8042112ddf:	0f b6 c0             	movzbl %al,%eax
  8042112de2:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  8042112de5:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042112de8:	41 29 c4             	sub    %eax,%r12d
  8042112deb:	e9 9f fe ff ff       	jmp    8042112c8f <LZ4_compress_fast_extState_fastReset+0x345>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042112df0:	49 83 c4 04          	add    $0x4,%r12
  8042112df4:	48 83 c0 04          	add    $0x4,%rax
  8042112df8:	eb b8                	jmp    8042112db2 <LZ4_compress_fast_extState_fastReset+0x468>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042112dfa:	49 83 c4 02          	add    $0x2,%r12
  8042112dfe:	48 83 c0 02          	add    $0x2,%rax
  8042112e02:	eb c4                	jmp    8042112dc8 <LZ4_compress_fast_extState_fastReset+0x47e>
                *token += ML_MASK;
  8042112e04:	41 80 07 0f          	addb   $0xf,(%r15)
                matchCode -= ML_MASK;
  8042112e08:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042112e0c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042112e10:	c7 40 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rax)
                while (matchCode >= 4*255) {
  8042112e17:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042112e1e:	76 1b                	jbe    8042112e3b <LZ4_compress_fast_extState_fastReset+0x4f1>
                    op+=4;
  8042112e20:	49 83 c6 04          	add    $0x4,%r14
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042112e24:	41 c7 06 ff ff ff ff 	movl   $0xffffffff,(%r14)
                    matchCode -= 4*255;
  8042112e2b:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  8042112e32:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042112e39:	77 e5                	ja     8042112e20 <LZ4_compress_fast_extState_fastReset+0x4d6>
                op += matchCode / 255;
  8042112e3b:	44 89 e0             	mov    %r12d,%eax
  8042112e3e:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042112e43:	48 0f af c6          	imul   %rsi,%rax
  8042112e47:	48 c1 e8 27          	shr    $0x27,%rax
  8042112e4b:	89 c2                	mov    %eax,%edx
  8042112e4d:	4c 01 f2             	add    %r14,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042112e50:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
  8042112e54:	89 c1                	mov    %eax,%ecx
  8042112e56:	c1 e1 08             	shl    $0x8,%ecx
  8042112e59:	29 c1                	sub    %eax,%ecx
  8042112e5b:	41 29 cc             	sub    %ecx,%r12d
  8042112e5e:	44 88 22             	mov    %r12b,(%rdx)
  8042112e61:	e9 41 fe ff ff       	jmp    8042112ca7 <LZ4_compress_fast_extState_fastReset+0x35d>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112e66:	4c 89 7d b0          	mov    %r15,-0x50(%rbp)
  8042112e6a:	49 89 df             	mov    %rbx,%r15
  8042112e6d:	44 8b a5 64 ff ff ff 	mov    -0x9c(%rbp),%r12d
  8042112e74:	41 69 45 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r13),%eax
  8042112e7b:	9e 
  8042112e7c:	c1 e8 13             	shr    $0x13,%eax
  8042112e7f:	4d 89 ea             	mov    %r13,%r10
  8042112e82:	4d 8d 6d 01          	lea    0x1(%r13),%r13
  8042112e86:	e9 66 fc ff ff       	jmp    8042112af1 <LZ4_compress_fast_extState_fastReset+0x1a7>
    BYTE* op = (BYTE*) dest;
  8042112e8b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042112e8f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  8042112e93:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
  8042112e97:	eb 0d                	jmp    8042112ea6 <LZ4_compress_fast_extState_fastReset+0x55c>
        anchor = ip;
  8042112e99:	4c 89 7d b0          	mov    %r15,-0x50(%rbp)
  8042112e9d:	4d 89 ea             	mov    %r13,%r10
  8042112ea0:	eb 04                	jmp    8042112ea6 <LZ4_compress_fast_extState_fastReset+0x55c>
  8042112ea2:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    {   size_t lastRun = (size_t)(iend - anchor);
  8042112ea6:	4c 8b 65 88          	mov    -0x78(%rbp),%r12
  8042112eaa:	4d 29 d4             	sub    %r10,%r12
        if (lastRun >= RUN_MASK) {
  8042112ead:	49 83 fc 0e          	cmp    $0xe,%r12
  8042112eb1:	76 5a                	jbe    8042112f0d <LZ4_compress_fast_extState_fastReset+0x5c3>
            size_t accumulator = lastRun - RUN_MASK;
  8042112eb3:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042112eb8:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
  8042112ebc:	48 8d 43 01          	lea    0x1(%rbx),%rax
  8042112ec0:	c6 03 f0             	movb   $0xf0,(%rbx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042112ec3:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042112eca:	76 18                	jbe    8042112ee4 <LZ4_compress_fast_extState_fastReset+0x59a>
  8042112ecc:	48 83 c0 01          	add    $0x1,%rax
  8042112ed0:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042112ed4:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042112edb:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042112ee2:	77 e8                	ja     8042112ecc <LZ4_compress_fast_extState_fastReset+0x582>
            *op++ = (BYTE) accumulator;
  8042112ee4:	48 8d 58 01          	lea    0x1(%rax),%rbx
  8042112ee8:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042112eea:	4c 89 e2             	mov    %r12,%rdx
  8042112eed:	4c 89 d6             	mov    %r10,%rsi
  8042112ef0:	48 89 df             	mov    %rbx,%rdi
  8042112ef3:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042112efa:	00 00 00 
  8042112efd:	ff d0                	call   *%rax
        op += lastRun;
  8042112eff:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
    result = (int)(((char*)op) - dest);
  8042112f03:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  8042112f06:	29 d8                	sub    %ebx,%eax
    return result;
  8042112f08:	e9 76 09 00 00       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042112f0d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042112f11:	48 8d 5e 01          	lea    0x1(%rsi),%rbx
  8042112f15:	44 89 e0             	mov    %r12d,%eax
  8042112f18:	c1 e0 04             	shl    $0x4,%eax
  8042112f1b:	88 06                	mov    %al,(%rsi)
  8042112f1d:	eb cb                	jmp    8042112eea <LZ4_compress_fast_extState_fastReset+0x5a0>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042112f1f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042112f24:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042112f2b:	0f 87 52 09 00 00    	ja     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
    const BYTE* const iend = ip + inputSize;
  8042112f31:	49 63 c4             	movslq %r12d,%rax
  8042112f34:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8042112f38:	48 01 c8             	add    %rcx,%rax
  8042112f3b:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042112f3f:	45 01 a7 18 40 00 00 	add    %r12d,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  8042112f46:	45 89 a7 00 40 00 00 	mov    %r12d,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042112f4d:	66 41 c7 87 06 40 00 	movw   $0x3,0x4006(%r15)
  8042112f54:	00 03 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  8042112f57:	41 83 fc 0c          	cmp    $0xc,%r12d
  8042112f5b:	0f 8e 5a 03 00 00    	jle    80421132bb <LZ4_compress_fast_extState_fastReset+0x971>
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042112f61:	48 8d 78 f5          	lea    -0xb(%rax),%rdi
  8042112f65:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042112f69:	48 83 e8 05          	sub    $0x5,%rax
  8042112f6d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112f71:	69 01 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%eax
  8042112f77:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042112f7a:	89 c0                	mov    %eax,%eax
  8042112f7c:	66 41 c7 04 47 00 00 	movw   $0x0,(%r15,%rax,2)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042112f83:	48 89 c8             	mov    %rcx,%rax
  8042112f86:	48 8d 49 01          	lea    0x1(%rcx),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112f8a:	69 50 01 b1 79 37 9e 	imul   $0x9e3779b1,0x1(%rax),%edx
  8042112f91:	c1 ea 13             	shr    $0x13,%edx
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042112f94:	c1 e3 06             	shl    $0x6,%ebx
  8042112f97:	41 89 dd             	mov    %ebx,%r13d
  8042112f9a:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  8042112f9e:	48 89 5d 98          	mov    %rbx,-0x68(%rbp)
  8042112fa2:	49 89 c6             	mov    %rax,%r14
            int step = 1;
  8042112fa5:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
  8042112fa9:	49 89 c7             	mov    %rax,%r15
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042112fac:	44 89 ee             	mov    %r13d,%esi
            int step = 1;
  8042112faf:	b8 01 00 00 00       	mov    $0x1,%eax
  8042112fb4:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
  8042112fb8:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
                U32 const current = (U32)(forwardIp - base);
  8042112fbc:	49 89 c8             	mov    %rcx,%r8
  8042112fbf:	4d 29 f8             	sub    %r15,%r8
        return hashTable[h];
  8042112fc2:	89 d2                	mov    %edx,%edx
  8042112fc4:	49 8d 3c 52          	lea    (%r10,%rdx,2),%rdi
  8042112fc8:	0f b7 17             	movzwl (%rdi),%edx
                forwardIp += step;
  8042112fcb:	48 89 cb             	mov    %rcx,%rbx
  8042112fce:	48 98                	cltq
  8042112fd0:	48 01 c1             	add    %rax,%rcx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042112fd3:	89 f0                	mov    %esi,%eax
  8042112fd5:	83 c6 01             	add    $0x1,%esi
  8042112fd8:	c1 f8 06             	sar    $0x6,%eax
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042112fdb:	49 39 c9             	cmp    %rcx,%r9
  8042112fde:	0f 82 e3 02 00 00    	jb     80421132c7 <LZ4_compress_fast_extState_fastReset+0x97d>
                    match = base + matchIndex;
  8042112fe4:	0f b7 d2             	movzwl %dx,%edx
  8042112fe7:	4d 8d 24 17          	lea    (%r15,%rdx,1),%r12
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042112feb:	69 11 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%edx
  8042112ff1:	c1 ea 13             	shr    $0x13,%edx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042112ff4:	66 44 89 07          	mov    %r8w,(%rdi)
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042112ff8:	41 8b 3c 24          	mov    (%r12),%edi
  8042112ffc:	39 3b                	cmp    %edi,(%rbx)
  8042112ffe:	75 bc                	jne    8042112fbc <LZ4_compress_fast_extState_fastReset+0x672>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042113000:	4d 39 e7             	cmp    %r12,%r15
  8042113003:	73 10                	jae    8042113015 <LZ4_compress_fast_extState_fastReset+0x6cb>
  8042113005:	49 39 de             	cmp    %rbx,%r14
  8042113008:	73 0b                	jae    8042113015 <LZ4_compress_fast_extState_fastReset+0x6cb>
  804211300a:	41 0f b6 44 24 ff    	movzbl -0x1(%r12),%eax
  8042113010:	38 43 ff             	cmp    %al,-0x1(%rbx)
  8042113013:	74 7b                	je     8042113090 <LZ4_compress_fast_extState_fastReset+0x746>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042113015:	48 89 da             	mov    %rbx,%rdx
  8042113018:	4c 29 f2             	sub    %r14,%rdx
            token = op++;
  804211301b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211301f:	48 8d 78 01          	lea    0x1(%rax),%rdi
            if (litLength >= RUN_MASK) {
  8042113023:	83 fa 0e             	cmp    $0xe,%edx
  8042113026:	0f 87 83 00 00 00    	ja     80421130af <LZ4_compress_fast_extState_fastReset+0x765>
            else *token = (BYTE)(litLength<<ML_BITS);
  804211302c:	89 d0                	mov    %edx,%eax
  804211302e:	c1 e0 04             	shl    $0x4,%eax
  8042113031:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042113035:	88 06                	mov    %al,(%rsi)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042113037:	89 d2                	mov    %edx,%edx
  8042113039:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
  804211303d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042113041:	48 89 c2             	mov    %rax,%rdx
  8042113044:	4c 89 f6             	mov    %r14,%rsi
  8042113047:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211304e:	00 00 00 
  8042113051:	ff d0                	call   *%rax
  8042113053:	49 89 de             	mov    %rbx,%r14
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042113056:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211305a:	48 8d 58 f4          	lea    -0xc(%rax),%rbx
  804211305e:	48 89 5d b8          	mov    %rbx,-0x48(%rbp)
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042113062:	48 8d 58 f8          	lea    -0x8(%rax),%rbx
  8042113066:	48 89 5d 80          	mov    %rbx,-0x80(%rbp)
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211306a:	48 83 e8 06          	sub    $0x6,%rax
  804211306e:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                op += matchCode / 255;
  8042113075:	44 89 ad 70 ff ff ff 	mov    %r13d,-0x90(%rbp)
  804211307c:	4c 89 e0             	mov    %r12,%rax
  804211307f:	4c 8b 65 c0          	mov    -0x40(%rbp),%r12
  8042113083:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
  8042113087:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
  804211308b:	e9 d5 00 00 00       	jmp    8042113165 <LZ4_compress_fast_extState_fastReset+0x81b>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042113090:	48 83 eb 01          	sub    $0x1,%rbx
  8042113094:	49 83 ec 01          	sub    $0x1,%r12
  8042113098:	49 39 de             	cmp    %rbx,%r14
  804211309b:	0f 83 74 ff ff ff    	jae    8042113015 <LZ4_compress_fast_extState_fastReset+0x6cb>
  80421130a1:	4d 39 e7             	cmp    %r12,%r15
  80421130a4:	0f 82 60 ff ff ff    	jb     804211300a <LZ4_compress_fast_extState_fastReset+0x6c0>
  80421130aa:	e9 66 ff ff ff       	jmp    8042113015 <LZ4_compress_fast_extState_fastReset+0x6cb>
                int len = (int)(litLength - RUN_MASK);
  80421130af:	8d 42 f1             	lea    -0xf(%rdx),%eax
                *token = (RUN_MASK<<ML_BITS);
  80421130b2:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  80421130b6:	c6 06 f0             	movb   $0xf0,(%rsi)
                for(; len >= 255 ; len-=255) *op++ = 255;
  80421130b9:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421130be:	7e 14                	jle    80421130d4 <LZ4_compress_fast_extState_fastReset+0x78a>
  80421130c0:	48 83 c7 01          	add    $0x1,%rdi
  80421130c4:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  80421130c8:	2d ff 00 00 00       	sub    $0xff,%eax
  80421130cd:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421130d2:	7f ec                	jg     80421130c0 <LZ4_compress_fast_extState_fastReset+0x776>
                *op++ = (BYTE)len;
  80421130d4:	88 07                	mov    %al,(%rdi)
  80421130d6:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  80421130da:	e9 58 ff ff ff       	jmp    8042113037 <LZ4_compress_fast_extState_fastReset+0x6ed>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421130df:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  80421130e2:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421130e9:	00 00 00 
  80421130ec:	ff d0                	call   *%rax
  80421130ee:	89 c3                	mov    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  80421130f0:	89 d8                	mov    %ebx,%eax
  80421130f2:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
            if (matchCode >= ML_MASK) {
  80421130f7:	83 fb 0e             	cmp    $0xe,%ebx
  80421130fa:	0f 87 3e 01 00 00    	ja     804211323e <LZ4_compress_fast_extState_fastReset+0x8f4>
                *token += (BYTE)(matchCode);
  8042113100:	41 00 1f             	add    %bl,(%r15)
  8042113103:	4d 89 ef             	mov    %r13,%r15
        if (ip >= mflimitPlusOne) break;
  8042113106:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211310a:	49 39 c6             	cmp    %rax,%r14
  804211310d:	0f 83 1b 02 00 00    	jae    804211332e <LZ4_compress_fast_extState_fastReset+0x9e4>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113113:	41 69 46 fe b1 79 37 	imul   $0x9e3779b1,-0x2(%r14),%eax
  804211311a:	9e 
  804211311b:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  804211311e:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042113120:	49 8d 56 fe          	lea    -0x2(%r14),%rdx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042113124:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8042113128:	48 29 f2             	sub    %rsi,%rdx
  804211312b:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  804211312f:	66 89 14 41          	mov    %dx,(%rcx,%rax,2)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113133:	41 69 06 b1 79 37 9e 	imul   $0x9e3779b1,(%r14),%eax
  804211313a:	c1 e8 13             	shr    $0x13,%eax
        return hashTable[h];
  804211313d:	89 c0                	mov    %eax,%eax
  804211313f:	48 8d 14 41          	lea    (%rcx,%rax,2),%rdx
                match = base + matchIndex;
  8042113143:	0f b7 02             	movzwl (%rdx),%eax
  8042113146:	48 01 f0             	add    %rsi,%rax
            U32 const current = (U32)(ip-base);
  8042113149:	4c 89 f1             	mov    %r14,%rcx
  804211314c:	48 29 f1             	sub    %rsi,%rcx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  804211314f:	66 89 0a             	mov    %cx,(%rdx)
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042113152:	8b 30                	mov    (%rax),%esi
  8042113154:	41 39 36             	cmp    %esi,(%r14)
  8042113157:	0f 85 3b 01 00 00    	jne    8042113298 <LZ4_compress_fast_extState_fastReset+0x94e>
                token=op++;
  804211315d:	4d 8d 67 01          	lea    0x1(%r15),%r12
                *token=0;
  8042113161:	41 c6 07 00          	movb   $0x0,(%r15)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042113165:	4c 89 f2             	mov    %r14,%rdx
  8042113168:	48 29 c2             	sub    %rax,%rdx
  804211316b:	66 41 89 14 24       	mov    %dx,(%r12)
  8042113170:	4d 8d 6c 24 02       	lea    0x2(%r12),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042113175:	49 8d 4e 04          	lea    0x4(%r14),%rcx
  8042113179:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211317d:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042113181:	48 39 f1             	cmp    %rsi,%rcx
  8042113184:	73 58                	jae    80421131de <LZ4_compress_fast_extState_fastReset+0x894>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042113186:	48 8b 50 04          	mov    0x4(%rax),%rdx
  804211318a:	49 8b 7e 04          	mov    0x4(%r14),%rdi
        if (!diff) {
  804211318e:	48 39 d7             	cmp    %rdx,%rdi
  8042113191:	0f 85 48 ff ff ff    	jne    80421130df <LZ4_compress_fast_extState_fastReset+0x795>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042113197:	49 8d 5e 0c          	lea    0xc(%r14),%rbx
  804211319b:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211319f:	48 39 f3             	cmp    %rsi,%rbx
  80421131a2:	73 42                	jae    80421131e6 <LZ4_compress_fast_extState_fastReset+0x89c>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421131a4:	48 8b 10             	mov    (%rax),%rdx
  80421131a7:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421131aa:	48 39 d7             	cmp    %rdx,%rdi
  80421131ad:	74 1c                	je     80421131cb <LZ4_compress_fast_extState_fastReset+0x881>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421131af:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  80421131b2:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421131b9:	00 00 00 
  80421131bc:	ff d0                	call   *%rax
  80421131be:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  80421131c1:	8b 45 c0             	mov    -0x40(%rbp),%eax
  80421131c4:	29 c3                	sub    %eax,%ebx
  80421131c6:	e9 25 ff ff ff       	jmp    80421130f0 <LZ4_compress_fast_extState_fastReset+0x7a6>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421131cb:	48 83 c3 08          	add    $0x8,%rbx
  80421131cf:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421131d3:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80421131d7:	48 39 fb             	cmp    %rdi,%rbx
  80421131da:	72 c8                	jb     80421131a4 <LZ4_compress_fast_extState_fastReset+0x85a>
  80421131dc:	eb 08                	jmp    80421131e6 <LZ4_compress_fast_extState_fastReset+0x89c>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  80421131de:	48 83 c0 04          	add    $0x4,%rax
  80421131e2:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421131e6:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  80421131ea:	48 39 f3             	cmp    %rsi,%rbx
  80421131ed:	73 06                	jae    80421131f5 <LZ4_compress_fast_extState_fastReset+0x8ab>
  80421131ef:	8b 30                	mov    (%rax),%esi
  80421131f1:	39 33                	cmp    %esi,(%rbx)
  80421131f3:	74 35                	je     804211322a <LZ4_compress_fast_extState_fastReset+0x8e0>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421131f5:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
  80421131fc:	48 39 cb             	cmp    %rcx,%rbx
  80421131ff:	73 08                	jae    8042113209 <LZ4_compress_fast_extState_fastReset+0x8bf>
  8042113201:	0f b7 38             	movzwl (%rax),%edi
  8042113204:	66 39 3b             	cmp    %di,(%rbx)
  8042113207:	74 2b                	je     8042113234 <LZ4_compress_fast_extState_fastReset+0x8ea>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042113209:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  804211320d:	48 39 fb             	cmp    %rdi,%rbx
  8042113210:	73 0e                	jae    8042113220 <LZ4_compress_fast_extState_fastReset+0x8d6>
  8042113212:	0f b6 0b             	movzbl (%rbx),%ecx
  8042113215:	38 08                	cmp    %cl,(%rax)
  8042113217:	0f 94 c0             	sete   %al
  804211321a:	0f b6 c0             	movzbl %al,%eax
  804211321d:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  8042113220:	8b 45 c0             	mov    -0x40(%rbp),%eax
  8042113223:	29 c3                	sub    %eax,%ebx
  8042113225:	e9 c6 fe ff ff       	jmp    80421130f0 <LZ4_compress_fast_extState_fastReset+0x7a6>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211322a:	48 83 c3 04          	add    $0x4,%rbx
  804211322e:	48 83 c0 04          	add    $0x4,%rax
  8042113232:	eb c1                	jmp    80421131f5 <LZ4_compress_fast_extState_fastReset+0x8ab>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042113234:	48 83 c3 02          	add    $0x2,%rbx
  8042113238:	48 83 c0 02          	add    $0x2,%rax
  804211323c:	eb cb                	jmp    8042113209 <LZ4_compress_fast_extState_fastReset+0x8bf>
                *token += ML_MASK;
  804211323e:	41 80 07 0f          	addb   $0xf,(%r15)
                matchCode -= ML_MASK;
  8042113242:	83 eb 0f             	sub    $0xf,%ebx
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042113245:	41 c7 44 24 02 ff ff 	movl   $0xffffffff,0x2(%r12)
  804211324c:	ff ff 
                while (matchCode >= 4*255) {
  804211324e:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  8042113254:	76 1a                	jbe    8042113270 <LZ4_compress_fast_extState_fastReset+0x926>
                    op+=4;
  8042113256:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211325a:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  8042113261:	ff 
                    matchCode -= 4*255;
  8042113262:	81 eb fc 03 00 00    	sub    $0x3fc,%ebx
                while (matchCode >= 4*255) {
  8042113268:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  804211326e:	77 e6                	ja     8042113256 <LZ4_compress_fast_extState_fastReset+0x90c>
                op += matchCode / 255;
  8042113270:	89 d8                	mov    %ebx,%eax
  8042113272:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042113277:	48 0f af c6          	imul   %rsi,%rax
  804211327b:	48 c1 e8 27          	shr    $0x27,%rax
  804211327f:	89 c2                	mov    %eax,%edx
  8042113281:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042113284:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
  8042113288:	89 c1                	mov    %eax,%ecx
  804211328a:	c1 e1 08             	shl    $0x8,%ecx
  804211328d:	29 c1                	sub    %eax,%ecx
  804211328f:	29 cb                	sub    %ecx,%ebx
  8042113291:	88 1a                	mov    %bl,(%rdx)
  8042113293:	e9 6e fe ff ff       	jmp    8042113106 <LZ4_compress_fast_extState_fastReset+0x7bc>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042113298:	44 8b ad 70 ff ff ff 	mov    -0x90(%rbp),%r13d
  804211329f:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  80421132a3:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
  80421132a7:	49 8d 4e 01          	lea    0x1(%r14),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421132ab:	41 69 56 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r14),%edx
  80421132b2:	9e 
  80421132b3:	c1 ea 13             	shr    $0x13,%edx
  80421132b6:	e9 f1 fc ff ff       	jmp    8042112fac <LZ4_compress_fast_extState_fastReset+0x662>
    BYTE* op = (BYTE*) dest;
  80421132bb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421132bf:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  80421132c3:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
    {   size_t lastRun = (size_t)(iend - anchor);
  80421132c7:	4c 8b 65 90          	mov    -0x70(%rbp),%r12
  80421132cb:	4d 29 f4             	sub    %r14,%r12
        if (lastRun >= RUN_MASK) {
  80421132ce:	49 83 fc 0e          	cmp    $0xe,%r12
  80421132d2:	76 60                	jbe    8042113334 <LZ4_compress_fast_extState_fastReset+0x9ea>
            size_t accumulator = lastRun - RUN_MASK;
  80421132d4:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  80421132d9:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  80421132dd:	48 8d 43 01          	lea    0x1(%rbx),%rax
  80421132e1:	c6 03 f0             	movb   $0xf0,(%rbx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  80421132e4:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421132eb:	76 18                	jbe    8042113305 <LZ4_compress_fast_extState_fastReset+0x9bb>
  80421132ed:	48 83 c0 01          	add    $0x1,%rax
  80421132f1:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  80421132f5:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  80421132fc:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042113303:	77 e8                	ja     80421132ed <LZ4_compress_fast_extState_fastReset+0x9a3>
            *op++ = (BYTE) accumulator;
  8042113305:	48 8d 58 01          	lea    0x1(%rax),%rbx
  8042113309:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  804211330b:	4c 89 e2             	mov    %r12,%rdx
  804211330e:	4c 89 f6             	mov    %r14,%rsi
  8042113311:	48 89 df             	mov    %rbx,%rdi
  8042113314:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211331b:	00 00 00 
  804211331e:	ff d0                	call   *%rax
        op += lastRun;
  8042113320:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
    result = (int)(((char*)op) - dest);
  8042113324:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  8042113327:	29 d8                	sub    %ebx,%eax
    return result;
  8042113329:	e9 55 05 00 00       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
  804211332e:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  8042113332:	eb 93                	jmp    80421132c7 <LZ4_compress_fast_extState_fastReset+0x97d>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042113334:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042113338:	48 8d 5e 01          	lea    0x1(%rsi),%rbx
  804211333c:	44 89 e0             	mov    %r12d,%eax
  804211333f:	c1 e0 04             	shl    $0x4,%eax
  8042113342:	88 06                	mov    %al,(%rsi)
  8042113344:	eb c5                	jmp    804211330b <LZ4_compress_fast_extState_fastReset+0x9c1>
    if (cctx->dirty) {
  8042113346:	66 41 83 bf 04 40 00 	cmpw   $0x0,0x4004(%r15)
  804211334d:	00 00 
  804211334f:	75 3b                	jne    804211338c <LZ4_compress_fast_extState_fastReset+0xa42>
    if (cctx->tableType != clearedTable) {
  8042113351:	66 41 83 bf 06 40 00 	cmpw   $0x0,0x4006(%r15)
  8042113358:	00 00 
  804211335a:	74 4b                	je     80421133a7 <LZ4_compress_fast_extState_fastReset+0xa5d>
            MEM_INIT(cctx->hashTable, 0, LZ4_HASHTABLESIZE);
  804211335c:	ba 00 40 00 00       	mov    $0x4000,%edx
  8042113361:	be 00 00 00 00       	mov    $0x0,%esi
  8042113366:	4c 89 ff             	mov    %r15,%rdi
  8042113369:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042113370:	00 00 00 
  8042113373:	ff d0                	call   *%rax
            cctx->currentOffset = 0;
  8042113375:	41 c7 87 00 40 00 00 	movl   $0x0,0x4000(%r15)
  804211337c:	00 00 00 00 
            cctx->tableType = clearedTable;
  8042113380:	66 41 c7 87 06 40 00 	movw   $0x0,0x4006(%r15)
  8042113387:	00 00 00 
    if (cctx->currentOffset != 0 && tableType == byU32) {
  804211338a:	eb 32                	jmp    80421133be <LZ4_compress_fast_extState_fastReset+0xa74>
        MEM_INIT(cctx, 0, sizeof(LZ4_stream_t_internal));
  804211338c:	ba 20 40 00 00       	mov    $0x4020,%edx
  8042113391:	be 00 00 00 00       	mov    $0x0,%esi
  8042113396:	4c 89 ff             	mov    %r15,%rdi
  8042113399:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  80421133a0:	00 00 00 
  80421133a3:	ff d0                	call   *%rax
        return;
  80421133a5:	eb 38                	jmp    80421133df <LZ4_compress_fast_extState_fastReset+0xa95>
    if (cctx->currentOffset != 0 && tableType == byU32) {
  80421133a7:	41 8b 87 00 40 00 00 	mov    0x4000(%r15),%eax
  80421133ae:	85 c0                	test   %eax,%eax
  80421133b0:	74 0c                	je     80421133be <LZ4_compress_fast_extState_fastReset+0xa74>
        cctx->currentOffset += 64 KB;
  80421133b2:	05 00 00 01 00       	add    $0x10000,%eax
  80421133b7:	41 89 87 00 40 00 00 	mov    %eax,0x4000(%r15)
    cctx->dictCtx = NULL;
  80421133be:	49 c7 87 10 40 00 00 	movq   $0x0,0x4010(%r15)
  80421133c5:	00 00 00 00 
    cctx->dictionary = NULL;
  80421133c9:	49 c7 87 08 40 00 00 	movq   $0x0,0x4008(%r15)
  80421133d0:	00 00 00 00 
    cctx->dictSize = 0;
  80421133d4:	41 c7 87 18 40 00 00 	movl   $0x0,0x4018(%r15)
  80421133db:	00 00 00 00 
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  80421133df:	b8 00 00 00 00       	mov    $0x0,%eax
  80421133e4:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  80421133eb:	0f 87 92 04 00 00    	ja     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
    U32 const startIndex = cctx->currentOffset;
  80421133f1:	45 8b af 00 40 00 00 	mov    0x4000(%r15),%r13d
    const BYTE* base = (const BYTE*) source - startIndex;
  80421133f8:	44 89 e8             	mov    %r13d,%eax
  80421133fb:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
  80421133ff:	4c 89 f7             	mov    %r14,%rdi
  8042113402:	48 29 c7             	sub    %rax,%rdi
  8042113405:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    const BYTE* const iend = ip + inputSize;
  8042113409:	49 63 c4             	movslq %r12d,%rax
  804211340c:	4c 01 f0             	add    %r14,%rax
  804211340f:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042113413:	48 8d 48 f5          	lea    -0xb(%rax),%rcx
  8042113417:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  804211341b:	48 83 e8 05          	sub    $0x5,%rax
  804211341f:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042113426:	45 01 a7 18 40 00 00 	add    %r12d,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  804211342d:	45 01 ec             	add    %r13d,%r12d
  8042113430:	45 89 a7 00 40 00 00 	mov    %r12d,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042113437:	66 41 c7 87 06 40 00 	movw   $0x2,0x4006(%r15)
  804211343e:	00 02 00 
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042113441:	49 8b 3e             	mov    (%r14),%rdi
  8042113444:	be 02 00 00 00       	mov    $0x2,%esi
  8042113449:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  8042113450:	00 00 00 
  8042113453:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042113456:	89 c0                	mov    %eax,%eax
  8042113458:	45 89 2c 87          	mov    %r13d,(%r15,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  804211345c:	4d 89 f5             	mov    %r14,%r13
  804211345f:	4d 8d 76 01          	lea    0x1(%r14),%r14
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042113463:	49 8b 7d 01          	mov    0x1(%r13),%rdi
  8042113467:	be 02 00 00 00       	mov    $0x2,%esi
  804211346c:	41 ff d4             	call   *%r12
  804211346f:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042113473:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8042113477:	4c 89 ee             	mov    %r13,%rsi
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  804211347a:	c1 e3 06             	shl    $0x6,%ebx
  804211347d:	89 5d 80             	mov    %ebx,-0x80(%rbp)
  8042113480:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
  8042113484:	4d 89 f7             	mov    %r14,%r15
                U32 const current = (U32)(forwardIp - base);
  8042113487:	45 89 fe             	mov    %r15d,%r14d
  804211348a:	8b 5d b8             	mov    -0x48(%rbp),%ebx
  804211348d:	41 29 de             	sub    %ebx,%r14d
        return hashTable[h];
  8042113490:	89 c0                	mov    %eax,%eax
  8042113492:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
  8042113496:	4c 8d 2c 83          	lea    (%rbx,%rax,4),%r13
  804211349a:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  804211349e:	4d 8d 67 01          	lea    0x1(%r15),%r12
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421134a2:	8b 45 80             	mov    -0x80(%rbp),%eax
  80421134a5:	8d 78 01             	lea    0x1(%rax),%edi
  80421134a8:	c1 f8 06             	sar    $0x6,%eax
  80421134ab:	89 45 b0             	mov    %eax,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421134ae:	4c 39 65 a8          	cmp    %r12,-0x58(%rbp)
  80421134b2:	0f 82 6c 03 00 00    	jb     8042113824 <LZ4_compress_fast_extState_fastReset+0xeda>
  80421134b8:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
  80421134bf:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  80421134c3:	41 89 ff             	mov    %edi,%r15d
  80421134c6:	eb 3e                	jmp    8042113506 <LZ4_compress_fast_extState_fastReset+0xbbc>
                U32 const current = (U32)(forwardIp - base);
  80421134c8:	45 89 e6             	mov    %r12d,%r14d
  80421134cb:	8b 75 b8             	mov    -0x48(%rbp),%esi
  80421134ce:	41 29 f6             	sub    %esi,%r14d
        return hashTable[h];
  80421134d1:	89 c0                	mov    %eax,%eax
  80421134d3:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80421134d7:	4c 8d 2c 86          	lea    (%rsi,%rax,4),%r13
  80421134db:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  80421134df:	48 63 45 b0          	movslq -0x50(%rbp),%rax
  80421134e3:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421134e6:	41 8d 57 01          	lea    0x1(%r15),%edx
  80421134ea:	41 c1 ff 06          	sar    $0x6,%r15d
  80421134ee:	44 89 7d b0          	mov    %r15d,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421134f2:	4c 89 65 98          	mov    %r12,-0x68(%rbp)
  80421134f6:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  80421134fa:	0f 82 1d 03 00 00    	jb     804211381d <LZ4_compress_fast_extState_fastReset+0xed3>
  8042113500:	41 89 d7             	mov    %edx,%r15d
  8042113503:	49 89 c4             	mov    %rax,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042113506:	49 8b 3c 24          	mov    (%r12),%rdi
  804211350a:	be 02 00 00 00       	mov    $0x2,%esi
  804211350f:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042113516:	00 00 00 
  8042113519:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211351b:	45 89 75 00          	mov    %r14d,0x0(%r13)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  804211351f:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  8042113525:	44 39 f2             	cmp    %r14d,%edx
  8042113528:	72 9e                	jb     80421134c8 <LZ4_compress_fast_extState_fastReset+0xb7e>
                    match = base + matchIndex;
  804211352a:	89 db                	mov    %ebx,%ebx
  804211352c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042113530:	48 01 fb             	add    %rdi,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042113533:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042113537:	8b 3b                	mov    (%rbx),%edi
  8042113539:	39 3e                	cmp    %edi,(%rsi)
  804211353b:	75 8b                	jne    80421134c8 <LZ4_compress_fast_extState_fastReset+0xb7e>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211353d:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  8042113544:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
  8042113548:	4c 39 fe             	cmp    %r15,%rsi
  804211354b:	73 10                	jae    804211355d <LZ4_compress_fast_extState_fastReset+0xc13>
  804211354d:	48 39 5d c0          	cmp    %rbx,-0x40(%rbp)
  8042113551:	73 0a                	jae    804211355d <LZ4_compress_fast_extState_fastReset+0xc13>
  8042113553:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042113557:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  804211355b:	74 61                	je     80421135be <LZ4_compress_fast_extState_fastReset+0xc74>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  804211355d:	4c 89 fa             	mov    %r15,%rdx
  8042113560:	48 29 f2             	sub    %rsi,%rdx
            token = op++;
  8042113563:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8042113567:	48 8d 78 01          	lea    0x1(%rax),%rdi
            if (litLength >= RUN_MASK) {
  804211356b:	83 fa 0e             	cmp    $0xe,%edx
  804211356e:	77 63                	ja     80421135d3 <LZ4_compress_fast_extState_fastReset+0xc89>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042113570:	89 d0                	mov    %edx,%eax
  8042113572:	c1 e0 04             	shl    $0x4,%eax
  8042113575:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042113579:	88 01                	mov    %al,(%rcx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  804211357b:	89 d2                	mov    %edx,%edx
  804211357d:	4c 8d 34 17          	lea    (%rdi,%rdx,1),%r14
  8042113581:	4c 89 f2             	mov    %r14,%rdx
  8042113584:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211358b:	00 00 00 
  804211358e:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042113590:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8042113594:	48 8d 70 f4          	lea    -0xc(%rax),%rsi
  8042113598:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211359c:	48 8d 70 f8          	lea    -0x8(%rax),%rsi
  80421135a0:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421135a7:	48 83 e8 06          	sub    $0x6,%rax
  80421135ab:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421135b2:	48 89 d8             	mov    %rbx,%rax
  80421135b5:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  80421135b9:	e9 e7 00 00 00       	jmp    80421136a5 <LZ4_compress_fast_extState_fastReset+0xd5b>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  80421135be:	49 83 ef 01          	sub    $0x1,%r15
  80421135c2:	48 83 eb 01          	sub    $0x1,%rbx
  80421135c6:	4c 39 fe             	cmp    %r15,%rsi
  80421135c9:	73 92                	jae    804211355d <LZ4_compress_fast_extState_fastReset+0xc13>
  80421135cb:	48 39 5d c0          	cmp    %rbx,-0x40(%rbp)
  80421135cf:	72 82                	jb     8042113553 <LZ4_compress_fast_extState_fastReset+0xc09>
  80421135d1:	eb 8a                	jmp    804211355d <LZ4_compress_fast_extState_fastReset+0xc13>
                int len = (int)(litLength - RUN_MASK);
  80421135d3:	8d 42 f1             	lea    -0xf(%rdx),%eax
                *token = (RUN_MASK<<ML_BITS);
  80421135d6:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  80421135da:	c6 01 f0             	movb   $0xf0,(%rcx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  80421135dd:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421135e2:	7e 14                	jle    80421135f8 <LZ4_compress_fast_extState_fastReset+0xcae>
  80421135e4:	48 83 c7 01          	add    $0x1,%rdi
  80421135e8:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  80421135ec:	2d ff 00 00 00       	sub    $0xff,%eax
  80421135f1:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421135f6:	7f ec                	jg     80421135e4 <LZ4_compress_fast_extState_fastReset+0xc9a>
                *op++ = (BYTE)len;
  80421135f8:	88 07                	mov    %al,(%rdi)
  80421135fa:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  80421135fe:	e9 78 ff ff ff       	jmp    804211357b <LZ4_compress_fast_extState_fastReset+0xc31>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042113603:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042113606:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211360d:	00 00 00 
  8042113610:	ff d0                	call   *%rax
  8042113612:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042113615:	44 89 e0             	mov    %r12d,%eax
  8042113618:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
            if (matchCode >= ML_MASK) {
  804211361d:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042113621:	0f 87 66 01 00 00    	ja     804211378d <LZ4_compress_fast_extState_fastReset+0xe43>
                *token += (BYTE)(matchCode);
  8042113627:	44 00 23             	add    %r12b,(%rbx)
  804211362a:	4c 89 eb             	mov    %r13,%rbx
        if (ip >= mflimitPlusOne) break;
  804211362d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042113631:	49 39 c7             	cmp    %rax,%r15
  8042113634:	0f 83 da 01 00 00    	jae    8042113814 <LZ4_compress_fast_extState_fastReset+0xeca>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211363a:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  804211363e:	be 02 00 00 00       	mov    $0x2,%esi
  8042113643:	49 bd ce 28 11 42 80 	movabs $0x80421128ce,%r13
  804211364a:	00 00 00 
  804211364d:	41 ff d5             	call   *%r13
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042113650:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042113652:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042113656:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
  804211365a:	4c 29 f2             	sub    %r14,%rdx
  804211365d:	4c 8b 65 a0          	mov    -0x60(%rbp),%r12
  8042113661:	41 89 14 84          	mov    %edx,(%r12,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042113665:	49 8b 3f             	mov    (%r15),%rdi
  8042113668:	be 02 00 00 00       	mov    $0x2,%esi
  804211366d:	41 ff d5             	call   *%r13
            U32 const current = (U32)(ip-base);
  8042113670:	4c 89 f9             	mov    %r15,%rcx
  8042113673:	4c 29 f1             	sub    %r14,%rcx
        return hashTable[h];
  8042113676:	89 c0                	mov    %eax,%eax
  8042113678:	49 8d 34 84          	lea    (%r12,%rax,4),%rsi
  804211367c:	8b 16                	mov    (%rsi),%edx
                match = base + matchIndex;
  804211367e:	89 d0                	mov    %edx,%eax
  8042113680:	4c 01 f0             	add    %r14,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042113683:	89 0e                	mov    %ecx,(%rsi)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  8042113685:	81 c2 ff ff 00 00    	add    $0xffff,%edx
  804211368b:	39 ca                	cmp    %ecx,%edx
  804211368d:	0f 82 59 01 00 00    	jb     80421137ec <LZ4_compress_fast_extState_fastReset+0xea2>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042113693:	8b 38                	mov    (%rax),%edi
  8042113695:	41 39 3f             	cmp    %edi,(%r15)
  8042113698:	0f 85 4e 01 00 00    	jne    80421137ec <LZ4_compress_fast_extState_fastReset+0xea2>
                token=op++;
  804211369e:	4c 8d 73 01          	lea    0x1(%rbx),%r14
                *token=0;
  80421136a2:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  80421136a5:	4c 89 fa             	mov    %r15,%rdx
  80421136a8:	48 29 c2             	sub    %rax,%rdx
  80421136ab:	66 41 89 16          	mov    %dx,(%r14)
  80421136af:	4d 8d 6e 02          	lea    0x2(%r14),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  80421136b3:	49 8d 77 04          	lea    0x4(%r15),%rsi
  80421136b7:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421136bb:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  80421136bf:	48 39 ce             	cmp    %rcx,%rsi
  80421136c2:	73 5b                	jae    804211371f <LZ4_compress_fast_extState_fastReset+0xdd5>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421136c4:	48 8b 50 04          	mov    0x4(%rax),%rdx
  80421136c8:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  80421136cc:	48 39 d7             	cmp    %rdx,%rdi
  80421136cf:	0f 85 2e ff ff ff    	jne    8042113603 <LZ4_compress_fast_extState_fastReset+0xcb9>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  80421136d5:	4d 8d 67 0c          	lea    0xc(%r15),%r12
  80421136d9:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421136dd:	49 39 cc             	cmp    %rcx,%r12
  80421136e0:	73 45                	jae    8042113727 <LZ4_compress_fast_extState_fastReset+0xddd>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421136e2:	48 8b 10             	mov    (%rax),%rdx
  80421136e5:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421136e9:	48 39 d7             	cmp    %rdx,%rdi
  80421136ec:	74 1e                	je     804211370c <LZ4_compress_fast_extState_fastReset+0xdc2>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421136ee:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  80421136f1:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421136f8:	00 00 00 
  80421136fb:	ff d0                	call   *%rax
  80421136fd:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  8042113701:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042113704:	41 29 c4             	sub    %eax,%r12d
  8042113707:	e9 09 ff ff ff       	jmp    8042113615 <LZ4_compress_fast_extState_fastReset+0xccb>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211370c:	49 83 c4 08          	add    $0x8,%r12
  8042113710:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042113714:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8042113718:	49 39 fc             	cmp    %rdi,%r12
  804211371b:	72 c5                	jb     80421136e2 <LZ4_compress_fast_extState_fastReset+0xd98>
  804211371d:	eb 08                	jmp    8042113727 <LZ4_compress_fast_extState_fastReset+0xddd>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211371f:	48 83 c0 04          	add    $0x4,%rax
  8042113723:	4c 8b 65 b0          	mov    -0x50(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042113727:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  804211372e:	49 39 f4             	cmp    %rsi,%r12
  8042113731:	73 08                	jae    804211373b <LZ4_compress_fast_extState_fastReset+0xdf1>
  8042113733:	8b 38                	mov    (%rax),%edi
  8042113735:	41 39 3c 24          	cmp    %edi,(%r12)
  8042113739:	74 3e                	je     8042113779 <LZ4_compress_fast_extState_fastReset+0xe2f>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211373b:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
  8042113742:	49 39 fc             	cmp    %rdi,%r12
  8042113745:	73 0a                	jae    8042113751 <LZ4_compress_fast_extState_fastReset+0xe07>
  8042113747:	0f b7 08             	movzwl (%rax),%ecx
  804211374a:	66 41 39 0c 24       	cmp    %cx,(%r12)
  804211374f:	74 32                	je     8042113783 <LZ4_compress_fast_extState_fastReset+0xe39>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042113751:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  8042113758:	49 39 cc             	cmp    %rcx,%r12
  804211375b:	73 11                	jae    804211376e <LZ4_compress_fast_extState_fastReset+0xe24>
  804211375d:	41 0f b6 34 24       	movzbl (%r12),%esi
  8042113762:	40 38 30             	cmp    %sil,(%rax)
  8042113765:	0f 94 c0             	sete   %al
  8042113768:	0f b6 c0             	movzbl %al,%eax
  804211376b:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  804211376e:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042113771:	41 29 c4             	sub    %eax,%r12d
  8042113774:	e9 9c fe ff ff       	jmp    8042113615 <LZ4_compress_fast_extState_fastReset+0xccb>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042113779:	49 83 c4 04          	add    $0x4,%r12
  804211377d:	48 83 c0 04          	add    $0x4,%rax
  8042113781:	eb b8                	jmp    804211373b <LZ4_compress_fast_extState_fastReset+0xdf1>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042113783:	49 83 c4 02          	add    $0x2,%r12
  8042113787:	48 83 c0 02          	add    $0x2,%rax
  804211378b:	eb c4                	jmp    8042113751 <LZ4_compress_fast_extState_fastReset+0xe07>
                *token += ML_MASK;
  804211378d:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  8042113790:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042113794:	41 c7 46 02 ff ff ff 	movl   $0xffffffff,0x2(%r14)
  804211379b:	ff 
                while (matchCode >= 4*255) {
  804211379c:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  80421137a3:	76 1c                	jbe    80421137c1 <LZ4_compress_fast_extState_fastReset+0xe77>
                    op+=4;
  80421137a5:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421137a9:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  80421137b0:	ff 
                    matchCode -= 4*255;
  80421137b1:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  80421137b8:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  80421137bf:	77 e4                	ja     80421137a5 <LZ4_compress_fast_extState_fastReset+0xe5b>
                op += matchCode / 255;
  80421137c1:	44 89 e0             	mov    %r12d,%eax
  80421137c4:	bb 81 80 80 80       	mov    $0x80808081,%ebx
  80421137c9:	48 0f af c3          	imul   %rbx,%rax
  80421137cd:	48 c1 e8 27          	shr    $0x27,%rax
  80421137d1:	89 c2                	mov    %eax,%edx
  80421137d3:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  80421137d6:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  80421137da:	89 c1                	mov    %eax,%ecx
  80421137dc:	c1 e1 08             	shl    $0x8,%ecx
  80421137df:	29 c1                	sub    %eax,%ecx
  80421137e1:	41 29 cc             	sub    %ecx,%r12d
  80421137e4:	44 88 22             	mov    %r12b,(%rdx)
  80421137e7:	e9 41 fe ff ff       	jmp    804211362d <LZ4_compress_fast_extState_fastReset+0xce3>
        forwardH = LZ4_hashPosition(++ip, tableType);
  80421137ec:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
  80421137f0:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421137f4:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  80421137f8:	be 02 00 00 00       	mov    $0x2,%esi
  80421137fd:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042113804:	00 00 00 
  8042113807:	ff d0                	call   *%rax
  8042113809:	4c 89 fe             	mov    %r15,%rsi
  804211380c:	49 89 df             	mov    %rbx,%r15
  804211380f:	e9 73 fc ff ff       	jmp    8042113487 <LZ4_compress_fast_extState_fastReset+0xb3d>
        anchor = ip;
  8042113814:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
  8042113818:	4c 89 fe             	mov    %r15,%rsi
  804211381b:	eb 07                	jmp    8042113824 <LZ4_compress_fast_extState_fastReset+0xeda>
  804211381d:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
    {   size_t lastRun = (size_t)(iend - anchor);
  8042113824:	4c 8b 65 88          	mov    -0x78(%rbp),%r12
  8042113828:	49 29 f4             	sub    %rsi,%r12
        if (lastRun >= RUN_MASK) {
  804211382b:	49 83 fc 0e          	cmp    $0xe,%r12
  804211382f:	76 61                	jbe    8042113892 <LZ4_compress_fast_extState_fastReset+0xf48>
            size_t accumulator = lastRun - RUN_MASK;
  8042113831:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042113836:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  804211383a:	48 8d 43 01          	lea    0x1(%rbx),%rax
  804211383e:	c6 03 f0             	movb   $0xf0,(%rbx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042113841:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042113848:	76 18                	jbe    8042113862 <LZ4_compress_fast_extState_fastReset+0xf18>
  804211384a:	48 83 c0 01          	add    $0x1,%rax
  804211384e:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042113852:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042113859:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042113860:	77 e8                	ja     804211384a <LZ4_compress_fast_extState_fastReset+0xf00>
            *op++ = (BYTE) accumulator;
  8042113862:	48 8d 58 01          	lea    0x1(%rax),%rbx
  8042113866:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042113868:	4c 89 e2             	mov    %r12,%rdx
  804211386b:	48 89 df             	mov    %rbx,%rdi
  804211386e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042113875:	00 00 00 
  8042113878:	ff d0                	call   *%rax
        op += lastRun;
  804211387a:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
    result = (int)(((char*)op) - dest);
  804211387e:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  8042113881:	29 d8                	sub    %ebx,%eax
}
  8042113883:	48 83 c4 78          	add    $0x78,%rsp
  8042113887:	5b                   	pop    %rbx
  8042113888:	41 5c                	pop    %r12
  804211388a:	41 5d                	pop    %r13
  804211388c:	41 5e                	pop    %r14
  804211388e:	41 5f                	pop    %r15
  8042113890:	5d                   	pop    %rbp
  8042113891:	c3                   	ret
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042113892:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  8042113896:	48 8d 5f 01          	lea    0x1(%rdi),%rbx
  804211389a:	44 89 e0             	mov    %r12d,%eax
  804211389d:	c1 e0 04             	shl    $0x4,%eax
  80421138a0:	88 07                	mov    %al,(%rdi)
  80421138a2:	eb c4                	jmp    8042113868 <LZ4_compress_fast_extState_fastReset+0xf1e>
        if (srcSize < LZ4_64Klimit) {
  80421138a4:	41 81 fc 0a 00 01 00 	cmp    $0x1000a,%r12d
  80421138ab:	0f 8f 8f 0a 00 00    	jg     8042114340 <LZ4_compress_fast_extState_fastReset+0x19f6>
    if (cctx->dirty) {
  80421138b1:	66 41 83 bf 04 40 00 	cmpw   $0x0,0x4004(%r15)
  80421138b8:	00 00 
  80421138ba:	0f 85 85 01 00 00    	jne    8042113a45 <LZ4_compress_fast_extState_fastReset+0x10fb>
    if (cctx->tableType != clearedTable) {
  80421138c0:	41 0f b7 87 06 40 00 	movzwl 0x4006(%r15),%eax
  80421138c7:	00 
  80421138c8:	66 85 c0             	test   %ax,%ax
  80421138cb:	74 4e                	je     804211391b <LZ4_compress_fast_extState_fastReset+0xfd1>
        if (cctx->tableType != tableType
  80421138cd:	66 83 f8 03          	cmp    $0x3,%ax
  80421138d1:	75 1a                	jne    80421138ed <LZ4_compress_fast_extState_fastReset+0xfa3>
            || ((tableType == byU16) && cctx->currentOffset + (unsigned)inputSize >= 0xFFFFU)
  80421138d3:	44 89 e0             	mov    %r12d,%eax
  80421138d6:	41 03 87 00 40 00 00 	add    0x4000(%r15),%eax
            || inputSize >= 4 KB)
  80421138dd:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  80421138e2:	77 09                	ja     80421138ed <LZ4_compress_fast_extState_fastReset+0xfa3>
  80421138e4:	41 81 fc ff 0f 00 00 	cmp    $0xfff,%r12d
  80421138eb:	7e 2e                	jle    804211391b <LZ4_compress_fast_extState_fastReset+0xfd1>
            MEM_INIT(cctx->hashTable, 0, LZ4_HASHTABLESIZE);
  80421138ed:	ba 00 40 00 00       	mov    $0x4000,%edx
  80421138f2:	be 00 00 00 00       	mov    $0x0,%esi
  80421138f7:	4c 89 ff             	mov    %r15,%rdi
  80421138fa:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042113901:	00 00 00 
  8042113904:	ff d0                	call   *%rax
            cctx->currentOffset = 0;
  8042113906:	41 c7 87 00 40 00 00 	movl   $0x0,0x4000(%r15)
  804211390d:	00 00 00 00 
            cctx->tableType = clearedTable;
  8042113911:	66 41 c7 87 06 40 00 	movw   $0x0,0x4006(%r15)
  8042113918:	00 00 00 
    cctx->dictCtx = NULL;
  804211391b:	49 c7 87 10 40 00 00 	movq   $0x0,0x4010(%r15)
  8042113922:	00 00 00 00 
    cctx->dictionary = NULL;
  8042113926:	49 c7 87 08 40 00 00 	movq   $0x0,0x4008(%r15)
  804211392d:	00 00 00 00 
    cctx->dictSize = 0;
  8042113931:	41 c7 87 18 40 00 00 	movl   $0x0,0x4018(%r15)
  8042113938:	00 00 00 00 
            if (ctx->currentOffset) {
  804211393c:	41 8b 97 00 40 00 00 	mov    0x4000(%r15),%edx
  8042113943:	85 d2                	test   %edx,%edx
  8042113945:	0f 84 54 05 00 00    	je     8042113e9f <LZ4_compress_fast_extState_fastReset+0x1555>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  804211394b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042113950:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042113957:	0f 87 26 ff ff ff    	ja     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
            dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;
  804211395d:	41 8b 87 18 40 00 00 	mov    0x4018(%r15),%eax
    const BYTE* const iend = ip + inputSize;
  8042113964:	49 63 cc             	movslq %r12d,%rcx
  8042113967:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
  804211396b:	49 8d 3c 0a          	lea    (%r10,%rcx,1),%rdi
  804211396f:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  8042113973:	4d 63 ed             	movslq %r13d,%r13
  8042113976:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211397a:	4a 8d 0c 2e          	lea    (%rsi,%r13,1),%rcx
  804211397e:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042113982:	42 8d 0c 20          	lea    (%rax,%r12,1),%ecx
  8042113986:	41 89 8f 18 40 00 00 	mov    %ecx,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  804211398d:	42 8d 0c 22          	lea    (%rdx,%r12,1),%ecx
  8042113991:	41 89 8f 00 40 00 00 	mov    %ecx,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042113998:	66 41 c7 87 06 40 00 	movw   $0x3,0x4006(%r15)
  804211399f:	00 03 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  80421139a2:	41 83 fc 0c          	cmp    $0xc,%r12d
  80421139a6:	0f 8e 2f 04 00 00    	jle    8042113ddb <LZ4_compress_fast_extState_fastReset+0x1491>
    const BYTE* base = (const BYTE*) source - startIndex;
  80421139ac:	89 d1                	mov    %edx,%ecx
  80421139ae:	4d 89 d6             	mov    %r10,%r14
  80421139b1:	49 29 ce             	sub    %rcx,%r14
    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
  80421139b4:	41 89 d5             	mov    %edx,%r13d
  80421139b7:	41 29 c5             	sub    %eax,%r13d
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  80421139ba:	48 8d 47 f5          	lea    -0xb(%rdi),%rax
  80421139be:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  80421139c2:	48 8d 47 fb          	lea    -0x5(%rdi),%rax
  80421139c6:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421139cd:	41 69 02 b1 79 37 9e 	imul   $0x9e3779b1,(%r10),%eax
  80421139d4:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  80421139d7:	89 c0                	mov    %eax,%eax
  80421139d9:	66 41 89 14 47       	mov    %dx,(%r15,%rax,2)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  80421139de:	4d 8d 62 01          	lea    0x1(%r10),%r12
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421139e2:	41 69 42 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r10),%eax
  80421139e9:	9e 
  80421139ea:	c1 e8 13             	shr    $0x13,%eax
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  80421139ed:	c1 e3 06             	shl    $0x6,%ebx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421139f0:	8d 4b 01             	lea    0x1(%rbx),%ecx
  80421139f3:	89 4d 88             	mov    %ecx,-0x78(%rbp)
  80421139f6:	c1 fb 06             	sar    $0x6,%ebx
  80421139f9:	89 5d 80             	mov    %ebx,-0x80(%rbp)
  80421139fc:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8042113a00:	44 89 6d 98          	mov    %r13d,-0x68(%rbp)
  8042113a04:	4c 89 fb             	mov    %r15,%rbx
  8042113a07:	4d 89 f7             	mov    %r14,%r15
  8042113a0a:	49 89 de             	mov    %rbx,%r14
                U32 const current = (U32)(forwardIp - base);
  8042113a0d:	4d 89 e0             	mov    %r12,%r8
  8042113a10:	4d 29 f8             	sub    %r15,%r8
        return hashTable[h];
  8042113a13:	89 c0                	mov    %eax,%eax
  8042113a15:	49 8d 34 46          	lea    (%r14,%rax,2),%rsi
  8042113a19:	0f b7 1e             	movzwl (%rsi),%ebx
  8042113a1c:	44 0f b7 cb          	movzwl %bx,%r9d
                forwardIp += step;
  8042113a20:	49 8d 4c 24 01       	lea    0x1(%r12),%rcx
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042113a25:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042113a29:	48 39 c8             	cmp    %rcx,%rax
  8042113a2c:	0f 82 c4 03 00 00    	jb     8042113df6 <LZ4_compress_fast_extState_fastReset+0x14ac>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042113a32:	8b 55 80             	mov    -0x80(%rbp),%edx
  8042113a35:	8b 7d 88             	mov    -0x78(%rbp),%edi
  8042113a38:	44 8b 6d 98          	mov    -0x68(%rbp),%r13d
  8042113a3c:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
  8042113a40:	49 89 c2             	mov    %rax,%r10
  8042113a43:	eb 52                	jmp    8042113a97 <LZ4_compress_fast_extState_fastReset+0x114d>
        MEM_INIT(cctx, 0, sizeof(LZ4_stream_t_internal));
  8042113a45:	ba 20 40 00 00       	mov    $0x4020,%edx
  8042113a4a:	be 00 00 00 00       	mov    $0x0,%esi
  8042113a4f:	4c 89 ff             	mov    %r15,%rdi
  8042113a52:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042113a59:	00 00 00 
  8042113a5c:	ff d0                	call   *%rax
        return;
  8042113a5e:	e9 d9 fe ff ff       	jmp    804211393c <LZ4_compress_fast_extState_fastReset+0xff2>
                U32 const current = (U32)(forwardIp - base);
  8042113a63:	49 89 c8             	mov    %rcx,%r8
  8042113a66:	4d 29 f8             	sub    %r15,%r8
        return hashTable[h];
  8042113a69:	89 c0                	mov    %eax,%eax
  8042113a6b:	49 8d 34 46          	lea    (%r14,%rax,2),%rsi
  8042113a6f:	0f b7 1e             	movzwl (%rsi),%ebx
  8042113a72:	44 0f b7 cb          	movzwl %bx,%r9d
                forwardIp += step;
  8042113a76:	48 63 c2             	movslq %edx,%rax
  8042113a79:	48 01 c8             	add    %rcx,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042113a7c:	44 8d 5f 01          	lea    0x1(%rdi),%r11d
  8042113a80:	c1 ff 06             	sar    $0x6,%edi
  8042113a83:	89 fa                	mov    %edi,%edx
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042113a85:	49 89 cc             	mov    %rcx,%r12
  8042113a88:	49 39 c2             	cmp    %rax,%r10
  8042113a8b:	0f 82 61 03 00 00    	jb     8042113df2 <LZ4_compress_fast_extState_fastReset+0x14a8>
  8042113a91:	44 89 df             	mov    %r11d,%edi
  8042113a94:	48 89 c1             	mov    %rax,%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113a97:	69 01 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%eax
  8042113a9d:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042113aa0:	66 44 89 06          	mov    %r8w,(%rsi)
                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */
  8042113aa4:	45 39 e9             	cmp    %r13d,%r9d
  8042113aa7:	72 ba                	jb     8042113a63 <LZ4_compress_fast_extState_fastReset+0x1119>
                    match = base + matchIndex;
  8042113aa9:	0f b7 db             	movzwl %bx,%ebx
  8042113aac:	4c 01 fb             	add    %r15,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042113aaf:	8b 33                	mov    (%rbx),%esi
  8042113ab1:	41 39 34 24          	cmp    %esi,(%r12)
  8042113ab5:	75 ac                	jne    8042113a63 <LZ4_compress_fast_extState_fastReset+0x1119>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042113ab7:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
  8042113abb:	48 39 5d c0          	cmp    %rbx,-0x40(%rbp)
  8042113abf:	73 10                	jae    8042113ad1 <LZ4_compress_fast_extState_fastReset+0x1187>
  8042113ac1:	4d 39 e2             	cmp    %r12,%r10
  8042113ac4:	73 0b                	jae    8042113ad1 <LZ4_compress_fast_extState_fastReset+0x1187>
  8042113ac6:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042113aca:	41 38 44 24 ff       	cmp    %al,-0x1(%r12)
  8042113acf:	74 7e                	je     8042113b4f <LZ4_compress_fast_extState_fastReset+0x1205>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042113ad1:	4c 89 e0             	mov    %r12,%rax
  8042113ad4:	4c 29 d0             	sub    %r10,%rax
            token = op++;
  8042113ad7:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8042113adb:	48 83 c7 01          	add    $0x1,%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  8042113adf:	89 c1                	mov    %eax,%ecx
  8042113ae1:	89 c2                	mov    %eax,%edx
  8042113ae3:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042113ae8:	48 0f af d6          	imul   %rsi,%rdx
  8042113aec:	48 c1 ea 27          	shr    $0x27,%rdx
  8042113af0:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  8042113af5:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  8042113af8:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8042113afc:	0f 82 0c 0e 00 00    	jb     804211490e <LZ4_compress_fast_extState_fastReset+0x1fc4>
            if (litLength >= RUN_MASK) {
  8042113b02:	83 f8 0e             	cmp    $0xe,%eax
  8042113b05:	77 68                	ja     8042113b6f <LZ4_compress_fast_extState_fastReset+0x1225>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042113b07:	c1 e0 04             	shl    $0x4,%eax
  8042113b0a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042113b0e:	88 06                	mov    %al,(%rsi)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042113b10:	4c 8d 2c 0f          	lea    (%rdi,%rcx,1),%r13
  8042113b14:	4c 89 ea             	mov    %r13,%rdx
  8042113b17:	4c 89 d6             	mov    %r10,%rsi
  8042113b1a:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042113b21:	00 00 00 
  8042113b24:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042113b26:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042113b2a:	48 83 e8 0c          	sub    $0xc,%rax
  8042113b2e:	48 89 45 90          	mov    %rax,-0x70(%rbp)
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042113b32:	4c 89 bd 78 ff ff ff 	mov    %r15,-0x88(%rbp)
  8042113b39:	48 89 d8             	mov    %rbx,%rax
  8042113b3c:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
  8042113b40:	4d 89 ef             	mov    %r13,%r15
  8042113b43:	4c 89 b5 70 ff ff ff 	mov    %r14,-0x90(%rbp)
  8042113b4a:	e9 16 01 00 00       	jmp    8042113c65 <LZ4_compress_fast_extState_fastReset+0x131b>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042113b4f:	49 83 ec 01          	sub    $0x1,%r12
  8042113b53:	48 83 eb 01          	sub    $0x1,%rbx
  8042113b57:	4d 39 e2             	cmp    %r12,%r10
  8042113b5a:	0f 83 71 ff ff ff    	jae    8042113ad1 <LZ4_compress_fast_extState_fastReset+0x1187>
  8042113b60:	48 39 5d c0          	cmp    %rbx,-0x40(%rbp)
  8042113b64:	0f 82 5c ff ff ff    	jb     8042113ac6 <LZ4_compress_fast_extState_fastReset+0x117c>
  8042113b6a:	e9 62 ff ff ff       	jmp    8042113ad1 <LZ4_compress_fast_extState_fastReset+0x1187>
                int len = (int)(litLength - RUN_MASK);
  8042113b6f:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  8042113b72:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042113b76:	c6 06 f0             	movb   $0xf0,(%rsi)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042113b79:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042113b7e:	7e 14                	jle    8042113b94 <LZ4_compress_fast_extState_fastReset+0x124a>
  8042113b80:	48 83 c7 01          	add    $0x1,%rdi
  8042113b84:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042113b88:	2d ff 00 00 00       	sub    $0xff,%eax
  8042113b8d:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042113b92:	7f ec                	jg     8042113b80 <LZ4_compress_fast_extState_fastReset+0x1236>
                *op++ = (BYTE)len;
  8042113b94:	88 07                	mov    %al,(%rdi)
  8042113b96:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042113b9a:	e9 71 ff ff ff       	jmp    8042113b10 <LZ4_compress_fast_extState_fastReset+0x11c6>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042113b9f:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042113ba2:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042113ba9:	00 00 00 
  8042113bac:	ff d0                	call   *%rax
  8042113bae:	41 89 c5             	mov    %eax,%r13d
                ip += (size_t)matchCode + MINMATCH;
  8042113bb1:	44 89 e8             	mov    %r13d,%eax
  8042113bb4:	4d 8d 64 04 04       	lea    0x4(%r12,%rax,1),%r12
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042113bb9:	41 8d 85 f0 00 00 00 	lea    0xf0(%r13),%eax
  8042113bc0:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042113bc5:	48 0f af c6          	imul   %rsi,%rax
  8042113bc9:	48 c1 e8 27          	shr    $0x27,%rax
  8042113bcd:	49 8d 44 06 06       	lea    0x6(%r14,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042113bd2:	48 39 45 b8          	cmp    %rax,-0x48(%rbp)
  8042113bd6:	0f 82 3c 0d 00 00    	jb     8042114918 <LZ4_compress_fast_extState_fastReset+0x1fce>
            if (matchCode >= ML_MASK) {
  8042113bdc:	41 83 fd 0e          	cmp    $0xe,%r13d
  8042113be0:	0f 87 6c 01 00 00    	ja     8042113d52 <LZ4_compress_fast_extState_fastReset+0x1408>
                *token += (BYTE)(matchCode);
  8042113be6:	44 00 2b             	add    %r13b,(%rbx)
  8042113be9:	4c 89 f3             	mov    %r14,%rbx
        if (ip >= mflimitPlusOne) break;
  8042113bec:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042113bf0:	49 39 c4             	cmp    %rax,%r12
  8042113bf3:	0f 83 f0 01 00 00    	jae    8042113de9 <LZ4_compress_fast_extState_fastReset+0x149f>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113bf9:	41 69 44 24 fe b1 79 	imul   $0x9e3779b1,-0x2(%r12),%eax
  8042113c00:	37 9e 
  8042113c02:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042113c05:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042113c07:	49 8d 54 24 fe       	lea    -0x2(%r12),%rdx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042113c0c:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
  8042113c13:	48 29 fa             	sub    %rdi,%rdx
  8042113c16:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  8042113c1d:	66 89 14 41          	mov    %dx,(%rcx,%rax,2)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113c21:	41 69 04 24 b1 79 37 	imul   $0x9e3779b1,(%r12),%eax
  8042113c28:	9e 
  8042113c29:	c1 e8 13             	shr    $0x13,%eax
        return hashTable[h];
  8042113c2c:	89 c0                	mov    %eax,%eax
  8042113c2e:	48 8d 0c 41          	lea    (%rcx,%rax,2),%rcx
  8042113c32:	0f b7 11             	movzwl (%rcx),%edx
                match = base + matchIndex;
  8042113c35:	0f b7 c2             	movzwl %dx,%eax
  8042113c38:	48 01 f8             	add    %rdi,%rax
            U32 const current = (U32)(ip-base);
  8042113c3b:	4c 89 e6             	mov    %r12,%rsi
  8042113c3e:	48 29 fe             	sub    %rdi,%rsi
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042113c41:	66 89 31             	mov    %si,(%rcx)
        return hashTable[h];
  8042113c44:	0f b7 d2             	movzwl %dx,%edx
            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)
  8042113c47:	8b 7d 98             	mov    -0x68(%rbp),%edi
  8042113c4a:	39 fa                	cmp    %edi,%edx
  8042113c4c:	0f 82 5e 01 00 00    	jb     8042113db0 <LZ4_compress_fast_extState_fastReset+0x1466>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042113c52:	8b 30                	mov    (%rax),%esi
  8042113c54:	41 39 34 24          	cmp    %esi,(%r12)
  8042113c58:	0f 85 52 01 00 00    	jne    8042113db0 <LZ4_compress_fast_extState_fastReset+0x1466>
                token=op++;
  8042113c5e:	4c 8d 7b 01          	lea    0x1(%rbx),%r15
                *token=0;
  8042113c62:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042113c65:	4c 89 e2             	mov    %r12,%rdx
  8042113c68:	48 29 c2             	sub    %rax,%rdx
  8042113c6b:	66 41 89 17          	mov    %dx,(%r15)
  8042113c6f:	4d 8d 77 02          	lea    0x2(%r15),%r14
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042113c73:	49 8d 74 24 04       	lea    0x4(%r12),%rsi
  8042113c78:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042113c7c:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042113c80:	48 39 ce             	cmp    %rcx,%rsi
  8042113c83:	73 5d                	jae    8042113ce2 <LZ4_compress_fast_extState_fastReset+0x1398>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042113c85:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042113c89:	49 8b 7c 24 04       	mov    0x4(%r12),%rdi
        if (!diff) {
  8042113c8e:	48 39 d7             	cmp    %rdx,%rdi
  8042113c91:	0f 85 08 ff ff ff    	jne    8042113b9f <LZ4_compress_fast_extState_fastReset+0x1255>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042113c97:	4d 8d 6c 24 0c       	lea    0xc(%r12),%r13
  8042113c9c:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042113ca0:	49 39 cd             	cmp    %rcx,%r13
  8042113ca3:	73 45                	jae    8042113cea <LZ4_compress_fast_extState_fastReset+0x13a0>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042113ca5:	48 8b 10             	mov    (%rax),%rdx
  8042113ca8:	49 8b 7d 00          	mov    0x0(%r13),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042113cac:	48 39 d7             	cmp    %rdx,%rdi
  8042113caf:	74 1e                	je     8042113ccf <LZ4_compress_fast_extState_fastReset+0x1385>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042113cb1:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042113cb4:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042113cbb:	00 00 00 
  8042113cbe:	ff d0                	call   *%rax
  8042113cc0:	46 8d 2c 28          	lea    (%rax,%r13,1),%r13d
        return (unsigned)(pIn - pStart);
  8042113cc4:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042113cc7:	41 29 c5             	sub    %eax,%r13d
  8042113cca:	e9 e2 fe ff ff       	jmp    8042113bb1 <LZ4_compress_fast_extState_fastReset+0x1267>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042113ccf:	49 83 c5 08          	add    $0x8,%r13
  8042113cd3:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042113cd7:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  8042113cdb:	49 39 f5             	cmp    %rsi,%r13
  8042113cde:	72 c5                	jb     8042113ca5 <LZ4_compress_fast_extState_fastReset+0x135b>
  8042113ce0:	eb 08                	jmp    8042113cea <LZ4_compress_fast_extState_fastReset+0x13a0>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042113ce2:	48 83 c0 04          	add    $0x4,%rax
  8042113ce6:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042113cea:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8042113cee:	48 8d 57 f8          	lea    -0x8(%rdi),%rdx
  8042113cf2:	49 39 d5             	cmp    %rdx,%r13
  8042113cf5:	73 08                	jae    8042113cff <LZ4_compress_fast_extState_fastReset+0x13b5>
  8042113cf7:	8b 38                	mov    (%rax),%edi
  8042113cf9:	41 39 7d 00          	cmp    %edi,0x0(%r13)
  8042113cfd:	74 3f                	je     8042113d3e <LZ4_compress_fast_extState_fastReset+0x13f4>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042113cff:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8042113d03:	48 8d 57 fa          	lea    -0x6(%rdi),%rdx
  8042113d07:	49 39 d5             	cmp    %rdx,%r13
  8042113d0a:	73 0a                	jae    8042113d16 <LZ4_compress_fast_extState_fastReset+0x13cc>
  8042113d0c:	0f b7 38             	movzwl (%rax),%edi
  8042113d0f:	66 41 39 7d 00       	cmp    %di,0x0(%r13)
  8042113d14:	74 32                	je     8042113d48 <LZ4_compress_fast_extState_fastReset+0x13fe>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042113d16:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  8042113d1d:	49 39 cd             	cmp    %rcx,%r13
  8042113d20:	73 11                	jae    8042113d33 <LZ4_compress_fast_extState_fastReset+0x13e9>
  8042113d22:	41 0f b6 7d 00       	movzbl 0x0(%r13),%edi
  8042113d27:	40 38 38             	cmp    %dil,(%rax)
  8042113d2a:	0f 94 c0             	sete   %al
  8042113d2d:	0f b6 c0             	movzbl %al,%eax
  8042113d30:	49 01 c5             	add    %rax,%r13
    return (unsigned)(pIn - pStart);
  8042113d33:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042113d36:	41 29 c5             	sub    %eax,%r13d
  8042113d39:	e9 73 fe ff ff       	jmp    8042113bb1 <LZ4_compress_fast_extState_fastReset+0x1267>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042113d3e:	49 83 c5 04          	add    $0x4,%r13
  8042113d42:	48 83 c0 04          	add    $0x4,%rax
  8042113d46:	eb b7                	jmp    8042113cff <LZ4_compress_fast_extState_fastReset+0x13b5>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042113d48:	49 83 c5 02          	add    $0x2,%r13
  8042113d4c:	48 83 c0 02          	add    $0x2,%rax
  8042113d50:	eb c4                	jmp    8042113d16 <LZ4_compress_fast_extState_fastReset+0x13cc>
                *token += ML_MASK;
  8042113d52:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  8042113d55:	41 83 ed 0f          	sub    $0xf,%r13d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042113d59:	41 c7 47 02 ff ff ff 	movl   $0xffffffff,0x2(%r15)
  8042113d60:	ff 
                while (matchCode >= 4*255) {
  8042113d61:	41 81 fd fb 03 00 00 	cmp    $0x3fb,%r13d
  8042113d68:	76 1b                	jbe    8042113d85 <LZ4_compress_fast_extState_fastReset+0x143b>
                    op+=4;
  8042113d6a:	49 83 c6 04          	add    $0x4,%r14
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042113d6e:	41 c7 06 ff ff ff ff 	movl   $0xffffffff,(%r14)
                    matchCode -= 4*255;
  8042113d75:	41 81 ed fc 03 00 00 	sub    $0x3fc,%r13d
                while (matchCode >= 4*255) {
  8042113d7c:	41 81 fd fb 03 00 00 	cmp    $0x3fb,%r13d
  8042113d83:	77 e5                	ja     8042113d6a <LZ4_compress_fast_extState_fastReset+0x1420>
                op += matchCode / 255;
  8042113d85:	44 89 e8             	mov    %r13d,%eax
  8042113d88:	ba 81 80 80 80       	mov    $0x80808081,%edx
  8042113d8d:	48 0f af c2          	imul   %rdx,%rax
  8042113d91:	48 c1 e8 27          	shr    $0x27,%rax
  8042113d95:	89 c2                	mov    %eax,%edx
  8042113d97:	4c 01 f2             	add    %r14,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042113d9a:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  8042113d9e:	89 c1                	mov    %eax,%ecx
  8042113da0:	c1 e1 08             	shl    $0x8,%ecx
  8042113da3:	29 c1                	sub    %eax,%ecx
  8042113da5:	41 29 cd             	sub    %ecx,%r13d
  8042113da8:	44 88 2a             	mov    %r13b,(%rdx)
  8042113dab:	e9 3c fe ff ff       	jmp    8042113bec <LZ4_compress_fast_extState_fastReset+0x12a2>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113db0:	4c 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%r15
  8042113db7:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
  8042113dbb:	4c 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%r14
  8042113dc2:	41 69 44 24 01 b1 79 	imul   $0x9e3779b1,0x1(%r12),%eax
  8042113dc9:	37 9e 
  8042113dcb:	c1 e8 13             	shr    $0x13,%eax
  8042113dce:	4d 89 e2             	mov    %r12,%r10
  8042113dd1:	4d 8d 64 24 01       	lea    0x1(%r12),%r12
  8042113dd6:	e9 32 fc ff ff       	jmp    8042113a0d <LZ4_compress_fast_extState_fastReset+0x10c3>
    BYTE* op = (BYTE*) dest;
  8042113ddb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042113ddf:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  8042113de3:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
  8042113de7:	eb 0d                	jmp    8042113df6 <LZ4_compress_fast_extState_fastReset+0x14ac>
        anchor = ip;
  8042113de9:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
  8042113ded:	4d 89 e2             	mov    %r12,%r10
  8042113df0:	eb 04                	jmp    8042113df6 <LZ4_compress_fast_extState_fastReset+0x14ac>
  8042113df2:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
    {   size_t lastRun = (size_t)(iend - anchor);
  8042113df6:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
  8042113dfa:	4c 29 d3             	sub    %r10,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  8042113dfd:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  8042113e04:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  8042113e0b:	80 80 80 
  8042113e0e:	48 89 d0             	mov    %rdx,%rax
  8042113e11:	48 f7 e1             	mul    %rcx
  8042113e14:	48 c1 ea 07          	shr    $0x7,%rdx
  8042113e18:	48 8d 54 13 01       	lea    0x1(%rbx,%rdx,1),%rdx
  8042113e1d:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  8042113e21:	48 01 fa             	add    %rdi,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042113e24:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  8042113e29:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8042113e2d:	0f 82 50 fa ff ff    	jb     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
        if (lastRun >= RUN_MASK) {
  8042113e33:	48 83 fb 0e          	cmp    $0xe,%rbx
  8042113e37:	76 55                	jbe    8042113e8e <LZ4_compress_fast_extState_fastReset+0x1544>
            size_t accumulator = lastRun - RUN_MASK;
  8042113e39:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042113e3d:	48 8d 47 01          	lea    0x1(%rdi),%rax
  8042113e41:	c6 07 f0             	movb   $0xf0,(%rdi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042113e44:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042113e4b:	76 18                	jbe    8042113e65 <LZ4_compress_fast_extState_fastReset+0x151b>
  8042113e4d:	48 83 c0 01          	add    $0x1,%rax
  8042113e51:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042113e55:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042113e5c:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042113e63:	77 e8                	ja     8042113e4d <LZ4_compress_fast_extState_fastReset+0x1503>
            *op++ = (BYTE) accumulator;
  8042113e65:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8042113e69:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042113e6b:	48 89 da             	mov    %rbx,%rdx
  8042113e6e:	4c 89 d6             	mov    %r10,%rsi
  8042113e71:	4c 89 e7             	mov    %r12,%rdi
  8042113e74:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042113e7b:	00 00 00 
  8042113e7e:	ff d0                	call   *%rax
        op += lastRun;
  8042113e80:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  8042113e84:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  8042113e87:	29 d8                	sub    %ebx,%eax
    return result;
  8042113e89:	e9 f5 f9 ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042113e8e:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8042113e92:	4c 8d 61 01          	lea    0x1(%rcx),%r12
  8042113e96:	89 d8                	mov    %ebx,%eax
  8042113e98:	c1 e0 04             	shl    $0x4,%eax
  8042113e9b:	88 01                	mov    %al,(%rcx)
  8042113e9d:	eb cc                	jmp    8042113e6b <LZ4_compress_fast_extState_fastReset+0x1521>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042113e9f:	b8 00 00 00 00       	mov    $0x0,%eax
  8042113ea4:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042113eab:	0f 87 d2 f9 ff ff    	ja     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
    const BYTE* const iend = ip + inputSize;
  8042113eb1:	49 63 c4             	movslq %r12d,%rax
  8042113eb4:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8042113eb8:	48 01 f0             	add    %rsi,%rax
  8042113ebb:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  8042113ebf:	4d 63 ed             	movslq %r13d,%r13
  8042113ec2:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042113ec6:	4a 8d 0c 2f          	lea    (%rdi,%r13,1),%rcx
  8042113eca:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042113ece:	45 01 a7 18 40 00 00 	add    %r12d,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  8042113ed5:	45 89 a7 00 40 00 00 	mov    %r12d,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042113edc:	66 41 c7 87 06 40 00 	movw   $0x3,0x4006(%r15)
  8042113ee3:	00 03 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  8042113ee6:	41 83 fc 0c          	cmp    $0xc,%r12d
  8042113eea:	0f 8e 92 03 00 00    	jle    8042114282 <LZ4_compress_fast_extState_fastReset+0x1938>
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042113ef0:	48 8d 48 f5          	lea    -0xb(%rax),%rcx
  8042113ef4:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042113ef8:	48 83 e8 05          	sub    $0x5,%rax
  8042113efc:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113f00:	69 06 b1 79 37 9e    	imul   $0x9e3779b1,(%rsi),%eax
  8042113f06:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042113f09:	89 c0                	mov    %eax,%eax
  8042113f0b:	66 41 c7 04 47 00 00 	movw   $0x0,(%r15,%rax,2)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042113f12:	48 8d 4e 01          	lea    0x1(%rsi),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113f16:	69 56 01 b1 79 37 9e 	imul   $0x9e3779b1,0x1(%rsi),%edx
  8042113f1d:	c1 ea 13             	shr    $0x13,%edx
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042113f20:	c1 e3 06             	shl    $0x6,%ebx
  8042113f23:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
            int step = 1;
  8042113f27:	41 89 dd             	mov    %ebx,%r13d
  8042113f2a:	49 89 f4             	mov    %rsi,%r12
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042113f2d:	44 89 ef             	mov    %r13d,%edi
            int step = 1;
  8042113f30:	b8 01 00 00 00       	mov    $0x1,%eax
  8042113f35:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
                U32 const current = (U32)(forwardIp - base);
  8042113f39:	49 89 c9             	mov    %rcx,%r9
  8042113f3c:	4d 29 e1             	sub    %r12,%r9
        return hashTable[h];
  8042113f3f:	89 d2                	mov    %edx,%edx
  8042113f41:	4d 8d 04 57          	lea    (%r15,%rdx,2),%r8
  8042113f45:	41 0f b7 10          	movzwl (%r8),%edx
                forwardIp += step;
  8042113f49:	49 89 ce             	mov    %rcx,%r14
  8042113f4c:	48 98                	cltq
  8042113f4e:	48 01 c1             	add    %rax,%rcx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042113f51:	89 f8                	mov    %edi,%eax
  8042113f53:	83 c7 01             	add    $0x1,%edi
  8042113f56:	c1 f8 06             	sar    $0x6,%eax
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042113f59:	49 39 ca             	cmp    %rcx,%r10
  8042113f5c:	0f 82 2c 03 00 00    	jb     804211428e <LZ4_compress_fast_extState_fastReset+0x1944>
                    match = base + matchIndex;
  8042113f62:	0f b7 d2             	movzwl %dx,%edx
  8042113f65:	49 8d 1c 14          	lea    (%r12,%rdx,1),%rbx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042113f69:	69 11 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%edx
  8042113f6f:	c1 ea 13             	shr    $0x13,%edx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042113f72:	66 45 89 08          	mov    %r9w,(%r8)
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042113f76:	44 8b 1b             	mov    (%rbx),%r11d
  8042113f79:	45 39 1e             	cmp    %r11d,(%r14)
  8042113f7c:	75 bb                	jne    8042113f39 <LZ4_compress_fast_extState_fastReset+0x15ef>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042113f7e:	4c 39 f6             	cmp    %r14,%rsi
  8042113f81:	73 13                	jae    8042113f96 <LZ4_compress_fast_extState_fastReset+0x164c>
  8042113f83:	49 39 dc             	cmp    %rbx,%r12
  8042113f86:	73 0e                	jae    8042113f96 <LZ4_compress_fast_extState_fastReset+0x164c>
  8042113f88:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042113f8c:	41 38 46 ff          	cmp    %al,-0x1(%r14)
  8042113f90:	0f 84 82 00 00 00    	je     8042114018 <LZ4_compress_fast_extState_fastReset+0x16ce>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042113f96:	4c 89 f0             	mov    %r14,%rax
  8042113f99:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  8042113f9c:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8042113fa0:	48 8d 79 01          	lea    0x1(%rcx),%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  8042113fa4:	89 c1                	mov    %eax,%ecx
  8042113fa6:	89 c2                	mov    %eax,%edx
  8042113fa8:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  8042113fae:	49 0f af d0          	imul   %r8,%rdx
  8042113fb2:	48 c1 ea 27          	shr    $0x27,%rdx
  8042113fb6:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  8042113fbb:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  8042113fbe:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8042113fc2:	0f 82 5a 09 00 00    	jb     8042114922 <LZ4_compress_fast_extState_fastReset+0x1fd8>
            if (litLength >= RUN_MASK) {
  8042113fc8:	83 f8 0e             	cmp    $0xe,%eax
  8042113fcb:	77 6a                	ja     8042114037 <LZ4_compress_fast_extState_fastReset+0x16ed>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042113fcd:	c1 e0 04             	shl    $0x4,%eax
  8042113fd0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8042113fd4:	88 02                	mov    %al,(%rdx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042113fd6:	48 8d 04 0f          	lea    (%rdi,%rcx,1),%rax
  8042113fda:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8042113fde:	48 89 c2             	mov    %rax,%rdx
  8042113fe1:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042113fe8:	00 00 00 
  8042113feb:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042113fed:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042113ff1:	48 83 e8 0c          	sub    $0xc,%rax
  8042113ff5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042113ff9:	44 89 ad 78 ff ff ff 	mov    %r13d,-0x88(%rbp)
  8042114000:	48 89 d8             	mov    %rbx,%rax
  8042114003:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
  8042114007:	4c 89 7d 90          	mov    %r15,-0x70(%rbp)
  804211400b:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
  804211400f:	4c 89 65 88          	mov    %r12,-0x78(%rbp)
  8042114013:	e9 fc 00 00 00       	jmp    8042114114 <LZ4_compress_fast_extState_fastReset+0x17ca>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042114018:	49 83 ee 01          	sub    $0x1,%r14
  804211401c:	48 83 eb 01          	sub    $0x1,%rbx
  8042114020:	4c 39 f6             	cmp    %r14,%rsi
  8042114023:	0f 83 6d ff ff ff    	jae    8042113f96 <LZ4_compress_fast_extState_fastReset+0x164c>
  8042114029:	49 39 dc             	cmp    %rbx,%r12
  804211402c:	0f 82 56 ff ff ff    	jb     8042113f88 <LZ4_compress_fast_extState_fastReset+0x163e>
  8042114032:	e9 5f ff ff ff       	jmp    8042113f96 <LZ4_compress_fast_extState_fastReset+0x164c>
                int len = (int)(litLength - RUN_MASK);
  8042114037:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  804211403a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804211403e:	c6 02 f0             	movb   $0xf0,(%rdx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042114041:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042114046:	7e 14                	jle    804211405c <LZ4_compress_fast_extState_fastReset+0x1712>
  8042114048:	48 83 c7 01          	add    $0x1,%rdi
  804211404c:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042114050:	2d ff 00 00 00       	sub    $0xff,%eax
  8042114055:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211405a:	7f ec                	jg     8042114048 <LZ4_compress_fast_extState_fastReset+0x16fe>
                *op++ = (BYTE)len;
  804211405c:	88 07                	mov    %al,(%rdi)
  804211405e:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042114062:	e9 6f ff ff ff       	jmp    8042113fd6 <LZ4_compress_fast_extState_fastReset+0x168c>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042114067:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211406a:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042114071:	00 00 00 
  8042114074:	ff d0                	call   *%rax
  8042114076:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042114079:	44 89 e0             	mov    %r12d,%eax
  804211407c:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042114081:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  8042114088:	00 
  8042114089:	b9 81 80 80 80       	mov    $0x80808081,%ecx
  804211408e:	48 0f af c1          	imul   %rcx,%rax
  8042114092:	48 c1 e8 27          	shr    $0x27,%rax
  8042114096:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  804211409b:	48 39 45 b8          	cmp    %rax,-0x48(%rbp)
  804211409f:	0f 82 87 08 00 00    	jb     804211492c <LZ4_compress_fast_extState_fastReset+0x1fe2>
            if (matchCode >= ML_MASK) {
  80421140a5:	41 83 fc 0e          	cmp    $0xe,%r12d
  80421140a9:	0f 87 4a 01 00 00    	ja     80421141f9 <LZ4_compress_fast_extState_fastReset+0x18af>
                *token += (BYTE)(matchCode);
  80421140af:	45 00 27             	add    %r12b,(%r15)
  80421140b2:	4d 89 ef             	mov    %r13,%r15
        if (ip >= mflimitPlusOne) break;
  80421140b5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80421140b9:	49 39 c6             	cmp    %rax,%r14
  80421140bc:	0f 83 61 02 00 00    	jae    8042114323 <LZ4_compress_fast_extState_fastReset+0x19d9>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421140c2:	41 69 46 fe b1 79 37 	imul   $0x9e3779b1,-0x2(%r14),%eax
  80421140c9:	9e 
  80421140ca:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  80421140cd:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  80421140cf:	49 8d 56 fe          	lea    -0x2(%r14),%rdx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  80421140d3:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
  80421140d7:	48 29 da             	sub    %rbx,%rdx
  80421140da:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  80421140de:	66 89 14 41          	mov    %dx,(%rcx,%rax,2)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421140e2:	41 69 06 b1 79 37 9e 	imul   $0x9e3779b1,(%r14),%eax
  80421140e9:	c1 e8 13             	shr    $0x13,%eax
        return hashTable[h];
  80421140ec:	89 c0                	mov    %eax,%eax
  80421140ee:	48 8d 14 41          	lea    (%rcx,%rax,2),%rdx
                match = base + matchIndex;
  80421140f2:	0f b7 02             	movzwl (%rdx),%eax
  80421140f5:	48 01 d8             	add    %rbx,%rax
            U32 const current = (U32)(ip-base);
  80421140f8:	4c 89 f1             	mov    %r14,%rcx
  80421140fb:	48 29 d9             	sub    %rbx,%rcx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  80421140fe:	66 89 0a             	mov    %cx,(%rdx)
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042114101:	8b 18                	mov    (%rax),%ebx
  8042114103:	41 39 1e             	cmp    %ebx,(%r14)
  8042114106:	0f 85 4c 01 00 00    	jne    8042114258 <LZ4_compress_fast_extState_fastReset+0x190e>
                token=op++;
  804211410c:	49 8d 5f 01          	lea    0x1(%r15),%rbx
                *token=0;
  8042114110:	41 c6 07 00          	movb   $0x0,(%r15)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042114114:	4c 89 f2             	mov    %r14,%rdx
  8042114117:	48 29 c2             	sub    %rax,%rdx
  804211411a:	66 89 13             	mov    %dx,(%rbx)
  804211411d:	4c 8d 6b 02          	lea    0x2(%rbx),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042114121:	49 8d 4e 04          	lea    0x4(%r14),%rcx
  8042114125:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042114129:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  804211412d:	48 39 f1             	cmp    %rsi,%rcx
  8042114130:	73 5b                	jae    804211418d <LZ4_compress_fast_extState_fastReset+0x1843>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042114132:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042114136:	49 8b 7e 04          	mov    0x4(%r14),%rdi
        if (!diff) {
  804211413a:	48 39 d7             	cmp    %rdx,%rdi
  804211413d:	0f 85 24 ff ff ff    	jne    8042114067 <LZ4_compress_fast_extState_fastReset+0x171d>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042114143:	4d 8d 66 0c          	lea    0xc(%r14),%r12
  8042114147:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211414b:	49 39 f4             	cmp    %rsi,%r12
  804211414e:	73 45                	jae    8042114195 <LZ4_compress_fast_extState_fastReset+0x184b>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042114150:	48 8b 10             	mov    (%rax),%rdx
  8042114153:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042114157:	48 39 d7             	cmp    %rdx,%rdi
  804211415a:	74 1e                	je     804211417a <LZ4_compress_fast_extState_fastReset+0x1830>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211415c:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211415f:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042114166:	00 00 00 
  8042114169:	ff d0                	call   *%rax
  804211416b:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  804211416f:	8b 45 c0             	mov    -0x40(%rbp),%eax
  8042114172:	41 29 c4             	sub    %eax,%r12d
  8042114175:	e9 ff fe ff ff       	jmp    8042114079 <LZ4_compress_fast_extState_fastReset+0x172f>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211417a:	49 83 c4 08          	add    $0x8,%r12
  804211417e:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042114182:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8042114186:	49 39 fc             	cmp    %rdi,%r12
  8042114189:	72 c5                	jb     8042114150 <LZ4_compress_fast_extState_fastReset+0x1806>
  804211418b:	eb 08                	jmp    8042114195 <LZ4_compress_fast_extState_fastReset+0x184b>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211418d:	48 83 c0 04          	add    $0x4,%rax
  8042114191:	4c 8b 65 c0          	mov    -0x40(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042114195:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8042114199:	48 8d 57 f8          	lea    -0x8(%rdi),%rdx
  804211419d:	49 39 d4             	cmp    %rdx,%r12
  80421141a0:	73 08                	jae    80421141aa <LZ4_compress_fast_extState_fastReset+0x1860>
  80421141a2:	8b 38                	mov    (%rax),%edi
  80421141a4:	41 39 3c 24          	cmp    %edi,(%r12)
  80421141a8:	74 3b                	je     80421141e5 <LZ4_compress_fast_extState_fastReset+0x189b>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421141aa:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80421141ae:	48 8d 51 fa          	lea    -0x6(%rcx),%rdx
  80421141b2:	49 39 d4             	cmp    %rdx,%r12
  80421141b5:	73 0a                	jae    80421141c1 <LZ4_compress_fast_extState_fastReset+0x1877>
  80421141b7:	0f b7 30             	movzwl (%rax),%esi
  80421141ba:	66 41 39 34 24       	cmp    %si,(%r12)
  80421141bf:	74 2e                	je     80421141ef <LZ4_compress_fast_extState_fastReset+0x18a5>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  80421141c1:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  80421141c5:	49 39 f4             	cmp    %rsi,%r12
  80421141c8:	73 10                	jae    80421141da <LZ4_compress_fast_extState_fastReset+0x1890>
  80421141ca:	41 0f b6 0c 24       	movzbl (%r12),%ecx
  80421141cf:	38 08                	cmp    %cl,(%rax)
  80421141d1:	0f 94 c0             	sete   %al
  80421141d4:	0f b6 c0             	movzbl %al,%eax
  80421141d7:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  80421141da:	8b 45 c0             	mov    -0x40(%rbp),%eax
  80421141dd:	41 29 c4             	sub    %eax,%r12d
  80421141e0:	e9 94 fe ff ff       	jmp    8042114079 <LZ4_compress_fast_extState_fastReset+0x172f>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421141e5:	49 83 c4 04          	add    $0x4,%r12
  80421141e9:	48 83 c0 04          	add    $0x4,%rax
  80421141ed:	eb bb                	jmp    80421141aa <LZ4_compress_fast_extState_fastReset+0x1860>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421141ef:	49 83 c4 02          	add    $0x2,%r12
  80421141f3:	48 83 c0 02          	add    $0x2,%rax
  80421141f7:	eb c8                	jmp    80421141c1 <LZ4_compress_fast_extState_fastReset+0x1877>
                *token += ML_MASK;
  80421141f9:	41 80 07 0f          	addb   $0xf,(%r15)
                matchCode -= ML_MASK;
  80421141fd:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042114201:	c7 43 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rbx)
                while (matchCode >= 4*255) {
  8042114208:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  804211420f:	76 1c                	jbe    804211422d <LZ4_compress_fast_extState_fastReset+0x18e3>
                    op+=4;
  8042114211:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042114215:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  804211421c:	ff 
                    matchCode -= 4*255;
  804211421d:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  8042114224:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  804211422b:	77 e4                	ja     8042114211 <LZ4_compress_fast_extState_fastReset+0x18c7>
                op += matchCode / 255;
  804211422d:	44 89 e0             	mov    %r12d,%eax
  8042114230:	bb 81 80 80 80       	mov    $0x80808081,%ebx
  8042114235:	48 0f af c3          	imul   %rbx,%rax
  8042114239:	48 c1 e8 27          	shr    $0x27,%rax
  804211423d:	89 c2                	mov    %eax,%edx
  804211423f:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042114242:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
  8042114246:	89 c1                	mov    %eax,%ecx
  8042114248:	c1 e1 08             	shl    $0x8,%ecx
  804211424b:	29 c1                	sub    %eax,%ecx
  804211424d:	41 29 cc             	sub    %ecx,%r12d
  8042114250:	44 88 22             	mov    %r12b,(%rdx)
  8042114253:	e9 5d fe ff ff       	jmp    80421140b5 <LZ4_compress_fast_extState_fastReset+0x176b>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042114258:	44 8b ad 78 ff ff ff 	mov    -0x88(%rbp),%r13d
  804211425f:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
  8042114263:	4c 8b 7d 90          	mov    -0x70(%rbp),%r15
  8042114267:	4c 8b 65 88          	mov    -0x78(%rbp),%r12
  804211426b:	49 8d 4e 01          	lea    0x1(%r14),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  804211426f:	41 69 56 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r14),%edx
  8042114276:	9e 
  8042114277:	c1 ea 13             	shr    $0x13,%edx
  804211427a:	4c 89 f6             	mov    %r14,%rsi
  804211427d:	e9 ab fc ff ff       	jmp    8042113f2d <LZ4_compress_fast_extState_fastReset+0x15e3>
    BYTE* op = (BYTE*) dest;
  8042114282:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042114286:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  804211428a:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    {   size_t lastRun = (size_t)(iend - anchor);
  804211428e:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
  8042114292:	48 29 f3             	sub    %rsi,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  8042114295:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  804211429c:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  80421142a3:	80 80 80 
  80421142a6:	48 89 d0             	mov    %rdx,%rax
  80421142a9:	48 f7 e1             	mul    %rcx
  80421142ac:	48 c1 ea 07          	shr    $0x7,%rdx
  80421142b0:	48 8d 54 13 01       	lea    0x1(%rbx,%rdx,1),%rdx
  80421142b5:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  80421142b9:	48 01 fa             	add    %rdi,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  80421142bc:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  80421142c1:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  80421142c5:	0f 82 b8 f5 ff ff    	jb     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
        if (lastRun >= RUN_MASK) {
  80421142cb:	48 83 fb 0e          	cmp    $0xe,%rbx
  80421142cf:	76 5e                	jbe    804211432f <LZ4_compress_fast_extState_fastReset+0x19e5>
            size_t accumulator = lastRun - RUN_MASK;
  80421142d1:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  80421142d5:	48 8d 47 01          	lea    0x1(%rdi),%rax
  80421142d9:	c6 07 f0             	movb   $0xf0,(%rdi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  80421142dc:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421142e3:	76 18                	jbe    80421142fd <LZ4_compress_fast_extState_fastReset+0x19b3>
  80421142e5:	48 83 c0 01          	add    $0x1,%rax
  80421142e9:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  80421142ed:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  80421142f4:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421142fb:	77 e8                	ja     80421142e5 <LZ4_compress_fast_extState_fastReset+0x199b>
            *op++ = (BYTE) accumulator;
  80421142fd:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8042114301:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042114303:	48 89 da             	mov    %rbx,%rdx
  8042114306:	4c 89 e7             	mov    %r12,%rdi
  8042114309:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042114310:	00 00 00 
  8042114313:	ff d0                	call   *%rax
        op += lastRun;
  8042114315:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  8042114319:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  804211431c:	29 d8                	sub    %ebx,%eax
    return result;
  804211431e:	e9 60 f5 ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
        anchor = ip;
  8042114323:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
  8042114327:	4c 89 f6             	mov    %r14,%rsi
  804211432a:	e9 5f ff ff ff       	jmp    804211428e <LZ4_compress_fast_extState_fastReset+0x1944>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  804211432f:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8042114333:	4c 8d 67 01          	lea    0x1(%rdi),%r12
  8042114337:	89 d8                	mov    %ebx,%eax
  8042114339:	c1 e0 04             	shl    $0x4,%eax
  804211433c:	88 07                	mov    %al,(%rdi)
  804211433e:	eb c3                	jmp    8042114303 <LZ4_compress_fast_extState_fastReset+0x19b9>
    if (cctx->dirty) {
  8042114340:	66 41 83 bf 04 40 00 	cmpw   $0x0,0x4004(%r15)
  8042114347:	00 00 
  8042114349:	75 3b                	jne    8042114386 <LZ4_compress_fast_extState_fastReset+0x1a3c>
    if (cctx->tableType != clearedTable) {
  804211434b:	66 41 83 bf 06 40 00 	cmpw   $0x0,0x4006(%r15)
  8042114352:	00 00 
  8042114354:	74 4b                	je     80421143a1 <LZ4_compress_fast_extState_fastReset+0x1a57>
            MEM_INIT(cctx->hashTable, 0, LZ4_HASHTABLESIZE);
  8042114356:	ba 00 40 00 00       	mov    $0x4000,%edx
  804211435b:	be 00 00 00 00       	mov    $0x0,%esi
  8042114360:	4c 89 ff             	mov    %r15,%rdi
  8042114363:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  804211436a:	00 00 00 
  804211436d:	ff d0                	call   *%rax
            cctx->currentOffset = 0;
  804211436f:	41 c7 87 00 40 00 00 	movl   $0x0,0x4000(%r15)
  8042114376:	00 00 00 00 
            cctx->tableType = clearedTable;
  804211437a:	66 41 c7 87 06 40 00 	movw   $0x0,0x4006(%r15)
  8042114381:	00 00 00 
    if (cctx->currentOffset != 0 && tableType == byU32) {
  8042114384:	eb 32                	jmp    80421143b8 <LZ4_compress_fast_extState_fastReset+0x1a6e>
        MEM_INIT(cctx, 0, sizeof(LZ4_stream_t_internal));
  8042114386:	ba 20 40 00 00       	mov    $0x4020,%edx
  804211438b:	be 00 00 00 00       	mov    $0x0,%esi
  8042114390:	4c 89 ff             	mov    %r15,%rdi
  8042114393:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  804211439a:	00 00 00 
  804211439d:	ff d0                	call   *%rax
        return;
  804211439f:	eb 38                	jmp    80421143d9 <LZ4_compress_fast_extState_fastReset+0x1a8f>
    if (cctx->currentOffset != 0 && tableType == byU32) {
  80421143a1:	41 8b 87 00 40 00 00 	mov    0x4000(%r15),%eax
  80421143a8:	85 c0                	test   %eax,%eax
  80421143aa:	74 0c                	je     80421143b8 <LZ4_compress_fast_extState_fastReset+0x1a6e>
        cctx->currentOffset += 64 KB;
  80421143ac:	05 00 00 01 00       	add    $0x10000,%eax
  80421143b1:	41 89 87 00 40 00 00 	mov    %eax,0x4000(%r15)
    cctx->dictCtx = NULL;
  80421143b8:	49 c7 87 10 40 00 00 	movq   $0x0,0x4010(%r15)
  80421143bf:	00 00 00 00 
    cctx->dictionary = NULL;
  80421143c3:	49 c7 87 08 40 00 00 	movq   $0x0,0x4008(%r15)
  80421143ca:	00 00 00 00 
    cctx->dictSize = 0;
  80421143ce:	41 c7 87 18 40 00 00 	movl   $0x0,0x4018(%r15)
  80421143d5:	00 00 00 00 
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  80421143d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80421143de:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  80421143e5:	0f 87 98 f4 ff ff    	ja     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
    U32 const startIndex = cctx->currentOffset;
  80421143eb:	45 8b b7 00 40 00 00 	mov    0x4000(%r15),%r14d
    const BYTE* base = (const BYTE*) source - startIndex;
  80421143f2:	44 89 f0             	mov    %r14d,%eax
  80421143f5:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80421143f9:	48 89 f7             	mov    %rsi,%rdi
  80421143fc:	48 29 c7             	sub    %rax,%rdi
  80421143ff:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    const BYTE* const iend = ip + inputSize;
  8042114403:	49 63 c4             	movslq %r12d,%rax
  8042114406:	48 01 f0             	add    %rsi,%rax
  8042114409:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  804211440d:	48 8d 48 f5          	lea    -0xb(%rax),%rcx
  8042114411:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042114415:	48 83 e8 05          	sub    $0x5,%rax
  8042114419:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  8042114420:	4d 63 ed             	movslq %r13d,%r13
  8042114423:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042114427:	4a 8d 0c 28          	lea    (%rax,%r13,1),%rcx
  804211442b:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
        cctx->dictSize += (U32)inputSize;
  804211442f:	45 01 a7 18 40 00 00 	add    %r12d,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  8042114436:	45 01 f4             	add    %r14d,%r12d
  8042114439:	45 89 a7 00 40 00 00 	mov    %r12d,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042114440:	66 41 c7 87 06 40 00 	movw   $0x2,0x4006(%r15)
  8042114447:	00 02 00 
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211444a:	49 89 f5             	mov    %rsi,%r13
  804211444d:	48 8b 3e             	mov    (%rsi),%rdi
  8042114450:	be 02 00 00 00       	mov    $0x2,%esi
  8042114455:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  804211445c:	00 00 00 
  804211445f:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042114462:	89 c0                	mov    %eax,%eax
  8042114464:	45 89 34 87          	mov    %r14d,(%r15,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042114468:	4d 89 ee             	mov    %r13,%r14
  804211446b:	4d 8d 6d 01          	lea    0x1(%r13),%r13
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211446f:	49 8b 7e 01          	mov    0x1(%r14),%rdi
  8042114473:	be 02 00 00 00       	mov    $0x2,%esi
  8042114478:	41 ff d4             	call   *%r12
  804211447b:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211447f:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
  8042114483:	4c 89 f6             	mov    %r14,%rsi
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042114486:	c1 e3 06             	shl    $0x6,%ebx
  8042114489:	89 9d 78 ff ff ff    	mov    %ebx,-0x88(%rbp)
  804211448f:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  8042114493:	4d 89 ef             	mov    %r13,%r15
                U32 const current = (U32)(forwardIp - base);
  8042114496:	45 89 fe             	mov    %r15d,%r14d
  8042114499:	8b 5d b8             	mov    -0x48(%rbp),%ebx
  804211449c:	41 29 de             	sub    %ebx,%r14d
        return hashTable[h];
  804211449f:	89 c0                	mov    %eax,%eax
  80421144a1:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  80421144a5:	4c 8d 2c 83          	lea    (%rbx,%rax,4),%r13
  80421144a9:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  80421144ad:	4d 8d 67 01          	lea    0x1(%r15),%r12
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421144b1:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  80421144b7:	8d 78 01             	lea    0x1(%rax),%edi
  80421144ba:	c1 f8 06             	sar    $0x6,%eax
  80421144bd:	89 45 b0             	mov    %eax,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421144c0:	4c 39 65 a0          	cmp    %r12,-0x60(%rbp)
  80421144c4:	0f 82 9e 03 00 00    	jb     8042114868 <LZ4_compress_fast_extState_fastReset+0x1f1e>
  80421144ca:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
  80421144ce:	41 89 ff             	mov    %edi,%r15d
  80421144d1:	48 89 b5 70 ff ff ff 	mov    %rsi,-0x90(%rbp)
  80421144d8:	eb 3e                	jmp    8042114518 <LZ4_compress_fast_extState_fastReset+0x1bce>
                U32 const current = (U32)(forwardIp - base);
  80421144da:	45 89 e6             	mov    %r12d,%r14d
  80421144dd:	8b 5d b8             	mov    -0x48(%rbp),%ebx
  80421144e0:	41 29 de             	sub    %ebx,%r14d
        return hashTable[h];
  80421144e3:	89 c0                	mov    %eax,%eax
  80421144e5:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  80421144e9:	4c 8d 2c 83          	lea    (%rbx,%rax,4),%r13
  80421144ed:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  80421144f1:	48 63 45 b0          	movslq -0x50(%rbp),%rax
  80421144f5:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421144f8:	41 8d 57 01          	lea    0x1(%r15),%edx
  80421144fc:	41 c1 ff 06          	sar    $0x6,%r15d
  8042114500:	44 89 7d b0          	mov    %r15d,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042114504:	4c 89 65 a8          	mov    %r12,-0x58(%rbp)
  8042114508:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  804211450c:	0f 82 4f 03 00 00    	jb     8042114861 <LZ4_compress_fast_extState_fastReset+0x1f17>
  8042114512:	41 89 d7             	mov    %edx,%r15d
  8042114515:	49 89 c4             	mov    %rax,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042114518:	49 8b 3c 24          	mov    (%r12),%rdi
  804211451c:	be 02 00 00 00       	mov    $0x2,%esi
  8042114521:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042114528:	00 00 00 
  804211452b:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211452d:	45 89 75 00          	mov    %r14d,0x0(%r13)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  8042114531:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  8042114537:	44 39 f2             	cmp    %r14d,%edx
  804211453a:	72 9e                	jb     80421144da <LZ4_compress_fast_extState_fastReset+0x1b90>
                    match = base + matchIndex;
  804211453c:	89 db                	mov    %ebx,%ebx
  804211453e:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042114542:	48 01 cb             	add    %rcx,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042114545:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8042114549:	8b 0b                	mov    (%rbx),%ecx
  804211454b:	39 0f                	cmp    %ecx,(%rdi)
  804211454d:	75 8b                	jne    80421144da <LZ4_compress_fast_extState_fastReset+0x1b90>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211454f:	49 89 ff             	mov    %rdi,%r15
  8042114552:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
  8042114559:	48 39 fe             	cmp    %rdi,%rsi
  804211455c:	73 10                	jae    804211456e <LZ4_compress_fast_extState_fastReset+0x1c24>
  804211455e:	48 39 5d c0          	cmp    %rbx,-0x40(%rbp)
  8042114562:	73 0a                	jae    804211456e <LZ4_compress_fast_extState_fastReset+0x1c24>
  8042114564:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042114568:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  804211456c:	74 6b                	je     80421145d9 <LZ4_compress_fast_extState_fastReset+0x1c8f>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  804211456e:	4c 89 f8             	mov    %r15,%rax
  8042114571:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  8042114574:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  8042114578:	48 83 c7 01          	add    $0x1,%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  804211457c:	89 c1                	mov    %eax,%ecx
  804211457e:	89 c2                	mov    %eax,%edx
  8042114580:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  8042114586:	49 0f af d0          	imul   %r8,%rdx
  804211458a:	48 c1 ea 27          	shr    $0x27,%rdx
  804211458e:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  8042114593:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  8042114596:	48 39 55 90          	cmp    %rdx,-0x70(%rbp)
  804211459a:	0f 82 96 03 00 00    	jb     8042114936 <LZ4_compress_fast_extState_fastReset+0x1fec>
            if (litLength >= RUN_MASK) {
  80421145a0:	83 f8 0e             	cmp    $0xe,%eax
  80421145a3:	77 50                	ja     80421145f5 <LZ4_compress_fast_extState_fastReset+0x1cab>
            else *token = (BYTE)(litLength<<ML_BITS);
  80421145a5:	c1 e0 04             	shl    $0x4,%eax
  80421145a8:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80421145ac:	88 02                	mov    %al,(%rdx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  80421145ae:	4c 8d 34 0f          	lea    (%rdi,%rcx,1),%r14
  80421145b2:	4c 89 f2             	mov    %r14,%rdx
  80421145b5:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  80421145bc:	00 00 00 
  80421145bf:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421145c1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80421145c5:	48 83 e8 0c          	sub    $0xc,%rax
  80421145c9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421145cd:	48 89 d8             	mov    %rbx,%rax
  80421145d0:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
  80421145d4:	e9 0f 01 00 00       	jmp    80421146e8 <LZ4_compress_fast_extState_fastReset+0x1d9e>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  80421145d9:	49 83 ef 01          	sub    $0x1,%r15
  80421145dd:	48 83 eb 01          	sub    $0x1,%rbx
  80421145e1:	4c 39 fe             	cmp    %r15,%rsi
  80421145e4:	73 88                	jae    804211456e <LZ4_compress_fast_extState_fastReset+0x1c24>
  80421145e6:	48 39 5d c0          	cmp    %rbx,-0x40(%rbp)
  80421145ea:	0f 82 74 ff ff ff    	jb     8042114564 <LZ4_compress_fast_extState_fastReset+0x1c1a>
  80421145f0:	e9 79 ff ff ff       	jmp    804211456e <LZ4_compress_fast_extState_fastReset+0x1c24>
                int len = (int)(litLength - RUN_MASK);
  80421145f5:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  80421145f8:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80421145fc:	c6 02 f0             	movb   $0xf0,(%rdx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  80421145ff:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042114604:	7e 14                	jle    804211461a <LZ4_compress_fast_extState_fastReset+0x1cd0>
  8042114606:	48 83 c7 01          	add    $0x1,%rdi
  804211460a:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  804211460e:	2d ff 00 00 00       	sub    $0xff,%eax
  8042114613:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042114618:	7f ec                	jg     8042114606 <LZ4_compress_fast_extState_fastReset+0x1cbc>
                *op++ = (BYTE)len;
  804211461a:	88 07                	mov    %al,(%rdi)
  804211461c:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042114620:	eb 8c                	jmp    80421145ae <LZ4_compress_fast_extState_fastReset+0x1c64>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042114622:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042114625:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211462c:	00 00 00 
  804211462f:	ff d0                	call   *%rax
  8042114631:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042114634:	44 89 e0             	mov    %r12d,%eax
  8042114637:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  804211463c:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  8042114643:	00 
  8042114644:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042114649:	48 0f af c6          	imul   %rsi,%rax
  804211464d:	48 c1 e8 27          	shr    $0x27,%rax
  8042114651:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042114656:	48 39 45 90          	cmp    %rax,-0x70(%rbp)
  804211465a:	0f 82 e0 02 00 00    	jb     8042114940 <LZ4_compress_fast_extState_fastReset+0x1ff6>
            if (matchCode >= ML_MASK) {
  8042114660:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042114664:	0f 87 67 01 00 00    	ja     80421147d1 <LZ4_compress_fast_extState_fastReset+0x1e87>
                *token += (BYTE)(matchCode);
  804211466a:	44 00 23             	add    %r12b,(%rbx)
  804211466d:	4c 89 eb             	mov    %r13,%rbx
        if (ip >= mflimitPlusOne) break;
  8042114670:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042114674:	49 39 c7             	cmp    %rax,%r15
  8042114677:	0f 83 db 01 00 00    	jae    8042114858 <LZ4_compress_fast_extState_fastReset+0x1f0e>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211467d:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  8042114681:	be 02 00 00 00       	mov    $0x2,%esi
  8042114686:	49 bd ce 28 11 42 80 	movabs $0x80421128ce,%r13
  804211468d:	00 00 00 
  8042114690:	41 ff d5             	call   *%r13
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042114693:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042114695:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042114699:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
  804211469d:	4c 29 f2             	sub    %r14,%rdx
  80421146a0:	4c 8b 65 98          	mov    -0x68(%rbp),%r12
  80421146a4:	41 89 14 84          	mov    %edx,(%r12,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421146a8:	49 8b 3f             	mov    (%r15),%rdi
  80421146ab:	be 02 00 00 00       	mov    $0x2,%esi
  80421146b0:	41 ff d5             	call   *%r13
            U32 const current = (U32)(ip-base);
  80421146b3:	4c 89 f9             	mov    %r15,%rcx
  80421146b6:	4c 29 f1             	sub    %r14,%rcx
        return hashTable[h];
  80421146b9:	89 c0                	mov    %eax,%eax
  80421146bb:	49 8d 34 84          	lea    (%r12,%rax,4),%rsi
  80421146bf:	8b 16                	mov    (%rsi),%edx
                match = base + matchIndex;
  80421146c1:	89 d0                	mov    %edx,%eax
  80421146c3:	4c 01 f0             	add    %r14,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  80421146c6:	89 0e                	mov    %ecx,(%rsi)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  80421146c8:	81 c2 ff ff 00 00    	add    $0xffff,%edx
  80421146ce:	39 ca                	cmp    %ecx,%edx
  80421146d0:	0f 82 5a 01 00 00    	jb     8042114830 <LZ4_compress_fast_extState_fastReset+0x1ee6>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  80421146d6:	8b 38                	mov    (%rax),%edi
  80421146d8:	41 39 3f             	cmp    %edi,(%r15)
  80421146db:	0f 85 4f 01 00 00    	jne    8042114830 <LZ4_compress_fast_extState_fastReset+0x1ee6>
                token=op++;
  80421146e1:	4c 8d 73 01          	lea    0x1(%rbx),%r14
                *token=0;
  80421146e5:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  80421146e8:	4c 89 fa             	mov    %r15,%rdx
  80421146eb:	48 29 c2             	sub    %rax,%rdx
  80421146ee:	66 41 89 16          	mov    %dx,(%r14)
  80421146f2:	4d 8d 6e 02          	lea    0x2(%r14),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  80421146f6:	49 8d 4f 04          	lea    0x4(%r15),%rcx
  80421146fa:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421146fe:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  8042114702:	48 39 f1             	cmp    %rsi,%rcx
  8042114705:	73 5b                	jae    8042114762 <LZ4_compress_fast_extState_fastReset+0x1e18>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042114707:	48 8b 50 04          	mov    0x4(%rax),%rdx
  804211470b:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211470f:	48 39 d7             	cmp    %rdx,%rdi
  8042114712:	0f 85 0a ff ff ff    	jne    8042114622 <LZ4_compress_fast_extState_fastReset+0x1cd8>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042114718:	4d 8d 67 0c          	lea    0xc(%r15),%r12
  804211471c:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042114720:	49 39 f4             	cmp    %rsi,%r12
  8042114723:	73 45                	jae    804211476a <LZ4_compress_fast_extState_fastReset+0x1e20>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042114725:	48 8b 10             	mov    (%rax),%rdx
  8042114728:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211472c:	48 39 d7             	cmp    %rdx,%rdi
  804211472f:	74 1e                	je     804211474f <LZ4_compress_fast_extState_fastReset+0x1e05>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042114731:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042114734:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211473b:	00 00 00 
  804211473e:	ff d0                	call   *%rax
  8042114740:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  8042114744:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042114747:	41 29 c4             	sub    %eax,%r12d
  804211474a:	e9 e5 fe ff ff       	jmp    8042114634 <LZ4_compress_fast_extState_fastReset+0x1cea>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211474f:	49 83 c4 08          	add    $0x8,%r12
  8042114753:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042114757:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  804211475b:	49 39 f4             	cmp    %rsi,%r12
  804211475e:	72 c5                	jb     8042114725 <LZ4_compress_fast_extState_fastReset+0x1ddb>
  8042114760:	eb 08                	jmp    804211476a <LZ4_compress_fast_extState_fastReset+0x1e20>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042114762:	48 83 c0 04          	add    $0x4,%rax
  8042114766:	4c 8b 65 b0          	mov    -0x50(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211476a:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804211476e:	48 8d 57 f8          	lea    -0x8(%rdi),%rdx
  8042114772:	49 39 d4             	cmp    %rdx,%r12
  8042114775:	73 08                	jae    804211477f <LZ4_compress_fast_extState_fastReset+0x1e35>
  8042114777:	8b 30                	mov    (%rax),%esi
  8042114779:	41 39 34 24          	cmp    %esi,(%r12)
  804211477d:	74 3e                	je     80421147bd <LZ4_compress_fast_extState_fastReset+0x1e73>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211477f:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  8042114783:	48 8d 56 fa          	lea    -0x6(%rsi),%rdx
  8042114787:	49 39 d4             	cmp    %rdx,%r12
  804211478a:	73 0a                	jae    8042114796 <LZ4_compress_fast_extState_fastReset+0x1e4c>
  804211478c:	0f b7 38             	movzwl (%rax),%edi
  804211478f:	66 41 39 3c 24       	cmp    %di,(%r12)
  8042114794:	74 31                	je     80421147c7 <LZ4_compress_fast_extState_fastReset+0x1e7d>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042114796:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  804211479d:	49 39 cc             	cmp    %rcx,%r12
  80421147a0:	73 10                	jae    80421147b2 <LZ4_compress_fast_extState_fastReset+0x1e68>
  80421147a2:	41 0f b6 0c 24       	movzbl (%r12),%ecx
  80421147a7:	38 08                	cmp    %cl,(%rax)
  80421147a9:	0f 94 c0             	sete   %al
  80421147ac:	0f b6 c0             	movzbl %al,%eax
  80421147af:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  80421147b2:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80421147b5:	41 29 c4             	sub    %eax,%r12d
  80421147b8:	e9 77 fe ff ff       	jmp    8042114634 <LZ4_compress_fast_extState_fastReset+0x1cea>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421147bd:	49 83 c4 04          	add    $0x4,%r12
  80421147c1:	48 83 c0 04          	add    $0x4,%rax
  80421147c5:	eb b8                	jmp    804211477f <LZ4_compress_fast_extState_fastReset+0x1e35>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421147c7:	49 83 c4 02          	add    $0x2,%r12
  80421147cb:	48 83 c0 02          	add    $0x2,%rax
  80421147cf:	eb c5                	jmp    8042114796 <LZ4_compress_fast_extState_fastReset+0x1e4c>
                *token += ML_MASK;
  80421147d1:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  80421147d4:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421147d8:	41 c7 46 02 ff ff ff 	movl   $0xffffffff,0x2(%r14)
  80421147df:	ff 
                while (matchCode >= 4*255) {
  80421147e0:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  80421147e7:	76 1c                	jbe    8042114805 <LZ4_compress_fast_extState_fastReset+0x1ebb>
                    op+=4;
  80421147e9:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421147ed:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  80421147f4:	ff 
                    matchCode -= 4*255;
  80421147f5:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  80421147fc:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042114803:	77 e4                	ja     80421147e9 <LZ4_compress_fast_extState_fastReset+0x1e9f>
                op += matchCode / 255;
  8042114805:	44 89 e0             	mov    %r12d,%eax
  8042114808:	ba 81 80 80 80       	mov    $0x80808081,%edx
  804211480d:	48 0f af c2          	imul   %rdx,%rax
  8042114811:	48 c1 e8 27          	shr    $0x27,%rax
  8042114815:	89 c2                	mov    %eax,%edx
  8042114817:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  804211481a:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  804211481e:	89 c1                	mov    %eax,%ecx
  8042114820:	c1 e1 08             	shl    $0x8,%ecx
  8042114823:	29 c1                	sub    %eax,%ecx
  8042114825:	41 29 cc             	sub    %ecx,%r12d
  8042114828:	44 88 22             	mov    %r12b,(%rdx)
  804211482b:	e9 40 fe ff ff       	jmp    8042114670 <LZ4_compress_fast_extState_fastReset+0x1d26>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042114830:	48 89 5d 88          	mov    %rbx,-0x78(%rbp)
  8042114834:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042114838:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  804211483c:	be 02 00 00 00       	mov    $0x2,%esi
  8042114841:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042114848:	00 00 00 
  804211484b:	ff d0                	call   *%rax
  804211484d:	4c 89 fe             	mov    %r15,%rsi
  8042114850:	49 89 df             	mov    %rbx,%r15
  8042114853:	e9 3e fc ff ff       	jmp    8042114496 <LZ4_compress_fast_extState_fastReset+0x1b4c>
        anchor = ip;
  8042114858:	4c 89 fe             	mov    %r15,%rsi
  804211485b:	48 89 5d 88          	mov    %rbx,-0x78(%rbp)
  804211485f:	eb 07                	jmp    8042114868 <LZ4_compress_fast_extState_fastReset+0x1f1e>
  8042114861:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
    {   size_t lastRun = (size_t)(iend - anchor);
  8042114868:	48 8b 5d 80          	mov    -0x80(%rbp),%rbx
  804211486c:	48 29 f3             	sub    %rsi,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  804211486f:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  8042114876:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  804211487d:	80 80 80 
  8042114880:	48 89 d0             	mov    %rdx,%rax
  8042114883:	48 f7 e1             	mul    %rcx
  8042114886:	48 c1 ea 07          	shr    $0x7,%rdx
  804211488a:	48 8d 54 13 01       	lea    0x1(%rbx,%rdx,1),%rdx
  804211488f:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  8042114893:	48 01 fa             	add    %rdi,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042114896:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  804211489b:	48 39 55 90          	cmp    %rdx,-0x70(%rbp)
  804211489f:	0f 82 de ef ff ff    	jb     8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
        if (lastRun >= RUN_MASK) {
  80421148a5:	48 83 fb 0e          	cmp    $0xe,%rbx
  80421148a9:	76 52                	jbe    80421148fd <LZ4_compress_fast_extState_fastReset+0x1fb3>
            size_t accumulator = lastRun - RUN_MASK;
  80421148ab:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  80421148af:	48 8d 47 01          	lea    0x1(%rdi),%rax
  80421148b3:	c6 07 f0             	movb   $0xf0,(%rdi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  80421148b6:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421148bd:	76 18                	jbe    80421148d7 <LZ4_compress_fast_extState_fastReset+0x1f8d>
  80421148bf:	48 83 c0 01          	add    $0x1,%rax
  80421148c3:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  80421148c7:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  80421148ce:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421148d5:	77 e8                	ja     80421148bf <LZ4_compress_fast_extState_fastReset+0x1f75>
            *op++ = (BYTE) accumulator;
  80421148d7:	4c 8d 60 01          	lea    0x1(%rax),%r12
  80421148db:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  80421148dd:	48 89 da             	mov    %rbx,%rdx
  80421148e0:	4c 89 e7             	mov    %r12,%rdi
  80421148e3:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421148ea:	00 00 00 
  80421148ed:	ff d0                	call   *%rax
        op += lastRun;
  80421148ef:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  80421148f3:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  80421148f6:	29 d8                	sub    %ebx,%eax
    return result;
  80421148f8:	e9 86 ef ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  80421148fd:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  8042114901:	4c 8d 67 01          	lea    0x1(%rdi),%r12
  8042114905:	89 d8                	mov    %ebx,%eax
  8042114907:	c1 e0 04             	shl    $0x4,%eax
  804211490a:	88 07                	mov    %al,(%rdi)
  804211490c:	eb cf                	jmp    80421148dd <LZ4_compress_fast_extState_fastReset+0x1f93>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211490e:	b8 00 00 00 00       	mov    $0x0,%eax
  8042114913:	e9 6b ef ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042114918:	b8 00 00 00 00       	mov    $0x0,%eax
  804211491d:	e9 61 ef ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042114922:	b8 00 00 00 00       	mov    $0x0,%eax
  8042114927:	e9 57 ef ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211492c:	b8 00 00 00 00       	mov    $0x0,%eax
  8042114931:	e9 4d ef ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042114936:	b8 00 00 00 00       	mov    $0x0,%eax
  804211493b:	e9 43 ef ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042114940:	b8 00 00 00 00       	mov    $0x0,%eax
  8042114945:	e9 39 ef ff ff       	jmp    8042113883 <LZ4_compress_fast_extState_fastReset+0xf39>

000000804211494a <LZ4_initStream>:
{
  804211494a:	f3 0f 1e fa          	endbr64
    if (size < sizeof(LZ4_stream_t)) { return NULL; }
  804211494e:	48 85 ff             	test   %rdi,%rdi
  8042114951:	74 46                	je     8042114999 <LZ4_initStream+0x4f>
{
  8042114953:	55                   	push   %rbp
  8042114954:	48 89 e5             	mov    %rsp,%rbp
  8042114957:	53                   	push   %rbx
  8042114958:	48 83 ec 08          	sub    $0x8,%rsp
  804211495c:	48 89 fb             	mov    %rdi,%rbx
    if (size < sizeof(LZ4_stream_t)) { return NULL; }
  804211495f:	48 81 fe 1f 40 00 00 	cmp    $0x401f,%rsi
  8042114966:	76 2a                	jbe    8042114992 <LZ4_initStream+0x48>
    if (((size_t)buffer) & (LZ4_stream_t_alignment() - 1)) { return NULL; } /* alignment check */
  8042114968:	b8 00 00 00 00       	mov    $0x0,%eax
  804211496d:	40 f6 c7 07          	test   $0x7,%dil
  8042114971:	75 19                	jne    804211498c <LZ4_initStream+0x42>
    MEM_INIT(buffer, 0, sizeof(LZ4_stream_t));
  8042114973:	ba 20 40 00 00       	mov    $0x4020,%edx
  8042114978:	be 00 00 00 00       	mov    $0x0,%esi
  804211497d:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042114984:	00 00 00 
  8042114987:	ff d0                	call   *%rax
    return (LZ4_stream_t*)buffer;
  8042114989:	48 89 d8             	mov    %rbx,%rax
}
  804211498c:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8042114990:	c9                   	leave
  8042114991:	c3                   	ret
    if (size < sizeof(LZ4_stream_t)) { return NULL; }
  8042114992:	b8 00 00 00 00       	mov    $0x0,%eax
  8042114997:	eb f3                	jmp    804211498c <LZ4_initStream+0x42>
  8042114999:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804211499e:	c3                   	ret

000000804211499f <LZ4_compress_fast_extState>:
{
  804211499f:	f3 0f 1e fa          	endbr64
  80421149a3:	55                   	push   %rbp
  80421149a4:	48 89 e5             	mov    %rsp,%rbp
  80421149a7:	41 57                	push   %r15
  80421149a9:	41 56                	push   %r14
  80421149ab:	41 55                	push   %r13
  80421149ad:	41 54                	push   %r12
  80421149af:	53                   	push   %rbx
  80421149b0:	48 83 ec 78          	sub    $0x78,%rsp
  80421149b4:	49 89 f6             	mov    %rsi,%r14
  80421149b7:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80421149bb:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80421149bf:	41 89 cc             	mov    %ecx,%r12d
  80421149c2:	45 89 c5             	mov    %r8d,%r13d
  80421149c5:	44 89 cb             	mov    %r9d,%ebx
    LZ4_stream_t_internal* const ctx = & LZ4_initStream(state, sizeof(LZ4_stream_t)) -> internal_donotuse;
  80421149c8:	be 20 40 00 00       	mov    $0x4020,%esi
  80421149cd:	48 b8 4a 49 11 42 80 	movabs $0x804211494a,%rax
  80421149d4:	00 00 00 
  80421149d7:	ff d0                	call   *%rax
  80421149d9:	49 89 c7             	mov    %rax,%r15
    if (acceleration < 1) acceleration = ACCELERATION_DEFAULT;
  80421149dc:	85 db                	test   %ebx,%ebx
  80421149de:	b8 01 00 00 00       	mov    $0x1,%eax
  80421149e3:	0f 4e d8             	cmovle %eax,%ebx
    if (maxOutputSize >= LZ4_compressBound(inputSize)) {
  80421149e6:	44 89 e7             	mov    %r12d,%edi
  80421149e9:	48 b8 10 29 11 42 80 	movabs $0x8042112910,%rax
  80421149f0:	00 00 00 
  80421149f3:	ff d0                	call   *%rax
  80421149f5:	44 39 e8             	cmp    %r13d,%eax
  80421149f8:	0f 8f 0c 09 00 00    	jg     804211530a <LZ4_compress_fast_extState+0x96b>
        if (inputSize < LZ4_64Klimit) {
  80421149fe:	41 81 fc 0a 00 01 00 	cmp    $0x1000a,%r12d
  8042114a05:	0f 8f 48 04 00 00    	jg     8042114e53 <LZ4_compress_fast_extState+0x4b4>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042114a0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042114a10:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042114a17:	0f 87 0f 04 00 00    	ja     8042114e2c <LZ4_compress_fast_extState+0x48d>
    U32 const startIndex = cctx->currentOffset;
  8042114a1d:	41 8b 97 00 40 00 00 	mov    0x4000(%r15),%edx
    const BYTE* const iend = ip + inputSize;
  8042114a24:	49 63 c4             	movslq %r12d,%rax
  8042114a27:	49 8d 0c 06          	lea    (%r14,%rax,1),%rcx
  8042114a2b:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042114a2f:	45 01 a7 18 40 00 00 	add    %r12d,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  8042114a36:	42 8d 04 22          	lea    (%rdx,%r12,1),%eax
  8042114a3a:	41 89 87 00 40 00 00 	mov    %eax,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042114a41:	66 41 c7 87 06 40 00 	movw   $0x3,0x4006(%r15)
  8042114a48:	00 03 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  8042114a4b:	41 83 fc 0c          	cmp    $0xc,%r12d
  8042114a4f:	0f 8e 69 03 00 00    	jle    8042114dbe <LZ4_compress_fast_extState+0x41f>
    const BYTE* base = (const BYTE*) source - startIndex;
  8042114a55:	89 d0                	mov    %edx,%eax
  8042114a57:	4c 89 f6             	mov    %r14,%rsi
  8042114a5a:	48 29 c6             	sub    %rax,%rsi
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042114a5d:	48 8d 79 f5          	lea    -0xb(%rcx),%rdi
  8042114a61:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042114a65:	48 83 e9 05          	sub    $0x5,%rcx
  8042114a69:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042114a6d:	41 69 06 b1 79 37 9e 	imul   $0x9e3779b1,(%r14),%eax
  8042114a74:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042114a77:	89 c0                	mov    %eax,%eax
  8042114a79:	66 41 89 14 47       	mov    %dx,(%r15,%rax,2)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042114a7e:	49 8d 4e 01          	lea    0x1(%r14),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042114a82:	41 69 56 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r14),%edx
  8042114a89:	9e 
  8042114a8a:	c1 ea 13             	shr    $0x13,%edx
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042114a8d:	c1 e3 06             	shl    $0x6,%ebx
  8042114a90:	41 89 dd             	mov    %ebx,%r13d
  8042114a93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042114a97:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
            int step = 1;
  8042114a9b:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
  8042114a9f:	49 89 f7             	mov    %rsi,%r15
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042114aa2:	44 89 ee             	mov    %r13d,%esi
            int step = 1;
  8042114aa5:	b8 01 00 00 00       	mov    $0x1,%eax
  8042114aaa:	4c 8b 4d a0          	mov    -0x60(%rbp),%r9
  8042114aae:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
                U32 const current = (U32)(forwardIp - base);
  8042114ab2:	49 89 c8             	mov    %rcx,%r8
  8042114ab5:	4d 29 f8             	sub    %r15,%r8
        return hashTable[h];
  8042114ab8:	89 d2                	mov    %edx,%edx
  8042114aba:	49 8d 3c 51          	lea    (%r9,%rdx,2),%rdi
  8042114abe:	0f b7 17             	movzwl (%rdi),%edx
                forwardIp += step;
  8042114ac1:	48 89 cb             	mov    %rcx,%rbx
  8042114ac4:	48 98                	cltq
  8042114ac6:	48 01 c1             	add    %rax,%rcx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042114ac9:	89 f0                	mov    %esi,%eax
  8042114acb:	83 c6 01             	add    $0x1,%esi
  8042114ace:	c1 f8 06             	sar    $0x6,%eax
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042114ad1:	49 39 ca             	cmp    %rcx,%r10
  8042114ad4:	0f 82 f0 02 00 00    	jb     8042114dca <LZ4_compress_fast_extState+0x42b>
                    match = base + matchIndex;
  8042114ada:	0f b7 d2             	movzwl %dx,%edx
  8042114add:	4d 8d 24 17          	lea    (%r15,%rdx,1),%r12
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042114ae1:	69 11 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%edx
  8042114ae7:	c1 ea 13             	shr    $0x13,%edx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042114aea:	66 44 89 07          	mov    %r8w,(%rdi)
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042114aee:	41 8b 3c 24          	mov    (%r12),%edi
  8042114af2:	39 3b                	cmp    %edi,(%rbx)
  8042114af4:	75 bc                	jne    8042114ab2 <LZ4_compress_fast_extState+0x113>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042114af6:	4c 39 65 b0          	cmp    %r12,-0x50(%rbp)
  8042114afa:	73 14                	jae    8042114b10 <LZ4_compress_fast_extState+0x171>
  8042114afc:	49 39 de             	cmp    %rbx,%r14
  8042114aff:	73 0f                	jae    8042114b10 <LZ4_compress_fast_extState+0x171>
  8042114b01:	41 0f b6 44 24 ff    	movzbl -0x1(%r12),%eax
  8042114b07:	38 43 ff             	cmp    %al,-0x1(%rbx)
  8042114b0a:	0f 84 81 00 00 00    	je     8042114b91 <LZ4_compress_fast_extState+0x1f2>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042114b10:	48 89 da             	mov    %rbx,%rdx
  8042114b13:	4c 29 f2             	sub    %r14,%rdx
            token = op++;
  8042114b16:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042114b1a:	48 8d 78 01          	lea    0x1(%rax),%rdi
            if (litLength >= RUN_MASK) {
  8042114b1e:	83 fa 0e             	cmp    $0xe,%edx
  8042114b21:	0f 87 8a 00 00 00    	ja     8042114bb1 <LZ4_compress_fast_extState+0x212>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042114b27:	89 d0                	mov    %edx,%eax
  8042114b29:	c1 e0 04             	shl    $0x4,%eax
  8042114b2c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8042114b30:	88 06                	mov    %al,(%rsi)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042114b32:	89 d2                	mov    %edx,%edx
  8042114b34:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
  8042114b38:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8042114b3f:	48 89 c2             	mov    %rax,%rdx
  8042114b42:	4c 89 f6             	mov    %r14,%rsi
  8042114b45:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042114b4c:	00 00 00 
  8042114b4f:	ff d0                	call   *%rax
  8042114b51:	49 89 de             	mov    %rbx,%r14
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042114b54:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8042114b58:	48 8d 58 f4          	lea    -0xc(%rax),%rbx
  8042114b5c:	48 89 5d b8          	mov    %rbx,-0x48(%rbp)
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042114b60:	48 8d 58 f8          	lea    -0x8(%rax),%rbx
  8042114b64:	48 89 5d 80          	mov    %rbx,-0x80(%rbp)
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042114b68:	48 83 e8 06          	sub    $0x6,%rax
  8042114b6c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                op += matchCode / 255;
  8042114b73:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  8042114b77:	44 89 ad 68 ff ff ff 	mov    %r13d,-0x98(%rbp)
  8042114b7e:	4c 89 e0             	mov    %r12,%rax
  8042114b81:	4c 8b a5 70 ff ff ff 	mov    -0x90(%rbp),%r12
  8042114b88:	4c 8b 7d c0          	mov    -0x40(%rbp),%r15
  8042114b8c:	e9 d6 00 00 00       	jmp    8042114c67 <LZ4_compress_fast_extState+0x2c8>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042114b91:	48 83 eb 01          	sub    $0x1,%rbx
  8042114b95:	49 83 ec 01          	sub    $0x1,%r12
  8042114b99:	49 39 de             	cmp    %rbx,%r14
  8042114b9c:	0f 83 6e ff ff ff    	jae    8042114b10 <LZ4_compress_fast_extState+0x171>
  8042114ba2:	4c 39 65 b0          	cmp    %r12,-0x50(%rbp)
  8042114ba6:	0f 82 55 ff ff ff    	jb     8042114b01 <LZ4_compress_fast_extState+0x162>
  8042114bac:	e9 5f ff ff ff       	jmp    8042114b10 <LZ4_compress_fast_extState+0x171>
                int len = (int)(litLength - RUN_MASK);
  8042114bb1:	8d 42 f1             	lea    -0xf(%rdx),%eax
                *token = (RUN_MASK<<ML_BITS);
  8042114bb4:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8042114bb8:	c6 01 f0             	movb   $0xf0,(%rcx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042114bbb:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042114bc0:	7e 14                	jle    8042114bd6 <LZ4_compress_fast_extState+0x237>
  8042114bc2:	48 83 c7 01          	add    $0x1,%rdi
  8042114bc6:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042114bca:	2d ff 00 00 00       	sub    $0xff,%eax
  8042114bcf:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042114bd4:	7f ec                	jg     8042114bc2 <LZ4_compress_fast_extState+0x223>
                *op++ = (BYTE)len;
  8042114bd6:	88 07                	mov    %al,(%rdi)
  8042114bd8:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042114bdc:	e9 51 ff ff ff       	jmp    8042114b32 <LZ4_compress_fast_extState+0x193>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042114be1:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042114be4:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042114beb:	00 00 00 
  8042114bee:	ff d0                	call   *%rax
  8042114bf0:	89 c3                	mov    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  8042114bf2:	89 d8                	mov    %ebx,%eax
  8042114bf4:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
            if (matchCode >= ML_MASK) {
  8042114bf9:	83 fb 0e             	cmp    $0xe,%ebx
  8042114bfc:	0f 87 3f 01 00 00    	ja     8042114d41 <LZ4_compress_fast_extState+0x3a2>
                *token += (BYTE)(matchCode);
  8042114c02:	41 00 1f             	add    %bl,(%r15)
  8042114c05:	4d 89 ef             	mov    %r13,%r15
        if (ip >= mflimitPlusOne) break;
  8042114c08:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042114c0c:	49 39 c6             	cmp    %rax,%r14
  8042114c0f:	0f 83 26 02 00 00    	jae    8042114e3b <LZ4_compress_fast_extState+0x49c>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042114c15:	41 69 46 fe b1 79 37 	imul   $0x9e3779b1,-0x2(%r14),%eax
  8042114c1c:	9e 
  8042114c1d:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042114c20:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042114c22:	49 8d 56 fe          	lea    -0x2(%r14),%rdx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042114c26:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042114c2a:	48 29 f2             	sub    %rsi,%rdx
  8042114c2d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8042114c31:	66 89 14 41          	mov    %dx,(%rcx,%rax,2)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042114c35:	41 69 06 b1 79 37 9e 	imul   $0x9e3779b1,(%r14),%eax
  8042114c3c:	c1 e8 13             	shr    $0x13,%eax
        return hashTable[h];
  8042114c3f:	89 c0                	mov    %eax,%eax
  8042114c41:	48 8d 14 41          	lea    (%rcx,%rax,2),%rdx
                match = base + matchIndex;
  8042114c45:	0f b7 02             	movzwl (%rdx),%eax
  8042114c48:	48 01 f0             	add    %rsi,%rax
            U32 const current = (U32)(ip-base);
  8042114c4b:	4c 89 f1             	mov    %r14,%rcx
  8042114c4e:	48 29 f1             	sub    %rsi,%rcx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042114c51:	66 89 0a             	mov    %cx,(%rdx)
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042114c54:	8b 30                	mov    (%rax),%esi
  8042114c56:	41 39 36             	cmp    %esi,(%r14)
  8042114c59:	0f 85 3c 01 00 00    	jne    8042114d9b <LZ4_compress_fast_extState+0x3fc>
                token=op++;
  8042114c5f:	4d 8d 67 01          	lea    0x1(%r15),%r12
                *token=0;
  8042114c63:	41 c6 07 00          	movb   $0x0,(%r15)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042114c67:	4c 89 f2             	mov    %r14,%rdx
  8042114c6a:	48 29 c2             	sub    %rax,%rdx
  8042114c6d:	66 41 89 14 24       	mov    %dx,(%r12)
  8042114c72:	4d 8d 6c 24 02       	lea    0x2(%r12),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042114c77:	49 8d 4e 04          	lea    0x4(%r14),%rcx
  8042114c7b:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042114c7f:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042114c83:	48 39 f1             	cmp    %rsi,%rcx
  8042114c86:	73 58                	jae    8042114ce0 <LZ4_compress_fast_extState+0x341>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042114c88:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042114c8c:	49 8b 7e 04          	mov    0x4(%r14),%rdi
        if (!diff) {
  8042114c90:	48 39 d7             	cmp    %rdx,%rdi
  8042114c93:	0f 85 48 ff ff ff    	jne    8042114be1 <LZ4_compress_fast_extState+0x242>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042114c99:	49 8d 5e 0c          	lea    0xc(%r14),%rbx
  8042114c9d:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042114ca1:	48 39 f3             	cmp    %rsi,%rbx
  8042114ca4:	73 42                	jae    8042114ce8 <LZ4_compress_fast_extState+0x349>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042114ca6:	48 8b 10             	mov    (%rax),%rdx
  8042114ca9:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042114cac:	48 39 d7             	cmp    %rdx,%rdi
  8042114caf:	74 1c                	je     8042114ccd <LZ4_compress_fast_extState+0x32e>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042114cb1:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042114cb4:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042114cbb:	00 00 00 
  8042114cbe:	ff d0                	call   *%rax
  8042114cc0:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  8042114cc3:	8b 45 c0             	mov    -0x40(%rbp),%eax
  8042114cc6:	29 c3                	sub    %eax,%ebx
  8042114cc8:	e9 25 ff ff ff       	jmp    8042114bf2 <LZ4_compress_fast_extState+0x253>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042114ccd:	48 83 c3 08          	add    $0x8,%rbx
  8042114cd1:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042114cd5:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042114cd9:	48 39 fb             	cmp    %rdi,%rbx
  8042114cdc:	72 c8                	jb     8042114ca6 <LZ4_compress_fast_extState+0x307>
  8042114cde:	eb 08                	jmp    8042114ce8 <LZ4_compress_fast_extState+0x349>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042114ce0:	48 83 c0 04          	add    $0x4,%rax
  8042114ce4:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042114ce8:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  8042114cec:	48 39 f3             	cmp    %rsi,%rbx
  8042114cef:	73 06                	jae    8042114cf7 <LZ4_compress_fast_extState+0x358>
  8042114cf1:	8b 30                	mov    (%rax),%esi
  8042114cf3:	39 33                	cmp    %esi,(%rbx)
  8042114cf5:	74 36                	je     8042114d2d <LZ4_compress_fast_extState+0x38e>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042114cf7:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  8042114cfe:	48 39 f3             	cmp    %rsi,%rbx
  8042114d01:	73 08                	jae    8042114d0b <LZ4_compress_fast_extState+0x36c>
  8042114d03:	0f b7 30             	movzwl (%rax),%esi
  8042114d06:	66 39 33             	cmp    %si,(%rbx)
  8042114d09:	74 2c                	je     8042114d37 <LZ4_compress_fast_extState+0x398>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042114d0b:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  8042114d0f:	48 39 cb             	cmp    %rcx,%rbx
  8042114d12:	73 0f                	jae    8042114d23 <LZ4_compress_fast_extState+0x384>
  8042114d14:	0f b6 33             	movzbl (%rbx),%esi
  8042114d17:	40 38 30             	cmp    %sil,(%rax)
  8042114d1a:	0f 94 c0             	sete   %al
  8042114d1d:	0f b6 c0             	movzbl %al,%eax
  8042114d20:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  8042114d23:	8b 45 c0             	mov    -0x40(%rbp),%eax
  8042114d26:	29 c3                	sub    %eax,%ebx
  8042114d28:	e9 c5 fe ff ff       	jmp    8042114bf2 <LZ4_compress_fast_extState+0x253>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042114d2d:	48 83 c3 04          	add    $0x4,%rbx
  8042114d31:	48 83 c0 04          	add    $0x4,%rax
  8042114d35:	eb c0                	jmp    8042114cf7 <LZ4_compress_fast_extState+0x358>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042114d37:	48 83 c3 02          	add    $0x2,%rbx
  8042114d3b:	48 83 c0 02          	add    $0x2,%rax
  8042114d3f:	eb ca                	jmp    8042114d0b <LZ4_compress_fast_extState+0x36c>
                *token += ML_MASK;
  8042114d41:	41 80 07 0f          	addb   $0xf,(%r15)
                matchCode -= ML_MASK;
  8042114d45:	83 eb 0f             	sub    $0xf,%ebx
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042114d48:	41 c7 44 24 02 ff ff 	movl   $0xffffffff,0x2(%r12)
  8042114d4f:	ff ff 
                while (matchCode >= 4*255) {
  8042114d51:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  8042114d57:	76 1a                	jbe    8042114d73 <LZ4_compress_fast_extState+0x3d4>
                    op+=4;
  8042114d59:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042114d5d:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  8042114d64:	ff 
                    matchCode -= 4*255;
  8042114d65:	81 eb fc 03 00 00    	sub    $0x3fc,%ebx
                while (matchCode >= 4*255) {
  8042114d6b:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  8042114d71:	77 e6                	ja     8042114d59 <LZ4_compress_fast_extState+0x3ba>
                op += matchCode / 255;
  8042114d73:	89 d8                	mov    %ebx,%eax
  8042114d75:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042114d7a:	48 0f af c6          	imul   %rsi,%rax
  8042114d7e:	48 c1 e8 27          	shr    $0x27,%rax
  8042114d82:	89 c2                	mov    %eax,%edx
  8042114d84:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042114d87:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
  8042114d8b:	89 c1                	mov    %eax,%ecx
  8042114d8d:	c1 e1 08             	shl    $0x8,%ecx
  8042114d90:	29 c1                	sub    %eax,%ecx
  8042114d92:	29 cb                	sub    %ecx,%ebx
  8042114d94:	88 1a                	mov    %bl,(%rdx)
  8042114d96:	e9 6d fe ff ff       	jmp    8042114c08 <LZ4_compress_fast_extState+0x269>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042114d9b:	44 8b ad 68 ff ff ff 	mov    -0x98(%rbp),%r13d
  8042114da2:	4c 89 7d c0          	mov    %r15,-0x40(%rbp)
  8042114da6:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
  8042114daa:	49 8d 4e 01          	lea    0x1(%r14),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042114dae:	41 69 56 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r14),%edx
  8042114db5:	9e 
  8042114db6:	c1 ea 13             	shr    $0x13,%edx
  8042114db9:	e9 e4 fc ff ff       	jmp    8042114aa2 <LZ4_compress_fast_extState+0x103>
    BYTE* op = (BYTE*) dest;
  8042114dbe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042114dc2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  8042114dc6:	4c 8b 75 b0          	mov    -0x50(%rbp),%r14
    {   size_t lastRun = (size_t)(iend - anchor);
  8042114dca:	4c 8b 65 90          	mov    -0x70(%rbp),%r12
  8042114dce:	4d 29 f4             	sub    %r14,%r12
        if (lastRun >= RUN_MASK) {
  8042114dd1:	49 83 fc 0e          	cmp    $0xe,%r12
  8042114dd5:	76 6a                	jbe    8042114e41 <LZ4_compress_fast_extState+0x4a2>
            size_t accumulator = lastRun - RUN_MASK;
  8042114dd7:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042114ddc:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
  8042114de0:	48 8d 43 01          	lea    0x1(%rbx),%rax
  8042114de4:	c6 03 f0             	movb   $0xf0,(%rbx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042114de7:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042114dee:	76 18                	jbe    8042114e08 <LZ4_compress_fast_extState+0x469>
  8042114df0:	48 83 c0 01          	add    $0x1,%rax
  8042114df4:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042114df8:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042114dff:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042114e06:	77 e8                	ja     8042114df0 <LZ4_compress_fast_extState+0x451>
            *op++ = (BYTE) accumulator;
  8042114e08:	48 8d 58 01          	lea    0x1(%rax),%rbx
  8042114e0c:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042114e0e:	4c 89 e2             	mov    %r12,%rdx
  8042114e11:	4c 89 f6             	mov    %r14,%rsi
  8042114e14:	48 89 df             	mov    %rbx,%rdi
  8042114e17:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042114e1e:	00 00 00 
  8042114e21:	ff d0                	call   *%rax
        op += lastRun;
  8042114e23:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
    result = (int)(((char*)op) - dest);
  8042114e27:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  8042114e2a:	29 d8                	sub    %ebx,%eax
}
  8042114e2c:	48 83 c4 78          	add    $0x78,%rsp
  8042114e30:	5b                   	pop    %rbx
  8042114e31:	41 5c                	pop    %r12
  8042114e33:	41 5d                	pop    %r13
  8042114e35:	41 5e                	pop    %r14
  8042114e37:	41 5f                	pop    %r15
  8042114e39:	5d                   	pop    %rbp
  8042114e3a:	c3                   	ret
  8042114e3b:	4c 89 7d c0          	mov    %r15,-0x40(%rbp)
  8042114e3f:	eb 89                	jmp    8042114dca <LZ4_compress_fast_extState+0x42b>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042114e41:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8042114e45:	48 8d 5e 01          	lea    0x1(%rsi),%rbx
  8042114e49:	44 89 e0             	mov    %r12d,%eax
  8042114e4c:	c1 e0 04             	shl    $0x4,%eax
  8042114e4f:	88 06                	mov    %al,(%rsi)
  8042114e51:	eb bb                	jmp    8042114e0e <LZ4_compress_fast_extState+0x46f>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042114e53:	b8 00 00 00 00       	mov    $0x0,%eax
  8042114e58:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042114e5f:	77 cb                	ja     8042114e2c <LZ4_compress_fast_extState+0x48d>
    U32 const startIndex = cctx->currentOffset;
  8042114e61:	45 8b af 00 40 00 00 	mov    0x4000(%r15),%r13d
    const BYTE* base = (const BYTE*) source - startIndex;
  8042114e68:	44 89 e8             	mov    %r13d,%eax
  8042114e6b:	4c 8b 75 b0          	mov    -0x50(%rbp),%r14
  8042114e6f:	4c 89 f7             	mov    %r14,%rdi
  8042114e72:	48 29 c7             	sub    %rax,%rdi
  8042114e75:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
    const BYTE* const iend = ip + inputSize;
  8042114e79:	49 63 c4             	movslq %r12d,%rax
  8042114e7c:	4c 01 f0             	add    %r14,%rax
  8042114e7f:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042114e83:	48 8d 70 f5          	lea    -0xb(%rax),%rsi
  8042114e87:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042114e8b:	48 83 e8 05          	sub    $0x5,%rax
  8042114e8f:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042114e96:	45 01 a7 18 40 00 00 	add    %r12d,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  8042114e9d:	45 01 ec             	add    %r13d,%r12d
  8042114ea0:	45 89 a7 00 40 00 00 	mov    %r12d,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042114ea7:	66 41 c7 87 06 40 00 	movw   $0x2,0x4006(%r15)
  8042114eae:	00 02 00 
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042114eb1:	49 8b 3e             	mov    (%r14),%rdi
  8042114eb4:	be 02 00 00 00       	mov    $0x2,%esi
  8042114eb9:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  8042114ec0:	00 00 00 
  8042114ec3:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042114ec6:	89 c0                	mov    %eax,%eax
  8042114ec8:	45 89 2c 87          	mov    %r13d,(%r15,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042114ecc:	4d 89 f5             	mov    %r14,%r13
  8042114ecf:	4d 8d 76 01          	lea    0x1(%r14),%r14
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042114ed3:	49 8b 7d 01          	mov    0x1(%r13),%rdi
  8042114ed7:	be 02 00 00 00       	mov    $0x2,%esi
  8042114edc:	41 ff d4             	call   *%r12
  8042114edf:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042114ee3:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8042114ee7:	4c 89 ee             	mov    %r13,%rsi
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042114eea:	c1 e3 06             	shl    $0x6,%ebx
  8042114eed:	89 5d 80             	mov    %ebx,-0x80(%rbp)
  8042114ef0:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
  8042114ef4:	4d 89 f7             	mov    %r14,%r15
                U32 const current = (U32)(forwardIp - base);
  8042114ef7:	45 89 fe             	mov    %r15d,%r14d
  8042114efa:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  8042114efd:	41 29 de             	sub    %ebx,%r14d
        return hashTable[h];
  8042114f00:	89 c0                	mov    %eax,%eax
  8042114f02:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
  8042114f06:	4c 8d 2c 83          	lea    (%rbx,%rax,4),%r13
  8042114f0a:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  8042114f0e:	4d 8d 67 01          	lea    0x1(%r15),%r12
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042114f12:	8b 45 80             	mov    -0x80(%rbp),%eax
  8042114f15:	8d 78 01             	lea    0x1(%rax),%edi
  8042114f18:	c1 f8 06             	sar    $0x6,%eax
  8042114f1b:	89 45 b8             	mov    %eax,-0x48(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042114f1e:	4c 39 65 a8          	cmp    %r12,-0x58(%rbp)
  8042114f22:	0f 82 6c 03 00 00    	jb     8042115294 <LZ4_compress_fast_extState+0x8f5>
  8042114f28:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
  8042114f2f:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  8042114f33:	41 89 ff             	mov    %edi,%r15d
  8042114f36:	eb 3e                	jmp    8042114f76 <LZ4_compress_fast_extState+0x5d7>
                U32 const current = (U32)(forwardIp - base);
  8042114f38:	45 89 e6             	mov    %r12d,%r14d
  8042114f3b:	8b 4d c0             	mov    -0x40(%rbp),%ecx
  8042114f3e:	41 29 ce             	sub    %ecx,%r14d
        return hashTable[h];
  8042114f41:	89 c0                	mov    %eax,%eax
  8042114f43:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8042114f47:	4c 8d 2c 81          	lea    (%rcx,%rax,4),%r13
  8042114f4b:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  8042114f4f:	48 63 45 b8          	movslq -0x48(%rbp),%rax
  8042114f53:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042114f56:	41 8d 57 01          	lea    0x1(%r15),%edx
  8042114f5a:	41 c1 ff 06          	sar    $0x6,%r15d
  8042114f5e:	44 89 7d b8          	mov    %r15d,-0x48(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042114f62:	4c 89 65 98          	mov    %r12,-0x68(%rbp)
  8042114f66:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  8042114f6a:	0f 82 1d 03 00 00    	jb     804211528d <LZ4_compress_fast_extState+0x8ee>
  8042114f70:	41 89 d7             	mov    %edx,%r15d
  8042114f73:	49 89 c4             	mov    %rax,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042114f76:	49 8b 3c 24          	mov    (%r12),%rdi
  8042114f7a:	be 02 00 00 00       	mov    $0x2,%esi
  8042114f7f:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042114f86:	00 00 00 
  8042114f89:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042114f8b:	45 89 75 00          	mov    %r14d,0x0(%r13)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  8042114f8f:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  8042114f95:	44 39 f2             	cmp    %r14d,%edx
  8042114f98:	72 9e                	jb     8042114f38 <LZ4_compress_fast_extState+0x599>
                    match = base + matchIndex;
  8042114f9a:	89 db                	mov    %ebx,%ebx
  8042114f9c:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  8042114fa0:	48 01 fb             	add    %rdi,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042114fa3:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042114fa7:	8b 0b                	mov    (%rbx),%ecx
  8042114fa9:	39 0e                	cmp    %ecx,(%rsi)
  8042114fab:	75 8b                	jne    8042114f38 <LZ4_compress_fast_extState+0x599>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042114fad:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  8042114fb4:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
  8042114fb8:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
  8042114fbc:	73 0f                	jae    8042114fcd <LZ4_compress_fast_extState+0x62e>
  8042114fbe:	4c 39 fe             	cmp    %r15,%rsi
  8042114fc1:	73 0a                	jae    8042114fcd <LZ4_compress_fast_extState+0x62e>
  8042114fc3:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042114fc7:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  8042114fcb:	74 61                	je     804211502e <LZ4_compress_fast_extState+0x68f>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042114fcd:	4c 89 fa             	mov    %r15,%rdx
  8042114fd0:	48 29 f2             	sub    %rsi,%rdx
            token = op++;
  8042114fd3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8042114fd7:	48 8d 78 01          	lea    0x1(%rax),%rdi
            if (litLength >= RUN_MASK) {
  8042114fdb:	83 fa 0e             	cmp    $0xe,%edx
  8042114fde:	77 63                	ja     8042115043 <LZ4_compress_fast_extState+0x6a4>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042114fe0:	89 d0                	mov    %edx,%eax
  8042114fe2:	c1 e0 04             	shl    $0x4,%eax
  8042114fe5:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042114fe9:	88 01                	mov    %al,(%rcx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042114feb:	89 d2                	mov    %edx,%edx
  8042114fed:	4c 8d 34 17          	lea    (%rdi,%rdx,1),%r14
  8042114ff1:	4c 89 f2             	mov    %r14,%rdx
  8042114ff4:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042114ffb:	00 00 00 
  8042114ffe:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042115000:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8042115004:	48 8d 70 f4          	lea    -0xc(%rax),%rsi
  8042115008:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211500c:	48 8d 70 f8          	lea    -0x8(%rax),%rsi
  8042115010:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042115017:	48 83 e8 06          	sub    $0x6,%rax
  804211501b:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042115022:	48 89 d8             	mov    %rbx,%rax
  8042115025:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8042115029:	e9 e7 00 00 00       	jmp    8042115115 <LZ4_compress_fast_extState+0x776>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211502e:	49 83 ef 01          	sub    $0x1,%r15
  8042115032:	48 83 eb 01          	sub    $0x1,%rbx
  8042115036:	4c 39 fe             	cmp    %r15,%rsi
  8042115039:	73 92                	jae    8042114fcd <LZ4_compress_fast_extState+0x62e>
  804211503b:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
  804211503f:	72 82                	jb     8042114fc3 <LZ4_compress_fast_extState+0x624>
  8042115041:	eb 8a                	jmp    8042114fcd <LZ4_compress_fast_extState+0x62e>
                int len = (int)(litLength - RUN_MASK);
  8042115043:	8d 42 f1             	lea    -0xf(%rdx),%eax
                *token = (RUN_MASK<<ML_BITS);
  8042115046:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  804211504a:	c6 01 f0             	movb   $0xf0,(%rcx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  804211504d:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042115052:	7e 14                	jle    8042115068 <LZ4_compress_fast_extState+0x6c9>
  8042115054:	48 83 c7 01          	add    $0x1,%rdi
  8042115058:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  804211505c:	2d ff 00 00 00       	sub    $0xff,%eax
  8042115061:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042115066:	7f ec                	jg     8042115054 <LZ4_compress_fast_extState+0x6b5>
                *op++ = (BYTE)len;
  8042115068:	88 07                	mov    %al,(%rdi)
  804211506a:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  804211506e:	e9 78 ff ff ff       	jmp    8042114feb <LZ4_compress_fast_extState+0x64c>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042115073:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042115076:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211507d:	00 00 00 
  8042115080:	ff d0                	call   *%rax
  8042115082:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042115085:	44 89 e0             	mov    %r12d,%eax
  8042115088:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
            if (matchCode >= ML_MASK) {
  804211508d:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042115091:	0f 87 66 01 00 00    	ja     80421151fd <LZ4_compress_fast_extState+0x85e>
                *token += (BYTE)(matchCode);
  8042115097:	44 00 23             	add    %r12b,(%rbx)
  804211509a:	4c 89 eb             	mov    %r13,%rbx
        if (ip >= mflimitPlusOne) break;
  804211509d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80421150a1:	49 39 c7             	cmp    %rax,%r15
  80421150a4:	0f 83 da 01 00 00    	jae    8042115284 <LZ4_compress_fast_extState+0x8e5>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421150aa:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  80421150ae:	be 02 00 00 00       	mov    $0x2,%esi
  80421150b3:	49 bd ce 28 11 42 80 	movabs $0x80421128ce,%r13
  80421150ba:	00 00 00 
  80421150bd:	41 ff d5             	call   *%r13
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  80421150c0:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  80421150c2:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  80421150c6:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
  80421150ca:	4c 29 f2             	sub    %r14,%rdx
  80421150cd:	4c 8b 65 a0          	mov    -0x60(%rbp),%r12
  80421150d1:	41 89 14 84          	mov    %edx,(%r12,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421150d5:	49 8b 3f             	mov    (%r15),%rdi
  80421150d8:	be 02 00 00 00       	mov    $0x2,%esi
  80421150dd:	41 ff d5             	call   *%r13
            U32 const current = (U32)(ip-base);
  80421150e0:	4c 89 f9             	mov    %r15,%rcx
  80421150e3:	4c 29 f1             	sub    %r14,%rcx
        return hashTable[h];
  80421150e6:	89 c0                	mov    %eax,%eax
  80421150e8:	49 8d 34 84          	lea    (%r12,%rax,4),%rsi
  80421150ec:	8b 16                	mov    (%rsi),%edx
                match = base + matchIndex;
  80421150ee:	89 d0                	mov    %edx,%eax
  80421150f0:	4c 01 f0             	add    %r14,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  80421150f3:	89 0e                	mov    %ecx,(%rsi)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  80421150f5:	81 c2 ff ff 00 00    	add    $0xffff,%edx
  80421150fb:	39 ca                	cmp    %ecx,%edx
  80421150fd:	0f 82 59 01 00 00    	jb     804211525c <LZ4_compress_fast_extState+0x8bd>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042115103:	8b 38                	mov    (%rax),%edi
  8042115105:	41 39 3f             	cmp    %edi,(%r15)
  8042115108:	0f 85 4e 01 00 00    	jne    804211525c <LZ4_compress_fast_extState+0x8bd>
                token=op++;
  804211510e:	4c 8d 73 01          	lea    0x1(%rbx),%r14
                *token=0;
  8042115112:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042115115:	4c 89 fa             	mov    %r15,%rdx
  8042115118:	48 29 c2             	sub    %rax,%rdx
  804211511b:	66 41 89 16          	mov    %dx,(%r14)
  804211511f:	4d 8d 6e 02          	lea    0x2(%r14),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042115123:	49 8d 4f 04          	lea    0x4(%r15),%rcx
  8042115127:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211512b:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  804211512f:	48 39 f1             	cmp    %rsi,%rcx
  8042115132:	73 5b                	jae    804211518f <LZ4_compress_fast_extState+0x7f0>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042115134:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042115138:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211513c:	48 39 d7             	cmp    %rdx,%rdi
  804211513f:	0f 85 2e ff ff ff    	jne    8042115073 <LZ4_compress_fast_extState+0x6d4>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042115145:	4d 8d 67 0c          	lea    0xc(%r15),%r12
  8042115149:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211514d:	49 39 f4             	cmp    %rsi,%r12
  8042115150:	73 45                	jae    8042115197 <LZ4_compress_fast_extState+0x7f8>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042115152:	48 8b 10             	mov    (%rax),%rdx
  8042115155:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042115159:	48 39 d7             	cmp    %rdx,%rdi
  804211515c:	74 1e                	je     804211517c <LZ4_compress_fast_extState+0x7dd>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211515e:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042115161:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042115168:	00 00 00 
  804211516b:	ff d0                	call   *%rax
  804211516d:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  8042115171:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042115174:	41 29 c4             	sub    %eax,%r12d
  8042115177:	e9 09 ff ff ff       	jmp    8042115085 <LZ4_compress_fast_extState+0x6e6>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211517c:	49 83 c4 08          	add    $0x8,%r12
  8042115180:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042115184:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042115188:	49 39 f4             	cmp    %rsi,%r12
  804211518b:	72 c5                	jb     8042115152 <LZ4_compress_fast_extState+0x7b3>
  804211518d:	eb 08                	jmp    8042115197 <LZ4_compress_fast_extState+0x7f8>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211518f:	48 83 c0 04          	add    $0x4,%rax
  8042115193:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042115197:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
  804211519e:	49 39 fc             	cmp    %rdi,%r12
  80421151a1:	73 08                	jae    80421151ab <LZ4_compress_fast_extState+0x80c>
  80421151a3:	8b 30                	mov    (%rax),%esi
  80421151a5:	41 39 34 24          	cmp    %esi,(%r12)
  80421151a9:	74 3e                	je     80421151e9 <LZ4_compress_fast_extState+0x84a>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421151ab:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  80421151b2:	49 39 f4             	cmp    %rsi,%r12
  80421151b5:	73 0a                	jae    80421151c1 <LZ4_compress_fast_extState+0x822>
  80421151b7:	0f b7 30             	movzwl (%rax),%esi
  80421151ba:	66 41 39 34 24       	cmp    %si,(%r12)
  80421151bf:	74 32                	je     80421151f3 <LZ4_compress_fast_extState+0x854>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  80421151c1:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  80421151c8:	49 39 fc             	cmp    %rdi,%r12
  80421151cb:	73 11                	jae    80421151de <LZ4_compress_fast_extState+0x83f>
  80421151cd:	41 0f b6 34 24       	movzbl (%r12),%esi
  80421151d2:	40 38 30             	cmp    %sil,(%rax)
  80421151d5:	0f 94 c0             	sete   %al
  80421151d8:	0f b6 c0             	movzbl %al,%eax
  80421151db:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  80421151de:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421151e1:	41 29 c4             	sub    %eax,%r12d
  80421151e4:	e9 9c fe ff ff       	jmp    8042115085 <LZ4_compress_fast_extState+0x6e6>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421151e9:	49 83 c4 04          	add    $0x4,%r12
  80421151ed:	48 83 c0 04          	add    $0x4,%rax
  80421151f1:	eb b8                	jmp    80421151ab <LZ4_compress_fast_extState+0x80c>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421151f3:	49 83 c4 02          	add    $0x2,%r12
  80421151f7:	48 83 c0 02          	add    $0x2,%rax
  80421151fb:	eb c4                	jmp    80421151c1 <LZ4_compress_fast_extState+0x822>
                *token += ML_MASK;
  80421151fd:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  8042115200:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042115204:	41 c7 46 02 ff ff ff 	movl   $0xffffffff,0x2(%r14)
  804211520b:	ff 
                while (matchCode >= 4*255) {
  804211520c:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042115213:	76 1c                	jbe    8042115231 <LZ4_compress_fast_extState+0x892>
                    op+=4;
  8042115215:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042115219:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  8042115220:	ff 
                    matchCode -= 4*255;
  8042115221:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  8042115228:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  804211522f:	77 e4                	ja     8042115215 <LZ4_compress_fast_extState+0x876>
                op += matchCode / 255;
  8042115231:	44 89 e0             	mov    %r12d,%eax
  8042115234:	bb 81 80 80 80       	mov    $0x80808081,%ebx
  8042115239:	48 0f af c3          	imul   %rbx,%rax
  804211523d:	48 c1 e8 27          	shr    $0x27,%rax
  8042115241:	89 c2                	mov    %eax,%edx
  8042115243:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042115246:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  804211524a:	89 c1                	mov    %eax,%ecx
  804211524c:	c1 e1 08             	shl    $0x8,%ecx
  804211524f:	29 c1                	sub    %eax,%ecx
  8042115251:	41 29 cc             	sub    %ecx,%r12d
  8042115254:	44 88 22             	mov    %r12b,(%rdx)
  8042115257:	e9 41 fe ff ff       	jmp    804211509d <LZ4_compress_fast_extState+0x6fe>
        forwardH = LZ4_hashPosition(++ip, tableType);
  804211525c:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
  8042115260:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042115264:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  8042115268:	be 02 00 00 00       	mov    $0x2,%esi
  804211526d:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042115274:	00 00 00 
  8042115277:	ff d0                	call   *%rax
  8042115279:	4c 89 fe             	mov    %r15,%rsi
  804211527c:	49 89 df             	mov    %rbx,%r15
  804211527f:	e9 73 fc ff ff       	jmp    8042114ef7 <LZ4_compress_fast_extState+0x558>
        anchor = ip;
  8042115284:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
  8042115288:	4c 89 fe             	mov    %r15,%rsi
  804211528b:	eb 07                	jmp    8042115294 <LZ4_compress_fast_extState+0x8f5>
  804211528d:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
    {   size_t lastRun = (size_t)(iend - anchor);
  8042115294:	4c 8b 65 88          	mov    -0x78(%rbp),%r12
  8042115298:	49 29 f4             	sub    %rsi,%r12
        if (lastRun >= RUN_MASK) {
  804211529b:	49 83 fc 0e          	cmp    $0xe,%r12
  804211529f:	76 57                	jbe    80421152f8 <LZ4_compress_fast_extState+0x959>
            size_t accumulator = lastRun - RUN_MASK;
  80421152a1:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  80421152a6:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  80421152aa:	48 8d 43 01          	lea    0x1(%rbx),%rax
  80421152ae:	c6 03 f0             	movb   $0xf0,(%rbx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  80421152b1:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421152b8:	76 18                	jbe    80421152d2 <LZ4_compress_fast_extState+0x933>
  80421152ba:	48 83 c0 01          	add    $0x1,%rax
  80421152be:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  80421152c2:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  80421152c9:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421152d0:	77 e8                	ja     80421152ba <LZ4_compress_fast_extState+0x91b>
            *op++ = (BYTE) accumulator;
  80421152d2:	48 8d 58 01          	lea    0x1(%rax),%rbx
  80421152d6:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  80421152d8:	4c 89 e2             	mov    %r12,%rdx
  80421152db:	48 89 df             	mov    %rbx,%rdi
  80421152de:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421152e5:	00 00 00 
  80421152e8:	ff d0                	call   *%rax
        op += lastRun;
  80421152ea:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
    result = (int)(((char*)op) - dest);
  80421152ee:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  80421152f1:	29 d8                	sub    %ebx,%eax
    return result;
  80421152f3:	e9 34 fb ff ff       	jmp    8042114e2c <LZ4_compress_fast_extState+0x48d>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  80421152f8:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  80421152fc:	48 8d 5f 01          	lea    0x1(%rdi),%rbx
  8042115300:	44 89 e0             	mov    %r12d,%eax
  8042115303:	c1 e0 04             	shl    $0x4,%eax
  8042115306:	88 07                	mov    %al,(%rdi)
  8042115308:	eb ce                	jmp    80421152d8 <LZ4_compress_fast_extState+0x939>
        if (inputSize < LZ4_64Klimit) {
  804211530a:	41 81 fc 0a 00 01 00 	cmp    $0x1000a,%r12d
  8042115311:	0f 8f b0 04 00 00    	jg     80421157c7 <LZ4_compress_fast_extState+0xe28>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042115317:	b8 00 00 00 00       	mov    $0x0,%eax
  804211531c:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042115323:	0f 87 03 fb ff ff    	ja     8042114e2c <LZ4_compress_fast_extState+0x48d>
    U32 const startIndex = cctx->currentOffset;
  8042115329:	41 8b 97 00 40 00 00 	mov    0x4000(%r15),%edx
    const BYTE* const iend = ip + inputSize;
  8042115330:	49 63 c4             	movslq %r12d,%rax
  8042115333:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042115337:	48 8d 0c 06          	lea    (%rsi,%rax,1),%rcx
  804211533b:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  804211533f:	4d 63 ed             	movslq %r13d,%r13
  8042115342:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042115346:	4a 8d 04 2f          	lea    (%rdi,%r13,1),%rax
  804211534a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        cctx->dictSize += (U32)inputSize;
  804211534e:	45 01 a7 18 40 00 00 	add    %r12d,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  8042115355:	42 8d 04 22          	lea    (%rdx,%r12,1),%eax
  8042115359:	41 89 87 00 40 00 00 	mov    %eax,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  8042115360:	66 41 c7 87 06 40 00 	movw   $0x3,0x4006(%r15)
  8042115367:	00 03 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  804211536a:	41 83 fc 0c          	cmp    $0xc,%r12d
  804211536e:	0f 8e 95 03 00 00    	jle    8042115709 <LZ4_compress_fast_extState+0xd6a>
    const BYTE* base = (const BYTE*) source - startIndex;
  8042115374:	89 d0                	mov    %edx,%eax
  8042115376:	49 89 f4             	mov    %rsi,%r12
  8042115379:	49 29 c4             	sub    %rax,%r12
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  804211537c:	48 8d 41 f5          	lea    -0xb(%rcx),%rax
  8042115380:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042115384:	48 8d 41 fb          	lea    -0x5(%rcx),%rax
  8042115388:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  804211538c:	69 06 b1 79 37 9e    	imul   $0x9e3779b1,(%rsi),%eax
  8042115392:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042115395:	89 c0                	mov    %eax,%eax
  8042115397:	66 41 89 14 47       	mov    %dx,(%r15,%rax,2)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  804211539c:	48 8d 4e 01          	lea    0x1(%rsi),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421153a0:	69 56 01 b1 79 37 9e 	imul   $0x9e3779b1,0x1(%rsi),%edx
  80421153a7:	c1 ea 13             	shr    $0x13,%edx
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  80421153aa:	c1 e3 06             	shl    $0x6,%ebx
  80421153ad:	41 89 dd             	mov    %ebx,%r13d
  80421153b0:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
            int step = 1;
  80421153b4:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
  80421153b8:	4d 89 e7             	mov    %r12,%r15
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  80421153bb:	44 89 ef             	mov    %r13d,%edi
            int step = 1;
  80421153be:	b8 01 00 00 00       	mov    $0x1,%eax
  80421153c3:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
  80421153c7:	4c 8b 5d a8          	mov    -0x58(%rbp),%r11
                U32 const current = (U32)(forwardIp - base);
  80421153cb:	49 89 c9             	mov    %rcx,%r9
  80421153ce:	4d 29 f9             	sub    %r15,%r9
        return hashTable[h];
  80421153d1:	89 d2                	mov    %edx,%edx
  80421153d3:	4d 8d 04 52          	lea    (%r10,%rdx,2),%r8
  80421153d7:	41 0f b7 10          	movzwl (%r8),%edx
                forwardIp += step;
  80421153db:	49 89 ce             	mov    %rcx,%r14
  80421153de:	48 98                	cltq
  80421153e0:	48 01 c1             	add    %rax,%rcx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421153e3:	89 f8                	mov    %edi,%eax
  80421153e5:	83 c7 01             	add    $0x1,%edi
  80421153e8:	c1 f8 06             	sar    $0x6,%eax
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421153eb:	49 39 cb             	cmp    %rcx,%r11
  80421153ee:	0f 82 21 03 00 00    	jb     8042115715 <LZ4_compress_fast_extState+0xd76>
                    match = base + matchIndex;
  80421153f4:	0f b7 d2             	movzwl %dx,%edx
  80421153f7:	49 8d 1c 17          	lea    (%r15,%rdx,1),%rbx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421153fb:	69 11 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%edx
  8042115401:	c1 ea 13             	shr    $0x13,%edx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042115404:	66 45 89 08          	mov    %r9w,(%r8)
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042115408:	44 8b 0b             	mov    (%rbx),%r9d
  804211540b:	45 39 0e             	cmp    %r9d,(%r14)
  804211540e:	75 bb                	jne    80421153cb <LZ4_compress_fast_extState+0xa2c>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042115410:	4c 39 f6             	cmp    %r14,%rsi
  8042115413:	73 10                	jae    8042115425 <LZ4_compress_fast_extState+0xa86>
  8042115415:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
  8042115419:	73 0a                	jae    8042115425 <LZ4_compress_fast_extState+0xa86>
  804211541b:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  804211541f:	41 38 46 ff          	cmp    %al,-0x1(%r14)
  8042115423:	74 79                	je     804211549e <LZ4_compress_fast_extState+0xaff>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042115425:	4c 89 f0             	mov    %r14,%rax
  8042115428:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  804211542b:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804211542f:	48 8d 79 01          	lea    0x1(%rcx),%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  8042115433:	89 c1                	mov    %eax,%ecx
  8042115435:	89 c2                	mov    %eax,%edx
  8042115437:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  804211543d:	49 0f af d0          	imul   %r8,%rdx
  8042115441:	48 c1 ea 27          	shr    $0x27,%rdx
  8042115445:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  804211544a:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  804211544d:	48 39 55 c0          	cmp    %rdx,-0x40(%rbp)
  8042115451:	0f 82 a6 08 00 00    	jb     8042115cfd <LZ4_compress_fast_extState+0x135e>
            if (litLength >= RUN_MASK) {
  8042115457:	83 f8 0e             	cmp    $0xe,%eax
  804211545a:	77 62                	ja     80421154be <LZ4_compress_fast_extState+0xb1f>
            else *token = (BYTE)(litLength<<ML_BITS);
  804211545c:	c1 e0 04             	shl    $0x4,%eax
  804211545f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8042115463:	88 02                	mov    %al,(%rdx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042115465:	4c 8d 24 0f          	lea    (%rdi,%rcx,1),%r12
  8042115469:	4c 89 e2             	mov    %r12,%rdx
  804211546c:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042115473:	00 00 00 
  8042115476:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042115478:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211547c:	48 83 e8 0c          	sub    $0xc,%rax
  8042115480:	48 89 45 90          	mov    %rax,-0x70(%rbp)
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042115484:	48 89 d8             	mov    %rbx,%rax
  8042115487:	4c 89 7d 88          	mov    %r15,-0x78(%rbp)
  804211548b:	44 89 ad 78 ff ff ff 	mov    %r13d,-0x88(%rbp)
  8042115492:	4d 89 e7             	mov    %r12,%r15
  8042115495:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
  8042115499:	e9 ff 00 00 00       	jmp    804211559d <LZ4_compress_fast_extState+0xbfe>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211549e:	49 83 ee 01          	sub    $0x1,%r14
  80421154a2:	48 83 eb 01          	sub    $0x1,%rbx
  80421154a6:	4c 39 f6             	cmp    %r14,%rsi
  80421154a9:	0f 83 76 ff ff ff    	jae    8042115425 <LZ4_compress_fast_extState+0xa86>
  80421154af:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
  80421154b3:	0f 82 62 ff ff ff    	jb     804211541b <LZ4_compress_fast_extState+0xa7c>
  80421154b9:	e9 67 ff ff ff       	jmp    8042115425 <LZ4_compress_fast_extState+0xa86>
                int len = (int)(litLength - RUN_MASK);
  80421154be:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  80421154c1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80421154c5:	c6 02 f0             	movb   $0xf0,(%rdx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  80421154c8:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421154cd:	7e 14                	jle    80421154e3 <LZ4_compress_fast_extState+0xb44>
  80421154cf:	48 83 c7 01          	add    $0x1,%rdi
  80421154d3:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  80421154d7:	2d ff 00 00 00       	sub    $0xff,%eax
  80421154dc:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421154e1:	7f ec                	jg     80421154cf <LZ4_compress_fast_extState+0xb30>
                *op++ = (BYTE)len;
  80421154e3:	88 07                	mov    %al,(%rdi)
  80421154e5:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  80421154e9:	e9 77 ff ff ff       	jmp    8042115465 <LZ4_compress_fast_extState+0xac6>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421154ee:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  80421154f1:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421154f8:	00 00 00 
  80421154fb:	ff d0                	call   *%rax
  80421154fd:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042115500:	44 89 e0             	mov    %r12d,%eax
  8042115503:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042115508:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  804211550f:	00 
  8042115510:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042115515:	48 0f af c6          	imul   %rsi,%rax
  8042115519:	48 c1 e8 27          	shr    $0x27,%rax
  804211551d:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042115522:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8042115526:	0f 82 db 07 00 00    	jb     8042115d07 <LZ4_compress_fast_extState+0x1368>
            if (matchCode >= ML_MASK) {
  804211552c:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042115530:	0f 87 4e 01 00 00    	ja     8042115684 <LZ4_compress_fast_extState+0xce5>
                *token += (BYTE)(matchCode);
  8042115536:	44 00 23             	add    %r12b,(%rbx)
  8042115539:	4c 89 eb             	mov    %r13,%rbx
        if (ip >= mflimitPlusOne) break;
  804211553c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042115540:	49 39 c6             	cmp    %rax,%r14
  8042115543:	0f 83 61 02 00 00    	jae    80421157aa <LZ4_compress_fast_extState+0xe0b>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042115549:	41 69 46 fe b1 79 37 	imul   $0x9e3779b1,-0x2(%r14),%eax
  8042115550:	9e 
  8042115551:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042115554:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042115556:	49 8d 56 fe          	lea    -0x2(%r14),%rdx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  804211555a:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  804211555e:	48 29 ca             	sub    %rcx,%rdx
  8042115561:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8042115565:	66 89 14 47          	mov    %dx,(%rdi,%rax,2)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042115569:	41 69 06 b1 79 37 9e 	imul   $0x9e3779b1,(%r14),%eax
  8042115570:	c1 e8 13             	shr    $0x13,%eax
        return hashTable[h];
  8042115573:	89 c0                	mov    %eax,%eax
  8042115575:	48 8d 14 47          	lea    (%rdi,%rax,2),%rdx
                match = base + matchIndex;
  8042115579:	0f b7 02             	movzwl (%rdx),%eax
  804211557c:	48 89 cf             	mov    %rcx,%rdi
  804211557f:	48 01 c8             	add    %rcx,%rax
            U32 const current = (U32)(ip-base);
  8042115582:	4c 89 f1             	mov    %r14,%rcx
  8042115585:	48 29 f9             	sub    %rdi,%rcx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042115588:	66 89 0a             	mov    %cx,(%rdx)
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  804211558b:	8b 30                	mov    (%rax),%esi
  804211558d:	41 39 36             	cmp    %esi,(%r14)
  8042115590:	0f 85 4d 01 00 00    	jne    80421156e3 <LZ4_compress_fast_extState+0xd44>
                token=op++;
  8042115596:	4c 8d 7b 01          	lea    0x1(%rbx),%r15
                *token=0;
  804211559a:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  804211559d:	4c 89 f2             	mov    %r14,%rdx
  80421155a0:	48 29 c2             	sub    %rax,%rdx
  80421155a3:	66 41 89 17          	mov    %dx,(%r15)
  80421155a7:	4d 8d 6f 02          	lea    0x2(%r15),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  80421155ab:	49 8d 4e 04          	lea    0x4(%r14),%rcx
  80421155af:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421155b3:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  80421155b7:	48 39 f1             	cmp    %rsi,%rcx
  80421155ba:	73 5b                	jae    8042115617 <LZ4_compress_fast_extState+0xc78>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421155bc:	48 8b 50 04          	mov    0x4(%rax),%rdx
  80421155c0:	49 8b 7e 04          	mov    0x4(%r14),%rdi
        if (!diff) {
  80421155c4:	48 39 d7             	cmp    %rdx,%rdi
  80421155c7:	0f 85 21 ff ff ff    	jne    80421154ee <LZ4_compress_fast_extState+0xb4f>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  80421155cd:	4d 8d 66 0c          	lea    0xc(%r14),%r12
  80421155d1:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421155d5:	49 39 f4             	cmp    %rsi,%r12
  80421155d8:	73 45                	jae    804211561f <LZ4_compress_fast_extState+0xc80>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421155da:	48 8b 10             	mov    (%rax),%rdx
  80421155dd:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421155e1:	48 39 d7             	cmp    %rdx,%rdi
  80421155e4:	74 1e                	je     8042115604 <LZ4_compress_fast_extState+0xc65>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421155e6:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  80421155e9:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421155f0:	00 00 00 
  80421155f3:	ff d0                	call   *%rax
  80421155f5:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  80421155f9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80421155fc:	41 29 c4             	sub    %eax,%r12d
  80421155ff:	e9 fc fe ff ff       	jmp    8042115500 <LZ4_compress_fast_extState+0xb61>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042115604:	49 83 c4 08          	add    $0x8,%r12
  8042115608:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211560c:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  8042115610:	49 39 f4             	cmp    %rsi,%r12
  8042115613:	72 c5                	jb     80421155da <LZ4_compress_fast_extState+0xc3b>
  8042115615:	eb 08                	jmp    804211561f <LZ4_compress_fast_extState+0xc80>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042115617:	48 83 c0 04          	add    $0x4,%rax
  804211561b:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211561f:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042115623:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  8042115627:	49 39 d4             	cmp    %rdx,%r12
  804211562a:	73 08                	jae    8042115634 <LZ4_compress_fast_extState+0xc95>
  804211562c:	8b 38                	mov    (%rax),%edi
  804211562e:	41 39 3c 24          	cmp    %edi,(%r12)
  8042115632:	74 3c                	je     8042115670 <LZ4_compress_fast_extState+0xcd1>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042115634:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042115638:	48 8d 56 fa          	lea    -0x6(%rsi),%rdx
  804211563c:	49 39 d4             	cmp    %rdx,%r12
  804211563f:	73 0a                	jae    804211564b <LZ4_compress_fast_extState+0xcac>
  8042115641:	0f b7 08             	movzwl (%rax),%ecx
  8042115644:	66 41 39 0c 24       	cmp    %cx,(%r12)
  8042115649:	74 2f                	je     804211567a <LZ4_compress_fast_extState+0xcdb>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211564b:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  804211564f:	49 39 fc             	cmp    %rdi,%r12
  8042115652:	73 11                	jae    8042115665 <LZ4_compress_fast_extState+0xcc6>
  8042115654:	41 0f b6 34 24       	movzbl (%r12),%esi
  8042115659:	40 38 30             	cmp    %sil,(%rax)
  804211565c:	0f 94 c0             	sete   %al
  804211565f:	0f b6 c0             	movzbl %al,%eax
  8042115662:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  8042115665:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042115668:	41 29 c4             	sub    %eax,%r12d
  804211566b:	e9 90 fe ff ff       	jmp    8042115500 <LZ4_compress_fast_extState+0xb61>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042115670:	49 83 c4 04          	add    $0x4,%r12
  8042115674:	48 83 c0 04          	add    $0x4,%rax
  8042115678:	eb ba                	jmp    8042115634 <LZ4_compress_fast_extState+0xc95>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211567a:	49 83 c4 02          	add    $0x2,%r12
  804211567e:	48 83 c0 02          	add    $0x2,%rax
  8042115682:	eb c7                	jmp    804211564b <LZ4_compress_fast_extState+0xcac>
                *token += ML_MASK;
  8042115684:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  8042115687:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211568b:	41 c7 47 02 ff ff ff 	movl   $0xffffffff,0x2(%r15)
  8042115692:	ff 
                while (matchCode >= 4*255) {
  8042115693:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  804211569a:	76 1c                	jbe    80421156b8 <LZ4_compress_fast_extState+0xd19>
                    op+=4;
  804211569c:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421156a0:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  80421156a7:	ff 
                    matchCode -= 4*255;
  80421156a8:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  80421156af:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  80421156b6:	77 e4                	ja     804211569c <LZ4_compress_fast_extState+0xcfd>
                op += matchCode / 255;
  80421156b8:	44 89 e0             	mov    %r12d,%eax
  80421156bb:	bb 81 80 80 80       	mov    $0x80808081,%ebx
  80421156c0:	48 0f af c3          	imul   %rbx,%rax
  80421156c4:	48 c1 e8 27          	shr    $0x27,%rax
  80421156c8:	89 c2                	mov    %eax,%edx
  80421156ca:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  80421156cd:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  80421156d1:	89 c1                	mov    %eax,%ecx
  80421156d3:	c1 e1 08             	shl    $0x8,%ecx
  80421156d6:	29 c1                	sub    %eax,%ecx
  80421156d8:	41 29 cc             	sub    %ecx,%r12d
  80421156db:	44 88 22             	mov    %r12b,(%rdx)
  80421156de:	e9 59 fe ff ff       	jmp    804211553c <LZ4_compress_fast_extState+0xb9d>
        forwardH = LZ4_hashPosition(++ip, tableType);
  80421156e3:	4c 8b 7d 88          	mov    -0x78(%rbp),%r15
  80421156e7:	44 8b ad 78 ff ff ff 	mov    -0x88(%rbp),%r13d
  80421156ee:	48 89 5d b8          	mov    %rbx,-0x48(%rbp)
  80421156f2:	49 8d 4e 01          	lea    0x1(%r14),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421156f6:	41 69 56 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r14),%edx
  80421156fd:	9e 
  80421156fe:	c1 ea 13             	shr    $0x13,%edx
  8042115701:	4c 89 f6             	mov    %r14,%rsi
  8042115704:	e9 b2 fc ff ff       	jmp    80421153bb <LZ4_compress_fast_extState+0xa1c>
    BYTE* op = (BYTE*) dest;
  8042115709:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211570d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  8042115711:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    {   size_t lastRun = (size_t)(iend - anchor);
  8042115715:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  8042115719:	48 29 f3             	sub    %rsi,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  804211571c:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  8042115723:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  804211572a:	80 80 80 
  804211572d:	48 89 d0             	mov    %rdx,%rax
  8042115730:	48 f7 e1             	mul    %rcx
  8042115733:	48 c1 ea 07          	shr    $0x7,%rdx
  8042115737:	48 8d 54 13 01       	lea    0x1(%rbx,%rdx,1),%rdx
  804211573c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042115740:	48 01 fa             	add    %rdi,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042115743:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  8042115748:	48 39 55 c0          	cmp    %rdx,-0x40(%rbp)
  804211574c:	0f 82 da f6 ff ff    	jb     8042114e2c <LZ4_compress_fast_extState+0x48d>
        if (lastRun >= RUN_MASK) {
  8042115752:	48 83 fb 0e          	cmp    $0xe,%rbx
  8042115756:	76 5e                	jbe    80421157b6 <LZ4_compress_fast_extState+0xe17>
            size_t accumulator = lastRun - RUN_MASK;
  8042115758:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  804211575c:	48 8d 47 01          	lea    0x1(%rdi),%rax
  8042115760:	c6 07 f0             	movb   $0xf0,(%rdi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042115763:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211576a:	76 18                	jbe    8042115784 <LZ4_compress_fast_extState+0xde5>
  804211576c:	48 83 c0 01          	add    $0x1,%rax
  8042115770:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042115774:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  804211577b:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042115782:	77 e8                	ja     804211576c <LZ4_compress_fast_extState+0xdcd>
            *op++ = (BYTE) accumulator;
  8042115784:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8042115788:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  804211578a:	48 89 da             	mov    %rbx,%rdx
  804211578d:	4c 89 e7             	mov    %r12,%rdi
  8042115790:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042115797:	00 00 00 
  804211579a:	ff d0                	call   *%rax
        op += lastRun;
  804211579c:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  80421157a0:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  80421157a3:	29 d8                	sub    %ebx,%eax
    return result;
  80421157a5:	e9 82 f6 ff ff       	jmp    8042114e2c <LZ4_compress_fast_extState+0x48d>
        anchor = ip;
  80421157aa:	48 89 5d b8          	mov    %rbx,-0x48(%rbp)
  80421157ae:	4c 89 f6             	mov    %r14,%rsi
  80421157b1:	e9 5f ff ff ff       	jmp    8042115715 <LZ4_compress_fast_extState+0xd76>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  80421157b6:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80421157ba:	4c 8d 67 01          	lea    0x1(%rdi),%r12
  80421157be:	89 d8                	mov    %ebx,%eax
  80421157c0:	c1 e0 04             	shl    $0x4,%eax
  80421157c3:	88 07                	mov    %al,(%rdi)
  80421157c5:	eb c3                	jmp    804211578a <LZ4_compress_fast_extState+0xdeb>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  80421157c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80421157cc:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  80421157d3:	0f 87 53 f6 ff ff    	ja     8042114e2c <LZ4_compress_fast_extState+0x48d>
    U32 const startIndex = cctx->currentOffset;
  80421157d9:	45 8b b7 00 40 00 00 	mov    0x4000(%r15),%r14d
    const BYTE* base = (const BYTE*) source - startIndex;
  80421157e0:	44 89 f0             	mov    %r14d,%eax
  80421157e3:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80421157e7:	48 89 cf             	mov    %rcx,%rdi
  80421157ea:	48 29 c7             	sub    %rax,%rdi
  80421157ed:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
    const BYTE* const iend = ip + inputSize;
  80421157f1:	49 63 c4             	movslq %r12d,%rax
  80421157f4:	48 01 c8             	add    %rcx,%rax
  80421157f7:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  80421157fb:	48 8d 70 f5          	lea    -0xb(%rax),%rsi
  80421157ff:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042115803:	48 83 e8 05          	sub    $0x5,%rax
  8042115807:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  804211580e:	4d 63 ed             	movslq %r13d,%r13
  8042115811:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042115815:	4a 8d 3c 28          	lea    (%rax,%r13,1),%rdi
  8042115819:	48 89 7d 90          	mov    %rdi,-0x70(%rbp)
        cctx->dictSize += (U32)inputSize;
  804211581d:	45 01 a7 18 40 00 00 	add    %r12d,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  8042115824:	45 01 f4             	add    %r14d,%r12d
  8042115827:	45 89 a7 00 40 00 00 	mov    %r12d,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  804211582e:	66 41 c7 87 06 40 00 	movw   $0x2,0x4006(%r15)
  8042115835:	00 02 00 
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042115838:	49 89 cd             	mov    %rcx,%r13
  804211583b:	48 8b 39             	mov    (%rcx),%rdi
  804211583e:	be 02 00 00 00       	mov    $0x2,%esi
  8042115843:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  804211584a:	00 00 00 
  804211584d:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042115850:	89 c0                	mov    %eax,%eax
  8042115852:	45 89 34 87          	mov    %r14d,(%r15,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042115856:	4d 89 ee             	mov    %r13,%r14
  8042115859:	4d 8d 6d 01          	lea    0x1(%r13),%r13
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211585d:	49 8b 7e 01          	mov    0x1(%r14),%rdi
  8042115861:	be 02 00 00 00       	mov    $0x2,%esi
  8042115866:	41 ff d4             	call   *%r12
  8042115869:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211586d:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
  8042115871:	4c 89 f6             	mov    %r14,%rsi
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042115874:	c1 e3 06             	shl    $0x6,%ebx
  8042115877:	89 9d 78 ff ff ff    	mov    %ebx,-0x88(%rbp)
  804211587d:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  8042115881:	4d 89 ef             	mov    %r13,%r15
                U32 const current = (U32)(forwardIp - base);
  8042115884:	45 89 fe             	mov    %r15d,%r14d
  8042115887:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  804211588a:	41 29 de             	sub    %ebx,%r14d
        return hashTable[h];
  804211588d:	89 c0                	mov    %eax,%eax
  804211588f:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  8042115893:	4c 8d 2c 83          	lea    (%rbx,%rax,4),%r13
  8042115897:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  804211589b:	4d 8d 67 01          	lea    0x1(%r15),%r12
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211589f:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  80421158a5:	8d 48 01             	lea    0x1(%rax),%ecx
  80421158a8:	c1 f8 06             	sar    $0x6,%eax
  80421158ab:	89 45 b8             	mov    %eax,-0x48(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421158ae:	4c 39 65 a0          	cmp    %r12,-0x60(%rbp)
  80421158b2:	0f 82 9f 03 00 00    	jb     8042115c57 <LZ4_compress_fast_extState+0x12b8>
  80421158b8:	48 89 b5 70 ff ff ff 	mov    %rsi,-0x90(%rbp)
  80421158bf:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
  80421158c3:	41 89 cf             	mov    %ecx,%r15d
  80421158c6:	eb 3e                	jmp    8042115906 <LZ4_compress_fast_extState+0xf67>
                U32 const current = (U32)(forwardIp - base);
  80421158c8:	45 89 e6             	mov    %r12d,%r14d
  80421158cb:	8b 75 c0             	mov    -0x40(%rbp),%esi
  80421158ce:	41 29 f6             	sub    %esi,%r14d
        return hashTable[h];
  80421158d1:	89 c0                	mov    %eax,%eax
  80421158d3:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  80421158d7:	4c 8d 2c 86          	lea    (%rsi,%rax,4),%r13
  80421158db:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  80421158df:	48 63 45 b8          	movslq -0x48(%rbp),%rax
  80421158e3:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421158e6:	41 8d 57 01          	lea    0x1(%r15),%edx
  80421158ea:	41 c1 ff 06          	sar    $0x6,%r15d
  80421158ee:	44 89 7d b8          	mov    %r15d,-0x48(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421158f2:	4c 89 65 a8          	mov    %r12,-0x58(%rbp)
  80421158f6:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  80421158fa:	0f 82 50 03 00 00    	jb     8042115c50 <LZ4_compress_fast_extState+0x12b1>
  8042115900:	41 89 d7             	mov    %edx,%r15d
  8042115903:	49 89 c4             	mov    %rax,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042115906:	49 8b 3c 24          	mov    (%r12),%rdi
  804211590a:	be 02 00 00 00       	mov    $0x2,%esi
  804211590f:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042115916:	00 00 00 
  8042115919:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211591b:	45 89 75 00          	mov    %r14d,0x0(%r13)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  804211591f:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  8042115925:	44 39 f2             	cmp    %r14d,%edx
  8042115928:	72 9e                	jb     80421158c8 <LZ4_compress_fast_extState+0xf29>
                    match = base + matchIndex;
  804211592a:	89 db                	mov    %ebx,%ebx
  804211592c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8042115930:	48 01 f3             	add    %rsi,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042115933:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8042115937:	8b 3b                	mov    (%rbx),%edi
  8042115939:	39 39                	cmp    %edi,(%rcx)
  804211593b:	75 8b                	jne    80421158c8 <LZ4_compress_fast_extState+0xf29>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211593d:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
  8042115944:	49 89 cf             	mov    %rcx,%r15
  8042115947:	48 39 ce             	cmp    %rcx,%rsi
  804211594a:	73 10                	jae    804211595c <LZ4_compress_fast_extState+0xfbd>
  804211594c:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
  8042115950:	73 0a                	jae    804211595c <LZ4_compress_fast_extState+0xfbd>
  8042115952:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042115956:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  804211595a:	74 6b                	je     80421159c7 <LZ4_compress_fast_extState+0x1028>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  804211595c:	4c 89 f8             	mov    %r15,%rax
  804211595f:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  8042115962:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  8042115966:	48 8d 79 01          	lea    0x1(%rcx),%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  804211596a:	89 c1                	mov    %eax,%ecx
  804211596c:	89 c2                	mov    %eax,%edx
  804211596e:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  8042115974:	49 0f af d0          	imul   %r8,%rdx
  8042115978:	48 c1 ea 27          	shr    $0x27,%rdx
  804211597c:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  8042115981:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  8042115984:	48 39 55 90          	cmp    %rdx,-0x70(%rbp)
  8042115988:	0f 82 83 03 00 00    	jb     8042115d11 <LZ4_compress_fast_extState+0x1372>
            if (litLength >= RUN_MASK) {
  804211598e:	83 f8 0e             	cmp    $0xe,%eax
  8042115991:	77 50                	ja     80421159e3 <LZ4_compress_fast_extState+0x1044>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042115993:	c1 e0 04             	shl    $0x4,%eax
  8042115996:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  804211599a:	88 02                	mov    %al,(%rdx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  804211599c:	4c 8d 34 0f          	lea    (%rdi,%rcx,1),%r14
  80421159a0:	4c 89 f2             	mov    %r14,%rdx
  80421159a3:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  80421159aa:	00 00 00 
  80421159ad:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421159af:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80421159b3:	48 83 e8 0c          	sub    $0xc,%rax
  80421159b7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421159bb:	48 89 d8             	mov    %rbx,%rax
  80421159be:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
  80421159c2:	e9 0f 01 00 00       	jmp    8042115ad6 <LZ4_compress_fast_extState+0x1137>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  80421159c7:	49 83 ef 01          	sub    $0x1,%r15
  80421159cb:	48 83 eb 01          	sub    $0x1,%rbx
  80421159cf:	4c 39 fe             	cmp    %r15,%rsi
  80421159d2:	73 88                	jae    804211595c <LZ4_compress_fast_extState+0xfbd>
  80421159d4:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
  80421159d8:	0f 82 74 ff ff ff    	jb     8042115952 <LZ4_compress_fast_extState+0xfb3>
  80421159de:	e9 79 ff ff ff       	jmp    804211595c <LZ4_compress_fast_extState+0xfbd>
                int len = (int)(litLength - RUN_MASK);
  80421159e3:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  80421159e6:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80421159ea:	c6 02 f0             	movb   $0xf0,(%rdx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  80421159ed:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421159f2:	7e 14                	jle    8042115a08 <LZ4_compress_fast_extState+0x1069>
  80421159f4:	48 83 c7 01          	add    $0x1,%rdi
  80421159f8:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  80421159fc:	2d ff 00 00 00       	sub    $0xff,%eax
  8042115a01:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042115a06:	7f ec                	jg     80421159f4 <LZ4_compress_fast_extState+0x1055>
                *op++ = (BYTE)len;
  8042115a08:	88 07                	mov    %al,(%rdi)
  8042115a0a:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042115a0e:	eb 8c                	jmp    804211599c <LZ4_compress_fast_extState+0xffd>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042115a10:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042115a13:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042115a1a:	00 00 00 
  8042115a1d:	ff d0                	call   *%rax
  8042115a1f:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042115a22:	44 89 e0             	mov    %r12d,%eax
  8042115a25:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042115a2a:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  8042115a31:	00 
  8042115a32:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042115a37:	48 0f af c6          	imul   %rsi,%rax
  8042115a3b:	48 c1 e8 27          	shr    $0x27,%rax
  8042115a3f:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042115a44:	48 39 45 90          	cmp    %rax,-0x70(%rbp)
  8042115a48:	0f 82 cd 02 00 00    	jb     8042115d1b <LZ4_compress_fast_extState+0x137c>
            if (matchCode >= ML_MASK) {
  8042115a4e:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042115a52:	0f 87 68 01 00 00    	ja     8042115bc0 <LZ4_compress_fast_extState+0x1221>
                *token += (BYTE)(matchCode);
  8042115a58:	44 00 23             	add    %r12b,(%rbx)
  8042115a5b:	4c 89 eb             	mov    %r13,%rbx
        if (ip >= mflimitPlusOne) break;
  8042115a5e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042115a62:	49 39 c7             	cmp    %rax,%r15
  8042115a65:	0f 83 dc 01 00 00    	jae    8042115c47 <LZ4_compress_fast_extState+0x12a8>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042115a6b:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  8042115a6f:	be 02 00 00 00       	mov    $0x2,%esi
  8042115a74:	49 bd ce 28 11 42 80 	movabs $0x80421128ce,%r13
  8042115a7b:	00 00 00 
  8042115a7e:	41 ff d5             	call   *%r13
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042115a81:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042115a83:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042115a87:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
  8042115a8b:	4c 29 f2             	sub    %r14,%rdx
  8042115a8e:	4c 8b 65 98          	mov    -0x68(%rbp),%r12
  8042115a92:	41 89 14 84          	mov    %edx,(%r12,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042115a96:	49 8b 3f             	mov    (%r15),%rdi
  8042115a99:	be 02 00 00 00       	mov    $0x2,%esi
  8042115a9e:	41 ff d5             	call   *%r13
            U32 const current = (U32)(ip-base);
  8042115aa1:	4c 89 f9             	mov    %r15,%rcx
  8042115aa4:	4c 29 f1             	sub    %r14,%rcx
        return hashTable[h];
  8042115aa7:	89 c0                	mov    %eax,%eax
  8042115aa9:	49 8d 34 84          	lea    (%r12,%rax,4),%rsi
  8042115aad:	8b 16                	mov    (%rsi),%edx
                match = base + matchIndex;
  8042115aaf:	89 d0                	mov    %edx,%eax
  8042115ab1:	4c 01 f0             	add    %r14,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042115ab4:	89 0e                	mov    %ecx,(%rsi)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  8042115ab6:	81 c2 ff ff 00 00    	add    $0xffff,%edx
  8042115abc:	39 ca                	cmp    %ecx,%edx
  8042115abe:	0f 82 5b 01 00 00    	jb     8042115c1f <LZ4_compress_fast_extState+0x1280>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042115ac4:	8b 08                	mov    (%rax),%ecx
  8042115ac6:	41 39 0f             	cmp    %ecx,(%r15)
  8042115ac9:	0f 85 50 01 00 00    	jne    8042115c1f <LZ4_compress_fast_extState+0x1280>
                token=op++;
  8042115acf:	4c 8d 73 01          	lea    0x1(%rbx),%r14
                *token=0;
  8042115ad3:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042115ad6:	4c 89 fa             	mov    %r15,%rdx
  8042115ad9:	48 29 c2             	sub    %rax,%rdx
  8042115adc:	66 41 89 16          	mov    %dx,(%r14)
  8042115ae0:	4d 8d 6e 02          	lea    0x2(%r14),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042115ae4:	49 8d 77 04          	lea    0x4(%r15),%rsi
  8042115ae8:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042115aec:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8042115af0:	48 39 ce             	cmp    %rcx,%rsi
  8042115af3:	73 5b                	jae    8042115b50 <LZ4_compress_fast_extState+0x11b1>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042115af5:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042115af9:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  8042115afd:	48 39 d7             	cmp    %rdx,%rdi
  8042115b00:	0f 85 0a ff ff ff    	jne    8042115a10 <LZ4_compress_fast_extState+0x1071>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042115b06:	4d 8d 67 0c          	lea    0xc(%r15),%r12
  8042115b0a:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042115b0e:	49 39 cc             	cmp    %rcx,%r12
  8042115b11:	73 45                	jae    8042115b58 <LZ4_compress_fast_extState+0x11b9>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042115b13:	48 8b 10             	mov    (%rax),%rdx
  8042115b16:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042115b1a:	48 39 d7             	cmp    %rdx,%rdi
  8042115b1d:	74 1e                	je     8042115b3d <LZ4_compress_fast_extState+0x119e>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042115b1f:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042115b22:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042115b29:	00 00 00 
  8042115b2c:	ff d0                	call   *%rax
  8042115b2e:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  8042115b32:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042115b35:	41 29 c4             	sub    %eax,%r12d
  8042115b38:	e9 e5 fe ff ff       	jmp    8042115a22 <LZ4_compress_fast_extState+0x1083>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042115b3d:	49 83 c4 08          	add    $0x8,%r12
  8042115b41:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042115b45:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  8042115b49:	49 39 f4             	cmp    %rsi,%r12
  8042115b4c:	72 c5                	jb     8042115b13 <LZ4_compress_fast_extState+0x1174>
  8042115b4e:	eb 08                	jmp    8042115b58 <LZ4_compress_fast_extState+0x11b9>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042115b50:	48 83 c0 04          	add    $0x4,%rax
  8042115b54:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042115b58:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  8042115b5c:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  8042115b60:	49 39 d4             	cmp    %rdx,%r12
  8042115b63:	73 08                	jae    8042115b6d <LZ4_compress_fast_extState+0x11ce>
  8042115b65:	8b 38                	mov    (%rax),%edi
  8042115b67:	41 39 3c 24          	cmp    %edi,(%r12)
  8042115b6b:	74 3f                	je     8042115bac <LZ4_compress_fast_extState+0x120d>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042115b6d:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  8042115b71:	48 8d 57 fa          	lea    -0x6(%rdi),%rdx
  8042115b75:	49 39 d4             	cmp    %rdx,%r12
  8042115b78:	73 0a                	jae    8042115b84 <LZ4_compress_fast_extState+0x11e5>
  8042115b7a:	0f b7 30             	movzwl (%rax),%esi
  8042115b7d:	66 41 39 34 24       	cmp    %si,(%r12)
  8042115b82:	74 32                	je     8042115bb6 <LZ4_compress_fast_extState+0x1217>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042115b84:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  8042115b8b:	49 39 f4             	cmp    %rsi,%r12
  8042115b8e:	73 11                	jae    8042115ba1 <LZ4_compress_fast_extState+0x1202>
  8042115b90:	41 0f b6 3c 24       	movzbl (%r12),%edi
  8042115b95:	40 38 38             	cmp    %dil,(%rax)
  8042115b98:	0f 94 c0             	sete   %al
  8042115b9b:	0f b6 c0             	movzbl %al,%eax
  8042115b9e:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  8042115ba1:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8042115ba4:	41 29 c4             	sub    %eax,%r12d
  8042115ba7:	e9 76 fe ff ff       	jmp    8042115a22 <LZ4_compress_fast_extState+0x1083>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042115bac:	49 83 c4 04          	add    $0x4,%r12
  8042115bb0:	48 83 c0 04          	add    $0x4,%rax
  8042115bb4:	eb b7                	jmp    8042115b6d <LZ4_compress_fast_extState+0x11ce>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042115bb6:	49 83 c4 02          	add    $0x2,%r12
  8042115bba:	48 83 c0 02          	add    $0x2,%rax
  8042115bbe:	eb c4                	jmp    8042115b84 <LZ4_compress_fast_extState+0x11e5>
                *token += ML_MASK;
  8042115bc0:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  8042115bc3:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042115bc7:	41 c7 46 02 ff ff ff 	movl   $0xffffffff,0x2(%r14)
  8042115bce:	ff 
                while (matchCode >= 4*255) {
  8042115bcf:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042115bd6:	76 1c                	jbe    8042115bf4 <LZ4_compress_fast_extState+0x1255>
                    op+=4;
  8042115bd8:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042115bdc:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  8042115be3:	ff 
                    matchCode -= 4*255;
  8042115be4:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  8042115beb:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042115bf2:	77 e4                	ja     8042115bd8 <LZ4_compress_fast_extState+0x1239>
                op += matchCode / 255;
  8042115bf4:	44 89 e0             	mov    %r12d,%eax
  8042115bf7:	ba 81 80 80 80       	mov    $0x80808081,%edx
  8042115bfc:	48 0f af c2          	imul   %rdx,%rax
  8042115c00:	48 c1 e8 27          	shr    $0x27,%rax
  8042115c04:	89 c2                	mov    %eax,%edx
  8042115c06:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042115c09:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  8042115c0d:	89 c1                	mov    %eax,%ecx
  8042115c0f:	c1 e1 08             	shl    $0x8,%ecx
  8042115c12:	29 c1                	sub    %eax,%ecx
  8042115c14:	41 29 cc             	sub    %ecx,%r12d
  8042115c17:	44 88 22             	mov    %r12b,(%rdx)
  8042115c1a:	e9 3f fe ff ff       	jmp    8042115a5e <LZ4_compress_fast_extState+0x10bf>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042115c1f:	48 89 5d 88          	mov    %rbx,-0x78(%rbp)
  8042115c23:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042115c27:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  8042115c2b:	be 02 00 00 00       	mov    $0x2,%esi
  8042115c30:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042115c37:	00 00 00 
  8042115c3a:	ff d0                	call   *%rax
  8042115c3c:	4c 89 fe             	mov    %r15,%rsi
  8042115c3f:	49 89 df             	mov    %rbx,%r15
  8042115c42:	e9 3d fc ff ff       	jmp    8042115884 <LZ4_compress_fast_extState+0xee5>
        anchor = ip;
  8042115c47:	48 89 5d 88          	mov    %rbx,-0x78(%rbp)
  8042115c4b:	4c 89 fe             	mov    %r15,%rsi
  8042115c4e:	eb 07                	jmp    8042115c57 <LZ4_compress_fast_extState+0x12b8>
  8042115c50:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
    {   size_t lastRun = (size_t)(iend - anchor);
  8042115c57:	48 8b 5d 80          	mov    -0x80(%rbp),%rbx
  8042115c5b:	48 29 f3             	sub    %rsi,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  8042115c5e:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  8042115c65:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  8042115c6c:	80 80 80 
  8042115c6f:	48 89 d0             	mov    %rdx,%rax
  8042115c72:	48 f7 e1             	mul    %rcx
  8042115c75:	48 c1 ea 07          	shr    $0x7,%rdx
  8042115c79:	48 8d 54 13 01       	lea    0x1(%rbx,%rdx,1),%rdx
  8042115c7e:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  8042115c82:	48 01 fa             	add    %rdi,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042115c85:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  8042115c8a:	48 39 55 90          	cmp    %rdx,-0x70(%rbp)
  8042115c8e:	0f 82 98 f1 ff ff    	jb     8042114e2c <LZ4_compress_fast_extState+0x48d>
        if (lastRun >= RUN_MASK) {
  8042115c94:	48 83 fb 0e          	cmp    $0xe,%rbx
  8042115c98:	76 52                	jbe    8042115cec <LZ4_compress_fast_extState+0x134d>
            size_t accumulator = lastRun - RUN_MASK;
  8042115c9a:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042115c9e:	48 8d 47 01          	lea    0x1(%rdi),%rax
  8042115ca2:	c6 07 f0             	movb   $0xf0,(%rdi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042115ca5:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042115cac:	76 18                	jbe    8042115cc6 <LZ4_compress_fast_extState+0x1327>
  8042115cae:	48 83 c0 01          	add    $0x1,%rax
  8042115cb2:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042115cb6:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042115cbd:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042115cc4:	77 e8                	ja     8042115cae <LZ4_compress_fast_extState+0x130f>
            *op++ = (BYTE) accumulator;
  8042115cc6:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8042115cca:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042115ccc:	48 89 da             	mov    %rbx,%rdx
  8042115ccf:	4c 89 e7             	mov    %r12,%rdi
  8042115cd2:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042115cd9:	00 00 00 
  8042115cdc:	ff d0                	call   *%rax
        op += lastRun;
  8042115cde:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  8042115ce2:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  8042115ce5:	29 d8                	sub    %ebx,%eax
    return result;
  8042115ce7:	e9 40 f1 ff ff       	jmp    8042114e2c <LZ4_compress_fast_extState+0x48d>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042115cec:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  8042115cf0:	4c 8d 67 01          	lea    0x1(%rdi),%r12
  8042115cf4:	89 d8                	mov    %ebx,%eax
  8042115cf6:	c1 e0 04             	shl    $0x4,%eax
  8042115cf9:	88 07                	mov    %al,(%rdi)
  8042115cfb:	eb cf                	jmp    8042115ccc <LZ4_compress_fast_extState+0x132d>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042115cfd:	b8 00 00 00 00       	mov    $0x0,%eax
  8042115d02:	e9 25 f1 ff ff       	jmp    8042114e2c <LZ4_compress_fast_extState+0x48d>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042115d07:	b8 00 00 00 00       	mov    $0x0,%eax
  8042115d0c:	e9 1b f1 ff ff       	jmp    8042114e2c <LZ4_compress_fast_extState+0x48d>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042115d11:	b8 00 00 00 00       	mov    $0x0,%eax
  8042115d16:	e9 11 f1 ff ff       	jmp    8042114e2c <LZ4_compress_fast_extState+0x48d>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042115d1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8042115d20:	e9 07 f1 ff ff       	jmp    8042114e2c <LZ4_compress_fast_extState+0x48d>

0000008042115d25 <LZ4_compress_fast>:
{
  8042115d25:	f3 0f 1e fa          	endbr64
  8042115d29:	55                   	push   %rbp
  8042115d2a:	48 89 e5             	mov    %rsp,%rbp
  8042115d2d:	4c 8d 9c 24 00 c0 ff 	lea    -0x4000(%rsp),%r11
  8042115d34:	ff 
  8042115d35:	48 81 ec 00 10 00 00 	sub    $0x1000,%rsp
  8042115d3c:	48 83 0c 24 00       	orq    $0x0,(%rsp)
  8042115d41:	4c 39 dc             	cmp    %r11,%rsp
  8042115d44:	75 ef                	jne    8042115d35 <LZ4_compress_fast+0x10>
  8042115d46:	48 83 ec 20          	sub    $0x20,%rsp
    result = LZ4_compress_fast_extState(ctxPtr, source, dest, inputSize, maxOutputSize, acceleration);
  8042115d4a:	45 89 c1             	mov    %r8d,%r9d
  8042115d4d:	41 89 c8             	mov    %ecx,%r8d
  8042115d50:	89 d1                	mov    %edx,%ecx
  8042115d52:	48 89 f2             	mov    %rsi,%rdx
  8042115d55:	48 89 fe             	mov    %rdi,%rsi
  8042115d58:	48 8d bd e0 bf ff ff 	lea    -0x4020(%rbp),%rdi
  8042115d5f:	48 b8 9f 49 11 42 80 	movabs $0x804211499f,%rax
  8042115d66:	00 00 00 
  8042115d69:	ff d0                	call   *%rax
}
  8042115d6b:	c9                   	leave
  8042115d6c:	c3                   	ret

0000008042115d6d <LZ4_compress_default>:
{
  8042115d6d:	f3 0f 1e fa          	endbr64
  8042115d71:	55                   	push   %rbp
  8042115d72:	48 89 e5             	mov    %rsp,%rbp
    return LZ4_compress_fast(src, dst, srcSize, maxOutputSize, 1);
  8042115d75:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8042115d7b:	48 b8 25 5d 11 42 80 	movabs $0x8042115d25,%rax
  8042115d82:	00 00 00 
  8042115d85:	ff d0                	call   *%rax
}
  8042115d87:	5d                   	pop    %rbp
  8042115d88:	c3                   	ret

0000008042115d89 <LZ4_compress_fast_force>:
{
  8042115d89:	f3 0f 1e fa          	endbr64
  8042115d8d:	55                   	push   %rbp
  8042115d8e:	48 89 e5             	mov    %rsp,%rbp
  8042115d91:	41 57                	push   %r15
  8042115d93:	41 56                	push   %r14
  8042115d95:	41 55                	push   %r13
  8042115d97:	41 54                	push   %r12
  8042115d99:	53                   	push   %rbx
  8042115d9a:	4c 8d 9c 24 00 c0 ff 	lea    -0x4000(%rsp),%r11
  8042115da1:	ff 
  8042115da2:	48 81 ec 00 10 00 00 	sub    $0x1000,%rsp
  8042115da9:	48 83 0c 24 00       	orq    $0x0,(%rsp)
  8042115dae:	4c 39 dc             	cmp    %r11,%rsp
  8042115db1:	75 ef                	jne    8042115da2 <LZ4_compress_fast_force+0x19>
  8042115db3:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8042115dba:	49 89 fe             	mov    %rdi,%r14
  8042115dbd:	48 89 bd 80 bf ff ff 	mov    %rdi,-0x4080(%rbp)
  8042115dc4:	49 89 f7             	mov    %rsi,%r15
  8042115dc7:	48 89 b5 88 bf ff ff 	mov    %rsi,-0x4078(%rbp)
  8042115dce:	89 d3                	mov    %edx,%ebx
  8042115dd0:	41 89 cd             	mov    %ecx,%r13d
  8042115dd3:	45 89 c4             	mov    %r8d,%r12d
    LZ4_initStream(&ctx, sizeof(ctx));
  8042115dd6:	be 20 40 00 00       	mov    $0x4020,%esi
  8042115ddb:	48 8d bd b0 bf ff ff 	lea    -0x4050(%rbp),%rdi
  8042115de2:	48 b8 4a 49 11 42 80 	movabs $0x804211494a,%rax
  8042115de9:	00 00 00 
  8042115dec:	ff d0                	call   *%rax
    if (srcSize < LZ4_64Klimit) {
  8042115dee:	81 fb 0a 00 01 00    	cmp    $0x1000a,%ebx
  8042115df4:	0f 8f 0f 05 00 00    	jg     8042116309 <LZ4_compress_fast_force+0x580>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042115dfa:	b8 00 00 00 00       	mov    $0x0,%eax
  8042115dff:	81 fb 00 00 00 7e    	cmp    $0x7e000000,%ebx
  8042115e05:	0f 87 99 0a 00 00    	ja     80421168a4 <LZ4_compress_fast_force+0xb1b>
    U32 const startIndex = cctx->currentOffset;
  8042115e0b:	8b 55 b0             	mov    -0x50(%rbp),%edx
    const BYTE* const iend = ip + inputSize;
  8042115e0e:	48 63 c3             	movslq %ebx,%rax
  8042115e11:	4c 89 f6             	mov    %r14,%rsi
  8042115e14:	4d 8d 14 06          	lea    (%r14,%rax,1),%r10
  8042115e18:	4c 89 95 90 bf ff ff 	mov    %r10,-0x4070(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  8042115e1f:	4d 63 ed             	movslq %r13d,%r13
  8042115e22:	4c 89 ff             	mov    %r15,%rdi
  8042115e25:	4b 8d 04 2f          	lea    (%r15,%r13,1),%rax
  8042115e29:	48 89 85 a8 bf ff ff 	mov    %rax,-0x4058(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042115e30:	01 5d c8             	add    %ebx,-0x38(%rbp)
    cctx->currentOffset += (U32)inputSize;
  8042115e33:	8d 04 1a             	lea    (%rdx,%rbx,1),%eax
  8042115e36:	89 45 b0             	mov    %eax,-0x50(%rbp)
    cctx->tableType = (U16)tableType;
  8042115e39:	66 c7 45 b6 03 00    	movw   $0x3,-0x4a(%rbp)
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  8042115e3f:	83 fb 0c             	cmp    $0xc,%ebx
  8042115e42:	0f 8e e8 03 00 00    	jle    8042116230 <LZ4_compress_fast_force+0x4a7>
    const BYTE* base = (const BYTE*) source - startIndex;
  8042115e48:	89 d0                	mov    %edx,%eax
  8042115e4a:	4d 89 f7             	mov    %r14,%r15
  8042115e4d:	49 29 c7             	sub    %rax,%r15
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042115e50:	49 8d 42 f5          	lea    -0xb(%r10),%rax
  8042115e54:	48 89 85 98 bf ff ff 	mov    %rax,-0x4068(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042115e5b:	49 8d 42 fb          	lea    -0x5(%r10),%rax
  8042115e5f:	48 89 85 68 bf ff ff 	mov    %rax,-0x4098(%rbp)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042115e66:	41 69 06 b1 79 37 9e 	imul   $0x9e3779b1,(%r14),%eax
  8042115e6d:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042115e70:	89 c0                	mov    %eax,%eax
  8042115e72:	66 89 94 45 b0 bf ff 	mov    %dx,-0x4050(%rbp,%rax,2)
  8042115e79:	ff 
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042115e7a:	49 8d 4e 01          	lea    0x1(%r14),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042115e7e:	41 69 56 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r14),%edx
  8042115e85:	9e 
  8042115e86:	c1 ea 13             	shr    $0x13,%edx
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042115e89:	41 c1 e4 06          	shl    $0x6,%r12d
  8042115e8d:	48 89 bd a0 bf ff ff 	mov    %rdi,-0x4060(%rbp)
  8042115e94:	44 89 e7             	mov    %r12d,%edi
            int step = 1;
  8042115e97:	b8 01 00 00 00       	mov    $0x1,%eax
        return hashTable[h];
  8042115e9c:	4c 8b 95 98 bf ff ff 	mov    -0x4068(%rbp),%r10
                U32 const current = (U32)(forwardIp - base);
  8042115ea3:	49 89 c9             	mov    %rcx,%r9
  8042115ea6:	4d 29 f9             	sub    %r15,%r9
        return hashTable[h];
  8042115ea9:	89 d2                	mov    %edx,%edx
  8042115eab:	4c 8d 84 55 b0 bf ff 	lea    -0x4050(%rbp,%rdx,2),%r8
  8042115eb2:	ff 
  8042115eb3:	41 0f b7 10          	movzwl (%r8),%edx
                forwardIp += step;
  8042115eb7:	49 89 ce             	mov    %rcx,%r14
  8042115eba:	48 98                	cltq
  8042115ebc:	48 01 c1             	add    %rax,%rcx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042115ebf:	89 f8                	mov    %edi,%eax
  8042115ec1:	83 c7 01             	add    $0x1,%edi
  8042115ec4:	c1 f8 06             	sar    $0x6,%eax
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042115ec7:	49 39 ca             	cmp    %rcx,%r10
  8042115eca:	0f 82 75 03 00 00    	jb     8042116245 <LZ4_compress_fast_force+0x4bc>
                    match = base + matchIndex;
  8042115ed0:	0f b7 d2             	movzwl %dx,%edx
  8042115ed3:	49 8d 1c 17          	lea    (%r15,%rdx,1),%rbx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042115ed7:	69 11 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%edx
  8042115edd:	c1 ea 13             	shr    $0x13,%edx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042115ee0:	66 45 89 08          	mov    %r9w,(%r8)
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042115ee4:	44 8b 1b             	mov    (%rbx),%r11d
  8042115ee7:	45 39 1e             	cmp    %r11d,(%r14)
  8042115eea:	75 b7                	jne    8042115ea3 <LZ4_compress_fast_force+0x11a>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042115eec:	4c 39 f6             	cmp    %r14,%rsi
  8042115eef:	73 17                	jae    8042115f08 <LZ4_compress_fast_force+0x17f>
  8042115ef1:	48 39 9d 80 bf ff ff 	cmp    %rbx,-0x4080(%rbp)
  8042115ef8:	73 0e                	jae    8042115f08 <LZ4_compress_fast_force+0x17f>
  8042115efa:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042115efe:	41 38 46 ff          	cmp    %al,-0x1(%r14)
  8042115f02:	0f 84 8e 00 00 00    	je     8042115f96 <LZ4_compress_fast_force+0x20d>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042115f08:	4c 89 f0             	mov    %r14,%rax
  8042115f0b:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  8042115f0e:	48 8b 8d a0 bf ff ff 	mov    -0x4060(%rbp),%rcx
  8042115f15:	48 8d 79 01          	lea    0x1(%rcx),%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  8042115f19:	89 c1                	mov    %eax,%ecx
  8042115f1b:	89 c2                	mov    %eax,%edx
  8042115f1d:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  8042115f23:	49 0f af d0          	imul   %r8,%rdx
  8042115f27:	48 c1 ea 27          	shr    $0x27,%rdx
  8042115f2b:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  8042115f30:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  8042115f33:	48 39 95 a8 bf ff ff 	cmp    %rdx,-0x4058(%rbp)
  8042115f3a:	0f 82 8a 09 00 00    	jb     80421168ca <LZ4_compress_fast_force+0xb41>
            if (litLength >= RUN_MASK) {
  8042115f40:	83 f8 0e             	cmp    $0xe,%eax
  8042115f43:	77 74                	ja     8042115fb9 <LZ4_compress_fast_force+0x230>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042115f45:	c1 e0 04             	shl    $0x4,%eax
  8042115f48:	48 8b 95 a0 bf ff ff 	mov    -0x4060(%rbp),%rdx
  8042115f4f:	88 02                	mov    %al,(%rdx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042115f51:	4c 8d 2c 0f          	lea    (%rdi,%rcx,1),%r13
  8042115f55:	4c 89 ea             	mov    %r13,%rdx
  8042115f58:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042115f5f:	00 00 00 
  8042115f62:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042115f64:	48 8b 85 90 bf ff ff 	mov    -0x4070(%rbp),%rax
  8042115f6b:	48 83 e8 0c          	sub    $0xc,%rax
  8042115f6f:	48 89 85 78 bf ff ff 	mov    %rax,-0x4088(%rbp)
        return hashTable[h];
  8042115f76:	4c 89 bd 70 bf ff ff 	mov    %r15,-0x4090(%rbp)
  8042115f7d:	44 89 a5 64 bf ff ff 	mov    %r12d,-0x409c(%rbp)
  8042115f84:	48 89 d8             	mov    %rbx,%rax
  8042115f87:	4c 89 eb             	mov    %r13,%rbx
  8042115f8a:	4c 8b bd a0 bf ff ff 	mov    -0x4060(%rbp),%r15
  8042115f91:	e9 0f 01 00 00       	jmp    80421160a5 <LZ4_compress_fast_force+0x31c>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042115f96:	49 83 ee 01          	sub    $0x1,%r14
  8042115f9a:	48 83 eb 01          	sub    $0x1,%rbx
  8042115f9e:	4c 39 f6             	cmp    %r14,%rsi
  8042115fa1:	0f 83 61 ff ff ff    	jae    8042115f08 <LZ4_compress_fast_force+0x17f>
  8042115fa7:	48 39 9d 80 bf ff ff 	cmp    %rbx,-0x4080(%rbp)
  8042115fae:	0f 82 46 ff ff ff    	jb     8042115efa <LZ4_compress_fast_force+0x171>
  8042115fb4:	e9 4f ff ff ff       	jmp    8042115f08 <LZ4_compress_fast_force+0x17f>
                int len = (int)(litLength - RUN_MASK);
  8042115fb9:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  8042115fbc:	48 8b 95 a0 bf ff ff 	mov    -0x4060(%rbp),%rdx
  8042115fc3:	c6 02 f0             	movb   $0xf0,(%rdx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042115fc6:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042115fcb:	7e 14                	jle    8042115fe1 <LZ4_compress_fast_force+0x258>
  8042115fcd:	48 83 c7 01          	add    $0x1,%rdi
  8042115fd1:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042115fd5:	2d ff 00 00 00       	sub    $0xff,%eax
  8042115fda:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042115fdf:	7f ec                	jg     8042115fcd <LZ4_compress_fast_force+0x244>
                *op++ = (BYTE)len;
  8042115fe1:	88 07                	mov    %al,(%rdi)
  8042115fe3:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042115fe7:	e9 65 ff ff ff       	jmp    8042115f51 <LZ4_compress_fast_force+0x1c8>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042115fec:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042115fef:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042115ff6:	00 00 00 
  8042115ff9:	ff d0                	call   *%rax
  8042115ffb:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042115ffe:	44 89 e0             	mov    %r12d,%eax
  8042116001:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042116006:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  804211600d:	00 
  804211600e:	bf 81 80 80 80       	mov    $0x80808081,%edi
  8042116013:	48 0f af c7          	imul   %rdi,%rax
  8042116017:	48 c1 e8 27          	shr    $0x27,%rax
  804211601b:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042116020:	48 39 85 a8 bf ff ff 	cmp    %rax,-0x4058(%rbp)
  8042116027:	0f 82 a4 08 00 00    	jb     80421168d1 <LZ4_compress_fast_force+0xb48>
            if (matchCode >= ML_MASK) {
  804211602d:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042116031:	0f 87 6e 01 00 00    	ja     80421161a5 <LZ4_compress_fast_force+0x41c>
                *token += (BYTE)(matchCode);
  8042116037:	45 00 27             	add    %r12b,(%r15)
  804211603a:	4d 89 ef             	mov    %r13,%r15
        if (ip >= mflimitPlusOne) break;
  804211603d:	48 8b 85 98 bf ff ff 	mov    -0x4068(%rbp),%rax
  8042116044:	49 39 c6             	cmp    %rax,%r14
  8042116047:	0f 83 99 02 00 00    	jae    80421162e6 <LZ4_compress_fast_force+0x55d>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  804211604d:	41 69 46 fe b1 79 37 	imul   $0x9e3779b1,-0x2(%r14),%eax
  8042116054:	9e 
  8042116055:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042116058:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  804211605a:	49 8d 56 fe          	lea    -0x2(%r14),%rdx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  804211605e:	48 8b b5 70 bf ff ff 	mov    -0x4090(%rbp),%rsi
  8042116065:	48 29 f2             	sub    %rsi,%rdx
  8042116068:	66 89 94 45 b0 bf ff 	mov    %dx,-0x4050(%rbp,%rax,2)
  804211606f:	ff 
static U32 LZ4_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
  8042116070:	41 8b 16             	mov    (%r14),%edx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042116073:	69 c2 b1 79 37 9e    	imul   $0x9e3779b1,%edx,%eax
  8042116079:	c1 e8 13             	shr    $0x13,%eax
        return hashTable[h];
  804211607c:	89 c0                	mov    %eax,%eax
  804211607e:	48 8d 8c 45 b0 bf ff 	lea    -0x4050(%rbp,%rax,2),%rcx
  8042116085:	ff 
                match = base + matchIndex;
  8042116086:	0f b7 01             	movzwl (%rcx),%eax
  8042116089:	48 01 f0             	add    %rsi,%rax
            U32 const current = (U32)(ip-base);
  804211608c:	4c 89 f3             	mov    %r14,%rbx
  804211608f:	48 29 f3             	sub    %rsi,%rbx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042116092:	66 89 19             	mov    %bx,(%rcx)
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042116095:	39 10                	cmp    %edx,(%rax)
  8042116097:	0f 85 67 01 00 00    	jne    8042116204 <LZ4_compress_fast_force+0x47b>
                token=op++;
  804211609d:	49 8d 5f 01          	lea    0x1(%r15),%rbx
                *token=0;
  80421160a1:	41 c6 07 00          	movb   $0x0,(%r15)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  80421160a5:	4c 89 f2             	mov    %r14,%rdx
  80421160a8:	48 29 c2             	sub    %rax,%rdx
  80421160ab:	66 89 13             	mov    %dx,(%rbx)
  80421160ae:	4c 8d 6b 02          	lea    0x2(%rbx),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  80421160b2:	49 8d 4e 04          	lea    0x4(%r14),%rcx
  80421160b6:	48 89 8d a0 bf ff ff 	mov    %rcx,-0x4060(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421160bd:	48 8b b5 78 bf ff ff 	mov    -0x4088(%rbp),%rsi
  80421160c4:	48 39 f1             	cmp    %rsi,%rcx
  80421160c7:	73 61                	jae    804211612a <LZ4_compress_fast_force+0x3a1>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421160c9:	48 8b 50 04          	mov    0x4(%rax),%rdx
  80421160cd:	49 8b 7e 04          	mov    0x4(%r14),%rdi
        if (!diff) {
  80421160d1:	48 39 d7             	cmp    %rdx,%rdi
  80421160d4:	0f 85 12 ff ff ff    	jne    8042115fec <LZ4_compress_fast_force+0x263>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  80421160da:	4d 8d 66 0c          	lea    0xc(%r14),%r12
  80421160de:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421160e2:	49 39 f4             	cmp    %rsi,%r12
  80421160e5:	73 4e                	jae    8042116135 <LZ4_compress_fast_force+0x3ac>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421160e7:	48 8b 10             	mov    (%rax),%rdx
  80421160ea:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421160ee:	48 39 d7             	cmp    %rdx,%rdi
  80421160f1:	74 21                	je     8042116114 <LZ4_compress_fast_force+0x38b>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421160f3:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  80421160f6:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421160fd:	00 00 00 
  8042116100:	ff d0                	call   *%rax
  8042116102:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  8042116106:	8b 85 a0 bf ff ff    	mov    -0x4060(%rbp),%eax
  804211610c:	41 29 c4             	sub    %eax,%r12d
  804211610f:	e9 ea fe ff ff       	jmp    8042115ffe <LZ4_compress_fast_force+0x275>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042116114:	49 83 c4 08          	add    $0x8,%r12
  8042116118:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211611c:	48 8b 8d 78 bf ff ff 	mov    -0x4088(%rbp),%rcx
  8042116123:	49 39 cc             	cmp    %rcx,%r12
  8042116126:	72 bf                	jb     80421160e7 <LZ4_compress_fast_force+0x35e>
  8042116128:	eb 0b                	jmp    8042116135 <LZ4_compress_fast_force+0x3ac>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211612a:	48 83 c0 04          	add    $0x4,%rax
  804211612e:	4c 8b a5 a0 bf ff ff 	mov    -0x4060(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042116135:	48 8b 8d 90 bf ff ff 	mov    -0x4070(%rbp),%rcx
  804211613c:	48 8d 51 f8          	lea    -0x8(%rcx),%rdx
  8042116140:	49 39 d4             	cmp    %rdx,%r12
  8042116143:	73 08                	jae    804211614d <LZ4_compress_fast_force+0x3c4>
  8042116145:	8b 30                	mov    (%rax),%esi
  8042116147:	41 39 34 24          	cmp    %esi,(%r12)
  804211614b:	74 44                	je     8042116191 <LZ4_compress_fast_force+0x408>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211614d:	48 8b bd 90 bf ff ff 	mov    -0x4070(%rbp),%rdi
  8042116154:	48 8d 57 fa          	lea    -0x6(%rdi),%rdx
  8042116158:	49 39 d4             	cmp    %rdx,%r12
  804211615b:	73 0a                	jae    8042116167 <LZ4_compress_fast_force+0x3de>
  804211615d:	0f b7 38             	movzwl (%rax),%edi
  8042116160:	66 41 39 3c 24       	cmp    %di,(%r12)
  8042116165:	74 34                	je     804211619b <LZ4_compress_fast_force+0x412>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042116167:	48 8b b5 68 bf ff ff 	mov    -0x4098(%rbp),%rsi
  804211616e:	49 39 f4             	cmp    %rsi,%r12
  8042116171:	73 10                	jae    8042116183 <LZ4_compress_fast_force+0x3fa>
  8042116173:	41 0f b6 0c 24       	movzbl (%r12),%ecx
  8042116178:	38 08                	cmp    %cl,(%rax)
  804211617a:	0f 94 c0             	sete   %al
  804211617d:	0f b6 c0             	movzbl %al,%eax
  8042116180:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  8042116183:	8b 85 a0 bf ff ff    	mov    -0x4060(%rbp),%eax
  8042116189:	41 29 c4             	sub    %eax,%r12d
  804211618c:	e9 6d fe ff ff       	jmp    8042115ffe <LZ4_compress_fast_force+0x275>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042116191:	49 83 c4 04          	add    $0x4,%r12
  8042116195:	48 83 c0 04          	add    $0x4,%rax
  8042116199:	eb b2                	jmp    804211614d <LZ4_compress_fast_force+0x3c4>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211619b:	49 83 c4 02          	add    $0x2,%r12
  804211619f:	48 83 c0 02          	add    $0x2,%rax
  80421161a3:	eb c2                	jmp    8042116167 <LZ4_compress_fast_force+0x3de>
                *token += ML_MASK;
  80421161a5:	41 80 07 0f          	addb   $0xf,(%r15)
                matchCode -= ML_MASK;
  80421161a9:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421161ad:	c7 43 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rbx)
                while (matchCode >= 4*255) {
  80421161b4:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  80421161bb:	76 1c                	jbe    80421161d9 <LZ4_compress_fast_force+0x450>
                    op+=4;
  80421161bd:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421161c1:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  80421161c8:	ff 
                    matchCode -= 4*255;
  80421161c9:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  80421161d0:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  80421161d7:	77 e4                	ja     80421161bd <LZ4_compress_fast_force+0x434>
                op += matchCode / 255;
  80421161d9:	44 89 e0             	mov    %r12d,%eax
  80421161dc:	bb 81 80 80 80       	mov    $0x80808081,%ebx
  80421161e1:	48 0f af c3          	imul   %rbx,%rax
  80421161e5:	48 c1 e8 27          	shr    $0x27,%rax
  80421161e9:	89 c2                	mov    %eax,%edx
  80421161eb:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  80421161ee:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
  80421161f2:	89 c1                	mov    %eax,%ecx
  80421161f4:	c1 e1 08             	shl    $0x8,%ecx
  80421161f7:	29 c1                	sub    %eax,%ecx
  80421161f9:	41 29 cc             	sub    %ecx,%r12d
  80421161fc:	44 88 22             	mov    %r12b,(%rdx)
  80421161ff:	e9 39 fe ff ff       	jmp    804211603d <LZ4_compress_fast_force+0x2b4>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042116204:	44 8b a5 64 bf ff ff 	mov    -0x409c(%rbp),%r12d
  804211620b:	4c 89 bd a0 bf ff ff 	mov    %r15,-0x4060(%rbp)
  8042116212:	4c 8b bd 70 bf ff ff 	mov    -0x4090(%rbp),%r15
  8042116219:	49 8d 4e 01          	lea    0x1(%r14),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  804211621d:	41 69 56 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r14),%edx
  8042116224:	9e 
  8042116225:	c1 ea 13             	shr    $0x13,%edx
  8042116228:	4c 89 f6             	mov    %r14,%rsi
  804211622b:	e9 64 fc ff ff       	jmp    8042115e94 <LZ4_compress_fast_force+0x10b>
    BYTE* op = (BYTE*) dest;
  8042116230:	48 8b 85 88 bf ff ff 	mov    -0x4078(%rbp),%rax
  8042116237:	48 89 85 a0 bf ff ff 	mov    %rax,-0x4060(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  804211623e:	48 8b b5 80 bf ff ff 	mov    -0x4080(%rbp),%rsi
    {   size_t lastRun = (size_t)(iend - anchor);
  8042116245:	48 8b 9d 90 bf ff ff 	mov    -0x4070(%rbp),%rbx
  804211624c:	48 29 f3             	sub    %rsi,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  804211624f:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  8042116256:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  804211625d:	80 80 80 
  8042116260:	48 89 d0             	mov    %rdx,%rax
  8042116263:	48 f7 e1             	mul    %rcx
  8042116266:	48 c1 ea 07          	shr    $0x7,%rdx
  804211626a:	48 8d 54 13 01       	lea    0x1(%rbx,%rdx,1),%rdx
  804211626f:	48 8b 8d a0 bf ff ff 	mov    -0x4060(%rbp),%rcx
  8042116276:	48 01 ca             	add    %rcx,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042116279:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  804211627e:	48 39 95 a8 bf ff ff 	cmp    %rdx,-0x4058(%rbp)
  8042116285:	0f 82 19 06 00 00    	jb     80421168a4 <LZ4_compress_fast_force+0xb1b>
        if (lastRun >= RUN_MASK) {
  804211628b:	48 83 fb 0e          	cmp    $0xe,%rbx
  804211628f:	76 64                	jbe    80421162f5 <LZ4_compress_fast_force+0x56c>
            size_t accumulator = lastRun - RUN_MASK;
  8042116291:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042116295:	48 8d 41 01          	lea    0x1(%rcx),%rax
  8042116299:	c6 01 f0             	movb   $0xf0,(%rcx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  804211629c:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421162a3:	76 18                	jbe    80421162bd <LZ4_compress_fast_force+0x534>
  80421162a5:	48 83 c0 01          	add    $0x1,%rax
  80421162a9:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  80421162ad:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  80421162b4:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421162bb:	77 e8                	ja     80421162a5 <LZ4_compress_fast_force+0x51c>
            *op++ = (BYTE) accumulator;
  80421162bd:	4c 8d 60 01          	lea    0x1(%rax),%r12
  80421162c1:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  80421162c3:	48 89 da             	mov    %rbx,%rdx
  80421162c6:	4c 89 e7             	mov    %r12,%rdi
  80421162c9:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421162d0:	00 00 00 
  80421162d3:	ff d0                	call   *%rax
        op += lastRun;
  80421162d5:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  80421162d9:	8b 9d 88 bf ff ff    	mov    -0x4078(%rbp),%ebx
  80421162df:	29 d8                	sub    %ebx,%eax
    return result;
  80421162e1:	e9 be 05 00 00       	jmp    80421168a4 <LZ4_compress_fast_force+0xb1b>
        anchor = ip;
  80421162e6:	4c 89 bd a0 bf ff ff 	mov    %r15,-0x4060(%rbp)
  80421162ed:	4c 89 f6             	mov    %r14,%rsi
  80421162f0:	e9 50 ff ff ff       	jmp    8042116245 <LZ4_compress_fast_force+0x4bc>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  80421162f5:	48 8b bd a0 bf ff ff 	mov    -0x4060(%rbp),%rdi
  80421162fc:	4c 8d 67 01          	lea    0x1(%rdi),%r12
  8042116300:	89 d8                	mov    %ebx,%eax
  8042116302:	c1 e0 04             	shl    $0x4,%eax
  8042116305:	88 07                	mov    %al,(%rdi)
  8042116307:	eb ba                	jmp    80421162c3 <LZ4_compress_fast_force+0x53a>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042116309:	b8 00 00 00 00       	mov    $0x0,%eax
  804211630e:	81 fb 00 00 00 7e    	cmp    $0x7e000000,%ebx
  8042116314:	0f 87 8a 05 00 00    	ja     80421168a4 <LZ4_compress_fast_force+0xb1b>
    U32 const startIndex = cctx->currentOffset;
  804211631a:	44 8b 75 b0          	mov    -0x50(%rbp),%r14d
    const BYTE* base = (const BYTE*) source - startIndex;
  804211631e:	44 89 f0             	mov    %r14d,%eax
  8042116321:	4c 8b bd 80 bf ff ff 	mov    -0x4080(%rbp),%r15
  8042116328:	4c 89 fe             	mov    %r15,%rsi
  804211632b:	48 29 c6             	sub    %rax,%rsi
  804211632e:	48 89 b5 a8 bf ff ff 	mov    %rsi,-0x4058(%rbp)
    const BYTE* const iend = ip + inputSize;
  8042116335:	48 63 c3             	movslq %ebx,%rax
  8042116338:	4c 01 f8             	add    %r15,%rax
  804211633b:	48 89 85 68 bf ff ff 	mov    %rax,-0x4098(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042116342:	48 8d 78 f5          	lea    -0xb(%rax),%rdi
  8042116346:	48 89 bd 90 bf ff ff 	mov    %rdi,-0x4070(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  804211634d:	48 83 e8 05          	sub    $0x5,%rax
  8042116351:	48 89 85 50 bf ff ff 	mov    %rax,-0x40b0(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  8042116358:	4d 63 ed             	movslq %r13d,%r13
  804211635b:	48 8b 85 88 bf ff ff 	mov    -0x4078(%rbp),%rax
  8042116362:	4a 8d 3c 28          	lea    (%rax,%r13,1),%rdi
  8042116366:	48 89 bd 78 bf ff ff 	mov    %rdi,-0x4088(%rbp)
        cctx->dictSize += (U32)inputSize;
  804211636d:	01 5d c8             	add    %ebx,-0x38(%rbp)
    cctx->currentOffset += (U32)inputSize;
  8042116370:	44 01 f3             	add    %r14d,%ebx
  8042116373:	89 5d b0             	mov    %ebx,-0x50(%rbp)
    cctx->tableType = (U16)tableType;
  8042116376:	66 c7 45 b6 02 00    	movw   $0x2,-0x4a(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211637c:	49 8b 3f             	mov    (%r15),%rdi
  804211637f:	be 02 00 00 00       	mov    $0x2,%esi
  8042116384:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  804211638b:	00 00 00 
  804211638e:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042116390:	89 c0                	mov    %eax,%eax
  8042116392:	44 89 b4 85 b0 bf ff 	mov    %r14d,-0x4050(%rbp,%rax,4)
  8042116399:	ff 
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  804211639a:	4d 89 fe             	mov    %r15,%r14
  804211639d:	4d 8d 7f 01          	lea    0x1(%r15),%r15
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421163a1:	49 8b 7e 01          	mov    0x1(%r14),%rdi
  80421163a5:	be 02 00 00 00       	mov    $0x2,%esi
  80421163aa:	ff d3                	call   *%rbx
  80421163ac:	48 8b 9d 88 bf ff ff 	mov    -0x4078(%rbp),%rbx
  80421163b3:	48 89 9d 70 bf ff ff 	mov    %rbx,-0x4090(%rbp)
  80421163ba:	4c 89 f6             	mov    %r14,%rsi
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  80421163bd:	41 c1 e4 06          	shl    $0x6,%r12d
  80421163c1:	44 89 a5 64 bf ff ff 	mov    %r12d,-0x409c(%rbp)
                U32 const current = (U32)(forwardIp - base);
  80421163c8:	45 89 fe             	mov    %r15d,%r14d
  80421163cb:	8b 9d a8 bf ff ff    	mov    -0x4058(%rbp),%ebx
  80421163d1:	41 29 de             	sub    %ebx,%r14d
        return hashTable[h];
  80421163d4:	89 c0                	mov    %eax,%eax
  80421163d6:	4c 8d ac 85 b0 bf ff 	lea    -0x4050(%rbp,%rax,4),%r13
  80421163dd:	ff 
  80421163de:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  80421163e2:	4d 8d 67 01          	lea    0x1(%r15),%r12
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421163e6:	8b 85 64 bf ff ff    	mov    -0x409c(%rbp),%eax
  80421163ec:	8d 48 01             	lea    0x1(%rax),%ecx
  80421163ef:	c1 f8 06             	sar    $0x6,%eax
  80421163f2:	89 85 a0 bf ff ff    	mov    %eax,-0x4060(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421163f8:	4c 39 a5 90 bf ff ff 	cmp    %r12,-0x4070(%rbp)
  80421163ff:	0f 82 07 04 00 00    	jb     804211680c <LZ4_compress_fast_force+0xa83>
  8042116405:	4c 89 bd 98 bf ff ff 	mov    %r15,-0x4068(%rbp)
  804211640c:	41 89 cf             	mov    %ecx,%r15d
  804211640f:	48 89 b5 58 bf ff ff 	mov    %rsi,-0x40a8(%rbp)
  8042116416:	eb 4d                	jmp    8042116465 <LZ4_compress_fast_force+0x6dc>
                U32 const current = (U32)(forwardIp - base);
  8042116418:	45 89 e6             	mov    %r12d,%r14d
  804211641b:	8b 8d a8 bf ff ff    	mov    -0x4058(%rbp),%ecx
  8042116421:	41 29 ce             	sub    %ecx,%r14d
        return hashTable[h];
  8042116424:	89 c0                	mov    %eax,%eax
  8042116426:	4c 8d ac 85 b0 bf ff 	lea    -0x4050(%rbp,%rax,4),%r13
  804211642d:	ff 
  804211642e:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  8042116432:	48 63 85 a0 bf ff ff 	movslq -0x4060(%rbp),%rax
  8042116439:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211643c:	41 8d 57 01          	lea    0x1(%r15),%edx
  8042116440:	41 c1 ff 06          	sar    $0x6,%r15d
  8042116444:	44 89 bd a0 bf ff ff 	mov    %r15d,-0x4060(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  804211644b:	4c 89 a5 98 bf ff ff 	mov    %r12,-0x4068(%rbp)
  8042116452:	48 39 85 90 bf ff ff 	cmp    %rax,-0x4070(%rbp)
  8042116459:	0f 82 a6 03 00 00    	jb     8042116805 <LZ4_compress_fast_force+0xa7c>
  804211645f:	41 89 d7             	mov    %edx,%r15d
  8042116462:	49 89 c4             	mov    %rax,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042116465:	49 8b 3c 24          	mov    (%r12),%rdi
  8042116469:	be 02 00 00 00       	mov    $0x2,%esi
  804211646e:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042116475:	00 00 00 
  8042116478:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211647a:	45 89 75 00          	mov    %r14d,0x0(%r13)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  804211647e:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  8042116484:	44 39 f2             	cmp    %r14d,%edx
  8042116487:	72 8f                	jb     8042116418 <LZ4_compress_fast_force+0x68f>
                    match = base + matchIndex;
  8042116489:	89 db                	mov    %ebx,%ebx
  804211648b:	48 8b b5 a8 bf ff ff 	mov    -0x4058(%rbp),%rsi
  8042116492:	48 01 f3             	add    %rsi,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042116495:	48 8b 8d 98 bf ff ff 	mov    -0x4068(%rbp),%rcx
  804211649c:	8b 33                	mov    (%rbx),%esi
  804211649e:	39 31                	cmp    %esi,(%rcx)
  80421164a0:	0f 85 72 ff ff ff    	jne    8042116418 <LZ4_compress_fast_force+0x68f>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  80421164a6:	49 89 cf             	mov    %rcx,%r15
  80421164a9:	48 8b b5 58 bf ff ff 	mov    -0x40a8(%rbp),%rsi
  80421164b0:	48 39 9d 80 bf ff ff 	cmp    %rbx,-0x4080(%rbp)
  80421164b7:	73 0f                	jae    80421164c8 <LZ4_compress_fast_force+0x73f>
  80421164b9:	48 39 ce             	cmp    %rcx,%rsi
  80421164bc:	73 0a                	jae    80421164c8 <LZ4_compress_fast_force+0x73f>
  80421164be:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  80421164c2:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  80421164c6:	74 7d                	je     8042116545 <LZ4_compress_fast_force+0x7bc>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  80421164c8:	4c 89 f8             	mov    %r15,%rax
  80421164cb:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  80421164ce:	48 8b 8d 70 bf ff ff 	mov    -0x4090(%rbp),%rcx
  80421164d5:	48 8d 79 01          	lea    0x1(%rcx),%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  80421164d9:	89 c1                	mov    %eax,%ecx
  80421164db:	89 c2                	mov    %eax,%edx
  80421164dd:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  80421164e3:	49 0f af d0          	imul   %r8,%rdx
  80421164e7:	48 c1 ea 27          	shr    $0x27,%rdx
  80421164eb:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  80421164f0:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  80421164f3:	48 39 95 78 bf ff ff 	cmp    %rdx,-0x4088(%rbp)
  80421164fa:	0f 82 d8 03 00 00    	jb     80421168d8 <LZ4_compress_fast_force+0xb4f>
            if (litLength >= RUN_MASK) {
  8042116500:	83 f8 0e             	cmp    $0xe,%eax
  8042116503:	77 63                	ja     8042116568 <LZ4_compress_fast_force+0x7df>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042116505:	c1 e0 04             	shl    $0x4,%eax
  8042116508:	48 8b 95 70 bf ff ff 	mov    -0x4090(%rbp),%rdx
  804211650f:	88 02                	mov    %al,(%rdx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042116511:	4c 8d 34 0f          	lea    (%rdi,%rcx,1),%r14
  8042116515:	4c 89 f2             	mov    %r14,%rdx
  8042116518:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211651f:	00 00 00 
  8042116522:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042116524:	48 8b 85 68 bf ff ff 	mov    -0x4098(%rbp),%rax
  804211652b:	48 83 e8 0c          	sub    $0xc,%rax
  804211652f:	48 89 85 98 bf ff ff 	mov    %rax,-0x4068(%rbp)
        return hashTable[h];
  8042116536:	48 89 d8             	mov    %rbx,%rax
  8042116539:	48 8b 9d 70 bf ff ff 	mov    -0x4090(%rbp),%rbx
  8042116540:	e9 28 01 00 00       	jmp    804211666d <LZ4_compress_fast_force+0x8e4>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042116545:	49 83 ef 01          	sub    $0x1,%r15
  8042116549:	48 83 eb 01          	sub    $0x1,%rbx
  804211654d:	4c 39 fe             	cmp    %r15,%rsi
  8042116550:	0f 83 72 ff ff ff    	jae    80421164c8 <LZ4_compress_fast_force+0x73f>
  8042116556:	48 39 9d 80 bf ff ff 	cmp    %rbx,-0x4080(%rbp)
  804211655d:	0f 82 5b ff ff ff    	jb     80421164be <LZ4_compress_fast_force+0x735>
  8042116563:	e9 60 ff ff ff       	jmp    80421164c8 <LZ4_compress_fast_force+0x73f>
                int len = (int)(litLength - RUN_MASK);
  8042116568:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  804211656b:	48 8b 95 70 bf ff ff 	mov    -0x4090(%rbp),%rdx
  8042116572:	c6 02 f0             	movb   $0xf0,(%rdx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042116575:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211657a:	7e 14                	jle    8042116590 <LZ4_compress_fast_force+0x807>
  804211657c:	48 83 c7 01          	add    $0x1,%rdi
  8042116580:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042116584:	2d ff 00 00 00       	sub    $0xff,%eax
  8042116589:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211658e:	7f ec                	jg     804211657c <LZ4_compress_fast_force+0x7f3>
                *op++ = (BYTE)len;
  8042116590:	88 07                	mov    %al,(%rdi)
  8042116592:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042116596:	e9 76 ff ff ff       	jmp    8042116511 <LZ4_compress_fast_force+0x788>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211659b:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211659e:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421165a5:	00 00 00 
  80421165a8:	ff d0                	call   *%rax
  80421165aa:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  80421165ad:	44 89 e0             	mov    %r12d,%eax
  80421165b0:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  80421165b5:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  80421165bc:	00 
  80421165bd:	bf 81 80 80 80       	mov    $0x80808081,%edi
  80421165c2:	48 0f af c7          	imul   %rdi,%rax
  80421165c6:	48 c1 e8 27          	shr    $0x27,%rax
  80421165ca:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  80421165cf:	48 39 85 78 bf ff ff 	cmp    %rax,-0x4088(%rbp)
  80421165d6:	0f 82 03 03 00 00    	jb     80421168df <LZ4_compress_fast_force+0xb56>
            if (matchCode >= ML_MASK) {
  80421165dc:	41 83 fc 0e          	cmp    $0xe,%r12d
  80421165e0:	0f 87 89 01 00 00    	ja     804211676f <LZ4_compress_fast_force+0x9e6>
                *token += (BYTE)(matchCode);
  80421165e6:	44 00 23             	add    %r12b,(%rbx)
  80421165e9:	4c 89 eb             	mov    %r13,%rbx
        if (ip >= mflimitPlusOne) break;
  80421165ec:	48 8b 85 90 bf ff ff 	mov    -0x4070(%rbp),%rax
  80421165f3:	49 39 c7             	cmp    %rax,%r15
  80421165f6:	0f 83 fd 01 00 00    	jae    80421167f9 <LZ4_compress_fast_force+0xa70>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421165fc:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  8042116600:	be 02 00 00 00       	mov    $0x2,%esi
  8042116605:	49 bd ce 28 11 42 80 	movabs $0x80421128ce,%r13
  804211660c:	00 00 00 
  804211660f:	41 ff d5             	call   *%r13
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042116612:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042116614:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042116618:	4c 8b b5 a8 bf ff ff 	mov    -0x4058(%rbp),%r14
  804211661f:	4c 29 f2             	sub    %r14,%rdx
  8042116622:	89 94 85 b0 bf ff ff 	mov    %edx,-0x4050(%rbp,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042116629:	49 8b 3f             	mov    (%r15),%rdi
  804211662c:	be 02 00 00 00       	mov    $0x2,%esi
  8042116631:	41 ff d5             	call   *%r13
            U32 const current = (U32)(ip-base);
  8042116634:	4c 89 f9             	mov    %r15,%rcx
  8042116637:	4c 29 f1             	sub    %r14,%rcx
        return hashTable[h];
  804211663a:	89 c0                	mov    %eax,%eax
  804211663c:	48 8d b4 85 b0 bf ff 	lea    -0x4050(%rbp,%rax,4),%rsi
  8042116643:	ff 
  8042116644:	8b 16                	mov    (%rsi),%edx
                match = base + matchIndex;
  8042116646:	89 d0                	mov    %edx,%eax
  8042116648:	4c 01 f0             	add    %r14,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211664b:	89 0e                	mov    %ecx,(%rsi)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  804211664d:	81 c2 ff ff 00 00    	add    $0xffff,%edx
  8042116653:	39 ca                	cmp    %ecx,%edx
  8042116655:	0f 82 73 01 00 00    	jb     80421167ce <LZ4_compress_fast_force+0xa45>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  804211665b:	8b 08                	mov    (%rax),%ecx
  804211665d:	41 39 0f             	cmp    %ecx,(%r15)
  8042116660:	0f 85 68 01 00 00    	jne    80421167ce <LZ4_compress_fast_force+0xa45>
                token=op++;
  8042116666:	4c 8d 73 01          	lea    0x1(%rbx),%r14
                *token=0;
  804211666a:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  804211666d:	4c 89 fa             	mov    %r15,%rdx
  8042116670:	48 29 c2             	sub    %rax,%rdx
  8042116673:	66 41 89 16          	mov    %dx,(%r14)
  8042116677:	4d 8d 6e 02          	lea    0x2(%r14),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211667b:	49 8d 4f 04          	lea    0x4(%r15),%rcx
  804211667f:	48 89 8d a0 bf ff ff 	mov    %rcx,-0x4060(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042116686:	48 8b b5 98 bf ff ff 	mov    -0x4068(%rbp),%rsi
  804211668d:	48 39 f1             	cmp    %rsi,%rcx
  8042116690:	73 61                	jae    80421166f3 <LZ4_compress_fast_force+0x96a>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042116692:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042116696:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211669a:	48 39 d7             	cmp    %rdx,%rdi
  804211669d:	0f 85 f8 fe ff ff    	jne    804211659b <LZ4_compress_fast_force+0x812>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  80421166a3:	4d 8d 67 0c          	lea    0xc(%r15),%r12
  80421166a7:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421166ab:	49 39 f4             	cmp    %rsi,%r12
  80421166ae:	73 4e                	jae    80421166fe <LZ4_compress_fast_force+0x975>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421166b0:	48 8b 10             	mov    (%rax),%rdx
  80421166b3:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421166b7:	48 39 d7             	cmp    %rdx,%rdi
  80421166ba:	74 21                	je     80421166dd <LZ4_compress_fast_force+0x954>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421166bc:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  80421166bf:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421166c6:	00 00 00 
  80421166c9:	ff d0                	call   *%rax
  80421166cb:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  80421166cf:	8b 85 a0 bf ff ff    	mov    -0x4060(%rbp),%eax
  80421166d5:	41 29 c4             	sub    %eax,%r12d
  80421166d8:	e9 d0 fe ff ff       	jmp    80421165ad <LZ4_compress_fast_force+0x824>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421166dd:	49 83 c4 08          	add    $0x8,%r12
  80421166e1:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421166e5:	48 8b 8d 98 bf ff ff 	mov    -0x4068(%rbp),%rcx
  80421166ec:	49 39 cc             	cmp    %rcx,%r12
  80421166ef:	72 bf                	jb     80421166b0 <LZ4_compress_fast_force+0x927>
  80421166f1:	eb 0b                	jmp    80421166fe <LZ4_compress_fast_force+0x975>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  80421166f3:	48 83 c0 04          	add    $0x4,%rax
  80421166f7:	4c 8b a5 a0 bf ff ff 	mov    -0x4060(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421166fe:	48 8b 8d 68 bf ff ff 	mov    -0x4098(%rbp),%rcx
  8042116705:	48 8d 51 f8          	lea    -0x8(%rcx),%rdx
  8042116709:	49 39 d4             	cmp    %rdx,%r12
  804211670c:	73 08                	jae    8042116716 <LZ4_compress_fast_force+0x98d>
  804211670e:	8b 30                	mov    (%rax),%esi
  8042116710:	41 39 34 24          	cmp    %esi,(%r12)
  8042116714:	74 45                	je     804211675b <LZ4_compress_fast_force+0x9d2>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042116716:	48 8b bd 68 bf ff ff 	mov    -0x4098(%rbp),%rdi
  804211671d:	48 8d 57 fa          	lea    -0x6(%rdi),%rdx
  8042116721:	49 39 d4             	cmp    %rdx,%r12
  8042116724:	73 0a                	jae    8042116730 <LZ4_compress_fast_force+0x9a7>
  8042116726:	0f b7 38             	movzwl (%rax),%edi
  8042116729:	66 41 39 3c 24       	cmp    %di,(%r12)
  804211672e:	74 35                	je     8042116765 <LZ4_compress_fast_force+0x9dc>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042116730:	48 8b 8d 50 bf ff ff 	mov    -0x40b0(%rbp),%rcx
  8042116737:	49 39 cc             	cmp    %rcx,%r12
  804211673a:	73 11                	jae    804211674d <LZ4_compress_fast_force+0x9c4>
  804211673c:	41 0f b6 34 24       	movzbl (%r12),%esi
  8042116741:	40 38 30             	cmp    %sil,(%rax)
  8042116744:	0f 94 c0             	sete   %al
  8042116747:	0f b6 c0             	movzbl %al,%eax
  804211674a:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  804211674d:	8b 85 a0 bf ff ff    	mov    -0x4060(%rbp),%eax
  8042116753:	41 29 c4             	sub    %eax,%r12d
  8042116756:	e9 52 fe ff ff       	jmp    80421165ad <LZ4_compress_fast_force+0x824>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211675b:	49 83 c4 04          	add    $0x4,%r12
  804211675f:	48 83 c0 04          	add    $0x4,%rax
  8042116763:	eb b1                	jmp    8042116716 <LZ4_compress_fast_force+0x98d>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042116765:	49 83 c4 02          	add    $0x2,%r12
  8042116769:	48 83 c0 02          	add    $0x2,%rax
  804211676d:	eb c1                	jmp    8042116730 <LZ4_compress_fast_force+0x9a7>
                *token += ML_MASK;
  804211676f:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  8042116772:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042116776:	41 c7 46 02 ff ff ff 	movl   $0xffffffff,0x2(%r14)
  804211677d:	ff 
                while (matchCode >= 4*255) {
  804211677e:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042116785:	76 1c                	jbe    80421167a3 <LZ4_compress_fast_force+0xa1a>
                    op+=4;
  8042116787:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211678b:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  8042116792:	ff 
                    matchCode -= 4*255;
  8042116793:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  804211679a:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  80421167a1:	77 e4                	ja     8042116787 <LZ4_compress_fast_force+0x9fe>
                op += matchCode / 255;
  80421167a3:	44 89 e0             	mov    %r12d,%eax
  80421167a6:	ba 81 80 80 80       	mov    $0x80808081,%edx
  80421167ab:	48 0f af c2          	imul   %rdx,%rax
  80421167af:	48 c1 e8 27          	shr    $0x27,%rax
  80421167b3:	89 c2                	mov    %eax,%edx
  80421167b5:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  80421167b8:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  80421167bc:	89 c1                	mov    %eax,%ecx
  80421167be:	c1 e1 08             	shl    $0x8,%ecx
  80421167c1:	29 c1                	sub    %eax,%ecx
  80421167c3:	41 29 cc             	sub    %ecx,%r12d
  80421167c6:	44 88 22             	mov    %r12b,(%rdx)
  80421167c9:	e9 1e fe ff ff       	jmp    80421165ec <LZ4_compress_fast_force+0x863>
        forwardH = LZ4_hashPosition(++ip, tableType);
  80421167ce:	48 89 9d 70 bf ff ff 	mov    %rbx,-0x4090(%rbp)
  80421167d5:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421167d9:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  80421167dd:	be 02 00 00 00       	mov    $0x2,%esi
  80421167e2:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  80421167e9:	00 00 00 
  80421167ec:	ff d0                	call   *%rax
  80421167ee:	4c 89 fe             	mov    %r15,%rsi
  80421167f1:	49 89 df             	mov    %rbx,%r15
  80421167f4:	e9 cf fb ff ff       	jmp    80421163c8 <LZ4_compress_fast_force+0x63f>
        anchor = ip;
  80421167f9:	48 89 9d 70 bf ff ff 	mov    %rbx,-0x4090(%rbp)
  8042116800:	4c 89 fe             	mov    %r15,%rsi
  8042116803:	eb 07                	jmp    804211680c <LZ4_compress_fast_force+0xa83>
  8042116805:	48 8b b5 58 bf ff ff 	mov    -0x40a8(%rbp),%rsi
    {   size_t lastRun = (size_t)(iend - anchor);
  804211680c:	48 8b 9d 68 bf ff ff 	mov    -0x4098(%rbp),%rbx
  8042116813:	48 29 f3             	sub    %rsi,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  8042116816:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  804211681d:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  8042116824:	80 80 80 
  8042116827:	48 89 d0             	mov    %rdx,%rax
  804211682a:	48 f7 e1             	mul    %rcx
  804211682d:	48 c1 ea 07          	shr    $0x7,%rdx
  8042116831:	48 8d 54 13 01       	lea    0x1(%rbx,%rdx,1),%rdx
  8042116836:	48 8b bd 70 bf ff ff 	mov    -0x4090(%rbp),%rdi
  804211683d:	48 01 fa             	add    %rdi,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042116840:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  8042116845:	48 39 95 78 bf ff ff 	cmp    %rdx,-0x4088(%rbp)
  804211684c:	72 56                	jb     80421168a4 <LZ4_compress_fast_force+0xb1b>
        if (lastRun >= RUN_MASK) {
  804211684e:	48 83 fb 0e          	cmp    $0xe,%rbx
  8042116852:	76 62                	jbe    80421168b6 <LZ4_compress_fast_force+0xb2d>
            size_t accumulator = lastRun - RUN_MASK;
  8042116854:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042116858:	48 8d 47 01          	lea    0x1(%rdi),%rax
  804211685c:	c6 07 f0             	movb   $0xf0,(%rdi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  804211685f:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042116866:	76 18                	jbe    8042116880 <LZ4_compress_fast_force+0xaf7>
  8042116868:	48 83 c0 01          	add    $0x1,%rax
  804211686c:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042116870:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042116877:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211687e:	77 e8                	ja     8042116868 <LZ4_compress_fast_force+0xadf>
            *op++ = (BYTE) accumulator;
  8042116880:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8042116884:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042116886:	48 89 da             	mov    %rbx,%rdx
  8042116889:	4c 89 e7             	mov    %r12,%rdi
  804211688c:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042116893:	00 00 00 
  8042116896:	ff d0                	call   *%rax
        op += lastRun;
  8042116898:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  804211689c:	8b 9d 88 bf ff ff    	mov    -0x4078(%rbp),%ebx
  80421168a2:	29 d8                	sub    %ebx,%eax
}
  80421168a4:	48 81 c4 88 40 00 00 	add    $0x4088,%rsp
  80421168ab:	5b                   	pop    %rbx
  80421168ac:	41 5c                	pop    %r12
  80421168ae:	41 5d                	pop    %r13
  80421168b0:	41 5e                	pop    %r14
  80421168b2:	41 5f                	pop    %r15
  80421168b4:	5d                   	pop    %rbp
  80421168b5:	c3                   	ret
            *op++ = (BYTE)(lastRun<<ML_BITS);
  80421168b6:	48 8b bd 70 bf ff ff 	mov    -0x4090(%rbp),%rdi
  80421168bd:	4c 8d 67 01          	lea    0x1(%rdi),%r12
  80421168c1:	89 d8                	mov    %ebx,%eax
  80421168c3:	c1 e0 04             	shl    $0x4,%eax
  80421168c6:	88 07                	mov    %al,(%rdi)
  80421168c8:	eb bc                	jmp    8042116886 <LZ4_compress_fast_force+0xafd>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  80421168ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80421168cf:	eb d3                	jmp    80421168a4 <LZ4_compress_fast_force+0xb1b>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  80421168d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80421168d6:	eb cc                	jmp    80421168a4 <LZ4_compress_fast_force+0xb1b>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  80421168d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80421168dd:	eb c5                	jmp    80421168a4 <LZ4_compress_fast_force+0xb1b>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  80421168df:	b8 00 00 00 00       	mov    $0x0,%eax
  80421168e4:	eb be                	jmp    80421168a4 <LZ4_compress_fast_force+0xb1b>

00000080421168e6 <LZ4_compress_destSize>:
{
  80421168e6:	f3 0f 1e fa          	endbr64
  80421168ea:	55                   	push   %rbp
  80421168eb:	48 89 e5             	mov    %rsp,%rbp
  80421168ee:	41 57                	push   %r15
  80421168f0:	41 56                	push   %r14
  80421168f2:	41 55                	push   %r13
  80421168f4:	41 54                	push   %r12
  80421168f6:	53                   	push   %rbx
  80421168f7:	4c 8d 9c 24 00 c0 ff 	lea    -0x4000(%rsp),%r11
  80421168fe:	ff 
  80421168ff:	48 81 ec 00 10 00 00 	sub    $0x1000,%rsp
  8042116906:	48 83 0c 24 00       	orq    $0x0,(%rsp)
  804211690b:	4c 39 dc             	cmp    %r11,%rsp
  804211690e:	75 ef                	jne    80421168ff <LZ4_compress_destSize+0x19>
  8042116910:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8042116917:	48 89 bd a0 bf ff ff 	mov    %rdi,-0x4060(%rbp)
  804211691e:	48 89 b5 98 bf ff ff 	mov    %rsi,-0x4068(%rbp)
  8042116925:	49 89 d7             	mov    %rdx,%r15
  8042116928:	48 89 95 78 bf ff ff 	mov    %rdx,-0x4088(%rbp)
  804211692f:	89 cb                	mov    %ecx,%ebx
    void* const s = LZ4_initStream(state, sizeof (*state));
  8042116931:	be 20 40 00 00       	mov    $0x4020,%esi
  8042116936:	48 8d bd b0 bf ff ff 	lea    -0x4050(%rbp),%rdi
  804211693d:	48 b8 4a 49 11 42 80 	movabs $0x804211494a,%rax
  8042116944:	00 00 00 
  8042116947:	ff d0                	call   *%rax
    if (targetDstSize >= LZ4_compressBound(*srcSizePtr)) {  /* compression success is guaranteed */
  8042116949:	45 8b 27             	mov    (%r15),%r12d
  804211694c:	44 89 e7             	mov    %r12d,%edi
  804211694f:	48 b8 10 29 11 42 80 	movabs $0x8042112910,%rax
  8042116956:	00 00 00 
  8042116959:	ff d0                	call   *%rax
  804211695b:	39 c3                	cmp    %eax,%ebx
  804211695d:	0f 8d ea 01 00 00    	jge    8042116b4d <LZ4_compress_destSize+0x267>
        if (*srcSizePtr < LZ4_64Klimit) {
  8042116963:	41 81 fc 0a 00 01 00 	cmp    $0x1000a,%r12d
  804211696a:	0f 8f 1d 06 00 00    	jg     8042116f8d <LZ4_compress_destSize+0x6a7>
    if (outputDirective == fillOutput && maxOutputSize < 1) { return 0; } /* Impossible to store anything */
  8042116970:	b8 00 00 00 00       	mov    $0x0,%eax
  8042116975:	85 db                	test   %ebx,%ebx
  8042116977:	0f 8e fd 01 00 00    	jle    8042116b7a <LZ4_compress_destSize+0x294>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  804211697d:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042116984:	0f 87 f0 01 00 00    	ja     8042116b7a <LZ4_compress_destSize+0x294>
    U32 const startIndex = cctx->currentOffset;
  804211698a:	8b 55 b0             	mov    -0x50(%rbp),%edx
    const BYTE* const iend = ip + inputSize;
  804211698d:	49 63 c4             	movslq %r12d,%rax
  8042116990:	48 8b bd a0 bf ff ff 	mov    -0x4060(%rbp),%rdi
  8042116997:	4c 8d 2c 07          	lea    (%rdi,%rax,1),%r13
    BYTE* const olimit = op + maxOutputSize;
  804211699b:	48 63 db             	movslq %ebx,%rbx
  804211699e:	4c 8b bd 98 bf ff ff 	mov    -0x4068(%rbp),%r15
  80421169a5:	49 8d 04 1f          	lea    (%r15,%rbx,1),%rax
  80421169a9:	48 89 85 a8 bf ff ff 	mov    %rax,-0x4058(%rbp)
        cctx->dictSize += (U32)inputSize;
  80421169b0:	44 01 65 c8          	add    %r12d,-0x38(%rbp)
    cctx->currentOffset += (U32)inputSize;
  80421169b4:	42 8d 04 22          	lea    (%rdx,%r12,1),%eax
  80421169b8:	89 45 b0             	mov    %eax,-0x50(%rbp)
    cctx->tableType = (U16)tableType;
  80421169bb:	66 c7 45 b6 03 00    	movw   $0x3,-0x4a(%rbp)
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  80421169c1:	41 83 fc 0c          	cmp    $0xc,%r12d
  80421169c5:	0f 8e c9 04 00 00    	jle    8042116e94 <LZ4_compress_destSize+0x5ae>
    const BYTE* base = (const BYTE*) source - startIndex;
  80421169cb:	89 d0                	mov    %edx,%eax
  80421169cd:	49 89 fc             	mov    %rdi,%r12
  80421169d0:	49 29 c4             	sub    %rax,%r12
  80421169d3:	4c 89 a5 70 bf ff ff 	mov    %r12,-0x4090(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  80421169da:	49 8d 45 f5          	lea    -0xb(%r13),%rax
  80421169de:	48 89 85 88 bf ff ff 	mov    %rax,-0x4078(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  80421169e5:	49 8d 45 fb          	lea    -0x5(%r13),%rax
  80421169e9:	48 89 85 68 bf ff ff 	mov    %rax,-0x4098(%rbp)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  80421169f0:	69 07 b1 79 37 9e    	imul   $0x9e3779b1,(%rdi),%eax
  80421169f6:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  80421169f9:	89 c0                	mov    %eax,%eax
  80421169fb:	66 89 94 45 b0 bf ff 	mov    %dx,-0x4050(%rbp,%rax,2)
  8042116a02:	ff 
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042116a03:	49 89 fc             	mov    %rdi,%r12
  8042116a06:	48 8d 4f 01          	lea    0x1(%rdi),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042116a0a:	69 47 01 b1 79 37 9e 	imul   $0x9e3779b1,0x1(%rdi),%eax
  8042116a11:	c1 e8 13             	shr    $0x13,%eax
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042116a14:	be 40 00 00 00       	mov    $0x40,%esi
            int step = 1;
  8042116a19:	ba 01 00 00 00       	mov    $0x1,%edx
        return hashTable[h];
  8042116a1e:	4c 8b 85 70 bf ff ff 	mov    -0x4090(%rbp),%r8
  8042116a25:	4c 8b 95 88 bf ff ff 	mov    -0x4078(%rbp),%r10
                U32 const current = (U32)(forwardIp - base);
  8042116a2c:	49 89 c9             	mov    %rcx,%r9
  8042116a2f:	4d 29 c1             	sub    %r8,%r9
        return hashTable[h];
  8042116a32:	89 c0                	mov    %eax,%eax
  8042116a34:	48 8d bc 45 b0 bf ff 	lea    -0x4050(%rbp,%rax,2),%rdi
  8042116a3b:	ff 
  8042116a3c:	0f b7 07             	movzwl (%rdi),%eax
                forwardIp += step;
  8042116a3f:	49 89 cb             	mov    %rcx,%r11
  8042116a42:	48 63 d2             	movslq %edx,%rdx
  8042116a45:	48 01 d1             	add    %rdx,%rcx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042116a48:	89 f2                	mov    %esi,%edx
  8042116a4a:	83 c6 01             	add    $0x1,%esi
  8042116a4d:	c1 fa 06             	sar    $0x6,%edx
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042116a50:	49 39 ca             	cmp    %rcx,%r10
  8042116a53:	0f 82 49 04 00 00    	jb     8042116ea2 <LZ4_compress_destSize+0x5bc>
                    match = base + matchIndex;
  8042116a59:	0f b7 c0             	movzwl %ax,%eax
  8042116a5c:	49 8d 1c 00          	lea    (%r8,%rax,1),%rbx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042116a60:	69 01 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%eax
  8042116a66:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042116a69:	66 44 89 0f          	mov    %r9w,(%rdi)
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042116a6d:	8b 3b                	mov    (%rbx),%edi
  8042116a6f:	41 39 3b             	cmp    %edi,(%r11)
  8042116a72:	75 b8                	jne    8042116a2c <LZ4_compress_destSize+0x146>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042116a74:	4c 89 9d 60 bf ff ff 	mov    %r11,-0x40a0(%rbp)
  8042116a7b:	4d 39 dc             	cmp    %r11,%r12
  8042116a7e:	0f 83 08 01 00 00    	jae    8042116b8c <LZ4_compress_destSize+0x2a6>
  8042116a84:	4d 89 de             	mov    %r11,%r14
  8042116a87:	48 39 9d a0 bf ff ff 	cmp    %rbx,-0x4060(%rbp)
  8042116a8e:	0f 83 f8 00 00 00    	jae    8042116b8c <LZ4_compress_destSize+0x2a6>
  8042116a94:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042116a98:	41 38 46 ff          	cmp    %al,-0x1(%r14)
  8042116a9c:	0f 84 f6 00 00 00    	je     8042116b98 <LZ4_compress_destSize+0x2b2>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042116aa2:	4c 89 f0             	mov    %r14,%rax
  8042116aa5:	4c 29 e0             	sub    %r12,%rax
            token = op++;
  8042116aa8:	49 8d 7f 01          	lea    0x1(%r15),%rdi
                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {
  8042116aac:	89 c1                	mov    %eax,%ecx
  8042116aae:	8d 90 f0 00 00 00    	lea    0xf0(%rax),%edx
  8042116ab4:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042116ab9:	48 0f af d6          	imul   %rsi,%rdx
  8042116abd:	48 c1 ea 27          	shr    $0x27,%rdx
  8042116ac1:	48 8d 54 11 0b       	lea    0xb(%rcx,%rdx,1),%rdx
  8042116ac6:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == fillOutput) &&
  8042116ac9:	48 39 95 a8 bf ff ff 	cmp    %rdx,-0x4058(%rbp)
  8042116ad0:	0f 82 cc 03 00 00    	jb     8042116ea2 <LZ4_compress_destSize+0x5bc>
            if (litLength >= RUN_MASK) {
  8042116ad6:	83 f8 0e             	cmp    $0xe,%eax
  8042116ad9:	0f 87 dc 00 00 00    	ja     8042116bbb <LZ4_compress_destSize+0x2d5>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042116adf:	c1 e0 04             	shl    $0x4,%eax
  8042116ae2:	41 88 07             	mov    %al,(%r15)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042116ae5:	48 8d 34 0f          	lea    (%rdi,%rcx,1),%rsi
  8042116ae9:	48 89 b5 90 bf ff ff 	mov    %rsi,-0x4070(%rbp)
  8042116af0:	48 89 f2             	mov    %rsi,%rdx
  8042116af3:	4c 89 e6             	mov    %r12,%rsi
  8042116af6:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042116afd:	00 00 00 
  8042116b00:	ff d0                	call   *%rax
            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {
  8042116b02:	48 8b b5 90 bf ff ff 	mov    -0x4070(%rbp),%rsi
  8042116b09:	48 8d 46 0b          	lea    0xb(%rsi),%rax
        if ((outputDirective == fillOutput) &&
  8042116b0d:	48 39 85 a8 bf ff ff 	cmp    %rax,-0x4058(%rbp)
  8042116b14:	0f 82 88 03 00 00    	jb     8042116ea2 <LZ4_compress_destSize+0x5bc>
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042116b1a:	49 8d 45 f4          	lea    -0xc(%r13),%rax
  8042116b1e:	48 89 85 80 bf ff ff 	mov    %rax,-0x4080(%rbp)
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042116b25:	49 8d 45 f8          	lea    -0x8(%r13),%rax
  8042116b29:	48 89 85 58 bf ff ff 	mov    %rax,-0x40a8(%rbp)
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042116b30:	49 8d 45 fa          	lea    -0x6(%r13),%rax
  8042116b34:	48 89 85 50 bf ff ff 	mov    %rax,-0x40b0(%rbp)
        return hashTable[h];
  8042116b3b:	4c 89 ad 48 bf ff ff 	mov    %r13,-0x40b8(%rbp)
  8042116b42:	48 89 d8             	mov    %rbx,%rax
  8042116b45:	48 89 f3             	mov    %rsi,%rbx
  8042116b48:	e9 65 01 00 00       	jmp    8042116cb2 <LZ4_compress_destSize+0x3cc>
        return LZ4_compress_fast_extState(state, src, dst, *srcSizePtr, targetDstSize, 1);
  8042116b4d:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  8042116b53:	41 89 d8             	mov    %ebx,%r8d
  8042116b56:	44 89 e1             	mov    %r12d,%ecx
  8042116b59:	48 8b 95 98 bf ff ff 	mov    -0x4068(%rbp),%rdx
  8042116b60:	48 8b b5 a0 bf ff ff 	mov    -0x4060(%rbp),%rsi
  8042116b67:	48 8d bd b0 bf ff ff 	lea    -0x4050(%rbp),%rdi
  8042116b6e:	48 b8 9f 49 11 42 80 	movabs $0x804211499f,%rax
  8042116b75:	00 00 00 
  8042116b78:	ff d0                	call   *%rax
}
  8042116b7a:	48 81 c4 98 40 00 00 	add    $0x4098,%rsp
  8042116b81:	5b                   	pop    %rbx
  8042116b82:	41 5c                	pop    %r12
  8042116b84:	41 5d                	pop    %r13
  8042116b86:	41 5e                	pop    %r14
  8042116b88:	41 5f                	pop    %r15
  8042116b8a:	5d                   	pop    %rbp
  8042116b8b:	c3                   	ret
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042116b8c:	4c 8b b5 60 bf ff ff 	mov    -0x40a0(%rbp),%r14
  8042116b93:	e9 0a ff ff ff       	jmp    8042116aa2 <LZ4_compress_destSize+0x1bc>
  8042116b98:	49 83 ee 01          	sub    $0x1,%r14
  8042116b9c:	48 83 eb 01          	sub    $0x1,%rbx
  8042116ba0:	4d 39 f4             	cmp    %r14,%r12
  8042116ba3:	0f 83 f9 fe ff ff    	jae    8042116aa2 <LZ4_compress_destSize+0x1bc>
  8042116ba9:	48 39 9d a0 bf ff ff 	cmp    %rbx,-0x4060(%rbp)
  8042116bb0:	0f 82 de fe ff ff    	jb     8042116a94 <LZ4_compress_destSize+0x1ae>
  8042116bb6:	e9 e7 fe ff ff       	jmp    8042116aa2 <LZ4_compress_destSize+0x1bc>
                int len = (int)(litLength - RUN_MASK);
  8042116bbb:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  8042116bbe:	41 c6 07 f0          	movb   $0xf0,(%r15)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042116bc2:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042116bc7:	7e 14                	jle    8042116bdd <LZ4_compress_destSize+0x2f7>
  8042116bc9:	48 83 c7 01          	add    $0x1,%rdi
  8042116bcd:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042116bd1:	2d ff 00 00 00       	sub    $0xff,%eax
  8042116bd6:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042116bdb:	7f ec                	jg     8042116bc9 <LZ4_compress_destSize+0x2e3>
                *op++ = (BYTE)len;
  8042116bdd:	88 07                	mov    %al,(%rdi)
  8042116bdf:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042116be3:	e9 fd fe ff ff       	jmp    8042116ae5 <LZ4_compress_destSize+0x1ff>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042116be8:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042116beb:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042116bf2:	00 00 00 
  8042116bf5:	ff d0                	call   *%rax
  8042116bf7:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042116bfa:	44 89 e0             	mov    %r12d,%eax
  8042116bfd:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042116c02:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  8042116c09:	00 
  8042116c0a:	b9 81 80 80 80       	mov    $0x80808081,%ecx
  8042116c0f:	48 0f af c1          	imul   %rcx,%rax
  8042116c13:	48 c1 e8 27          	shr    $0x27,%rax
  8042116c17:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042116c1c:	48 39 85 a8 bf ff ff 	cmp    %rax,-0x4058(%rbp)
  8042116c23:	0f 82 82 01 00 00    	jb     8042116dab <LZ4_compress_destSize+0x4c5>
            if (matchCode >= ML_MASK) {
  8042116c29:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042116c2d:	0f 87 d8 01 00 00    	ja     8042116e0b <LZ4_compress_destSize+0x525>
                *token += (BYTE)(matchCode);
  8042116c33:	45 00 27             	add    %r12b,(%r15)
  8042116c36:	4d 89 ef             	mov    %r13,%r15
        if (ip >= mflimitPlusOne) break;
  8042116c39:	48 8b 85 88 bf ff ff 	mov    -0x4078(%rbp),%rax
  8042116c40:	49 39 c6             	cmp    %rax,%r14
  8042116c43:	0f 83 27 03 00 00    	jae    8042116f70 <LZ4_compress_destSize+0x68a>
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042116c49:	41 69 46 fe b1 79 37 	imul   $0x9e3779b1,-0x2(%r14),%eax
  8042116c50:	9e 
  8042116c51:	c1 e8 13             	shr    $0x13,%eax
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042116c54:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042116c56:	49 8d 56 fe          	lea    -0x2(%r14),%rdx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
  8042116c5a:	48 8b b5 70 bf ff ff 	mov    -0x4090(%rbp),%rsi
  8042116c61:	48 29 f2             	sub    %rsi,%rdx
  8042116c64:	66 89 94 45 b0 bf ff 	mov    %dx,-0x4050(%rbp,%rax,2)
  8042116c6b:	ff 
static U32 LZ4_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
  8042116c6c:	41 8b 16             	mov    (%r14),%edx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042116c6f:	69 c2 b1 79 37 9e    	imul   $0x9e3779b1,%edx,%eax
  8042116c75:	c1 e8 13             	shr    $0x13,%eax
        return hashTable[h];
  8042116c78:	89 c0                	mov    %eax,%eax
  8042116c7a:	48 8d 8c 45 b0 bf ff 	lea    -0x4050(%rbp,%rax,2),%rcx
  8042116c81:	ff 
                match = base + matchIndex;
  8042116c82:	0f b7 01             	movzwl (%rcx),%eax
  8042116c85:	48 01 f0             	add    %rsi,%rax
            U32 const current = (U32)(ip-base);
  8042116c88:	4c 89 f3             	mov    %r14,%rbx
  8042116c8b:	48 29 f3             	sub    %rsi,%rbx
        case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
  8042116c8e:	66 89 19             	mov    %bx,(%rcx)
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042116c91:	39 10                	cmp    %edx,(%rax)
  8042116c93:	0f 85 dd 01 00 00    	jne    8042116e76 <LZ4_compress_destSize+0x590>
                token=op++;
  8042116c99:	49 8d 5f 01          	lea    0x1(%r15),%rbx
                *token=0;
  8042116c9d:	41 c6 07 00          	movb   $0x0,(%r15)
            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {
  8042116ca1:	49 8d 57 0c          	lea    0xc(%r15),%rdx
        if ((outputDirective == fillOutput) &&
  8042116ca5:	48 39 95 a8 bf ff ff 	cmp    %rdx,-0x4058(%rbp)
  8042116cac:	0f 82 b8 01 00 00    	jb     8042116e6a <LZ4_compress_destSize+0x584>
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042116cb2:	4c 89 f2             	mov    %r14,%rdx
  8042116cb5:	48 29 c2             	sub    %rax,%rdx
  8042116cb8:	66 89 13             	mov    %dx,(%rbx)
  8042116cbb:	4c 8d 6b 02          	lea    0x2(%rbx),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042116cbf:	49 8d 4e 04          	lea    0x4(%r14),%rcx
  8042116cc3:	48 89 8d 90 bf ff ff 	mov    %rcx,-0x4070(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042116cca:	48 8b b5 80 bf ff ff 	mov    -0x4080(%rbp),%rsi
  8042116cd1:	48 39 f1             	cmp    %rsi,%rcx
  8042116cd4:	73 61                	jae    8042116d37 <LZ4_compress_destSize+0x451>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042116cd6:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042116cda:	49 8b 7e 04          	mov    0x4(%r14),%rdi
        if (!diff) {
  8042116cde:	48 39 d7             	cmp    %rdx,%rdi
  8042116ce1:	0f 85 01 ff ff ff    	jne    8042116be8 <LZ4_compress_destSize+0x302>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042116ce7:	4d 8d 66 0c          	lea    0xc(%r14),%r12
  8042116ceb:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042116cef:	49 39 f4             	cmp    %rsi,%r12
  8042116cf2:	73 4e                	jae    8042116d42 <LZ4_compress_destSize+0x45c>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042116cf4:	48 8b 10             	mov    (%rax),%rdx
  8042116cf7:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042116cfb:	48 39 d7             	cmp    %rdx,%rdi
  8042116cfe:	74 21                	je     8042116d21 <LZ4_compress_destSize+0x43b>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042116d00:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042116d03:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042116d0a:	00 00 00 
  8042116d0d:	ff d0                	call   *%rax
  8042116d0f:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  8042116d13:	8b 85 90 bf ff ff    	mov    -0x4070(%rbp),%eax
  8042116d19:	41 29 c4             	sub    %eax,%r12d
  8042116d1c:	e9 d9 fe ff ff       	jmp    8042116bfa <LZ4_compress_destSize+0x314>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042116d21:	49 83 c4 08          	add    $0x8,%r12
  8042116d25:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042116d29:	48 8b 8d 80 bf ff ff 	mov    -0x4080(%rbp),%rcx
  8042116d30:	49 39 cc             	cmp    %rcx,%r12
  8042116d33:	72 bf                	jb     8042116cf4 <LZ4_compress_destSize+0x40e>
  8042116d35:	eb 0b                	jmp    8042116d42 <LZ4_compress_destSize+0x45c>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042116d37:	48 83 c0 04          	add    $0x4,%rax
  8042116d3b:	4c 8b a5 90 bf ff ff 	mov    -0x4070(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042116d42:	48 8b bd 58 bf ff ff 	mov    -0x40a8(%rbp),%rdi
  8042116d49:	49 39 fc             	cmp    %rdi,%r12
  8042116d4c:	73 08                	jae    8042116d56 <LZ4_compress_destSize+0x470>
  8042116d4e:	8b 38                	mov    (%rax),%edi
  8042116d50:	41 39 3c 24          	cmp    %edi,(%r12)
  8042116d54:	74 41                	je     8042116d97 <LZ4_compress_destSize+0x4b1>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042116d56:	48 8b 8d 50 bf ff ff 	mov    -0x40b0(%rbp),%rcx
  8042116d5d:	49 39 cc             	cmp    %rcx,%r12
  8042116d60:	73 0a                	jae    8042116d6c <LZ4_compress_destSize+0x486>
  8042116d62:	0f b7 08             	movzwl (%rax),%ecx
  8042116d65:	66 41 39 0c 24       	cmp    %cx,(%r12)
  8042116d6a:	74 35                	je     8042116da1 <LZ4_compress_destSize+0x4bb>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042116d6c:	48 8b bd 68 bf ff ff 	mov    -0x4098(%rbp),%rdi
  8042116d73:	49 39 fc             	cmp    %rdi,%r12
  8042116d76:	73 11                	jae    8042116d89 <LZ4_compress_destSize+0x4a3>
  8042116d78:	41 0f b6 34 24       	movzbl (%r12),%esi
  8042116d7d:	40 38 30             	cmp    %sil,(%rax)
  8042116d80:	0f 94 c0             	sete   %al
  8042116d83:	0f b6 c0             	movzbl %al,%eax
  8042116d86:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  8042116d89:	8b 85 90 bf ff ff    	mov    -0x4070(%rbp),%eax
  8042116d8f:	41 29 c4             	sub    %eax,%r12d
  8042116d92:	e9 63 fe ff ff       	jmp    8042116bfa <LZ4_compress_destSize+0x314>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042116d97:	49 83 c4 04          	add    $0x4,%r12
  8042116d9b:	48 83 c0 04          	add    $0x4,%rax
  8042116d9f:	eb b5                	jmp    8042116d56 <LZ4_compress_destSize+0x470>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042116da1:	49 83 c4 02          	add    $0x2,%r12
  8042116da5:	48 83 c0 02          	add    $0x2,%rax
  8042116da9:	eb c1                	jmp    8042116d6c <LZ4_compress_destSize+0x486>
                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 1 - LASTLITERALS) * 255;
  8042116dab:	48 8b 95 a8 bf ff ff 	mov    -0x4058(%rbp),%rdx
  8042116db2:	4c 29 ea             	sub    %r13,%rdx
  8042116db5:	89 d0                	mov    %edx,%eax
  8042116db7:	c1 e0 08             	shl    $0x8,%eax
  8042116dba:	29 d0                	sub    %edx,%eax
  8042116dbc:	2d ec 05 00 00       	sub    $0x5ec,%eax
                    ip -= matchCode - newMatchCode;
  8042116dc1:	41 29 c4             	sub    %eax,%r12d
  8042116dc4:	4d 29 e6             	sub    %r12,%r14
                    matchCode = newMatchCode;
  8042116dc7:	41 89 c4             	mov    %eax,%r12d
                    if (unlikely(ip <= filledIp)) {
  8042116dca:	4c 39 b5 60 bf ff ff 	cmp    %r14,-0x40a0(%rbp)
  8042116dd1:	0f 82 52 fe ff ff    	jb     8042116c29 <LZ4_compress_destSize+0x343>
  8042116dd7:	48 8b bd 60 bf ff ff 	mov    -0x40a0(%rbp),%rdi
  8042116dde:	48 8d 77 01          	lea    0x1(%rdi),%rsi
                        for (ptr = ip; ptr <= filledIp; ++ptr) {
  8042116de2:	4c 89 f1             	mov    %r14,%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042116de5:	69 11 b1 79 37 9e    	imul   $0x9e3779b1,(%rcx),%edx
  8042116deb:	c1 ea 13             	shr    $0x13,%edx
        case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = 0; return; }
  8042116dee:	89 d2                	mov    %edx,%edx
  8042116df0:	66 c7 84 55 b0 bf ff 	movw   $0x0,-0x4050(%rbp,%rdx,2)
  8042116df7:	ff 00 00 
                        for (ptr = ip; ptr <= filledIp; ++ptr) {
  8042116dfa:	48 83 c1 01          	add    $0x1,%rcx
  8042116dfe:	48 39 f1             	cmp    %rsi,%rcx
  8042116e01:	75 e2                	jne    8042116de5 <LZ4_compress_destSize+0x4ff>
                    matchCode = newMatchCode;
  8042116e03:	41 89 c4             	mov    %eax,%r12d
  8042116e06:	e9 1e fe ff ff       	jmp    8042116c29 <LZ4_compress_destSize+0x343>
                *token += ML_MASK;
  8042116e0b:	41 80 07 0f          	addb   $0xf,(%r15)
                matchCode -= ML_MASK;
  8042116e0f:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042116e13:	c7 43 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rbx)
                while (matchCode >= 4*255) {
  8042116e1a:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042116e21:	76 1c                	jbe    8042116e3f <LZ4_compress_destSize+0x559>
                    op+=4;
  8042116e23:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042116e27:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  8042116e2e:	ff 
                    matchCode -= 4*255;
  8042116e2f:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  8042116e36:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042116e3d:	77 e4                	ja     8042116e23 <LZ4_compress_destSize+0x53d>
                op += matchCode / 255;
  8042116e3f:	44 89 e0             	mov    %r12d,%eax
  8042116e42:	bb 81 80 80 80       	mov    $0x80808081,%ebx
  8042116e47:	48 0f af c3          	imul   %rbx,%rax
  8042116e4b:	48 c1 e8 27          	shr    $0x27,%rax
  8042116e4f:	89 c2                	mov    %eax,%edx
  8042116e51:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042116e54:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
  8042116e58:	89 c1                	mov    %eax,%ecx
  8042116e5a:	c1 e1 08             	shl    $0x8,%ecx
  8042116e5d:	29 c1                	sub    %eax,%ecx
  8042116e5f:	41 29 cc             	sub    %ecx,%r12d
  8042116e62:	44 88 22             	mov    %r12b,(%rdx)
  8042116e65:	e9 cf fd ff ff       	jmp    8042116c39 <LZ4_compress_destSize+0x353>
  8042116e6a:	4c 8b ad 48 bf ff ff 	mov    -0x40b8(%rbp),%r13
  8042116e71:	4d 89 f4             	mov    %r14,%r12
  8042116e74:	eb 2c                	jmp    8042116ea2 <LZ4_compress_destSize+0x5bc>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042116e76:	4c 8b ad 48 bf ff ff 	mov    -0x40b8(%rbp),%r13
  8042116e7d:	49 8d 4e 01          	lea    0x1(%r14),%rcx
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
  8042116e81:	41 69 46 01 b1 79 37 	imul   $0x9e3779b1,0x1(%r14),%eax
  8042116e88:	9e 
  8042116e89:	c1 e8 13             	shr    $0x13,%eax
  8042116e8c:	4d 89 f4             	mov    %r14,%r12
  8042116e8f:	e9 80 fb ff ff       	jmp    8042116a14 <LZ4_compress_destSize+0x12e>
    BYTE* op = (BYTE*) dest;
  8042116e94:	4c 8b bd 98 bf ff ff 	mov    -0x4068(%rbp),%r15
    const BYTE* anchor = (const BYTE*) source;
  8042116e9b:	4c 8b a5 a0 bf ff ff 	mov    -0x4060(%rbp),%r12
    {   size_t lastRun = (size_t)(iend - anchor);
  8042116ea2:	4c 89 eb             	mov    %r13,%rbx
  8042116ea5:	4c 29 e3             	sub    %r12,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  8042116ea8:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  8042116eaf:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  8042116eb6:	80 80 80 
  8042116eb9:	48 89 d0             	mov    %rdx,%rax
  8042116ebc:	48 f7 e1             	mul    %rcx
  8042116ebf:	48 c1 ea 07          	shr    $0x7,%rdx
  8042116ec3:	48 8d 44 13 01       	lea    0x1(%rbx,%rdx,1),%rax
  8042116ec8:	4c 01 f8             	add    %r15,%rax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  8042116ecb:	48 8b bd a8 bf ff ff 	mov    -0x4058(%rbp),%rdi
  8042116ed2:	48 39 c7             	cmp    %rax,%rdi
  8042116ed5:	73 1e                	jae    8042116ef5 <LZ4_compress_destSize+0x60f>
                lastRun  = (size_t)(olimit-op) - 1;
  8042116ed7:	48 89 fa             	mov    %rdi,%rdx
  8042116eda:	4c 29 fa             	sub    %r15,%rdx
  8042116edd:	48 8d 5a ff          	lea    -0x1(%rdx),%rbx
                lastRun -= (lastRun+240)/255;
  8042116ee1:	48 81 c2 ef 00 00 00 	add    $0xef,%rdx
  8042116ee8:	48 89 d0             	mov    %rdx,%rax
  8042116eeb:	48 f7 e1             	mul    %rcx
  8042116eee:	48 c1 ea 07          	shr    $0x7,%rdx
  8042116ef2:	48 29 d3             	sub    %rdx,%rbx
        if (lastRun >= RUN_MASK) {
  8042116ef5:	48 83 fb 0e          	cmp    $0xe,%rbx
  8042116ef9:	0f 86 80 00 00 00    	jbe    8042116f7f <LZ4_compress_destSize+0x699>
            size_t accumulator = lastRun - RUN_MASK;
  8042116eff:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042116f03:	49 8d 47 01          	lea    0x1(%r15),%rax
  8042116f07:	41 c6 07 f0          	movb   $0xf0,(%r15)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042116f0b:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042116f12:	76 18                	jbe    8042116f2c <LZ4_compress_destSize+0x646>
  8042116f14:	48 83 c0 01          	add    $0x1,%rax
  8042116f18:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042116f1c:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042116f23:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042116f2a:	77 e8                	ja     8042116f14 <LZ4_compress_destSize+0x62e>
            *op++ = (BYTE) accumulator;
  8042116f2c:	4c 8d 68 01          	lea    0x1(%rax),%r13
  8042116f30:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042116f32:	48 89 da             	mov    %rbx,%rdx
  8042116f35:	4c 89 e6             	mov    %r12,%rsi
  8042116f38:	4c 89 ef             	mov    %r13,%rdi
  8042116f3b:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042116f42:	00 00 00 
  8042116f45:	ff d0                	call   *%rax
        ip = anchor + lastRun;
  8042116f47:	49 01 dc             	add    %rbx,%r12
        *inputConsumed = (int) (((const char*)ip)-source);
  8042116f4a:	48 8b 85 a0 bf ff ff 	mov    -0x4060(%rbp),%rax
  8042116f51:	49 29 c4             	sub    %rax,%r12
  8042116f54:	48 8b 85 78 bf ff ff 	mov    -0x4088(%rbp),%rax
  8042116f5b:	44 89 20             	mov    %r12d,(%rax)
        op += lastRun;
  8042116f5e:	49 8d 44 1d 00       	lea    0x0(%r13,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  8042116f63:	8b 9d 98 bf ff ff    	mov    -0x4068(%rbp),%ebx
  8042116f69:	29 d8                	sub    %ebx,%eax
    return result;
  8042116f6b:	e9 0a fc ff ff       	jmp    8042116b7a <LZ4_compress_destSize+0x294>
        anchor = ip;
  8042116f70:	4c 8b ad 48 bf ff ff 	mov    -0x40b8(%rbp),%r13
  8042116f77:	4d 89 f4             	mov    %r14,%r12
  8042116f7a:	e9 23 ff ff ff       	jmp    8042116ea2 <LZ4_compress_destSize+0x5bc>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042116f7f:	4d 8d 6f 01          	lea    0x1(%r15),%r13
  8042116f83:	89 d8                	mov    %ebx,%eax
  8042116f85:	c1 e0 04             	shl    $0x4,%eax
  8042116f88:	41 88 07             	mov    %al,(%r15)
  8042116f8b:	eb a5                	jmp    8042116f32 <LZ4_compress_destSize+0x64c>
    if (outputDirective == fillOutput && maxOutputSize < 1) { return 0; } /* Impossible to store anything */
  8042116f8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8042116f92:	85 db                	test   %ebx,%ebx
  8042116f94:	0f 8e e0 fb ff ff    	jle    8042116b7a <LZ4_compress_destSize+0x294>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042116f9a:	41 81 fc 00 00 00 7e 	cmp    $0x7e000000,%r12d
  8042116fa1:	0f 87 d3 fb ff ff    	ja     8042116b7a <LZ4_compress_destSize+0x294>
    U32 const startIndex = cctx->currentOffset;
  8042116fa7:	44 8b 6d b0          	mov    -0x50(%rbp),%r13d
    const BYTE* base = (const BYTE*) source - startIndex;
  8042116fab:	44 89 e8             	mov    %r13d,%eax
  8042116fae:	4c 8b b5 a0 bf ff ff 	mov    -0x4060(%rbp),%r14
  8042116fb5:	4c 89 f6             	mov    %r14,%rsi
  8042116fb8:	48 29 c6             	sub    %rax,%rsi
  8042116fbb:	48 89 b5 a8 bf ff ff 	mov    %rsi,-0x4058(%rbp)
    const BYTE* const iend = ip + inputSize;
  8042116fc2:	49 63 c4             	movslq %r12d,%rax
  8042116fc5:	4c 01 f0             	add    %r14,%rax
  8042116fc8:	48 89 85 58 bf ff ff 	mov    %rax,-0x40a8(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042116fcf:	48 8d 70 f5          	lea    -0xb(%rax),%rsi
  8042116fd3:	48 89 b5 80 bf ff ff 	mov    %rsi,-0x4080(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042116fda:	48 83 e8 05          	sub    $0x5,%rax
  8042116fde:	48 89 85 50 bf ff ff 	mov    %rax,-0x40b0(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  8042116fe5:	48 63 db             	movslq %ebx,%rbx
  8042116fe8:	4c 8b bd 98 bf ff ff 	mov    -0x4068(%rbp),%r15
  8042116fef:	49 8d 04 1f          	lea    (%r15,%rbx,1),%rax
  8042116ff3:	48 89 85 70 bf ff ff 	mov    %rax,-0x4090(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042116ffa:	44 01 65 c8          	add    %r12d,-0x38(%rbp)
    cctx->currentOffset += (U32)inputSize;
  8042116ffe:	45 01 ec             	add    %r13d,%r12d
  8042117001:	44 89 65 b0          	mov    %r12d,-0x50(%rbp)
    cctx->tableType = (U16)tableType;
  8042117005:	66 c7 45 b6 02 00    	movw   $0x2,-0x4a(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211700b:	49 8b 3e             	mov    (%r14),%rdi
  804211700e:	be 02 00 00 00       	mov    $0x2,%esi
  8042117013:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  804211701a:	00 00 00 
  804211701d:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211701f:	89 c0                	mov    %eax,%eax
  8042117021:	44 89 ac 85 b0 bf ff 	mov    %r13d,-0x4050(%rbp,%rax,4)
  8042117028:	ff 
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042117029:	49 8d 46 01          	lea    0x1(%r14),%rax
  804211702d:	48 89 85 90 bf ff ff 	mov    %rax,-0x4070(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117034:	49 8b 7e 01          	mov    0x1(%r14),%rdi
  8042117038:	be 02 00 00 00       	mov    $0x2,%esi
  804211703d:	ff d3                	call   *%rbx
  804211703f:	4c 89 bd 60 bf ff ff 	mov    %r15,-0x40a0(%rbp)
  8042117046:	4c 89 b5 68 bf ff ff 	mov    %r14,-0x4098(%rbp)
                U32 const current = (U32)(forwardIp - base);
  804211704d:	48 8b 8d 90 bf ff ff 	mov    -0x4070(%rbp),%rcx
  8042117054:	41 89 ce             	mov    %ecx,%r14d
  8042117057:	8b 9d a8 bf ff ff    	mov    -0x4058(%rbp),%ebx
  804211705d:	41 29 de             	sub    %ebx,%r14d
        return hashTable[h];
  8042117060:	89 c0                	mov    %eax,%eax
  8042117062:	4c 8d ac 85 b0 bf ff 	lea    -0x4050(%rbp,%rax,4),%r13
  8042117069:	ff 
  804211706a:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  804211706e:	4c 8d 61 01          	lea    0x1(%rcx),%r12
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042117072:	4c 39 a5 80 bf ff ff 	cmp    %r12,-0x4080(%rbp)
  8042117079:	0f 82 fc 04 00 00    	jb     804211757b <LZ4_compress_destSize+0xc95>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211707f:	c7 85 88 bf ff ff 01 	movl   $0x1,-0x4078(%rbp)
  8042117086:	00 00 00 
  8042117089:	41 bf 41 00 00 00    	mov    $0x41,%r15d
  804211708f:	eb 4d                	jmp    80421170de <LZ4_compress_destSize+0x7f8>
                U32 const current = (U32)(forwardIp - base);
  8042117091:	45 89 e6             	mov    %r12d,%r14d
  8042117094:	8b 8d a8 bf ff ff    	mov    -0x4058(%rbp),%ecx
  804211709a:	41 29 ce             	sub    %ecx,%r14d
        return hashTable[h];
  804211709d:	89 c0                	mov    %eax,%eax
  804211709f:	4c 8d ac 85 b0 bf ff 	lea    -0x4050(%rbp,%rax,4),%r13
  80421170a6:	ff 
  80421170a7:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  80421170ab:	48 63 85 88 bf ff ff 	movslq -0x4078(%rbp),%rax
  80421170b2:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421170b5:	41 8d 57 01          	lea    0x1(%r15),%edx
  80421170b9:	41 c1 ff 06          	sar    $0x6,%r15d
  80421170bd:	44 89 bd 88 bf ff ff 	mov    %r15d,-0x4078(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421170c4:	4c 89 a5 90 bf ff ff 	mov    %r12,-0x4070(%rbp)
  80421170cb:	48 39 85 80 bf ff ff 	cmp    %rax,-0x4080(%rbp)
  80421170d2:	0f 82 a3 04 00 00    	jb     804211757b <LZ4_compress_destSize+0xc95>
  80421170d8:	41 89 d7             	mov    %edx,%r15d
  80421170db:	49 89 c4             	mov    %rax,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421170de:	49 8b 3c 24          	mov    (%r12),%rdi
  80421170e2:	be 02 00 00 00       	mov    $0x2,%esi
  80421170e7:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  80421170ee:	00 00 00 
  80421170f1:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  80421170f3:	45 89 75 00          	mov    %r14d,0x0(%r13)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  80421170f7:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  80421170fd:	44 39 f2             	cmp    %r14d,%edx
  8042117100:	72 8f                	jb     8042117091 <LZ4_compress_destSize+0x7ab>
                    match = base + matchIndex;
  8042117102:	89 db                	mov    %ebx,%ebx
  8042117104:	48 8b 8d a8 bf ff ff 	mov    -0x4058(%rbp),%rcx
  804211710b:	48 01 cb             	add    %rcx,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  804211710e:	48 8b b5 90 bf ff ff 	mov    -0x4070(%rbp),%rsi
  8042117115:	8b 0b                	mov    (%rbx),%ecx
  8042117117:	39 0e                	cmp    %ecx,(%rsi)
  8042117119:	0f 85 72 ff ff ff    	jne    8042117091 <LZ4_compress_destSize+0x7ab>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211711f:	48 39 b5 68 bf ff ff 	cmp    %rsi,-0x4098(%rbp)
  8042117126:	0f 83 da 00 00 00    	jae    8042117206 <LZ4_compress_destSize+0x920>
  804211712c:	49 89 f5             	mov    %rsi,%r13
  804211712f:	48 39 9d a0 bf ff ff 	cmp    %rbx,-0x4060(%rbp)
  8042117136:	0f 83 ca 00 00 00    	jae    8042117206 <LZ4_compress_destSize+0x920>
  804211713c:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042117140:	41 38 45 ff          	cmp    %al,-0x1(%r13)
  8042117144:	0f 84 c8 00 00 00    	je     8042117212 <LZ4_compress_destSize+0x92c>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  804211714a:	4c 89 e8             	mov    %r13,%rax
  804211714d:	48 8b bd 68 bf ff ff 	mov    -0x4098(%rbp),%rdi
  8042117154:	48 29 f8             	sub    %rdi,%rax
            token = op++;
  8042117157:	48 8b 8d 60 bf ff ff 	mov    -0x40a0(%rbp),%rcx
  804211715e:	48 8d 79 01          	lea    0x1(%rcx),%rdi
                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {
  8042117162:	89 c1                	mov    %eax,%ecx
  8042117164:	8d 90 f0 00 00 00    	lea    0xf0(%rax),%edx
  804211716a:	be 81 80 80 80       	mov    $0x80808081,%esi
  804211716f:	48 0f af d6          	imul   %rsi,%rdx
  8042117173:	48 c1 ea 27          	shr    $0x27,%rdx
  8042117177:	48 8d 54 11 0b       	lea    0xb(%rcx,%rdx,1),%rdx
  804211717c:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == fillOutput) &&
  804211717f:	48 39 95 70 bf ff ff 	cmp    %rdx,-0x4090(%rbp)
  8042117186:	0f 82 ef 03 00 00    	jb     804211757b <LZ4_compress_destSize+0xc95>
            if (litLength >= RUN_MASK) {
  804211718c:	83 f8 0e             	cmp    $0xe,%eax
  804211718f:	0f 87 a4 00 00 00    	ja     8042117239 <LZ4_compress_destSize+0x953>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042117195:	c1 e0 04             	shl    $0x4,%eax
  8042117198:	48 8b b5 60 bf ff ff 	mov    -0x40a0(%rbp),%rsi
  804211719f:	88 06                	mov    %al,(%rsi)
            LZ4_wildCopy8(op, anchor, op+litLength);
  80421171a1:	4c 8d 3c 0f          	lea    (%rdi,%rcx,1),%r15
  80421171a5:	4c 89 fa             	mov    %r15,%rdx
  80421171a8:	48 8b b5 68 bf ff ff 	mov    -0x4098(%rbp),%rsi
  80421171af:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  80421171b6:	00 00 00 
  80421171b9:	ff d0                	call   *%rax
            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {
  80421171bb:	49 8d 47 0b          	lea    0xb(%r15),%rax
        if ((outputDirective == fillOutput) &&
  80421171bf:	48 39 85 70 bf ff ff 	cmp    %rax,-0x4090(%rbp)
  80421171c6:	0f 82 af 03 00 00    	jb     804211757b <LZ4_compress_destSize+0xc95>
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421171cc:	48 8b 85 58 bf ff ff 	mov    -0x40a8(%rbp),%rax
  80421171d3:	48 8d 48 f4          	lea    -0xc(%rax),%rcx
  80421171d7:	48 89 8d 68 bf ff ff 	mov    %rcx,-0x4098(%rbp)
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421171de:	48 8d 70 f8          	lea    -0x8(%rax),%rsi
  80421171e2:	48 89 b5 48 bf ff ff 	mov    %rsi,-0x40b8(%rbp)
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421171e9:	48 83 e8 06          	sub    $0x6,%rax
  80421171ed:	48 89 85 40 bf ff ff 	mov    %rax,-0x40c0(%rbp)
        return hashTable[h];
  80421171f4:	48 89 d8             	mov    %rbx,%rax
  80421171f7:	4c 89 fb             	mov    %r15,%rbx
  80421171fa:	4c 8b bd 60 bf ff ff 	mov    -0x40a0(%rbp),%r15
  8042117201:	e9 4c 01 00 00       	jmp    8042117352 <LZ4_compress_destSize+0xa6c>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042117206:	4c 8b ad 90 bf ff ff 	mov    -0x4070(%rbp),%r13
  804211720d:	e9 38 ff ff ff       	jmp    804211714a <LZ4_compress_destSize+0x864>
  8042117212:	49 83 ed 01          	sub    $0x1,%r13
  8042117216:	48 83 eb 01          	sub    $0x1,%rbx
  804211721a:	4c 39 ad 68 bf ff ff 	cmp    %r13,-0x4098(%rbp)
  8042117221:	0f 83 23 ff ff ff    	jae    804211714a <LZ4_compress_destSize+0x864>
  8042117227:	48 39 9d a0 bf ff ff 	cmp    %rbx,-0x4060(%rbp)
  804211722e:	0f 82 08 ff ff ff    	jb     804211713c <LZ4_compress_destSize+0x856>
  8042117234:	e9 11 ff ff ff       	jmp    804211714a <LZ4_compress_destSize+0x864>
                int len = (int)(litLength - RUN_MASK);
  8042117239:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  804211723c:	48 8b b5 60 bf ff ff 	mov    -0x40a0(%rbp),%rsi
  8042117243:	c6 06 f0             	movb   $0xf0,(%rsi)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042117246:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211724b:	7e 14                	jle    8042117261 <LZ4_compress_destSize+0x97b>
  804211724d:	48 83 c7 01          	add    $0x1,%rdi
  8042117251:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042117255:	2d ff 00 00 00       	sub    $0xff,%eax
  804211725a:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211725f:	7f ec                	jg     804211724d <LZ4_compress_destSize+0x967>
                *op++ = (BYTE)len;
  8042117261:	88 07                	mov    %al,(%rdi)
  8042117263:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042117267:	e9 35 ff ff ff       	jmp    80421171a1 <LZ4_compress_destSize+0x8bb>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211726c:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211726f:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042117276:	00 00 00 
  8042117279:	ff d0                	call   *%rax
  804211727b:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  804211727e:	44 89 e0             	mov    %r12d,%eax
  8042117281:	4d 8d 6c 05 04       	lea    0x4(%r13,%rax,1),%r13
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042117286:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  804211728d:	00 
  804211728e:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042117293:	48 0f af c6          	imul   %rsi,%rax
  8042117297:	48 c1 e8 27          	shr    $0x27,%rax
  804211729b:	49 8d 44 06 06       	lea    0x6(%r14,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  80421172a0:	48 39 85 70 bf ff ff 	cmp    %rax,-0x4090(%rbp)
  80421172a7:	0f 82 9d 01 00 00    	jb     804211744a <LZ4_compress_destSize+0xb64>
            if (matchCode >= ML_MASK) {
  80421172ad:	41 83 fc 0e          	cmp    $0xe,%r12d
  80421172b1:	0f 87 25 02 00 00    	ja     80421174dc <LZ4_compress_destSize+0xbf6>
                *token += (BYTE)(matchCode);
  80421172b7:	45 00 27             	add    %r12b,(%r15)
  80421172ba:	4d 89 f7             	mov    %r14,%r15
        if (ip >= mflimitPlusOne) break;
  80421172bd:	48 8b 85 80 bf ff ff 	mov    -0x4080(%rbp),%rax
  80421172c4:	49 39 c5             	cmp    %rax,%r13
  80421172c7:	0f 83 a0 02 00 00    	jae    804211756d <LZ4_compress_destSize+0xc87>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421172cd:	49 8b 7d fe          	mov    -0x2(%r13),%rdi
  80421172d1:	be 02 00 00 00       	mov    $0x2,%esi
  80421172d6:	49 be ce 28 11 42 80 	movabs $0x80421128ce,%r14
  80421172dd:	00 00 00 
  80421172e0:	41 ff d6             	call   *%r14
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  80421172e3:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  80421172e5:	49 8d 55 fe          	lea    -0x2(%r13),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  80421172e9:	48 8b 9d a8 bf ff ff 	mov    -0x4058(%rbp),%rbx
  80421172f0:	48 29 da             	sub    %rbx,%rdx
  80421172f3:	89 94 85 b0 bf ff ff 	mov    %edx,-0x4050(%rbp,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421172fa:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  80421172fe:	be 02 00 00 00       	mov    $0x2,%esi
  8042117303:	41 ff d6             	call   *%r14
            U32 const current = (U32)(ip-base);
  8042117306:	4c 89 e9             	mov    %r13,%rcx
  8042117309:	48 29 d9             	sub    %rbx,%rcx
        return hashTable[h];
  804211730c:	89 c0                	mov    %eax,%eax
  804211730e:	48 8d b4 85 b0 bf ff 	lea    -0x4050(%rbp,%rax,4),%rsi
  8042117315:	ff 
  8042117316:	8b 16                	mov    (%rsi),%edx
                match = base + matchIndex;
  8042117318:	89 d0                	mov    %edx,%eax
  804211731a:	48 01 d8             	add    %rbx,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211731d:	89 0e                	mov    %ecx,(%rsi)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  804211731f:	81 c2 ff ff 00 00    	add    $0xffff,%edx
  8042117325:	39 ca                	cmp    %ecx,%edx
  8042117327:	0f 82 0d 02 00 00    	jb     804211753a <LZ4_compress_destSize+0xc54>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  804211732d:	8b 18                	mov    (%rax),%ebx
  804211732f:	41 39 5d 00          	cmp    %ebx,0x0(%r13)
  8042117333:	0f 85 01 02 00 00    	jne    804211753a <LZ4_compress_destSize+0xc54>
                token=op++;
  8042117339:	49 8d 5f 01          	lea    0x1(%r15),%rbx
                *token=0;
  804211733d:	41 c6 07 00          	movb   $0x0,(%r15)
            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {
  8042117341:	49 8d 57 0c          	lea    0xc(%r15),%rdx
        if ((outputDirective == fillOutput) &&
  8042117345:	48 39 95 70 bf ff ff 	cmp    %rdx,-0x4090(%rbp)
  804211734c:	0f 82 14 03 00 00    	jb     8042117666 <LZ4_compress_destSize+0xd80>
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042117352:	4c 89 ea             	mov    %r13,%rdx
  8042117355:	48 29 c2             	sub    %rax,%rdx
  8042117358:	66 89 13             	mov    %dx,(%rbx)
  804211735b:	4c 8d 73 02          	lea    0x2(%rbx),%r14
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211735f:	49 8d 75 04          	lea    0x4(%r13),%rsi
  8042117363:	48 89 b5 88 bf ff ff 	mov    %rsi,-0x4078(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211736a:	48 8b 8d 68 bf ff ff 	mov    -0x4098(%rbp),%rcx
  8042117371:	48 39 ce             	cmp    %rcx,%rsi
  8042117374:	73 61                	jae    80421173d7 <LZ4_compress_destSize+0xaf1>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042117376:	48 8b 50 04          	mov    0x4(%rax),%rdx
  804211737a:	49 8b 7d 04          	mov    0x4(%r13),%rdi
        if (!diff) {
  804211737e:	48 39 d7             	cmp    %rdx,%rdi
  8042117381:	0f 85 e5 fe ff ff    	jne    804211726c <LZ4_compress_destSize+0x986>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042117387:	4d 8d 65 0c          	lea    0xc(%r13),%r12
  804211738b:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211738f:	49 39 cc             	cmp    %rcx,%r12
  8042117392:	73 4e                	jae    80421173e2 <LZ4_compress_destSize+0xafc>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042117394:	48 8b 10             	mov    (%rax),%rdx
  8042117397:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211739b:	48 39 d7             	cmp    %rdx,%rdi
  804211739e:	74 21                	je     80421173c1 <LZ4_compress_destSize+0xadb>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421173a0:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  80421173a3:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421173aa:	00 00 00 
  80421173ad:	ff d0                	call   *%rax
  80421173af:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  80421173b3:	8b 85 88 bf ff ff    	mov    -0x4078(%rbp),%eax
  80421173b9:	41 29 c4             	sub    %eax,%r12d
  80421173bc:	e9 bd fe ff ff       	jmp    804211727e <LZ4_compress_destSize+0x998>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421173c1:	49 83 c4 08          	add    $0x8,%r12
  80421173c5:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421173c9:	48 8b 8d 68 bf ff ff 	mov    -0x4098(%rbp),%rcx
  80421173d0:	49 39 cc             	cmp    %rcx,%r12
  80421173d3:	72 bf                	jb     8042117394 <LZ4_compress_destSize+0xaae>
  80421173d5:	eb 0b                	jmp    80421173e2 <LZ4_compress_destSize+0xafc>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  80421173d7:	48 83 c0 04          	add    $0x4,%rax
  80421173db:	4c 8b a5 88 bf ff ff 	mov    -0x4078(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421173e2:	48 8b bd 48 bf ff ff 	mov    -0x40b8(%rbp),%rdi
  80421173e9:	49 39 fc             	cmp    %rdi,%r12
  80421173ec:	73 08                	jae    80421173f6 <LZ4_compress_destSize+0xb10>
  80421173ee:	8b 38                	mov    (%rax),%edi
  80421173f0:	41 39 3c 24          	cmp    %edi,(%r12)
  80421173f4:	74 40                	je     8042117436 <LZ4_compress_destSize+0xb50>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421173f6:	48 8b 8d 40 bf ff ff 	mov    -0x40c0(%rbp),%rcx
  80421173fd:	49 39 cc             	cmp    %rcx,%r12
  8042117400:	73 0a                	jae    804211740c <LZ4_compress_destSize+0xb26>
  8042117402:	0f b7 38             	movzwl (%rax),%edi
  8042117405:	66 41 39 3c 24       	cmp    %di,(%r12)
  804211740a:	74 34                	je     8042117440 <LZ4_compress_destSize+0xb5a>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211740c:	48 8b bd 50 bf ff ff 	mov    -0x40b0(%rbp),%rdi
  8042117413:	49 39 fc             	cmp    %rdi,%r12
  8042117416:	73 10                	jae    8042117428 <LZ4_compress_destSize+0xb42>
  8042117418:	41 0f b6 0c 24       	movzbl (%r12),%ecx
  804211741d:	38 08                	cmp    %cl,(%rax)
  804211741f:	0f 94 c0             	sete   %al
  8042117422:	0f b6 c0             	movzbl %al,%eax
  8042117425:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  8042117428:	8b 85 88 bf ff ff    	mov    -0x4078(%rbp),%eax
  804211742e:	41 29 c4             	sub    %eax,%r12d
  8042117431:	e9 48 fe ff ff       	jmp    804211727e <LZ4_compress_destSize+0x998>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042117436:	49 83 c4 04          	add    $0x4,%r12
  804211743a:	48 83 c0 04          	add    $0x4,%rax
  804211743e:	eb b6                	jmp    80421173f6 <LZ4_compress_destSize+0xb10>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042117440:	49 83 c4 02          	add    $0x2,%r12
  8042117444:	48 83 c0 02          	add    $0x2,%rax
  8042117448:	eb c2                	jmp    804211740c <LZ4_compress_destSize+0xb26>
                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 1 - LASTLITERALS) * 255;
  804211744a:	48 8b 95 70 bf ff ff 	mov    -0x4090(%rbp),%rdx
  8042117451:	4c 29 f2             	sub    %r14,%rdx
  8042117454:	89 d0                	mov    %edx,%eax
  8042117456:	c1 e0 08             	shl    $0x8,%eax
  8042117459:	29 d0                	sub    %edx,%eax
  804211745b:	2d ec 05 00 00       	sub    $0x5ec,%eax
                    ip -= matchCode - newMatchCode;
  8042117460:	41 29 c4             	sub    %eax,%r12d
  8042117463:	4d 29 e5             	sub    %r12,%r13
                    matchCode = newMatchCode;
  8042117466:	41 89 c4             	mov    %eax,%r12d
                    if (unlikely(ip <= filledIp)) {
  8042117469:	4c 39 ad 90 bf ff ff 	cmp    %r13,-0x4070(%rbp)
  8042117470:	0f 82 37 fe ff ff    	jb     80421172ad <LZ4_compress_destSize+0x9c7>
  8042117476:	48 8b bd 90 bf ff ff 	mov    -0x4070(%rbp),%rdi
  804211747d:	48 8d 4f 01          	lea    0x1(%rdi),%rcx
                        for (ptr = ip; ptr <= filledIp; ++ptr) {
  8042117481:	4d 89 ec             	mov    %r13,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117484:	48 89 9d 88 bf ff ff 	mov    %rbx,-0x4078(%rbp)
  804211748b:	4c 89 bd 60 bf ff ff 	mov    %r15,-0x40a0(%rbp)
  8042117492:	48 89 cb             	mov    %rcx,%rbx
  8042117495:	41 89 c7             	mov    %eax,%r15d
  8042117498:	49 8b 3c 24          	mov    (%r12),%rdi
  804211749c:	be 02 00 00 00       	mov    $0x2,%esi
  80421174a1:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  80421174a8:	00 00 00 
  80421174ab:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = 0; return; }
  80421174ad:	89 c0                	mov    %eax,%eax
  80421174af:	c7 84 85 b0 bf ff ff 	movl   $0x0,-0x4050(%rbp,%rax,4)
  80421174b6:	00 00 00 00 
                        for (ptr = ip; ptr <= filledIp; ++ptr) {
  80421174ba:	49 83 c4 01          	add    $0x1,%r12
  80421174be:	4c 39 e3             	cmp    %r12,%rbx
  80421174c1:	75 d5                	jne    8042117498 <LZ4_compress_destSize+0xbb2>
                    matchCode = newMatchCode;
  80421174c3:	48 8b 9d 88 bf ff ff 	mov    -0x4078(%rbp),%rbx
  80421174ca:	44 89 f8             	mov    %r15d,%eax
  80421174cd:	4c 8b bd 60 bf ff ff 	mov    -0x40a0(%rbp),%r15
  80421174d4:	41 89 c4             	mov    %eax,%r12d
  80421174d7:	e9 d1 fd ff ff       	jmp    80421172ad <LZ4_compress_destSize+0x9c7>
                *token += ML_MASK;
  80421174dc:	41 80 07 0f          	addb   $0xf,(%r15)
                matchCode -= ML_MASK;
  80421174e0:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421174e4:	c7 43 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rbx)
                while (matchCode >= 4*255) {
  80421174eb:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  80421174f2:	76 1b                	jbe    804211750f <LZ4_compress_destSize+0xc29>
                    op+=4;
  80421174f4:	49 83 c6 04          	add    $0x4,%r14
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421174f8:	41 c7 06 ff ff ff ff 	movl   $0xffffffff,(%r14)
                    matchCode -= 4*255;
  80421174ff:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  8042117506:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  804211750d:	77 e5                	ja     80421174f4 <LZ4_compress_destSize+0xc0e>
                op += matchCode / 255;
  804211750f:	44 89 e0             	mov    %r12d,%eax
  8042117512:	bb 81 80 80 80       	mov    $0x80808081,%ebx
  8042117517:	48 0f af c3          	imul   %rbx,%rax
  804211751b:	48 c1 e8 27          	shr    $0x27,%rax
  804211751f:	89 c2                	mov    %eax,%edx
  8042117521:	4c 01 f2             	add    %r14,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042117524:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
  8042117528:	89 c1                	mov    %eax,%ecx
  804211752a:	c1 e1 08             	shl    $0x8,%ecx
  804211752d:	29 c1                	sub    %eax,%ecx
  804211752f:	41 29 cc             	sub    %ecx,%r12d
  8042117532:	44 88 22             	mov    %r12b,(%rdx)
  8042117535:	e9 83 fd ff ff       	jmp    80421172bd <LZ4_compress_destSize+0x9d7>
        forwardH = LZ4_hashPosition(++ip, tableType);
  804211753a:	4c 89 bd 60 bf ff ff 	mov    %r15,-0x40a0(%rbp)
  8042117541:	49 8d 45 01          	lea    0x1(%r13),%rax
  8042117545:	48 89 85 90 bf ff ff 	mov    %rax,-0x4070(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211754c:	49 8b 7d 01          	mov    0x1(%r13),%rdi
  8042117550:	be 02 00 00 00       	mov    $0x2,%esi
  8042117555:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211755c:	00 00 00 
  804211755f:	ff d0                	call   *%rax
  8042117561:	4c 89 ad 68 bf ff ff 	mov    %r13,-0x4098(%rbp)
  8042117568:	e9 e0 fa ff ff       	jmp    804211704d <LZ4_compress_destSize+0x767>
        anchor = ip;
  804211756d:	4c 89 bd 60 bf ff ff 	mov    %r15,-0x40a0(%rbp)
  8042117574:	4c 89 ad 68 bf ff ff 	mov    %r13,-0x4098(%rbp)
    {   size_t lastRun = (size_t)(iend - anchor);
  804211757b:	48 8b 9d 58 bf ff ff 	mov    -0x40a8(%rbp),%rbx
  8042117582:	48 8b 85 68 bf ff ff 	mov    -0x4098(%rbp),%rax
  8042117589:	48 29 c3             	sub    %rax,%rbx
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  804211758c:	48 8d 93 f0 00 00 00 	lea    0xf0(%rbx),%rdx
  8042117593:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  804211759a:	80 80 80 
  804211759d:	48 89 d0             	mov    %rdx,%rax
  80421175a0:	48 f7 e1             	mul    %rcx
  80421175a3:	48 c1 ea 07          	shr    $0x7,%rdx
  80421175a7:	48 8d 44 13 01       	lea    0x1(%rbx,%rdx,1),%rax
  80421175ac:	48 8b b5 60 bf ff ff 	mov    -0x40a0(%rbp),%rsi
  80421175b3:	48 01 f0             	add    %rsi,%rax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  80421175b6:	48 8b 95 70 bf ff ff 	mov    -0x4090(%rbp),%rdx
  80421175bd:	48 39 c2             	cmp    %rax,%rdx
  80421175c0:	73 1b                	jae    80421175dd <LZ4_compress_destSize+0xcf7>
                lastRun  = (size_t)(olimit-op) - 1;
  80421175c2:	48 29 f2             	sub    %rsi,%rdx
  80421175c5:	48 8d 5a ff          	lea    -0x1(%rdx),%rbx
                lastRun -= (lastRun+240)/255;
  80421175c9:	48 81 c2 ef 00 00 00 	add    $0xef,%rdx
  80421175d0:	48 89 d0             	mov    %rdx,%rax
  80421175d3:	48 f7 e1             	mul    %rcx
  80421175d6:	48 c1 ea 07          	shr    $0x7,%rdx
  80421175da:	48 29 d3             	sub    %rdx,%rbx
        if (lastRun >= RUN_MASK) {
  80421175dd:	48 83 fb 0e          	cmp    $0xe,%rbx
  80421175e1:	0f 86 92 00 00 00    	jbe    8042117679 <LZ4_compress_destSize+0xd93>
            size_t accumulator = lastRun - RUN_MASK;
  80421175e7:	48 8d 53 f1          	lea    -0xf(%rbx),%rdx
            *op++ = RUN_MASK << ML_BITS;
  80421175eb:	48 8b b5 60 bf ff ff 	mov    -0x40a0(%rbp),%rsi
  80421175f2:	48 8d 46 01          	lea    0x1(%rsi),%rax
  80421175f6:	c6 06 f0             	movb   $0xf0,(%rsi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  80421175f9:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042117600:	76 18                	jbe    804211761a <LZ4_compress_destSize+0xd34>
  8042117602:	48 83 c0 01          	add    $0x1,%rax
  8042117606:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  804211760a:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042117611:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042117618:	77 e8                	ja     8042117602 <LZ4_compress_destSize+0xd1c>
            *op++ = (BYTE) accumulator;
  804211761a:	4c 8d 60 01          	lea    0x1(%rax),%r12
  804211761e:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042117620:	48 89 da             	mov    %rbx,%rdx
  8042117623:	4c 8b bd 68 bf ff ff 	mov    -0x4098(%rbp),%r15
  804211762a:	4c 89 fe             	mov    %r15,%rsi
  804211762d:	4c 89 e7             	mov    %r12,%rdi
  8042117630:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042117637:	00 00 00 
  804211763a:	ff d0                	call   *%rax
        ip = anchor + lastRun;
  804211763c:	4c 89 f8             	mov    %r15,%rax
  804211763f:	48 01 d8             	add    %rbx,%rax
        *inputConsumed = (int) (((const char*)ip)-source);
  8042117642:	48 8b bd a0 bf ff ff 	mov    -0x4060(%rbp),%rdi
  8042117649:	48 29 f8             	sub    %rdi,%rax
  804211764c:	48 8b 8d 78 bf ff ff 	mov    -0x4088(%rbp),%rcx
  8042117653:	89 01                	mov    %eax,(%rcx)
        op += lastRun;
  8042117655:	49 8d 04 1c          	lea    (%r12,%rbx,1),%rax
    result = (int)(((char*)op) - dest);
  8042117659:	8b 9d 98 bf ff ff    	mov    -0x4068(%rbp),%ebx
  804211765f:	29 d8                	sub    %ebx,%eax
    return result;
  8042117661:	e9 14 f5 ff ff       	jmp    8042116b7a <LZ4_compress_destSize+0x294>
  8042117666:	4c 89 bd 60 bf ff ff 	mov    %r15,-0x40a0(%rbp)
  804211766d:	4c 89 ad 68 bf ff ff 	mov    %r13,-0x4098(%rbp)
  8042117674:	e9 02 ff ff ff       	jmp    804211757b <LZ4_compress_destSize+0xc95>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042117679:	48 8b bd 60 bf ff ff 	mov    -0x40a0(%rbp),%rdi
  8042117680:	4c 8d 67 01          	lea    0x1(%rdi),%r12
  8042117684:	89 d8                	mov    %ebx,%eax
  8042117686:	c1 e0 04             	shl    $0x4,%eax
  8042117689:	88 07                	mov    %al,(%rdi)
  804211768b:	eb 93                	jmp    8042117620 <LZ4_compress_destSize+0xd3a>

000000804211768d <LZ4_resetStream>:
{
  804211768d:	f3 0f 1e fa          	endbr64
  8042117691:	55                   	push   %rbp
  8042117692:	48 89 e5             	mov    %rsp,%rbp
    MEM_INIT(LZ4_stream, 0, sizeof(LZ4_stream_t));
  8042117695:	ba 20 40 00 00       	mov    $0x4020,%edx
  804211769a:	be 00 00 00 00       	mov    $0x0,%esi
  804211769f:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  80421176a6:	00 00 00 
  80421176a9:	ff d0                	call   *%rax
}
  80421176ab:	5d                   	pop    %rbp
  80421176ac:	c3                   	ret

00000080421176ad <LZ4_resetStream_fast>:
void LZ4_resetStream_fast(LZ4_stream_t* ctx) {
  80421176ad:	f3 0f 1e fa          	endbr64
  80421176b1:	55                   	push   %rbp
  80421176b2:	48 89 e5             	mov    %rsp,%rbp
  80421176b5:	53                   	push   %rbx
  80421176b6:	48 83 ec 08          	sub    $0x8,%rsp
  80421176ba:	48 89 fb             	mov    %rdi,%rbx
    if (cctx->dirty) {
  80421176bd:	66 83 bf 04 40 00 00 	cmpw   $0x0,0x4004(%rdi)
  80421176c4:	00 
  80421176c5:	75 4c                	jne    8042117713 <LZ4_resetStream_fast+0x66>
    if (cctx->tableType != clearedTable) {
  80421176c7:	0f b7 87 06 40 00 00 	movzwl 0x4006(%rdi),%eax
  80421176ce:	66 85 c0             	test   %ax,%ax
  80421176d1:	74 58                	je     804211772b <LZ4_resetStream_fast+0x7e>
        if (cctx->tableType != tableType
  80421176d3:	66 83 f8 02          	cmp    $0x2,%ax
  80421176d7:	75 0c                	jne    80421176e5 <LZ4_resetStream_fast+0x38>
            || ((tableType == byU32) && cctx->currentOffset > 1 GB)
  80421176d9:	81 bf 00 40 00 00 00 	cmpl   $0x40000000,0x4000(%rdi)
  80421176e0:	00 00 40 
  80421176e3:	76 46                	jbe    804211772b <LZ4_resetStream_fast+0x7e>
            MEM_INIT(cctx->hashTable, 0, LZ4_HASHTABLESIZE);
  80421176e5:	ba 00 40 00 00       	mov    $0x4000,%edx
  80421176ea:	be 00 00 00 00       	mov    $0x0,%esi
  80421176ef:	48 89 df             	mov    %rbx,%rdi
  80421176f2:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  80421176f9:	00 00 00 
  80421176fc:	ff d0                	call   *%rax
            cctx->currentOffset = 0;
  80421176fe:	c7 83 00 40 00 00 00 	movl   $0x0,0x4000(%rbx)
  8042117705:	00 00 00 
            cctx->tableType = clearedTable;
  8042117708:	66 c7 83 06 40 00 00 	movw   $0x0,0x4006(%rbx)
  804211770f:	00 00 
    if (cctx->currentOffset != 0 && tableType == byU32) {
  8042117711:	eb 2d                	jmp    8042117740 <LZ4_resetStream_fast+0x93>
        MEM_INIT(cctx, 0, sizeof(LZ4_stream_t_internal));
  8042117713:	ba 20 40 00 00       	mov    $0x4020,%edx
  8042117718:	be 00 00 00 00       	mov    $0x0,%esi
  804211771d:	48 b8 3d 0c 11 42 80 	movabs $0x8042110c3d,%rax
  8042117724:	00 00 00 
  8042117727:	ff d0                	call   *%rax
        return;
  8042117729:	eb 35                	jmp    8042117760 <LZ4_resetStream_fast+0xb3>
    if (cctx->currentOffset != 0 && tableType == byU32) {
  804211772b:	8b 83 00 40 00 00    	mov    0x4000(%rbx),%eax
  8042117731:	85 c0                	test   %eax,%eax
  8042117733:	74 0b                	je     8042117740 <LZ4_resetStream_fast+0x93>
        cctx->currentOffset += 64 KB;
  8042117735:	05 00 00 01 00       	add    $0x10000,%eax
  804211773a:	89 83 00 40 00 00    	mov    %eax,0x4000(%rbx)
    cctx->dictCtx = NULL;
  8042117740:	48 c7 83 10 40 00 00 	movq   $0x0,0x4010(%rbx)
  8042117747:	00 00 00 00 
    cctx->dictionary = NULL;
  804211774b:	48 c7 83 08 40 00 00 	movq   $0x0,0x4008(%rbx)
  8042117752:	00 00 00 00 
    cctx->dictSize = 0;
  8042117756:	c7 83 18 40 00 00 00 	movl   $0x0,0x4018(%rbx)
  804211775d:	00 00 00 
}
  8042117760:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8042117764:	c9                   	leave
  8042117765:	c3                   	ret

0000008042117766 <LZ4_loadDict>:
{
  8042117766:	f3 0f 1e fa          	endbr64
  804211776a:	55                   	push   %rbp
  804211776b:	48 89 e5             	mov    %rsp,%rbp
  804211776e:	41 57                	push   %r15
  8042117770:	41 56                	push   %r14
  8042117772:	41 55                	push   %r13
  8042117774:	41 54                	push   %r12
  8042117776:	53                   	push   %rbx
  8042117777:	48 83 ec 08          	sub    $0x8,%rsp
  804211777b:	49 89 fc             	mov    %rdi,%r12
  804211777e:	48 89 f3             	mov    %rsi,%rbx
  8042117781:	41 89 d6             	mov    %edx,%r14d
    LZ4_resetStream(LZ4_dict);
  8042117784:	48 b8 8d 76 11 42 80 	movabs $0x804211768d,%rax
  804211778b:	00 00 00 
  804211778e:	ff d0                	call   *%rax
    dict->currentOffset += 64 KB;
  8042117790:	41 8b 84 24 00 40 00 	mov    0x4000(%r12),%eax
  8042117797:	00 
  8042117798:	05 00 00 01 00       	add    $0x10000,%eax
  804211779d:	41 89 84 24 00 40 00 	mov    %eax,0x4000(%r12)
  80421177a4:	00 
        return 0;
  80421177a5:	ba 00 00 00 00       	mov    $0x0,%edx
    if (dictSize < (int)HASH_UNIT) {
  80421177aa:	41 83 fe 07          	cmp    $0x7,%r14d
  80421177ae:	7e 7c                	jle    804211782c <LZ4_loadDict+0xc6>
    const BYTE* const dictEnd = p + dictSize;
  80421177b0:	4d 63 ee             	movslq %r14d,%r13
  80421177b3:	49 01 dd             	add    %rbx,%r13
    if ((dictEnd - p) > 64 KB) p = dictEnd - 64 KB;
  80421177b6:	49 8d 95 00 00 ff ff 	lea    -0x10000(%r13),%rdx
  80421177bd:	41 81 fe 00 00 01 00 	cmp    $0x10000,%r14d
  80421177c4:	48 0f 4f da          	cmovg  %rdx,%rbx
    base = dictEnd - dict->currentOffset;
  80421177c8:	89 c0                	mov    %eax,%eax
  80421177ca:	4d 89 ee             	mov    %r13,%r14
  80421177cd:	49 29 c6             	sub    %rax,%r14
    dict->dictionary = p;
  80421177d0:	49 89 9c 24 08 40 00 	mov    %rbx,0x4008(%r12)
  80421177d7:	00 
    dict->dictSize = (U32)(dictEnd - p);
  80421177d8:	4c 89 e8             	mov    %r13,%rax
  80421177db:	48 29 d8             	sub    %rbx,%rax
  80421177de:	41 89 84 24 18 40 00 	mov    %eax,0x4018(%r12)
  80421177e5:	00 
    dict->tableType = tableType;
  80421177e6:	66 41 c7 84 24 06 40 	movw   $0x2,0x4006(%r12)
  80421177ed:	00 00 02 00 
    while (p <= dictEnd-HASH_UNIT) {
  80421177f1:	49 83 ed 08          	sub    $0x8,%r13
  80421177f5:	49 39 dd             	cmp    %rbx,%r13
  80421177f8:	72 2a                	jb     8042117824 <LZ4_loadDict+0xbe>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421177fa:	49 bf ce 28 11 42 80 	movabs $0x80421128ce,%r15
  8042117801:	00 00 00 
  8042117804:	48 8b 3b             	mov    (%rbx),%rdi
  8042117807:	be 02 00 00 00       	mov    $0x2,%esi
  804211780c:	41 ff d7             	call   *%r15
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211780f:	89 c0                	mov    %eax,%eax
  8042117811:	48 89 da             	mov    %rbx,%rdx
  8042117814:	4c 29 f2             	sub    %r14,%rdx
  8042117817:	41 89 14 84          	mov    %edx,(%r12,%rax,4)
        p+=3;
  804211781b:	48 83 c3 03          	add    $0x3,%rbx
    while (p <= dictEnd-HASH_UNIT) {
  804211781f:	49 39 dd             	cmp    %rbx,%r13
  8042117822:	73 e0                	jae    8042117804 <LZ4_loadDict+0x9e>
    return (int)dict->dictSize;
  8042117824:	41 8b 94 24 18 40 00 	mov    0x4018(%r12),%edx
  804211782b:	00 
}
  804211782c:	89 d0                	mov    %edx,%eax
  804211782e:	48 83 c4 08          	add    $0x8,%rsp
  8042117832:	5b                   	pop    %rbx
  8042117833:	41 5c                	pop    %r12
  8042117835:	41 5d                	pop    %r13
  8042117837:	41 5e                	pop    %r14
  8042117839:	41 5f                	pop    %r15
  804211783b:	5d                   	pop    %rbp
  804211783c:	c3                   	ret

000000804211783d <LZ4_attach_dictionary>:
void LZ4_attach_dictionary(LZ4_stream_t* workingStream, const LZ4_stream_t* dictionaryStream) {
  804211783d:	f3 0f 1e fa          	endbr64
  8042117841:	55                   	push   %rbp
  8042117842:	48 89 e5             	mov    %rsp,%rbp
  8042117845:	41 54                	push   %r12
  8042117847:	53                   	push   %rbx
  8042117848:	48 89 fb             	mov    %rdi,%rbx
  804211784b:	49 89 f4             	mov    %rsi,%r12
    LZ4_resetStream_fast(workingStream);
  804211784e:	48 b8 ad 76 11 42 80 	movabs $0x80421176ad,%rax
  8042117855:	00 00 00 
  8042117858:	ff d0                	call   *%rax
    if (dictCtx != NULL) {
  804211785a:	4d 85 e4             	test   %r12,%r12
  804211785d:	74 24                	je     8042117883 <LZ4_attach_dictionary+0x46>
        if (workingStream->internal_donotuse.currentOffset == 0) {
  804211785f:	83 bb 00 40 00 00 00 	cmpl   $0x0,0x4000(%rbx)
  8042117866:	75 0a                	jne    8042117872 <LZ4_attach_dictionary+0x35>
            workingStream->internal_donotuse.currentOffset = 64 KB;
  8042117868:	c7 83 00 40 00 00 00 	movl   $0x10000,0x4000(%rbx)
  804211786f:	00 01 00 
        if (dictCtx->dictSize == 0) {
  8042117872:	41 83 bc 24 18 40 00 	cmpl   $0x0,0x4018(%r12)
  8042117879:	00 00 
  804211787b:	75 06                	jne    8042117883 <LZ4_attach_dictionary+0x46>
            dictCtx = NULL;
  804211787d:	41 bc 00 00 00 00    	mov    $0x0,%r12d
    workingStream->internal_donotuse.dictCtx = dictCtx;
  8042117883:	4c 89 a3 10 40 00 00 	mov    %r12,0x4010(%rbx)
}
  804211788a:	5b                   	pop    %rbx
  804211788b:	41 5c                	pop    %r12
  804211788d:	5d                   	pop    %rbp
  804211788e:	c3                   	ret

000000804211788f <LZ4_compress_fast_continue>:
{
  804211788f:	f3 0f 1e fa          	endbr64
  8042117893:	55                   	push   %rbp
  8042117894:	48 89 e5             	mov    %rsp,%rbp
  8042117897:	41 57                	push   %r15
  8042117899:	41 56                	push   %r14
  804211789b:	41 55                	push   %r13
  804211789d:	41 54                	push   %r12
  804211789f:	53                   	push   %rbx
  80421178a0:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
  80421178a7:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  80421178ab:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    if (streamPtr->dirty) { return 0; } /* Uninitialized structure detected */
  80421178af:	b8 00 00 00 00       	mov    $0x0,%eax
  80421178b4:	66 83 bf 04 40 00 00 	cmpw   $0x0,0x4004(%rdi)
  80421178bb:	00 
  80421178bc:	74 12                	je     80421178d0 <LZ4_compress_fast_continue+0x41>
}
  80421178be:	48 81 c4 c8 00 00 00 	add    $0xc8,%rsp
  80421178c5:	5b                   	pop    %rbx
  80421178c6:	41 5c                	pop    %r12
  80421178c8:	41 5d                	pop    %r13
  80421178ca:	41 5e                	pop    %r14
  80421178cc:	41 5f                	pop    %r15
  80421178ce:	5d                   	pop    %rbp
  80421178cf:	c3                   	ret
  80421178d0:	49 89 fe             	mov    %rdi,%r14
  80421178d3:	41 89 cf             	mov    %ecx,%r15d
  80421178d6:	45 89 c4             	mov    %r8d,%r12d
  80421178d9:	44 89 cb             	mov    %r9d,%ebx
    const BYTE* dictEnd = streamPtr->dictionary + streamPtr->dictSize;
  80421178dc:	44 8b af 18 40 00 00 	mov    0x4018(%rdi),%r13d
  80421178e3:	4c 03 af 08 40 00 00 	add    0x4008(%rdi),%r13
    LZ4_renormDictT(streamPtr, inputSize);   /* avoid index overflow */
  80421178ea:	89 ce                	mov    %ecx,%esi
  80421178ec:	48 b8 75 17 11 42 80 	movabs $0x8042111775,%rax
  80421178f3:	00 00 00 
  80421178f6:	ff d0                	call   *%rax
    if (acceleration < 1) acceleration = ACCELERATION_DEFAULT;
  80421178f8:	85 db                	test   %ebx,%ebx
  80421178fa:	b8 01 00 00 00       	mov    $0x1,%eax
  80421178ff:	0f 4e d8             	cmovle %eax,%ebx
    if ( (streamPtr->dictSize-1 < 4-1)   /* intentional underflow */
  8042117902:	41 8b 86 18 40 00 00 	mov    0x4018(%r14),%eax
  8042117909:	83 e8 01             	sub    $0x1,%eax
         && (dictEnd != (const BYTE*)source) ) {
  804211790c:	83 f8 02             	cmp    $0x2,%eax
  804211790f:	0f 87 6c 01 00 00    	ja     8042117a81 <LZ4_compress_fast_continue+0x1f2>
  8042117915:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8042117919:	49 39 cd             	cmp    %rcx,%r13
  804211791c:	0f 84 5f 01 00 00    	je     8042117a81 <LZ4_compress_fast_continue+0x1f2>
        streamPtr->dictSize = 0;
  8042117922:	41 c7 86 18 40 00 00 	movl   $0x0,0x4018(%r14)
  8042117929:	00 00 00 00 
        streamPtr->dictionary = (const BYTE*)source;
  804211792d:	49 89 8e 08 40 00 00 	mov    %rcx,0x4008(%r14)
    {   const BYTE* sourceEnd = (const BYTE*) source + inputSize;
  8042117934:	49 63 c7             	movslq %r15d,%rax
  8042117937:	48 01 c8             	add    %rcx,%rax
  804211793a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset))
  804211793e:	41 8b 96 18 40 00 00 	mov    0x4018(%r14),%edx
  8042117945:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  804211794b:	0f 87 c8 07 00 00    	ja     8042118119 <LZ4_compress_fast_continue+0x88a>
  8042117951:	45 8b ae 00 40 00 00 	mov    0x4000(%r14),%r13d
  8042117958:	44 39 ea             	cmp    %r13d,%edx
  804211795b:	0f 83 b8 07 00 00    	jae    8042118119 <LZ4_compress_fast_continue+0x88a>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042117961:	b8 00 00 00 00       	mov    $0x0,%eax
  8042117966:	41 81 ff 00 00 00 7e 	cmp    $0x7e000000,%r15d
  804211796d:	0f 87 4b ff ff ff    	ja     80421178be <LZ4_compress_fast_continue+0x2f>
    BYTE* const olimit = op + maxOutputSize;
  8042117973:	4d 63 e4             	movslq %r12d,%r12
  8042117976:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211797a:	4a 8d 0c 20          	lea    (%rax,%r12,1),%rcx
  804211797e:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042117982:	42 8d 04 3a          	lea    (%rdx,%r15,1),%eax
  8042117986:	41 89 86 18 40 00 00 	mov    %eax,0x4018(%r14)
    cctx->currentOffset += (U32)inputSize;
  804211798d:	43 8d 44 3d 00       	lea    0x0(%r13,%r15,1),%eax
  8042117992:	41 89 86 00 40 00 00 	mov    %eax,0x4000(%r14)
    cctx->tableType = (U16)tableType;
  8042117999:	66 41 c7 86 06 40 00 	movw   $0x2,0x4006(%r14)
  80421179a0:	00 02 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  80421179a3:	41 83 ff 0c          	cmp    $0xc,%r15d
  80421179a7:	0f 8e 99 06 00 00    	jle    8042118046 <LZ4_compress_fast_continue+0x7b7>
    const BYTE* base = (const BYTE*) source - startIndex;
  80421179ad:	44 89 e8             	mov    %r13d,%eax
  80421179b0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80421179b4:	48 89 cf             	mov    %rcx,%rdi
  80421179b7:	48 29 c7             	sub    %rax,%rdi
  80421179ba:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
  80421179be:	44 89 ef             	mov    %r13d,%edi
  80421179c1:	29 d7                	sub    %edx,%edi
  80421179c3:	89 7d 88             	mov    %edi,-0x78(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  80421179c6:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80421179ca:	4c 8d 5f f5          	lea    -0xb(%rdi),%r11
  80421179ce:	4c 89 5d 98          	mov    %r11,-0x68(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  80421179d2:	48 83 ef 05          	sub    $0x5,%rdi
  80421179d6:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    const BYTE* const dictEnd = dictionary + dictSize;
  80421179dd:	89 d2                	mov    %edx,%edx
    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);
  80421179df:	49 89 cf             	mov    %rcx,%r15
  80421179e2:	49 29 d7             	sub    %rdx,%r15
  80421179e5:	4c 89 bd 60 ff ff ff 	mov    %r15,-0xa0(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421179ec:	49 89 cf             	mov    %rcx,%r15
  80421179ef:	48 8b 39             	mov    (%rcx),%rdi
  80421179f2:	be 02 00 00 00       	mov    $0x2,%esi
  80421179f7:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  80421179fe:	00 00 00 
  8042117a01:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042117a04:	89 c0                	mov    %eax,%eax
  8042117a06:	45 89 2c 86          	mov    %r13d,(%r14,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042117a0a:	4d 8d 6f 01          	lea    0x1(%r15),%r13
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117a0e:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  8042117a12:	be 02 00 00 00       	mov    $0x2,%esi
  8042117a17:	41 ff d4             	call   *%r12
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042117a1a:	c1 e3 06             	shl    $0x6,%ebx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042117a1d:	8d 4b 01             	lea    0x1(%rbx),%ecx
  8042117a20:	89 8d 70 ff ff ff    	mov    %ecx,-0x90(%rbp)
  8042117a26:	c1 fb 06             	sar    $0x6,%ebx
  8042117a29:	89 9d 68 ff ff ff    	mov    %ebx,-0x98(%rbp)
  8042117a2f:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8042117a33:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
  8042117a3a:	4c 89 75 90          	mov    %r14,-0x70(%rbp)
  8042117a3e:	4d 89 ee             	mov    %r13,%r14
                U32 const current = (U32)(forwardIp - base);
  8042117a41:	45 89 f7             	mov    %r14d,%r15d
  8042117a44:	8b 4d a8             	mov    -0x58(%rbp),%ecx
  8042117a47:	41 29 cf             	sub    %ecx,%r15d
        return hashTable[h];
  8042117a4a:	89 c0                	mov    %eax,%eax
  8042117a4c:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8042117a50:	4c 8d 2c 83          	lea    (%rbx,%rax,4),%r13
  8042117a54:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  8042117a58:	4d 8d 66 01          	lea    0x1(%r14),%r12
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042117a5c:	4c 39 65 98          	cmp    %r12,-0x68(%rbp)
  8042117a60:	0f 82 eb 05 00 00    	jb     8042118051 <LZ4_compress_fast_continue+0x7c2>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042117a66:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  8042117a6c:	89 45 b0             	mov    %eax,-0x50(%rbp)
  8042117a6f:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
  8042117a75:	4c 89 75 a0          	mov    %r14,-0x60(%rbp)
  8042117a79:	41 89 c6             	mov    %eax,%r14d
  8042117a7c:	e9 52 02 00 00       	jmp    8042117cd3 <LZ4_compress_fast_continue+0x444>
    {   const BYTE* sourceEnd = (const BYTE*) source + inputSize;
  8042117a81:	49 63 c7             	movslq %r15d,%rax
  8042117a84:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042117a88:	48 01 f8             	add    %rdi,%rax
  8042117a8b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if ((sourceEnd > streamPtr->dictionary) && (sourceEnd < dictEnd)) {
  8042117a8f:	49 39 86 08 40 00 00 	cmp    %rax,0x4008(%r14)
  8042117a96:	73 3a                	jae    8042117ad2 <LZ4_compress_fast_continue+0x243>
  8042117a98:	4c 39 e8             	cmp    %r13,%rax
  8042117a9b:	73 35                	jae    8042117ad2 <LZ4_compress_fast_continue+0x243>
            streamPtr->dictSize = (U32)(dictEnd - sourceEnd);
  8042117a9d:	4c 89 ea             	mov    %r13,%rdx
  8042117aa0:	48 29 c2             	sub    %rax,%rdx
  8042117aa3:	89 d0                	mov    %edx,%eax
            if (streamPtr->dictSize > 64 KB) streamPtr->dictSize = 64 KB;
  8042117aa5:	81 fa 00 00 01 00    	cmp    $0x10000,%edx
  8042117aab:	0f 87 da 01 00 00    	ja     8042117c8b <LZ4_compress_fast_continue+0x3fc>
            if (streamPtr->dictSize < 4) streamPtr->dictSize = 0;
  8042117ab1:	83 fa 03             	cmp    $0x3,%edx
  8042117ab4:	ba 00 00 00 00       	mov    $0x0,%edx
  8042117ab9:	0f 46 c2             	cmovbe %edx,%eax
  8042117abc:	41 89 86 18 40 00 00 	mov    %eax,0x4018(%r14)
            streamPtr->dictionary = dictEnd - streamPtr->dictSize;
  8042117ac3:	89 c0                	mov    %eax,%eax
  8042117ac5:	4c 89 ea             	mov    %r13,%rdx
  8042117ac8:	48 29 c2             	sub    %rax,%rdx
  8042117acb:	49 89 96 08 40 00 00 	mov    %rdx,0x4008(%r14)
    if (dictEnd == (const BYTE*)source) {
  8042117ad2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042117ad6:	49 39 c5             	cmp    %rax,%r13
  8042117ad9:	0f 84 5f fe ff ff    	je     804211793e <LZ4_compress_fast_continue+0xaf>
        if (streamPtr->dictCtx) {
  8042117adf:	49 8b 86 10 40 00 00 	mov    0x4010(%r14),%rax
  8042117ae6:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8042117aea:	48 85 c0             	test   %rax,%rax
  8042117aed:	0f 84 95 1b 00 00    	je     8042119688 <LZ4_compress_fast_continue+0x1df9>
            if (inputSize > 4 KB) {
  8042117af3:	41 81 ff 00 10 00 00 	cmp    $0x1000,%r15d
  8042117afa:	0f 8f 83 0b 00 00    	jg     8042118683 <LZ4_compress_fast_continue+0xdf4>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042117b00:	b8 00 00 00 00       	mov    $0x0,%eax
  8042117b05:	41 81 ff 00 00 00 7e 	cmp    $0x7e000000,%r15d
  8042117b0c:	0f 87 4a 1b 00 00    	ja     804211965c <LZ4_compress_fast_continue+0x1dcd>
    U32 const startIndex = cctx->currentOffset;
  8042117b12:	45 8b ae 00 40 00 00 	mov    0x4000(%r14),%r13d
  8042117b19:	44 89 ad 78 ff ff ff 	mov    %r13d,-0x88(%rbp)
            dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
  8042117b20:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  8042117b24:	4c 8b 91 08 40 00 00 	mov    0x4008(%rcx),%r10
  8042117b2b:	4c 89 95 68 ff ff ff 	mov    %r10,-0x98(%rbp)
            dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;
  8042117b32:	8b 81 18 40 00 00    	mov    0x4018(%rcx),%eax
    const U32 dictDelta = (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with index in current context */
  8042117b38:	8b 91 00 40 00 00    	mov    0x4000(%rcx),%edx
    BYTE* const olimit = op + maxOutputSize;
  8042117b3e:	4d 63 e4             	movslq %r12d,%r12
  8042117b41:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8042117b45:	4a 8d 34 21          	lea    (%rcx,%r12,1),%rsi
  8042117b49:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
        cctx->dictCtx = NULL;
  8042117b50:	49 c7 86 10 40 00 00 	movq   $0x0,0x4010(%r14)
  8042117b57:	00 00 00 00 
        cctx->dictSize = (U32)inputSize;
  8042117b5b:	45 89 be 18 40 00 00 	mov    %r15d,0x4018(%r14)
    cctx->currentOffset += (U32)inputSize;
  8042117b62:	43 8d 4c 3d 00       	lea    0x0(%r13,%r15,1),%ecx
  8042117b67:	41 89 8e 00 40 00 00 	mov    %ecx,0x4000(%r14)
    cctx->tableType = (U16)tableType;
  8042117b6e:	66 41 c7 86 06 40 00 	movw   $0x2,0x4006(%r14)
  8042117b75:	00 02 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  8042117b78:	41 83 ff 0c          	cmp    $0xc,%r15d
  8042117b7c:	0f 8e fe 19 00 00    	jle    8042119580 <LZ4_compress_fast_continue+0x1cf1>
    const BYTE* base = (const BYTE*) source - startIndex;
  8042117b82:	44 89 e9             	mov    %r13d,%ecx
  8042117b85:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042117b89:	48 89 f7             	mov    %rsi,%rdi
  8042117b8c:	48 29 cf             	sub    %rcx,%rdi
  8042117b8f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    const U32 dictDelta = (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with index in current context */
  8042117b93:	44 89 e9             	mov    %r13d,%ecx
  8042117b96:	29 d1                	sub    %edx,%ecx
  8042117b98:	89 8d 60 ff ff ff    	mov    %ecx,-0xa0(%rbp)
    const BYTE* const dictEnd = dictionary + dictSize;
  8042117b9e:	89 c0                	mov    %eax,%eax
  8042117ba0:	49 8d 3c 02          	lea    (%r10,%rax,1),%rdi
  8042117ba4:	48 89 bd 10 ff ff ff 	mov    %rdi,-0xf0(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042117bab:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042117baf:	4c 8d 5f f5          	lea    -0xb(%rdi),%r11
  8042117bb3:	4c 89 5d 80          	mov    %r11,-0x80(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042117bb7:	48 83 ef 05          	sub    $0x5,%rdi
  8042117bbb:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
                           dictionary + dictSize - dictCtx->currentOffset :
  8042117bc2:	89 d2                	mov    %edx,%edx
  8042117bc4:	48 29 d0             	sub    %rdx,%rax
  8042117bc7:	4c 01 d0             	add    %r10,%rax
  8042117bca:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117bd1:	48 8b 3e             	mov    (%rsi),%rdi
  8042117bd4:	be 02 00 00 00       	mov    $0x2,%esi
  8042117bd9:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  8042117be0:	00 00 00 
  8042117be3:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042117be6:	89 c0                	mov    %eax,%eax
  8042117be8:	45 89 2c 86          	mov    %r13d,(%r14,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042117bec:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
  8042117bf0:	49 8d 45 01          	lea    0x1(%r13),%rax
  8042117bf4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117bf8:	49 8b 7d 01          	mov    0x1(%r13),%rdi
  8042117bfc:	be 02 00 00 00       	mov    $0x2,%esi
  8042117c01:	41 ff d4             	call   *%r12
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042117c04:	c1 e3 06             	shl    $0x6,%ebx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042117c07:	8d 73 01             	lea    0x1(%rbx),%esi
  8042117c0a:	89 b5 28 ff ff ff    	mov    %esi,-0xd8(%rbp)
  8042117c10:	c1 fb 06             	sar    $0x6,%ebx
  8042117c13:	89 9d 30 ff ff ff    	mov    %ebx,-0xd0(%rbp)
  8042117c19:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8042117c1d:	48 89 8d 40 ff ff ff 	mov    %rcx,-0xc0(%rbp)
  8042117c24:	4c 89 ee             	mov    %r13,%rsi
  8042117c27:	4c 89 75 90          	mov    %r14,-0x70(%rbp)
  8042117c2b:	44 89 bd 38 ff ff ff 	mov    %r15d,-0xc8(%rbp)
  8042117c32:	4c 8b 7d b0          	mov    -0x50(%rbp),%r15
                U32 const current = (U32)(forwardIp - base);
  8042117c36:	45 89 fd             	mov    %r15d,%r13d
  8042117c39:	8b 5d a8             	mov    -0x58(%rbp),%ebx
  8042117c3c:	41 29 dd             	sub    %ebx,%r13d
        return hashTable[h];
  8042117c3f:	89 c0                	mov    %eax,%eax
  8042117c41:	48 c1 e0 02          	shl    $0x2,%rax
  8042117c45:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042117c49:	4c 8d 34 01          	lea    (%rcx,%rax,1),%r14
  8042117c4d:	41 8b 1e             	mov    (%r14),%ebx
                forwardIp += step;
  8042117c50:	4d 8d 67 01          	lea    0x1(%r15),%r12
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042117c54:	4c 39 65 80          	cmp    %r12,-0x80(%rbp)
  8042117c58:	0f 82 4a 19 00 00    	jb     80421195a8 <LZ4_compress_fast_continue+0x1d19>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042117c5e:	8b bd 30 ff ff ff    	mov    -0xd0(%rbp),%edi
  8042117c64:	89 7d b0             	mov    %edi,-0x50(%rbp)
  8042117c67:	8b 8d 28 ff ff ff    	mov    -0xd8(%rbp),%ecx
  8042117c6d:	89 4d a0             	mov    %ecx,-0x60(%rbp)
                        lowLimit = (const BYTE*)source;
  8042117c70:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042117c74:	48 89 bd 48 ff ff ff 	mov    %rdi,-0xb8(%rbp)
  8042117c7b:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  8042117c82:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  8042117c86:	e9 13 13 00 00       	jmp    8042118f9e <LZ4_compress_fast_continue+0x170f>
            if (streamPtr->dictSize > 64 KB) streamPtr->dictSize = 64 KB;
  8042117c8b:	b8 00 00 01 00       	mov    $0x10000,%eax
  8042117c90:	e9 27 fe ff ff       	jmp    8042117abc <LZ4_compress_fast_continue+0x22d>
                U32 const current = (U32)(forwardIp - base);
  8042117c95:	45 89 e7             	mov    %r12d,%r15d
  8042117c98:	8b 5d a8             	mov    -0x58(%rbp),%ebx
  8042117c9b:	41 29 df             	sub    %ebx,%r15d
        return hashTable[h];
  8042117c9e:	89 c0                	mov    %eax,%eax
  8042117ca0:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8042117ca4:	4c 8d 2c 83          	lea    (%rbx,%rax,4),%r13
  8042117ca8:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  8042117cac:	48 63 45 b0          	movslq -0x50(%rbp),%rax
  8042117cb0:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042117cb3:	41 8d 56 01          	lea    0x1(%r14),%edx
  8042117cb7:	41 c1 fe 06          	sar    $0x6,%r14d
  8042117cbb:	44 89 75 b0          	mov    %r14d,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042117cbf:	4c 89 65 a0          	mov    %r12,-0x60(%rbp)
  8042117cc3:	48 39 45 98          	cmp    %rax,-0x68(%rbp)
  8042117cc7:	0f 82 84 03 00 00    	jb     8042118051 <LZ4_compress_fast_continue+0x7c2>
  8042117ccd:	41 89 d6             	mov    %edx,%r14d
  8042117cd0:	49 89 c4             	mov    %rax,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117cd3:	49 8b 3c 24          	mov    (%r12),%rdi
  8042117cd7:	be 02 00 00 00       	mov    $0x2,%esi
  8042117cdc:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042117ce3:	00 00 00 
  8042117ce6:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042117ce8:	45 89 7d 00          	mov    %r15d,0x0(%r13)
                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */
  8042117cec:	8b 4d 88             	mov    -0x78(%rbp),%ecx
  8042117cef:	39 cb                	cmp    %ecx,%ebx
  8042117cf1:	72 a2                	jb     8042117c95 <LZ4_compress_fast_continue+0x406>
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  8042117cf3:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  8042117cf9:	44 39 fa             	cmp    %r15d,%edx
  8042117cfc:	72 97                	jb     8042117c95 <LZ4_compress_fast_continue+0x406>
                    match = base + matchIndex;
  8042117cfe:	89 db                	mov    %ebx,%ebx
  8042117d00:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  8042117d04:	48 01 f3             	add    %rsi,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042117d07:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8042117d0b:	8b 0b                	mov    (%rbx),%ecx
  8042117d0d:	39 0e                	cmp    %ecx,(%rsi)
  8042117d0f:	75 84                	jne    8042117c95 <LZ4_compress_fast_continue+0x406>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042117d11:	49 89 f6             	mov    %rsi,%r14
  8042117d14:	48 39 75 c8          	cmp    %rsi,-0x38(%rbp)
  8042117d18:	73 13                	jae    8042117d2d <LZ4_compress_fast_continue+0x49e>
  8042117d1a:	48 39 9d 60 ff ff ff 	cmp    %rbx,-0xa0(%rbp)
  8042117d21:	73 0a                	jae    8042117d2d <LZ4_compress_fast_continue+0x49e>
  8042117d23:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  8042117d27:	41 38 46 ff          	cmp    %al,-0x1(%r14)
  8042117d2b:	74 7b                	je     8042117da8 <LZ4_compress_fast_continue+0x519>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  8042117d2d:	4c 89 f0             	mov    %r14,%rax
  8042117d30:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042117d34:	48 29 f8             	sub    %rdi,%rax
            token = op++;
  8042117d37:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
  8042117d3e:	48 83 c7 01          	add    $0x1,%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  8042117d42:	89 c1                	mov    %eax,%ecx
  8042117d44:	89 c2                	mov    %eax,%edx
  8042117d46:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042117d4b:	48 0f af d6          	imul   %rsi,%rdx
  8042117d4f:	48 c1 ea 27          	shr    $0x27,%rdx
  8042117d53:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  8042117d58:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  8042117d5b:	48 39 55 80          	cmp    %rdx,-0x80(%rbp)
  8042117d5f:	0f 82 03 2c 00 00    	jb     804211a968 <LZ4_compress_fast_continue+0x30d9>
            if (litLength >= RUN_MASK) {
  8042117d65:	83 f8 0e             	cmp    $0xe,%eax
  8042117d68:	77 62                	ja     8042117dcc <LZ4_compress_fast_continue+0x53d>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042117d6a:	c1 e0 04             	shl    $0x4,%eax
  8042117d6d:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  8042117d74:	88 06                	mov    %al,(%rsi)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042117d76:	4c 8d 3c 0f          	lea    (%rdi,%rcx,1),%r15
  8042117d7a:	4c 89 fa             	mov    %r15,%rdx
  8042117d7d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042117d81:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042117d88:	00 00 00 
  8042117d8b:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042117d8d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042117d91:	48 83 e8 0c          	sub    $0xc,%rax
  8042117d95:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117d99:	48 89 d8             	mov    %rbx,%rax
  8042117d9c:	48 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%rbx
  8042117da3:	e9 43 01 00 00       	jmp    8042117eeb <LZ4_compress_fast_continue+0x65c>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042117da8:	49 83 ee 01          	sub    $0x1,%r14
  8042117dac:	48 83 eb 01          	sub    $0x1,%rbx
  8042117db0:	4c 39 75 c8          	cmp    %r14,-0x38(%rbp)
  8042117db4:	0f 83 73 ff ff ff    	jae    8042117d2d <LZ4_compress_fast_continue+0x49e>
  8042117dba:	48 39 9d 60 ff ff ff 	cmp    %rbx,-0xa0(%rbp)
  8042117dc1:	0f 82 5c ff ff ff    	jb     8042117d23 <LZ4_compress_fast_continue+0x494>
  8042117dc7:	e9 61 ff ff ff       	jmp    8042117d2d <LZ4_compress_fast_continue+0x49e>
                int len = (int)(litLength - RUN_MASK);
  8042117dcc:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  8042117dcf:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  8042117dd6:	c6 06 f0             	movb   $0xf0,(%rsi)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042117dd9:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042117dde:	7e 14                	jle    8042117df4 <LZ4_compress_fast_continue+0x565>
  8042117de0:	48 83 c7 01          	add    $0x1,%rdi
  8042117de4:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042117de8:	2d ff 00 00 00       	sub    $0xff,%eax
  8042117ded:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042117df2:	7f ec                	jg     8042117de0 <LZ4_compress_fast_continue+0x551>
                *op++ = (BYTE)len;
  8042117df4:	88 07                	mov    %al,(%rdi)
  8042117df6:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042117dfa:	e9 77 ff ff ff       	jmp    8042117d76 <LZ4_compress_fast_continue+0x4e7>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042117dff:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042117e02:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042117e09:	00 00 00 
  8042117e0c:	ff d0                	call   *%rax
  8042117e0e:	41 89 c4             	mov    %eax,%r12d
  8042117e11:	eb 19                	jmp    8042117e2c <LZ4_compress_fast_continue+0x59d>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042117e13:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042117e16:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042117e1d:	00 00 00 
  8042117e20:	ff d0                	call   *%rax
  8042117e22:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  8042117e26:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8042117e29:	41 29 c4             	sub    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042117e2c:	44 89 e0             	mov    %r12d,%eax
  8042117e2f:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042117e34:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  8042117e3b:	00 
  8042117e3c:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042117e41:	48 0f af c6          	imul   %rsi,%rax
  8042117e45:	48 c1 e8 27          	shr    $0x27,%rax
  8042117e49:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042117e4e:	48 39 45 80          	cmp    %rax,-0x80(%rbp)
  8042117e52:	0f 82 1a 2b 00 00    	jb     804211a972 <LZ4_compress_fast_continue+0x30e3>
            if (matchCode >= ML_MASK) {
  8042117e58:	41 83 fc 0e          	cmp    $0xe,%r12d
  8042117e5c:	0f 87 59 01 00 00    	ja     8042117fbb <LZ4_compress_fast_continue+0x72c>
                *token += (BYTE)(matchCode);
  8042117e62:	44 00 23             	add    %r12b,(%rbx)
  8042117e65:	4c 89 eb             	mov    %r13,%rbx
        if (ip >= mflimitPlusOne) break;
  8042117e68:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8042117e6c:	49 39 c6             	cmp    %rax,%r14
  8042117e6f:	0f 83 7f 02 00 00    	jae    80421180f4 <LZ4_compress_fast_continue+0x865>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117e75:	49 8b 7e fe          	mov    -0x2(%r14),%rdi
  8042117e79:	be 02 00 00 00       	mov    $0x2,%esi
  8042117e7e:	49 bd ce 28 11 42 80 	movabs $0x80421128ce,%r13
  8042117e85:	00 00 00 
  8042117e88:	41 ff d5             	call   *%r13
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042117e8b:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042117e8d:	49 8d 56 fe          	lea    -0x2(%r14),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042117e91:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
  8042117e95:	4c 29 fa             	sub    %r15,%rdx
  8042117e98:	4c 8b 65 90          	mov    -0x70(%rbp),%r12
  8042117e9c:	41 89 14 84          	mov    %edx,(%r12,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042117ea0:	49 8b 3e             	mov    (%r14),%rdi
  8042117ea3:	be 02 00 00 00       	mov    $0x2,%esi
  8042117ea8:	41 ff d5             	call   *%r13
            U32 const current = (U32)(ip-base);
  8042117eab:	4c 89 f1             	mov    %r14,%rcx
  8042117eae:	4c 29 f9             	sub    %r15,%rcx
        return hashTable[h];
  8042117eb1:	89 c0                	mov    %eax,%eax
  8042117eb3:	49 8d 34 84          	lea    (%r12,%rax,4),%rsi
  8042117eb7:	8b 16                	mov    (%rsi),%edx
                match = base + matchIndex;
  8042117eb9:	89 d0                	mov    %edx,%eax
  8042117ebb:	4c 01 f8             	add    %r15,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042117ebe:	89 0e                	mov    %ecx,(%rsi)
            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)
  8042117ec0:	8b 7d 88             	mov    -0x78(%rbp),%edi
  8042117ec3:	39 fa                	cmp    %edi,%edx
  8042117ec5:	0f 82 4f 01 00 00    	jb     804211801a <LZ4_compress_fast_continue+0x78b>
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  8042117ecb:	81 c2 ff ff 00 00    	add    $0xffff,%edx
  8042117ed1:	39 ca                	cmp    %ecx,%edx
  8042117ed3:	0f 82 41 01 00 00    	jb     804211801a <LZ4_compress_fast_continue+0x78b>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042117ed9:	8b 08                	mov    (%rax),%ecx
  8042117edb:	41 39 0e             	cmp    %ecx,(%r14)
  8042117ede:	0f 85 36 01 00 00    	jne    804211801a <LZ4_compress_fast_continue+0x78b>
                token=op++;
  8042117ee4:	4c 8d 7b 01          	lea    0x1(%rbx),%r15
                *token=0;
  8042117ee8:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  8042117eeb:	4c 89 f2             	mov    %r14,%rdx
  8042117eee:	48 29 c2             	sub    %rax,%rdx
  8042117ef1:	66 41 89 17          	mov    %dx,(%r15)
  8042117ef5:	4d 8d 6f 02          	lea    0x2(%r15),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042117ef9:	49 8d 76 04          	lea    0x4(%r14),%rsi
  8042117efd:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042117f01:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8042117f05:	48 39 ce             	cmp    %rcx,%rsi
  8042117f08:	73 41                	jae    8042117f4b <LZ4_compress_fast_continue+0x6bc>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042117f0a:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042117f0e:	49 8b 7e 04          	mov    0x4(%r14),%rdi
        if (!diff) {
  8042117f12:	48 39 d7             	cmp    %rdx,%rdi
  8042117f15:	0f 85 e4 fe ff ff    	jne    8042117dff <LZ4_compress_fast_continue+0x570>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042117f1b:	4d 8d 66 0c          	lea    0xc(%r14),%r12
  8042117f1f:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042117f23:	49 39 cc             	cmp    %rcx,%r12
  8042117f26:	73 2b                	jae    8042117f53 <LZ4_compress_fast_continue+0x6c4>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042117f28:	48 8b 10             	mov    (%rax),%rdx
  8042117f2b:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042117f2f:	48 39 d7             	cmp    %rdx,%rdi
  8042117f32:	0f 85 db fe ff ff    	jne    8042117e13 <LZ4_compress_fast_continue+0x584>
  8042117f38:	49 83 c4 08          	add    $0x8,%r12
  8042117f3c:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042117f40:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8042117f44:	49 39 cc             	cmp    %rcx,%r12
  8042117f47:	72 df                	jb     8042117f28 <LZ4_compress_fast_continue+0x699>
  8042117f49:	eb 08                	jmp    8042117f53 <LZ4_compress_fast_continue+0x6c4>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042117f4b:	48 83 c0 04          	add    $0x4,%rax
  8042117f4f:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042117f53:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042117f57:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  8042117f5b:	49 39 d4             	cmp    %rdx,%r12
  8042117f5e:	73 08                	jae    8042117f68 <LZ4_compress_fast_continue+0x6d9>
  8042117f60:	8b 38                	mov    (%rax),%edi
  8042117f62:	41 39 3c 24          	cmp    %edi,(%r12)
  8042117f66:	74 3f                	je     8042117fa7 <LZ4_compress_fast_continue+0x718>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042117f68:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042117f6c:	48 8d 57 fa          	lea    -0x6(%rdi),%rdx
  8042117f70:	49 39 d4             	cmp    %rdx,%r12
  8042117f73:	73 0a                	jae    8042117f7f <LZ4_compress_fast_continue+0x6f0>
  8042117f75:	0f b7 38             	movzwl (%rax),%edi
  8042117f78:	66 41 39 3c 24       	cmp    %di,(%r12)
  8042117f7d:	74 32                	je     8042117fb1 <LZ4_compress_fast_continue+0x722>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042117f7f:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8042117f86:	49 39 cc             	cmp    %rcx,%r12
  8042117f89:	73 11                	jae    8042117f9c <LZ4_compress_fast_continue+0x70d>
  8042117f8b:	41 0f b6 3c 24       	movzbl (%r12),%edi
  8042117f90:	40 38 38             	cmp    %dil,(%rax)
  8042117f93:	0f 94 c0             	sete   %al
  8042117f96:	0f b6 c0             	movzbl %al,%eax
  8042117f99:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  8042117f9c:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8042117f9f:	41 29 c4             	sub    %eax,%r12d
  8042117fa2:	e9 85 fe ff ff       	jmp    8042117e2c <LZ4_compress_fast_continue+0x59d>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042117fa7:	49 83 c4 04          	add    $0x4,%r12
  8042117fab:	48 83 c0 04          	add    $0x4,%rax
  8042117faf:	eb b7                	jmp    8042117f68 <LZ4_compress_fast_continue+0x6d9>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042117fb1:	49 83 c4 02          	add    $0x2,%r12
  8042117fb5:	48 83 c0 02          	add    $0x2,%rax
  8042117fb9:	eb c4                	jmp    8042117f7f <LZ4_compress_fast_continue+0x6f0>
                *token += ML_MASK;
  8042117fbb:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  8042117fbe:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042117fc2:	41 c7 47 02 ff ff ff 	movl   $0xffffffff,0x2(%r15)
  8042117fc9:	ff 
                while (matchCode >= 4*255) {
  8042117fca:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042117fd1:	76 1c                	jbe    8042117fef <LZ4_compress_fast_continue+0x760>
                    op+=4;
  8042117fd3:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042117fd7:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  8042117fde:	ff 
                    matchCode -= 4*255;
  8042117fdf:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  8042117fe6:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042117fed:	77 e4                	ja     8042117fd3 <LZ4_compress_fast_continue+0x744>
                op += matchCode / 255;
  8042117fef:	44 89 e0             	mov    %r12d,%eax
  8042117ff2:	ba 81 80 80 80       	mov    $0x80808081,%edx
  8042117ff7:	48 0f af c2          	imul   %rdx,%rax
  8042117ffb:	48 c1 e8 27          	shr    $0x27,%rax
  8042117fff:	89 c2                	mov    %eax,%edx
  8042118001:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042118004:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  8042118008:	89 c1                	mov    %eax,%ecx
  804211800a:	c1 e1 08             	shl    $0x8,%ecx
  804211800d:	29 c1                	sub    %eax,%ecx
  804211800f:	41 29 cc             	sub    %ecx,%r12d
  8042118012:	44 88 22             	mov    %r12b,(%rdx)
  8042118015:	e9 4e fe ff ff       	jmp    8042117e68 <LZ4_compress_fast_continue+0x5d9>
        forwardH = LZ4_hashPosition(++ip, tableType);
  804211801a:	48 89 9d 78 ff ff ff 	mov    %rbx,-0x88(%rbp)
  8042118021:	49 8d 5e 01          	lea    0x1(%r14),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118025:	49 8b 7e 01          	mov    0x1(%r14),%rdi
  8042118029:	be 02 00 00 00       	mov    $0x2,%esi
  804211802e:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042118035:	00 00 00 
  8042118038:	ff d0                	call   *%rax
  804211803a:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
  804211803e:	49 89 de             	mov    %rbx,%r14
  8042118041:	e9 fb f9 ff ff       	jmp    8042117a41 <LZ4_compress_fast_continue+0x1b2>
    BYTE* op = (BYTE*) dest;
  8042118046:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211804a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    {   size_t lastRun = (size_t)(iend - anchor);
  8042118051:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  8042118055:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042118059:	49 29 c4             	sub    %rax,%r12
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  804211805c:	49 8d 94 24 f0 00 00 	lea    0xf0(%r12),%rdx
  8042118063:	00 
  8042118064:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  804211806b:	80 80 80 
  804211806e:	48 89 d0             	mov    %rdx,%rax
  8042118071:	48 f7 e1             	mul    %rcx
  8042118074:	48 c1 ea 07          	shr    $0x7,%rdx
  8042118078:	49 8d 54 14 01       	lea    0x1(%r12,%rdx,1),%rdx
  804211807d:	48 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%rbx
  8042118084:	48 01 da             	add    %rbx,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042118087:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  804211808c:	48 39 55 80          	cmp    %rdx,-0x80(%rbp)
  8042118090:	0f 82 28 f8 ff ff    	jb     80421178be <LZ4_compress_fast_continue+0x2f>
        if (lastRun >= RUN_MASK) {
  8042118096:	49 83 fc 0e          	cmp    $0xe,%r12
  804211809a:	76 68                	jbe    8042118104 <LZ4_compress_fast_continue+0x875>
            size_t accumulator = lastRun - RUN_MASK;
  804211809c:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  80421180a1:	48 8d 43 01          	lea    0x1(%rbx),%rax
  80421180a5:	c6 03 f0             	movb   $0xf0,(%rbx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  80421180a8:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421180af:	76 18                	jbe    80421180c9 <LZ4_compress_fast_continue+0x83a>
  80421180b1:	48 83 c0 01          	add    $0x1,%rax
  80421180b5:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  80421180b9:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  80421180c0:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  80421180c7:	77 e8                	ja     80421180b1 <LZ4_compress_fast_continue+0x822>
            *op++ = (BYTE) accumulator;
  80421180c9:	48 8d 58 01          	lea    0x1(%rax),%rbx
  80421180cd:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  80421180cf:	4c 89 e2             	mov    %r12,%rdx
  80421180d2:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80421180d6:	48 89 df             	mov    %rbx,%rdi
  80421180d9:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  80421180e0:	00 00 00 
  80421180e3:	ff d0                	call   *%rax
        op += lastRun;
  80421180e5:	4c 01 e3             	add    %r12,%rbx
    result = (int)(((char*)op) - dest);
  80421180e8:	89 d8                	mov    %ebx,%eax
  80421180ea:	8b 75 c0             	mov    -0x40(%rbp),%esi
  80421180ed:	29 f0                	sub    %esi,%eax
    return result;
  80421180ef:	e9 ca f7 ff ff       	jmp    80421178be <LZ4_compress_fast_continue+0x2f>
        anchor = ip;
  80421180f4:	48 89 9d 78 ff ff ff 	mov    %rbx,-0x88(%rbp)
  80421180fb:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
  80421180ff:	e9 4d ff ff ff       	jmp    8042118051 <LZ4_compress_fast_continue+0x7c2>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042118104:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  804211810b:	48 8d 5e 01          	lea    0x1(%rsi),%rbx
  804211810f:	44 89 e0             	mov    %r12d,%eax
  8042118112:	c1 e0 04             	shl    $0x4,%eax
  8042118115:	88 06                	mov    %al,(%rsi)
  8042118117:	eb b6                	jmp    80421180cf <LZ4_compress_fast_continue+0x840>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042118119:	b8 00 00 00 00       	mov    $0x0,%eax
  804211811e:	41 81 ff 00 00 00 7e 	cmp    $0x7e000000,%r15d
  8042118125:	0f 87 93 f7 ff ff    	ja     80421178be <LZ4_compress_fast_continue+0x2f>
    U32 const startIndex = cctx->currentOffset;
  804211812b:	45 8b ae 00 40 00 00 	mov    0x4000(%r14),%r13d
    BYTE* const olimit = op + maxOutputSize;
  8042118132:	4d 63 e4             	movslq %r12d,%r12
  8042118135:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042118139:	4a 8d 34 20          	lea    (%rax,%r12,1),%rsi
  804211813d:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
        cctx->dictSize += (U32)inputSize;
  8042118141:	42 8d 04 3a          	lea    (%rdx,%r15,1),%eax
  8042118145:	41 89 86 18 40 00 00 	mov    %eax,0x4018(%r14)
    cctx->currentOffset += (U32)inputSize;
  804211814c:	43 8d 44 3d 00       	lea    0x0(%r13,%r15,1),%eax
  8042118151:	41 89 86 00 40 00 00 	mov    %eax,0x4000(%r14)
    cctx->tableType = (U16)tableType;
  8042118158:	66 41 c7 86 06 40 00 	movw   $0x2,0x4006(%r14)
  804211815f:	00 02 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  8042118162:	41 83 ff 0c          	cmp    $0xc,%r15d
  8042118166:	0f 8e 50 04 00 00    	jle    80421185bc <LZ4_compress_fast_continue+0xd2d>
    const BYTE* base = (const BYTE*) source - startIndex;
  804211816c:	44 89 e8             	mov    %r13d,%eax
  804211816f:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042118173:	48 89 f1             	mov    %rsi,%rcx
  8042118176:	48 29 c1             	sub    %rax,%rcx
  8042118179:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  804211817d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042118181:	48 8d 79 f5          	lea    -0xb(%rcx),%rdi
  8042118185:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  8042118189:	48 83 e9 05          	sub    $0x5,%rcx
  804211818d:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
    const BYTE* const dictEnd = dictionary + dictSize;
  8042118194:	89 d2                	mov    %edx,%edx
    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);
  8042118196:	49 89 f7             	mov    %rsi,%r15
  8042118199:	49 29 d7             	sub    %rdx,%r15
  804211819c:	4c 89 bd 68 ff ff ff 	mov    %r15,-0x98(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421181a3:	49 89 f7             	mov    %rsi,%r15
  80421181a6:	48 8b 3e             	mov    (%rsi),%rdi
  80421181a9:	be 02 00 00 00       	mov    $0x2,%esi
  80421181ae:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  80421181b5:	00 00 00 
  80421181b8:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  80421181bb:	89 c0                	mov    %eax,%eax
  80421181bd:	45 89 2c 86          	mov    %r13d,(%r14,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  80421181c1:	4c 89 fe             	mov    %r15,%rsi
  80421181c4:	4d 8d 7f 01          	lea    0x1(%r15),%r15
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421181c8:	48 8b 7e 01          	mov    0x1(%rsi),%rdi
  80421181cc:	be 02 00 00 00       	mov    $0x2,%esi
  80421181d1:	41 ff d4             	call   *%r12
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  80421181d4:	c1 e3 06             	shl    $0x6,%ebx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421181d7:	8d 73 01             	lea    0x1(%rbx),%esi
  80421181da:	89 b5 78 ff ff ff    	mov    %esi,-0x88(%rbp)
  80421181e0:	c1 fb 06             	sar    $0x6,%ebx
  80421181e3:	89 9d 70 ff ff ff    	mov    %ebx,-0x90(%rbp)
  80421181e9:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
  80421181ed:	48 89 5d 80          	mov    %rbx,-0x80(%rbp)
  80421181f1:	4c 89 75 90          	mov    %r14,-0x70(%rbp)
                U32 const current = (U32)(forwardIp - base);
  80421181f5:	45 89 fe             	mov    %r15d,%r14d
  80421181f8:	8b 7d b0             	mov    -0x50(%rbp),%edi
  80421181fb:	41 29 fe             	sub    %edi,%r14d
        return hashTable[h];
  80421181fe:	89 c0                	mov    %eax,%eax
  8042118200:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  8042118204:	4c 8d 2c 86          	lea    (%rsi,%rax,4),%r13
  8042118208:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  804211820c:	4d 8d 67 01          	lea    0x1(%r15),%r12
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042118210:	4c 39 65 98          	cmp    %r12,-0x68(%rbp)
  8042118214:	0f 82 aa 03 00 00    	jb     80421185c4 <LZ4_compress_fast_continue+0xd35>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211821a:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
  8042118220:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8042118223:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  8042118229:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
  804211822d:	41 89 c7             	mov    %eax,%r15d
  8042118230:	eb 3e                	jmp    8042118270 <LZ4_compress_fast_continue+0x9e1>
                U32 const current = (U32)(forwardIp - base);
  8042118232:	45 89 e6             	mov    %r12d,%r14d
  8042118235:	8b 7d b0             	mov    -0x50(%rbp),%edi
  8042118238:	41 29 fe             	sub    %edi,%r14d
        return hashTable[h];
  804211823b:	89 c0                	mov    %eax,%eax
  804211823d:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042118241:	4c 8d 2c 81          	lea    (%rcx,%rax,4),%r13
  8042118245:	41 8b 5d 00          	mov    0x0(%r13),%ebx
                forwardIp += step;
  8042118249:	48 63 45 a8          	movslq -0x58(%rbp),%rax
  804211824d:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042118250:	41 8d 57 01          	lea    0x1(%r15),%edx
  8042118254:	41 c1 ff 06          	sar    $0x6,%r15d
  8042118258:	44 89 7d a8          	mov    %r15d,-0x58(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  804211825c:	4c 89 65 a0          	mov    %r12,-0x60(%rbp)
  8042118260:	48 39 45 98          	cmp    %rax,-0x68(%rbp)
  8042118264:	0f 82 5a 03 00 00    	jb     80421185c4 <LZ4_compress_fast_continue+0xd35>
  804211826a:	41 89 d7             	mov    %edx,%r15d
  804211826d:	49 89 c4             	mov    %rax,%r12
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118270:	49 8b 3c 24          	mov    (%r12),%rdi
  8042118274:	be 02 00 00 00       	mov    $0x2,%esi
  8042118279:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042118280:	00 00 00 
  8042118283:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042118285:	45 89 75 00          	mov    %r14d,0x0(%r13)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  8042118289:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  804211828f:	44 39 f2             	cmp    %r14d,%edx
  8042118292:	72 9e                	jb     8042118232 <LZ4_compress_fast_continue+0x9a3>
                    match = base + matchIndex;
  8042118294:	89 db                	mov    %ebx,%ebx
  8042118296:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211829a:	48 01 fb             	add    %rdi,%rbx
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  804211829d:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80421182a1:	8b 3b                	mov    (%rbx),%edi
  80421182a3:	39 3e                	cmp    %edi,(%rsi)
  80421182a5:	75 8b                	jne    8042118232 <LZ4_compress_fast_continue+0x9a3>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  80421182a7:	49 89 f7             	mov    %rsi,%r15
  80421182aa:	48 39 75 c8          	cmp    %rsi,-0x38(%rbp)
  80421182ae:	73 13                	jae    80421182c3 <LZ4_compress_fast_continue+0xa34>
  80421182b0:	48 39 9d 68 ff ff ff 	cmp    %rbx,-0x98(%rbp)
  80421182b7:	73 0a                	jae    80421182c3 <LZ4_compress_fast_continue+0xa34>
  80421182b9:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  80421182bd:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  80421182c1:	74 72                	je     8042118335 <LZ4_compress_fast_continue+0xaa6>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  80421182c3:	4c 89 f8             	mov    %r15,%rax
  80421182c6:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80421182ca:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  80421182cd:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  80421182d1:	48 8d 7e 01          	lea    0x1(%rsi),%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  80421182d5:	89 c1                	mov    %eax,%ecx
  80421182d7:	89 c2                	mov    %eax,%edx
  80421182d9:	be 81 80 80 80       	mov    $0x80808081,%esi
  80421182de:	48 0f af d6          	imul   %rsi,%rdx
  80421182e2:	48 c1 ea 27          	shr    $0x27,%rdx
  80421182e6:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  80421182eb:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  80421182ee:	48 39 55 88          	cmp    %rdx,-0x78(%rbp)
  80421182f2:	0f 82 84 26 00 00    	jb     804211a97c <LZ4_compress_fast_continue+0x30ed>
            if (litLength >= RUN_MASK) {
  80421182f8:	83 f8 0e             	cmp    $0xe,%eax
  80421182fb:	77 58                	ja     8042118355 <LZ4_compress_fast_continue+0xac6>
            else *token = (BYTE)(litLength<<ML_BITS);
  80421182fd:	c1 e0 04             	shl    $0x4,%eax
  8042118300:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  8042118304:	88 06                	mov    %al,(%rsi)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042118306:	4c 8d 34 0f          	lea    (%rdi,%rcx,1),%r14
  804211830a:	4c 89 f2             	mov    %r14,%rdx
  804211830d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042118311:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042118318:	00 00 00 
  804211831b:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211831d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042118321:	48 83 e8 0c          	sub    $0xc,%rax
  8042118325:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118329:	48 89 d8             	mov    %rbx,%rax
  804211832c:	48 8b 5d 80          	mov    -0x80(%rbp),%rbx
  8042118330:	e9 15 01 00 00       	jmp    804211844a <LZ4_compress_fast_continue+0xbbb>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042118335:	49 83 ef 01          	sub    $0x1,%r15
  8042118339:	48 83 eb 01          	sub    $0x1,%rbx
  804211833d:	4c 39 7d c8          	cmp    %r15,-0x38(%rbp)
  8042118341:	73 80                	jae    80421182c3 <LZ4_compress_fast_continue+0xa34>
  8042118343:	48 39 9d 68 ff ff ff 	cmp    %rbx,-0x98(%rbp)
  804211834a:	0f 82 69 ff ff ff    	jb     80421182b9 <LZ4_compress_fast_continue+0xa2a>
  8042118350:	e9 6e ff ff ff       	jmp    80421182c3 <LZ4_compress_fast_continue+0xa34>
                int len = (int)(litLength - RUN_MASK);
  8042118355:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  8042118358:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  804211835c:	c6 06 f0             	movb   $0xf0,(%rsi)
                for(; len >= 255 ; len-=255) *op++ = 255;
  804211835f:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042118364:	7e 14                	jle    804211837a <LZ4_compress_fast_continue+0xaeb>
  8042118366:	48 83 c7 01          	add    $0x1,%rdi
  804211836a:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  804211836e:	2d ff 00 00 00       	sub    $0xff,%eax
  8042118373:	3d fe 00 00 00       	cmp    $0xfe,%eax
  8042118378:	7f ec                	jg     8042118366 <LZ4_compress_fast_continue+0xad7>
                *op++ = (BYTE)len;
  804211837a:	88 07                	mov    %al,(%rdi)
  804211837c:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  8042118380:	eb 84                	jmp    8042118306 <LZ4_compress_fast_continue+0xa77>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042118382:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042118385:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211838c:	00 00 00 
  804211838f:	ff d0                	call   *%rax
  8042118391:	41 89 c4             	mov    %eax,%r12d
                ip += (size_t)matchCode + MINMATCH;
  8042118394:	44 89 e0             	mov    %r12d,%eax
  8042118397:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  804211839c:	41 8d 84 24 f0 00 00 	lea    0xf0(%r12),%eax
  80421183a3:	00 
  80421183a4:	be 81 80 80 80       	mov    $0x80808081,%esi
  80421183a9:	48 0f af c6          	imul   %rsi,%rax
  80421183ad:	48 c1 e8 27          	shr    $0x27,%rax
  80421183b1:	49 8d 44 05 06       	lea    0x6(%r13,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  80421183b6:	48 39 45 88          	cmp    %rax,-0x78(%rbp)
  80421183ba:	0f 82 c6 25 00 00    	jb     804211a986 <LZ4_compress_fast_continue+0x30f7>
            if (matchCode >= ML_MASK) {
  80421183c0:	41 83 fc 0e          	cmp    $0xe,%r12d
  80421183c4:	0f 87 6a 01 00 00    	ja     8042118534 <LZ4_compress_fast_continue+0xca5>
                *token += (BYTE)(matchCode);
  80421183ca:	44 00 23             	add    %r12b,(%rbx)
  80421183cd:	4c 89 eb             	mov    %r13,%rbx
        if (ip >= mflimitPlusOne) break;
  80421183d0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80421183d4:	49 39 c7             	cmp    %rax,%r15
  80421183d7:	0f 83 87 02 00 00    	jae    8042118664 <LZ4_compress_fast_continue+0xdd5>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  80421183dd:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  80421183e1:	be 02 00 00 00       	mov    $0x2,%esi
  80421183e6:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  80421183ed:	00 00 00 
  80421183f0:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  80421183f3:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  80421183f5:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  80421183f9:	4c 8b 75 b0          	mov    -0x50(%rbp),%r14
  80421183fd:	4c 29 f2             	sub    %r14,%rdx
  8042118400:	4c 8b 6d 90          	mov    -0x70(%rbp),%r13
  8042118404:	41 89 54 85 00       	mov    %edx,0x0(%r13,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118409:	49 8b 3f             	mov    (%r15),%rdi
  804211840c:	be 02 00 00 00       	mov    $0x2,%esi
  8042118411:	41 ff d4             	call   *%r12
            U32 const current = (U32)(ip-base);
  8042118414:	4c 89 f9             	mov    %r15,%rcx
  8042118417:	4c 29 f1             	sub    %r14,%rcx
        return hashTable[h];
  804211841a:	89 c0                	mov    %eax,%eax
  804211841c:	49 8d 74 85 00       	lea    0x0(%r13,%rax,4),%rsi
  8042118421:	8b 16                	mov    (%rsi),%edx
                match = base + matchIndex;
  8042118423:	89 d0                	mov    %edx,%eax
  8042118425:	4c 01 f0             	add    %r14,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042118428:	89 0e                	mov    %ecx,(%rsi)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  804211842a:	81 c2 ff ff 00 00    	add    $0xffff,%edx
  8042118430:	39 ca                	cmp    %ecx,%edx
  8042118432:	0f 82 5b 01 00 00    	jb     8042118593 <LZ4_compress_fast_continue+0xd04>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042118438:	8b 30                	mov    (%rax),%esi
  804211843a:	41 39 37             	cmp    %esi,(%r15)
  804211843d:	0f 85 50 01 00 00    	jne    8042118593 <LZ4_compress_fast_continue+0xd04>
                token=op++;
  8042118443:	4c 8d 73 01          	lea    0x1(%rbx),%r14
                *token=0;
  8042118447:	c6 03 00             	movb   $0x0,(%rbx)
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
  804211844a:	4c 89 fa             	mov    %r15,%rdx
  804211844d:	48 29 c2             	sub    %rax,%rdx
  8042118450:	66 41 89 16          	mov    %dx,(%r14)
  8042118454:	4d 8d 6e 02          	lea    0x2(%r14),%r13
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042118458:	49 8d 4f 04          	lea    0x4(%r15),%rcx
  804211845c:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118460:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  8042118464:	48 39 f1             	cmp    %rsi,%rcx
  8042118467:	73 5b                	jae    80421184c4 <LZ4_compress_fast_continue+0xc35>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042118469:	48 8b 50 04          	mov    0x4(%rax),%rdx
  804211846d:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  8042118471:	48 39 d7             	cmp    %rdx,%rdi
  8042118474:	0f 85 08 ff ff ff    	jne    8042118382 <LZ4_compress_fast_continue+0xaf3>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211847a:	4d 8d 67 0c          	lea    0xc(%r15),%r12
  804211847e:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118482:	49 39 f4             	cmp    %rsi,%r12
  8042118485:	73 45                	jae    80421184cc <LZ4_compress_fast_continue+0xc3d>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042118487:	48 8b 10             	mov    (%rax),%rdx
  804211848a:	49 8b 3c 24          	mov    (%r12),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211848e:	48 39 d7             	cmp    %rdx,%rdi
  8042118491:	74 1e                	je     80421184b1 <LZ4_compress_fast_continue+0xc22>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042118493:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042118496:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211849d:	00 00 00 
  80421184a0:	ff d0                	call   *%rax
  80421184a2:	46 8d 24 20          	lea    (%rax,%r12,1),%r12d
        return (unsigned)(pIn - pStart);
  80421184a6:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80421184a9:	41 29 c4             	sub    %eax,%r12d
  80421184ac:	e9 e3 fe ff ff       	jmp    8042118394 <LZ4_compress_fast_continue+0xb05>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421184b1:	49 83 c4 08          	add    $0x8,%r12
  80421184b5:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421184b9:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  80421184bd:	49 39 fc             	cmp    %rdi,%r12
  80421184c0:	72 c5                	jb     8042118487 <LZ4_compress_fast_continue+0xbf8>
  80421184c2:	eb 08                	jmp    80421184cc <LZ4_compress_fast_continue+0xc3d>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  80421184c4:	48 83 c0 04          	add    $0x4,%rax
  80421184c8:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421184cc:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80421184d0:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  80421184d4:	49 39 d4             	cmp    %rdx,%r12
  80421184d7:	73 08                	jae    80421184e1 <LZ4_compress_fast_continue+0xc52>
  80421184d9:	8b 08                	mov    (%rax),%ecx
  80421184db:	41 39 0c 24          	cmp    %ecx,(%r12)
  80421184df:	74 3f                	je     8042118520 <LZ4_compress_fast_continue+0xc91>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421184e1:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80421184e5:	48 8d 51 fa          	lea    -0x6(%rcx),%rdx
  80421184e9:	49 39 d4             	cmp    %rdx,%r12
  80421184ec:	73 0a                	jae    80421184f8 <LZ4_compress_fast_continue+0xc69>
  80421184ee:	0f b7 08             	movzwl (%rax),%ecx
  80421184f1:	66 41 39 0c 24       	cmp    %cx,(%r12)
  80421184f6:	74 32                	je     804211852a <LZ4_compress_fast_continue+0xc9b>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  80421184f8:	48 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%rdi
  80421184ff:	49 39 fc             	cmp    %rdi,%r12
  8042118502:	73 11                	jae    8042118515 <LZ4_compress_fast_continue+0xc86>
  8042118504:	41 0f b6 3c 24       	movzbl (%r12),%edi
  8042118509:	40 38 38             	cmp    %dil,(%rax)
  804211850c:	0f 94 c0             	sete   %al
  804211850f:	0f b6 c0             	movzbl %al,%eax
  8042118512:	49 01 c4             	add    %rax,%r12
    return (unsigned)(pIn - pStart);
  8042118515:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8042118518:	41 29 c4             	sub    %eax,%r12d
  804211851b:	e9 74 fe ff ff       	jmp    8042118394 <LZ4_compress_fast_continue+0xb05>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042118520:	49 83 c4 04          	add    $0x4,%r12
  8042118524:	48 83 c0 04          	add    $0x4,%rax
  8042118528:	eb b7                	jmp    80421184e1 <LZ4_compress_fast_continue+0xc52>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211852a:	49 83 c4 02          	add    $0x2,%r12
  804211852e:	48 83 c0 02          	add    $0x2,%rax
  8042118532:	eb c4                	jmp    80421184f8 <LZ4_compress_fast_continue+0xc69>
                *token += ML_MASK;
  8042118534:	80 03 0f             	addb   $0xf,(%rbx)
                matchCode -= ML_MASK;
  8042118537:	41 83 ec 0f          	sub    $0xf,%r12d
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211853b:	41 c7 46 02 ff ff ff 	movl   $0xffffffff,0x2(%r14)
  8042118542:	ff 
                while (matchCode >= 4*255) {
  8042118543:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  804211854a:	76 1c                	jbe    8042118568 <LZ4_compress_fast_continue+0xcd9>
                    op+=4;
  804211854c:	49 83 c5 04          	add    $0x4,%r13
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042118550:	41 c7 45 00 ff ff ff 	movl   $0xffffffff,0x0(%r13)
  8042118557:	ff 
                    matchCode -= 4*255;
  8042118558:	41 81 ec fc 03 00 00 	sub    $0x3fc,%r12d
                while (matchCode >= 4*255) {
  804211855f:	41 81 fc fb 03 00 00 	cmp    $0x3fb,%r12d
  8042118566:	77 e4                	ja     804211854c <LZ4_compress_fast_continue+0xcbd>
                op += matchCode / 255;
  8042118568:	44 89 e0             	mov    %r12d,%eax
  804211856b:	ba 81 80 80 80       	mov    $0x80808081,%edx
  8042118570:	48 0f af c2          	imul   %rdx,%rax
  8042118574:	48 c1 e8 27          	shr    $0x27,%rax
  8042118578:	89 c2                	mov    %eax,%edx
  804211857a:	4c 01 ea             	add    %r13,%rdx
                *op++ = (BYTE)(matchCode % 255);
  804211857d:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  8042118581:	89 c1                	mov    %eax,%ecx
  8042118583:	c1 e1 08             	shl    $0x8,%ecx
  8042118586:	29 c1                	sub    %eax,%ecx
  8042118588:	41 29 cc             	sub    %ecx,%r12d
  804211858b:	44 88 22             	mov    %r12b,(%rdx)
  804211858e:	e9 3d fe ff ff       	jmp    80421183d0 <LZ4_compress_fast_continue+0xb41>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042118593:	48 89 5d 80          	mov    %rbx,-0x80(%rbp)
  8042118597:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211859b:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  804211859f:	be 02 00 00 00       	mov    $0x2,%esi
  80421185a4:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  80421185ab:	00 00 00 
  80421185ae:	ff d0                	call   *%rax
  80421185b0:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  80421185b4:	49 89 df             	mov    %rbx,%r15
  80421185b7:	e9 39 fc ff ff       	jmp    80421181f5 <LZ4_compress_fast_continue+0x966>
    BYTE* op = (BYTE*) dest;
  80421185bc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80421185c0:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    {   size_t lastRun = (size_t)(iend - anchor);
  80421185c4:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  80421185c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421185cc:	49 29 c4             	sub    %rax,%r12
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  80421185cf:	49 8d 94 24 f0 00 00 	lea    0xf0(%r12),%rdx
  80421185d6:	00 
  80421185d7:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  80421185de:	80 80 80 
  80421185e1:	48 89 d0             	mov    %rdx,%rax
  80421185e4:	48 f7 e1             	mul    %rcx
  80421185e7:	48 c1 ea 07          	shr    $0x7,%rdx
  80421185eb:	49 8d 54 14 01       	lea    0x1(%r12,%rdx,1),%rdx
  80421185f0:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  80421185f4:	48 01 f2             	add    %rsi,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  80421185f7:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  80421185fc:	48 39 55 88          	cmp    %rdx,-0x78(%rbp)
  8042118600:	0f 82 b8 f2 ff ff    	jb     80421178be <LZ4_compress_fast_continue+0x2f>
        if (lastRun >= RUN_MASK) {
  8042118606:	49 83 fc 0e          	cmp    $0xe,%r12
  804211860a:	76 65                	jbe    8042118671 <LZ4_compress_fast_continue+0xde2>
            size_t accumulator = lastRun - RUN_MASK;
  804211860c:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042118611:	48 8d 46 01          	lea    0x1(%rsi),%rax
  8042118615:	c6 06 f0             	movb   $0xf0,(%rsi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042118618:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211861f:	76 18                	jbe    8042118639 <LZ4_compress_fast_continue+0xdaa>
  8042118621:	48 83 c0 01          	add    $0x1,%rax
  8042118625:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042118629:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042118630:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042118637:	77 e8                	ja     8042118621 <LZ4_compress_fast_continue+0xd92>
            *op++ = (BYTE) accumulator;
  8042118639:	48 8d 58 01          	lea    0x1(%rax),%rbx
  804211863d:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  804211863f:	4c 89 e2             	mov    %r12,%rdx
  8042118642:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042118646:	48 89 df             	mov    %rbx,%rdi
  8042118649:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042118650:	00 00 00 
  8042118653:	ff d0                	call   *%rax
        op += lastRun;
  8042118655:	4c 01 e3             	add    %r12,%rbx
    result = (int)(((char*)op) - dest);
  8042118658:	89 d8                	mov    %ebx,%eax
  804211865a:	8b 75 c0             	mov    -0x40(%rbp),%esi
  804211865d:	29 f0                	sub    %esi,%eax
    return result;
  804211865f:	e9 5a f2 ff ff       	jmp    80421178be <LZ4_compress_fast_continue+0x2f>
        anchor = ip;
  8042118664:	48 89 5d 80          	mov    %rbx,-0x80(%rbp)
  8042118668:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211866c:	e9 53 ff ff ff       	jmp    80421185c4 <LZ4_compress_fast_continue+0xd35>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042118671:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  8042118675:	48 8d 5e 01          	lea    0x1(%rsi),%rbx
  8042118679:	44 89 e0             	mov    %r12d,%eax
  804211867c:	c1 e0 04             	shl    $0x4,%eax
  804211867f:	88 06                	mov    %al,(%rsi)
  8042118681:	eb bc                	jmp    804211863f <LZ4_compress_fast_continue+0xdb0>
                memcpy(streamPtr, streamPtr->dictCtx, sizeof(LZ4_stream_t));
  8042118683:	ba 20 40 00 00       	mov    $0x4020,%edx
  8042118688:	48 89 c6             	mov    %rax,%rsi
  804211868b:	4c 89 f7             	mov    %r14,%rdi
  804211868e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042118695:	00 00 00 
  8042118698:	ff d0                	call   *%rax
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  804211869a:	b8 00 00 00 00       	mov    $0x0,%eax
  804211869f:	41 81 ff 00 00 00 7e 	cmp    $0x7e000000,%r15d
  80421186a6:	0f 87 b0 0f 00 00    	ja     804211965c <LZ4_compress_fast_continue+0x1dcd>
    U32 const startIndex = cctx->currentOffset;
  80421186ac:	41 8b be 00 40 00 00 	mov    0x4000(%r14),%edi
    const BYTE* base = (const BYTE*) source - startIndex;
  80421186b3:	89 f9                	mov    %edi,%ecx
  80421186b5:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
  80421186b9:	4c 89 e8             	mov    %r13,%rax
  80421186bc:	48 29 c8             	sub    %rcx,%rax
  80421186bf:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
            dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
  80421186c3:	4d 8b 9e 08 40 00 00 	mov    0x4008(%r14),%r11
  80421186ca:	4c 89 9d 70 ff ff ff 	mov    %r11,-0x90(%rbp)
            dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;
  80421186d1:	41 8b 86 18 40 00 00 	mov    0x4018(%r14),%eax
    const BYTE* const dictEnd = dictionary + dictSize;
  80421186d8:	89 c2                	mov    %eax,%edx
  80421186da:	4d 8d 14 13          	lea    (%r11,%rdx,1),%r10
  80421186de:	4c 89 95 30 ff ff ff 	mov    %r10,-0xd0(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  80421186e5:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
  80421186e9:	4d 8d 4a f5          	lea    -0xb(%r10),%r9
  80421186ed:	4c 89 4d 80          	mov    %r9,-0x80(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  80421186f1:	49 83 ea 05          	sub    $0x5,%r10
  80421186f5:	4c 89 95 38 ff ff ff 	mov    %r10,-0xc8(%rbp)
                           dictionary + dictSize - startIndex;
  80421186fc:	48 29 ca             	sub    %rcx,%rdx
                           dictionary + dictSize - dictCtx->currentOffset :
  80421186ff:	49 8d 0c 13          	lea    (%r11,%rdx,1),%rcx
  8042118703:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  804211870a:	4d 63 e4             	movslq %r12d,%r12
  804211870d:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8042118711:	4a 8d 14 21          	lea    (%rcx,%r12,1),%rdx
  8042118715:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
        cctx->dictSize += (U32)inputSize;
  804211871c:	44 01 f8             	add    %r15d,%eax
  804211871f:	41 89 86 18 40 00 00 	mov    %eax,0x4018(%r14)
    cctx->currentOffset += (U32)inputSize;
  8042118726:	89 7d 88             	mov    %edi,-0x78(%rbp)
  8042118729:	42 8d 04 3f          	lea    (%rdi,%r15,1),%eax
  804211872d:	41 89 86 00 40 00 00 	mov    %eax,0x4000(%r14)
    cctx->tableType = (U16)tableType;
  8042118734:	66 41 c7 86 06 40 00 	movw   $0x2,0x4006(%r14)
  804211873b:	00 02 00 
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211873e:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  8042118742:	be 02 00 00 00       	mov    $0x2,%esi
  8042118747:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  804211874e:	00 00 00 
  8042118751:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042118754:	89 c0                	mov    %eax,%eax
  8042118756:	8b 7d 88             	mov    -0x78(%rbp),%edi
  8042118759:	41 89 3c 86          	mov    %edi,(%r14,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  804211875d:	49 8d 45 01          	lea    0x1(%r13),%rax
  8042118761:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118765:	49 8b 7d 01          	mov    0x1(%r13),%rdi
  8042118769:	be 02 00 00 00       	mov    $0x2,%esi
  804211876e:	41 ff d4             	call   *%r12
  8042118771:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8042118775:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  804211877c:	4c 89 ee             	mov    %r13,%rsi
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  804211877f:	c1 e3 06             	shl    $0x6,%ebx
  8042118782:	89 9d 48 ff ff ff    	mov    %ebx,-0xb8(%rbp)
  8042118788:	4c 89 75 98          	mov    %r14,-0x68(%rbp)
  804211878c:	44 89 bd 40 ff ff ff 	mov    %r15d,-0xc0(%rbp)
  8042118793:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
                U32 const current = (U32)(forwardIp - base);
  8042118797:	45 89 fc             	mov    %r15d,%r12d
  804211879a:	8b 4d b0             	mov    -0x50(%rbp),%ecx
  804211879d:	41 29 cc             	sub    %ecx,%r12d
        return hashTable[h];
  80421187a0:	89 c0                	mov    %eax,%eax
  80421187a2:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  80421187a6:	4c 8d 34 81          	lea    (%rcx,%rax,4),%r14
  80421187aa:	45 8b 2e             	mov    (%r14),%r13d
                forwardIp += step;
  80421187ad:	49 8d 5f 01          	lea    0x1(%r15),%rbx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421187b1:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
  80421187b7:	8d 48 01             	lea    0x1(%rax),%ecx
  80421187ba:	89 4d a0             	mov    %ecx,-0x60(%rbp)
  80421187bd:	c1 f8 06             	sar    $0x6,%eax
  80421187c0:	89 45 a8             	mov    %eax,-0x58(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421187c3:	48 39 5d 80          	cmp    %rbx,-0x80(%rbp)
  80421187c7:	0f 82 78 06 00 00    	jb     8042118e45 <LZ4_compress_fast_continue+0x15b6>
                        lowLimit = (const BYTE*)source;
  80421187cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421187d1:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80421187d8:	48 89 b5 28 ff ff ff 	mov    %rsi,-0xd8(%rbp)
  80421187df:	4c 89 7d 90          	mov    %r15,-0x70(%rbp)
  80421187e3:	e9 83 00 00 00       	jmp    804211886b <LZ4_compress_fast_continue+0xfdc>
                        match = base + matchIndex;
  80421187e8:	45 89 ef             	mov    %r13d,%r15d
  80421187eb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80421187ef:	49 01 c7             	add    %rax,%r15
                        lowLimit = (const BYTE*)source;
  80421187f2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80421187f9:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118800:	48 8b 3b             	mov    (%rbx),%rdi
  8042118803:	be 02 00 00 00       	mov    $0x2,%esi
  8042118808:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211880f:	00 00 00 
  8042118812:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042118814:	45 89 26             	mov    %r12d,(%r14)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  8042118817:	41 8d 95 ff ff 00 00 	lea    0xffff(%r13),%edx
  804211881e:	44 39 e2             	cmp    %r12d,%edx
  8042118821:	72 0b                	jb     804211882e <LZ4_compress_fast_continue+0xf9f>
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042118823:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042118827:	41 8b 37             	mov    (%r15),%esi
  804211882a:	39 31                	cmp    %esi,(%rcx)
  804211882c:	74 69                	je     8042118897 <LZ4_compress_fast_continue+0x1008>
                U32 const current = (U32)(forwardIp - base);
  804211882e:	41 89 dc             	mov    %ebx,%r12d
  8042118831:	8b 4d b0             	mov    -0x50(%rbp),%ecx
  8042118834:	41 29 cc             	sub    %ecx,%r12d
        return hashTable[h];
  8042118837:	89 c0                	mov    %eax,%eax
  8042118839:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  804211883d:	4c 8d 34 81          	lea    (%rcx,%rax,4),%r14
  8042118841:	45 8b 2e             	mov    (%r14),%r13d
                forwardIp += step;
  8042118844:	48 63 45 a8          	movslq -0x58(%rbp),%rax
  8042118848:	48 01 d8             	add    %rbx,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211884b:	8b 4d a0             	mov    -0x60(%rbp),%ecx
  804211884e:	8d 51 01             	lea    0x1(%rcx),%edx
  8042118851:	c1 f9 06             	sar    $0x6,%ecx
  8042118854:	89 4d a8             	mov    %ecx,-0x58(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042118857:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
  804211885b:	48 39 45 80          	cmp    %rax,-0x80(%rbp)
  804211885f:	0f 82 ed 05 00 00    	jb     8042118e52 <LZ4_compress_fast_continue+0x15c3>
  8042118865:	89 55 a0             	mov    %edx,-0x60(%rbp)
  8042118868:	48 89 c3             	mov    %rax,%rbx
                    if (matchIndex < startIndex) {
  804211886b:	8b 45 88             	mov    -0x78(%rbp),%eax
  804211886e:	41 39 c5             	cmp    %eax,%r13d
  8042118871:	0f 83 71 ff ff ff    	jae    80421187e8 <LZ4_compress_fast_continue+0xf59>
                        match = dictBase + matchIndex;
  8042118877:	45 89 ef             	mov    %r13d,%r15d
  804211887a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8042118881:	49 01 c7             	add    %rax,%r15
                        lowLimit = dictionary;
  8042118884:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  804211888b:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8042118892:	e9 69 ff ff ff       	jmp    8042118800 <LZ4_compress_fast_continue+0xf71>
                    if (maybe_extMem) offset = current - matchIndex;
  8042118897:	4c 89 f8             	mov    %r15,%rax
  804211889a:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
  804211889e:	48 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%rsi
  80421188a5:	49 89 cf             	mov    %rcx,%r15
  80421188a8:	45 29 ec             	sub    %r13d,%r12d
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  80421188ab:	48 39 ce             	cmp    %rcx,%rsi
  80421188ae:	73 1b                	jae    80421188cb <LZ4_compress_fast_continue+0x103c>
  80421188b0:	48 39 85 78 ff ff ff 	cmp    %rax,-0x88(%rbp)
  80421188b7:	73 12                	jae    80421188cb <LZ4_compress_fast_continue+0x103c>
  80421188b9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80421188bd:	0f b6 40 ff          	movzbl -0x1(%rax),%eax
  80421188c1:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  80421188c5:	0f 84 8e 00 00 00    	je     8042118959 <LZ4_compress_fast_continue+0x10ca>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  80421188cb:	4c 89 f8             	mov    %r15,%rax
  80421188ce:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  80421188d1:	48 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%rbx
  80421188d8:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  80421188dc:	89 c1                	mov    %eax,%ecx
  80421188de:	89 c2                	mov    %eax,%edx
  80421188e0:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  80421188e6:	49 0f af d0          	imul   %r8,%rdx
  80421188ea:	48 c1 ea 27          	shr    $0x27,%rdx
  80421188ee:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  80421188f3:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  80421188f6:	48 39 95 60 ff ff ff 	cmp    %rdx,-0xa0(%rbp)
  80421188fd:	0f 82 bd 1f 00 00    	jb     804211a8c0 <LZ4_compress_fast_continue+0x3031>
            if (litLength >= RUN_MASK) {
  8042118903:	83 f8 0e             	cmp    $0xe,%eax
  8042118906:	77 79                	ja     8042118981 <LZ4_compress_fast_continue+0x10f2>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042118908:	c1 e0 04             	shl    $0x4,%eax
  804211890b:	48 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%rbx
  8042118912:	88 03                	mov    %al,(%rbx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042118914:	4c 8d 34 0f          	lea    (%rdi,%rcx,1),%r14
  8042118918:	4c 89 f2             	mov    %r14,%rdx
  804211891b:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042118922:	00 00 00 
  8042118925:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118927:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211892b:	48 83 e8 0c          	sub    $0xc,%rax
  804211892f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
  8042118933:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042118937:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  804211893e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042118942:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
  8042118946:	4c 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%r14
  804211894d:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  8042118954:	e9 58 03 00 00       	jmp    8042118cb1 <LZ4_compress_fast_continue+0x1422>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042118959:	49 83 ef 01          	sub    $0x1,%r15
  804211895d:	48 83 6d a8 01       	subq   $0x1,-0x58(%rbp)
  8042118962:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042118966:	4c 39 fe             	cmp    %r15,%rsi
  8042118969:	0f 83 5c ff ff ff    	jae    80421188cb <LZ4_compress_fast_continue+0x103c>
  804211896f:	48 39 85 78 ff ff ff 	cmp    %rax,-0x88(%rbp)
  8042118976:	0f 82 3d ff ff ff    	jb     80421188b9 <LZ4_compress_fast_continue+0x102a>
  804211897c:	e9 4a ff ff ff       	jmp    80421188cb <LZ4_compress_fast_continue+0x103c>
                int len = (int)(litLength - RUN_MASK);
  8042118981:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  8042118984:	c6 03 f0             	movb   $0xf0,(%rbx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  8042118987:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211898c:	7e 14                	jle    80421189a2 <LZ4_compress_fast_continue+0x1113>
  804211898e:	48 83 c7 01          	add    $0x1,%rdi
  8042118992:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  8042118996:	2d ff 00 00 00       	sub    $0xff,%eax
  804211899b:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421189a0:	7f ec                	jg     804211898e <LZ4_compress_fast_continue+0x10ff>
                *op++ = (BYTE)len;
  80421189a2:	88 07                	mov    %al,(%rdi)
  80421189a4:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  80421189a8:	e9 67 ff ff ff       	jmp    8042118914 <LZ4_compress_fast_continue+0x1085>
                const BYTE* limit = ip + (dictEnd-match);
  80421189ad:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  80421189b4:	48 29 c2             	sub    %rax,%rdx
  80421189b7:	4c 01 fa             	add    %r15,%rdx
                if (limit > matchlimit) limit = matchlimit;
  80421189ba:	48 8b 9d 38 ff ff ff 	mov    -0xc8(%rbp),%rbx
  80421189c1:	48 39 d3             	cmp    %rdx,%rbx
  80421189c4:	48 0f 46 d3          	cmovbe %rbx,%rdx
  80421189c8:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  80421189cc:	4d 8d 6f 04          	lea    0x4(%r15),%r13
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421189d0:	48 83 ea 07          	sub    $0x7,%rdx
  80421189d4:	49 39 d5             	cmp    %rdx,%r13
  80421189d7:	0f 83 f0 00 00 00    	jae    8042118acd <LZ4_compress_fast_continue+0x123e>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421189dd:	48 8b 48 04          	mov    0x4(%rax),%rcx
  80421189e1:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  80421189e5:	48 39 cf             	cmp    %rcx,%rdi
  80421189e8:	0f 85 b6 00 00 00    	jne    8042118aa4 <LZ4_compress_fast_continue+0x1215>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  80421189ee:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  80421189f2:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421189f6:	48 39 d3             	cmp    %rdx,%rbx
  80421189f9:	0f 83 d5 00 00 00    	jae    8042118ad4 <LZ4_compress_fast_continue+0x1245>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421189ff:	48 8b 08             	mov    (%rax),%rcx
  8042118a02:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042118a05:	48 39 cf             	cmp    %rcx,%rdi
  8042118a08:	0f 84 ac 00 00 00    	je     8042118aba <LZ4_compress_fast_continue+0x122b>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042118a0e:	48 31 cf             	xor    %rcx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042118a11:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042118a18:	00 00 00 
  8042118a1b:	ff d0                	call   *%rax
  8042118a1d:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  8042118a20:	44 29 eb             	sub    %r13d,%ebx
                ip += (size_t)matchCode + MINMATCH;
  8042118a23:	89 d8                	mov    %ebx,%eax
  8042118a25:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                if (ip==limit) {
  8042118a2a:	4c 39 7d 90          	cmp    %r15,-0x70(%rbp)
  8042118a2e:	0f 85 ad 01 00 00    	jne    8042118be1 <LZ4_compress_fast_continue+0x1352>
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118a34:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042118a38:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  8042118a3c:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  8042118a40:	48 39 d7             	cmp    %rdx,%rdi
  8042118a43:	0f 83 12 01 00 00    	jae    8042118b5b <LZ4_compress_fast_continue+0x12cc>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042118a49:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042118a4d:	48 8b 0e             	mov    (%rsi),%rcx
  8042118a50:	48 8b 07             	mov    (%rdi),%rax
        if (!diff) {
  8042118a53:	48 39 c8             	cmp    %rcx,%rax
  8042118a56:	0f 85 d2 00 00 00    	jne    8042118b2e <LZ4_compress_fast_continue+0x129f>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042118a5c:	4c 8d 6f 08          	lea    0x8(%rdi),%r13
  8042118a60:	48 8d 46 08          	lea    0x8(%rsi),%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118a64:	49 39 d5             	cmp    %rdx,%r13
  8042118a67:	0f 83 f6 00 00 00    	jae    8042118b63 <LZ4_compress_fast_continue+0x12d4>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042118a6d:	48 8b 08             	mov    (%rax),%rcx
  8042118a70:	49 8b 7d 00          	mov    0x0(%r13),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042118a74:	48 39 cf             	cmp    %rcx,%rdi
  8042118a77:	0f 84 cb 00 00 00    	je     8042118b48 <LZ4_compress_fast_continue+0x12b9>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042118a7d:	48 31 cf             	xor    %rcx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042118a80:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042118a87:	00 00 00 
  8042118a8a:	ff d0                	call   *%rax
  8042118a8c:	46 8d 2c 28          	lea    (%rax,%r13,1),%r13d
        return (unsigned)(pIn - pStart);
  8042118a90:	8b 45 90             	mov    -0x70(%rbp),%eax
  8042118a93:	41 29 c5             	sub    %eax,%r13d
                    matchCode += more;
  8042118a96:	44 01 eb             	add    %r13d,%ebx
                    ip += more;
  8042118a99:	45 89 ed             	mov    %r13d,%r13d
  8042118a9c:	4d 01 ef             	add    %r13,%r15
  8042118a9f:	e9 3d 01 00 00       	jmp    8042118be1 <LZ4_compress_fast_continue+0x1352>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042118aa4:	48 31 cf             	xor    %rcx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042118aa7:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042118aae:	00 00 00 
  8042118ab1:	ff d0                	call   *%rax
  8042118ab3:	89 c3                	mov    %eax,%ebx
  8042118ab5:	e9 69 ff ff ff       	jmp    8042118a23 <LZ4_compress_fast_continue+0x1194>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042118aba:	48 83 c3 08          	add    $0x8,%rbx
  8042118abe:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118ac2:	48 39 d3             	cmp    %rdx,%rbx
  8042118ac5:	0f 82 34 ff ff ff    	jb     80421189ff <LZ4_compress_fast_continue+0x1170>
  8042118acb:	eb 07                	jmp    8042118ad4 <LZ4_compress_fast_continue+0x1245>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  8042118acd:	48 83 c0 04          	add    $0x4,%rax
  8042118ad1:	4c 89 eb             	mov    %r13,%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042118ad4:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  8042118ad8:	48 8d 56 fd          	lea    -0x3(%rsi),%rdx
  8042118adc:	48 39 d3             	cmp    %rdx,%rbx
  8042118adf:	73 06                	jae    8042118ae7 <LZ4_compress_fast_continue+0x1258>
  8042118ae1:	8b 38                	mov    (%rax),%edi
  8042118ae3:	39 3b                	cmp    %edi,(%rbx)
  8042118ae5:	74 2d                	je     8042118b14 <LZ4_compress_fast_continue+0x1285>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042118ae7:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042118aeb:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
  8042118aef:	48 39 d3             	cmp    %rdx,%rbx
  8042118af2:	73 08                	jae    8042118afc <LZ4_compress_fast_continue+0x126d>
  8042118af4:	0f b7 30             	movzwl (%rax),%esi
  8042118af7:	66 39 33             	cmp    %si,(%rbx)
  8042118afa:	74 22                	je     8042118b1e <LZ4_compress_fast_continue+0x128f>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042118afc:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  8042118b00:	48 39 fb             	cmp    %rdi,%rbx
  8042118b03:	73 07                	jae    8042118b0c <LZ4_compress_fast_continue+0x127d>
  8042118b05:	0f b6 0b             	movzbl (%rbx),%ecx
  8042118b08:	38 08                	cmp    %cl,(%rax)
  8042118b0a:	74 1c                	je     8042118b28 <LZ4_compress_fast_continue+0x1299>
    return (unsigned)(pIn - pStart);
  8042118b0c:	44 29 eb             	sub    %r13d,%ebx
  8042118b0f:	e9 0f ff ff ff       	jmp    8042118a23 <LZ4_compress_fast_continue+0x1194>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042118b14:	48 83 c3 04          	add    $0x4,%rbx
  8042118b18:	48 83 c0 04          	add    $0x4,%rax
  8042118b1c:	eb c9                	jmp    8042118ae7 <LZ4_compress_fast_continue+0x1258>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042118b1e:	48 83 c3 02          	add    $0x2,%rbx
  8042118b22:	48 83 c0 02          	add    $0x2,%rax
  8042118b26:	eb d4                	jmp    8042118afc <LZ4_compress_fast_continue+0x126d>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042118b28:	48 83 c3 01          	add    $0x1,%rbx
  8042118b2c:	eb de                	jmp    8042118b0c <LZ4_compress_fast_continue+0x127d>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042118b2e:	48 31 c8             	xor    %rcx,%rax
  8042118b31:	48 89 c7             	mov    %rax,%rdi
            return LZ4_NbCommonBytes(diff);
  8042118b34:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042118b3b:	00 00 00 
  8042118b3e:	ff d0                	call   *%rax
  8042118b40:	41 89 c5             	mov    %eax,%r13d
  8042118b43:	e9 4e ff ff ff       	jmp    8042118a96 <LZ4_compress_fast_continue+0x1207>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042118b48:	49 83 c5 08          	add    $0x8,%r13
  8042118b4c:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118b50:	49 39 d5             	cmp    %rdx,%r13
  8042118b53:	0f 82 14 ff ff ff    	jb     8042118a6d <LZ4_compress_fast_continue+0x11de>
  8042118b59:	eb 08                	jmp    8042118b63 <LZ4_compress_fast_continue+0x12d4>
  8042118b5b:	4c 8b 6d 90          	mov    -0x70(%rbp),%r13
  8042118b5f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042118b63:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042118b67:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  8042118b6b:	49 39 d5             	cmp    %rdx,%r13
  8042118b6e:	73 08                	jae    8042118b78 <LZ4_compress_fast_continue+0x12e9>
  8042118b70:	8b 38                	mov    (%rax),%edi
  8042118b72:	41 39 7d 00          	cmp    %edi,0x0(%r13)
  8042118b76:	74 37                	je     8042118baf <LZ4_compress_fast_continue+0x1320>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042118b78:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042118b7c:	48 8d 51 fa          	lea    -0x6(%rcx),%rdx
  8042118b80:	49 39 d5             	cmp    %rdx,%r13
  8042118b83:	73 0a                	jae    8042118b8f <LZ4_compress_fast_continue+0x1300>
  8042118b85:	0f b7 30             	movzwl (%rax),%esi
  8042118b88:	66 41 39 75 00       	cmp    %si,0x0(%r13)
  8042118b8d:	74 2a                	je     8042118bb9 <LZ4_compress_fast_continue+0x132a>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042118b8f:	48 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%rdi
  8042118b96:	49 39 fd             	cmp    %rdi,%r13
  8042118b99:	73 09                	jae    8042118ba4 <LZ4_compress_fast_continue+0x1315>
  8042118b9b:	41 0f b6 4d 00       	movzbl 0x0(%r13),%ecx
  8042118ba0:	38 08                	cmp    %cl,(%rax)
  8042118ba2:	74 1f                	je     8042118bc3 <LZ4_compress_fast_continue+0x1334>
    return (unsigned)(pIn - pStart);
  8042118ba4:	8b 45 90             	mov    -0x70(%rbp),%eax
  8042118ba7:	41 29 c5             	sub    %eax,%r13d
  8042118baa:	e9 e7 fe ff ff       	jmp    8042118a96 <LZ4_compress_fast_continue+0x1207>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042118baf:	49 83 c5 04          	add    $0x4,%r13
  8042118bb3:	48 83 c0 04          	add    $0x4,%rax
  8042118bb7:	eb bf                	jmp    8042118b78 <LZ4_compress_fast_continue+0x12e9>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042118bb9:	49 83 c5 02          	add    $0x2,%r13
  8042118bbd:	48 83 c0 02          	add    $0x2,%rax
  8042118bc1:	eb cc                	jmp    8042118b8f <LZ4_compress_fast_continue+0x1300>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042118bc3:	49 83 c5 01          	add    $0x1,%r13
  8042118bc7:	eb db                	jmp    8042118ba4 <LZ4_compress_fast_continue+0x1315>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042118bc9:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042118bcc:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042118bd3:	00 00 00 
  8042118bd6:	ff d0                	call   *%rax
  8042118bd8:	89 c3                	mov    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  8042118bda:	89 d8                	mov    %ebx,%eax
  8042118bdc:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042118be1:	8d 83 f0 00 00 00    	lea    0xf0(%rbx),%eax
  8042118be7:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042118bec:	48 0f af c6          	imul   %rsi,%rax
  8042118bf0:	48 c1 e8 27          	shr    $0x27,%rax
  8042118bf4:	49 8d 44 04 06       	lea    0x6(%r12,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042118bf9:	48 39 85 60 ff ff ff 	cmp    %rax,-0xa0(%rbp)
  8042118c00:	0f 82 cf 1c 00 00    	jb     804211a8d5 <LZ4_compress_fast_continue+0x3046>
            if (matchCode >= ML_MASK) {
  8042118c06:	83 fb 0e             	cmp    $0xe,%ebx
  8042118c09:	0f 87 83 01 00 00    	ja     8042118d92 <LZ4_compress_fast_continue+0x1503>
                *token += (BYTE)(matchCode);
  8042118c0f:	41 00 1e             	add    %bl,(%r14)
  8042118c12:	4d 89 e6             	mov    %r12,%r14
        if (ip >= mflimitPlusOne) break;
  8042118c15:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8042118c19:	49 39 c7             	cmp    %rax,%r15
  8042118c1c:	0f 83 0c 02 00 00    	jae    8042118e2e <LZ4_compress_fast_continue+0x159f>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118c22:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  8042118c26:	be 02 00 00 00       	mov    $0x2,%esi
  8042118c2b:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  8042118c32:	00 00 00 
  8042118c35:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042118c37:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042118c39:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042118c3d:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
  8042118c41:	4c 29 ea             	sub    %r13,%rdx
  8042118c44:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8042118c48:	89 14 87             	mov    %edx,(%rdi,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118c4b:	49 8b 3f             	mov    (%r15),%rdi
  8042118c4e:	be 02 00 00 00       	mov    $0x2,%esi
  8042118c53:	ff d3                	call   *%rbx
            U32 const current = (U32)(ip-base);
  8042118c55:	4d 89 fc             	mov    %r15,%r12
  8042118c58:	4d 29 ec             	sub    %r13,%r12
        return hashTable[h];
  8042118c5b:	89 c0                	mov    %eax,%eax
  8042118c5d:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8042118c61:	48 8d 0c 87          	lea    (%rdi,%rax,4),%rcx
  8042118c65:	8b 11                	mov    (%rcx),%edx
                if (matchIndex < startIndex) {
  8042118c67:	8b 45 88             	mov    -0x78(%rbp),%eax
  8042118c6a:	39 c2                	cmp    %eax,%edx
  8042118c6c:	0f 83 7c 01 00 00    	jae    8042118dee <LZ4_compress_fast_continue+0x155f>
                    match = dictBase + matchIndex;
  8042118c72:	89 d0                	mov    %edx,%eax
  8042118c74:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  8042118c7b:	48 01 f0             	add    %rsi,%rax
                    lowLimit = dictionary;   /* required for match length counter */
  8042118c7e:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042118c85:	44 89 21             	mov    %r12d,(%rcx)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  8042118c88:	8d 8a ff ff 00 00    	lea    0xffff(%rdx),%ecx
  8042118c8e:	44 39 e1             	cmp    %r12d,%ecx
  8042118c91:	0f 82 6c 01 00 00    	jb     8042118e03 <LZ4_compress_fast_continue+0x1574>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042118c97:	8b 18                	mov    (%rax),%ebx
  8042118c99:	41 39 1f             	cmp    %ebx,(%r15)
  8042118c9c:	0f 85 61 01 00 00    	jne    8042118e03 <LZ4_compress_fast_continue+0x1574>
                token=op++;
  8042118ca2:	49 8d 5e 01          	lea    0x1(%r14),%rbx
  8042118ca6:	48 89 5d a8          	mov    %rbx,-0x58(%rbp)
                *token=0;
  8042118caa:	41 c6 06 00          	movb   $0x0,(%r14)
                if (maybe_extMem) offset = current - matchIndex;
  8042118cae:	41 29 d4             	sub    %edx,%r12d
static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
  8042118cb1:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  8042118cb5:	66 44 89 23          	mov    %r12w,(%rbx)
            LZ4_writeLE16(op, (U16)offset); op+=2;
  8042118cb9:	4c 8d 63 02          	lea    0x2(%rbx),%r12
                 && (lowLimit==dictionary) /* match within extDict */ ) {
  8042118cbd:	48 39 b5 70 ff ff ff 	cmp    %rsi,-0x90(%rbp)
  8042118cc4:	0f 84 e3 fc ff ff    	je     80421189ad <LZ4_compress_fast_continue+0x111e>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042118cca:	4d 8d 6f 04          	lea    0x4(%r15),%r13
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118cce:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8042118cd2:	49 39 cd             	cmp    %rcx,%r13
  8042118cd5:	73 56                	jae    8042118d2d <LZ4_compress_fast_continue+0x149e>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042118cd7:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042118cdb:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  8042118cdf:	48 39 d7             	cmp    %rdx,%rdi
  8042118ce2:	0f 85 e1 fe ff ff    	jne    8042118bc9 <LZ4_compress_fast_continue+0x133a>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042118ce8:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  8042118cec:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118cf0:	48 39 cb             	cmp    %rcx,%rbx
  8042118cf3:	73 3f                	jae    8042118d34 <LZ4_compress_fast_continue+0x14a5>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042118cf5:	48 8b 10             	mov    (%rax),%rdx
  8042118cf8:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042118cfb:	48 39 d7             	cmp    %rdx,%rdi
  8042118cfe:	74 1a                	je     8042118d1a <LZ4_compress_fast_continue+0x148b>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042118d00:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042118d03:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042118d0a:	00 00 00 
  8042118d0d:	ff d0                	call   *%rax
  8042118d0f:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  8042118d12:	44 29 eb             	sub    %r13d,%ebx
  8042118d15:	e9 c0 fe ff ff       	jmp    8042118bda <LZ4_compress_fast_continue+0x134b>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042118d1a:	48 83 c3 08          	add    $0x8,%rbx
  8042118d1e:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042118d22:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8042118d26:	48 39 fb             	cmp    %rdi,%rbx
  8042118d29:	72 ca                	jb     8042118cf5 <LZ4_compress_fast_continue+0x1466>
  8042118d2b:	eb 07                	jmp    8042118d34 <LZ4_compress_fast_continue+0x14a5>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042118d2d:	48 83 c0 04          	add    $0x4,%rax
  8042118d31:	4c 89 eb             	mov    %r13,%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042118d34:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042118d38:	48 8d 51 f8          	lea    -0x8(%rcx),%rdx
  8042118d3c:	48 39 d3             	cmp    %rdx,%rbx
  8042118d3f:	73 06                	jae    8042118d47 <LZ4_compress_fast_continue+0x14b8>
  8042118d41:	8b 30                	mov    (%rax),%esi
  8042118d43:	39 33                	cmp    %esi,(%rbx)
  8042118d45:	74 37                	je     8042118d7e <LZ4_compress_fast_continue+0x14ef>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042118d47:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042118d4b:	48 8d 57 fa          	lea    -0x6(%rdi),%rdx
  8042118d4f:	48 39 d3             	cmp    %rdx,%rbx
  8042118d52:	73 08                	jae    8042118d5c <LZ4_compress_fast_continue+0x14cd>
  8042118d54:	0f b7 38             	movzwl (%rax),%edi
  8042118d57:	66 39 3b             	cmp    %di,(%rbx)
  8042118d5a:	74 2c                	je     8042118d88 <LZ4_compress_fast_continue+0x14f9>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042118d5c:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
  8042118d63:	48 39 f3             	cmp    %rsi,%rbx
  8042118d66:	73 0e                	jae    8042118d76 <LZ4_compress_fast_continue+0x14e7>
  8042118d68:	0f b6 0b             	movzbl (%rbx),%ecx
  8042118d6b:	38 08                	cmp    %cl,(%rax)
  8042118d6d:	0f 94 c0             	sete   %al
  8042118d70:	0f b6 c0             	movzbl %al,%eax
  8042118d73:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  8042118d76:	44 29 eb             	sub    %r13d,%ebx
  8042118d79:	e9 5c fe ff ff       	jmp    8042118bda <LZ4_compress_fast_continue+0x134b>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042118d7e:	48 83 c3 04          	add    $0x4,%rbx
  8042118d82:	48 83 c0 04          	add    $0x4,%rax
  8042118d86:	eb bf                	jmp    8042118d47 <LZ4_compress_fast_continue+0x14b8>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042118d88:	48 83 c3 02          	add    $0x2,%rbx
  8042118d8c:	48 83 c0 02          	add    $0x2,%rax
  8042118d90:	eb ca                	jmp    8042118d5c <LZ4_compress_fast_continue+0x14cd>
                *token += ML_MASK;
  8042118d92:	41 80 06 0f          	addb   $0xf,(%r14)
                matchCode -= ML_MASK;
  8042118d96:	83 eb 0f             	sub    $0xf,%ebx
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042118d99:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042118d9d:	c7 40 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rax)
                while (matchCode >= 4*255) {
  8042118da4:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  8042118daa:	76 1a                	jbe    8042118dc6 <LZ4_compress_fast_continue+0x1537>
                    op+=4;
  8042118dac:	49 83 c4 04          	add    $0x4,%r12
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042118db0:	41 c7 04 24 ff ff ff 	movl   $0xffffffff,(%r12)
  8042118db7:	ff 
                    matchCode -= 4*255;
  8042118db8:	81 eb fc 03 00 00    	sub    $0x3fc,%ebx
                while (matchCode >= 4*255) {
  8042118dbe:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  8042118dc4:	77 e6                	ja     8042118dac <LZ4_compress_fast_continue+0x151d>
                op += matchCode / 255;
  8042118dc6:	89 d8                	mov    %ebx,%eax
  8042118dc8:	ba 81 80 80 80       	mov    $0x80808081,%edx
  8042118dcd:	48 0f af c2          	imul   %rdx,%rax
  8042118dd1:	48 c1 e8 27          	shr    $0x27,%rax
  8042118dd5:	89 c2                	mov    %eax,%edx
  8042118dd7:	4c 01 e2             	add    %r12,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042118dda:	4c 8d 72 01          	lea    0x1(%rdx),%r14
  8042118dde:	89 c1                	mov    %eax,%ecx
  8042118de0:	c1 e1 08             	shl    $0x8,%ecx
  8042118de3:	29 c1                	sub    %eax,%ecx
  8042118de5:	29 cb                	sub    %ecx,%ebx
  8042118de7:	88 1a                	mov    %bl,(%rdx)
  8042118de9:	e9 27 fe ff ff       	jmp    8042118c15 <LZ4_compress_fast_continue+0x1386>
                    match = base + matchIndex;
  8042118dee:	89 d0                	mov    %edx,%eax
  8042118df0:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042118df4:	48 01 f0             	add    %rsi,%rax
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
  8042118df7:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
  8042118dfe:	e9 82 fe ff ff       	jmp    8042118c85 <LZ4_compress_fast_continue+0x13f6>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042118e03:	4c 89 b5 50 ff ff ff 	mov    %r14,-0xb0(%rbp)
  8042118e0a:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118e0e:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  8042118e12:	be 02 00 00 00       	mov    $0x2,%esi
  8042118e17:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042118e1e:	00 00 00 
  8042118e21:	ff d0                	call   *%rax
  8042118e23:	4c 89 fe             	mov    %r15,%rsi
  8042118e26:	49 89 df             	mov    %rbx,%r15
  8042118e29:	e9 69 f9 ff ff       	jmp    8042118797 <LZ4_compress_fast_continue+0xf08>
        anchor = ip;
  8042118e2e:	4c 89 b5 50 ff ff ff 	mov    %r14,-0xb0(%rbp)
  8042118e35:	4c 89 fe             	mov    %r15,%rsi
  8042118e38:	4c 8b 75 98          	mov    -0x68(%rbp),%r14
  8042118e3c:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
  8042118e43:	eb 1f                	jmp    8042118e64 <LZ4_compress_fast_continue+0x15d5>
  8042118e45:	4c 8b 75 98          	mov    -0x68(%rbp),%r14
  8042118e49:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
  8042118e50:	eb 12                	jmp    8042118e64 <LZ4_compress_fast_continue+0x15d5>
  8042118e52:	48 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%rsi
  8042118e59:	4c 8b 75 98          	mov    -0x68(%rbp),%r14
  8042118e5d:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
    {   size_t lastRun = (size_t)(iend - anchor);
  8042118e64:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  8042118e68:	49 29 f4             	sub    %rsi,%r12
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  8042118e6b:	49 8d 94 24 f0 00 00 	lea    0xf0(%r12),%rdx
  8042118e72:	00 
  8042118e73:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  8042118e7a:	80 80 80 
  8042118e7d:	48 89 d0             	mov    %rdx,%rax
  8042118e80:	48 f7 e1             	mul    %rcx
  8042118e83:	48 c1 ea 07          	shr    $0x7,%rdx
  8042118e87:	49 8d 54 14 01       	lea    0x1(%r12,%rdx,1),%rdx
  8042118e8c:	48 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%rbx
  8042118e93:	48 01 da             	add    %rbx,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042118e96:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  8042118e9b:	48 39 95 60 ff ff ff 	cmp    %rdx,-0xa0(%rbp)
  8042118ea2:	0f 82 b4 07 00 00    	jb     804211965c <LZ4_compress_fast_continue+0x1dcd>
        if (lastRun >= RUN_MASK) {
  8042118ea8:	49 83 fc 0e          	cmp    $0xe,%r12
  8042118eac:	76 54                	jbe    8042118f02 <LZ4_compress_fast_continue+0x1673>
            size_t accumulator = lastRun - RUN_MASK;
  8042118eae:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042118eb3:	48 8d 43 01          	lea    0x1(%rbx),%rax
  8042118eb7:	c6 03 f0             	movb   $0xf0,(%rbx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042118eba:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042118ec1:	76 18                	jbe    8042118edb <LZ4_compress_fast_continue+0x164c>
  8042118ec3:	48 83 c0 01          	add    $0x1,%rax
  8042118ec7:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042118ecb:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042118ed2:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042118ed9:	77 e8                	ja     8042118ec3 <LZ4_compress_fast_continue+0x1634>
            *op++ = (BYTE) accumulator;
  8042118edb:	48 8d 58 01          	lea    0x1(%rax),%rbx
  8042118edf:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042118ee1:	4c 89 e2             	mov    %r12,%rdx
  8042118ee4:	48 89 df             	mov    %rbx,%rdi
  8042118ee7:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042118eee:	00 00 00 
  8042118ef1:	ff d0                	call   *%rax
        op += lastRun;
  8042118ef3:	4c 01 e3             	add    %r12,%rbx
    result = (int)(((char*)op) - dest);
  8042118ef6:	89 d8                	mov    %ebx,%eax
  8042118ef8:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  8042118efb:	29 d8                	sub    %ebx,%eax
    return result;
  8042118efd:	e9 5a 07 00 00       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042118f02:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8042118f09:	48 8d 5f 01          	lea    0x1(%rdi),%rbx
  8042118f0d:	44 89 e0             	mov    %r12d,%eax
  8042118f10:	c1 e0 04             	shl    $0x4,%eax
  8042118f13:	88 07                	mov    %al,(%rdi)
  8042118f15:	eb ca                	jmp    8042118ee1 <LZ4_compress_fast_continue+0x1652>
                        match = base + matchIndex;
  8042118f17:	41 89 df             	mov    %ebx,%r15d
  8042118f1a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8042118f1e:	49 01 c7             	add    %rax,%r15
                        lowLimit = (const BYTE*)source;
  8042118f21:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8042118f28:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042118f2f:	49 8b 3c 24          	mov    (%r12),%rdi
  8042118f33:	be 02 00 00 00       	mov    $0x2,%esi
  8042118f38:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042118f3f:	00 00 00 
  8042118f42:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042118f44:	45 89 2e             	mov    %r13d,(%r14)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  8042118f47:	8d 93 ff ff 00 00    	lea    0xffff(%rbx),%edx
  8042118f4d:	44 39 ea             	cmp    %r13d,%edx
  8042118f50:	72 0b                	jb     8042118f5d <LZ4_compress_fast_continue+0x16ce>
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  8042118f52:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  8042118f56:	41 8b 0f             	mov    (%r15),%ecx
  8042118f59:	39 0f                	cmp    %ecx,(%rdi)
  8042118f5b:	74 7e                	je     8042118fdb <LZ4_compress_fast_continue+0x174c>
                U32 const current = (U32)(forwardIp - base);
  8042118f5d:	45 89 e5             	mov    %r12d,%r13d
  8042118f60:	8b 4d a8             	mov    -0x58(%rbp),%ecx
  8042118f63:	41 29 cd             	sub    %ecx,%r13d
        return hashTable[h];
  8042118f66:	89 c0                	mov    %eax,%eax
  8042118f68:	48 c1 e0 02          	shl    $0x2,%rax
  8042118f6c:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042118f70:	4c 8d 34 01          	lea    (%rcx,%rax,1),%r14
  8042118f74:	41 8b 1e             	mov    (%r14),%ebx
                forwardIp += step;
  8042118f77:	48 63 55 b0          	movslq -0x50(%rbp),%rdx
  8042118f7b:	4c 01 e2             	add    %r12,%rdx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042118f7e:	8b 75 a0             	mov    -0x60(%rbp),%esi
  8042118f81:	8d 4e 01             	lea    0x1(%rsi),%ecx
  8042118f84:	c1 fe 06             	sar    $0x6,%esi
  8042118f87:	89 75 b0             	mov    %esi,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042118f8a:	4c 89 65 98          	mov    %r12,-0x68(%rbp)
  8042118f8e:	48 39 55 80          	cmp    %rdx,-0x80(%rbp)
  8042118f92:	0f 82 1d 06 00 00    	jb     80421195b5 <LZ4_compress_fast_continue+0x1d26>
  8042118f98:	89 4d a0             	mov    %ecx,-0x60(%rbp)
  8042118f9b:	49 89 d4             	mov    %rdx,%r12
                    if (matchIndex < startIndex) {
  8042118f9e:	8b 8d 78 ff ff ff    	mov    -0x88(%rbp),%ecx
  8042118fa4:	39 cb                	cmp    %ecx,%ebx
  8042118fa6:	0f 83 6b ff ff ff    	jae    8042118f17 <LZ4_compress_fast_continue+0x1688>
        return hashTable[h];
  8042118fac:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  8042118fb0:	8b 1c 07             	mov    (%rdi,%rax,1),%ebx
                        match = dictBase + matchIndex;
  8042118fb3:	41 89 df             	mov    %ebx,%r15d
  8042118fb6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8042118fbd:	49 01 c7             	add    %rax,%r15
                        matchIndex += dictDelta;   /* make dictCtx index comparable with current context */
  8042118fc0:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  8042118fc6:	01 c3                	add    %eax,%ebx
                        lowLimit = dictionary;
  8042118fc8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8042118fcf:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8042118fd6:	e9 54 ff ff ff       	jmp    8042118f2f <LZ4_compress_fast_continue+0x16a0>
                    if (maybe_extMem) offset = current - matchIndex;
  8042118fdb:	4c 89 f8             	mov    %r15,%rax
  8042118fde:	4d 89 fc             	mov    %r15,%r12
  8042118fe1:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  8042118fe8:	49 89 ff             	mov    %rdi,%r15
  8042118feb:	41 29 dd             	sub    %ebx,%r13d
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042118fee:	48 39 fe             	cmp    %rdi,%rsi
  8042118ff1:	73 19                	jae    804211900c <LZ4_compress_fast_continue+0x177d>
  8042118ff3:	48 39 85 70 ff ff ff 	cmp    %rax,-0x90(%rbp)
  8042118ffa:	73 10                	jae    804211900c <LZ4_compress_fast_continue+0x177d>
  8042118ffc:	41 0f b6 44 24 ff    	movzbl -0x1(%r12),%eax
  8042119002:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  8042119006:	0f 84 8d 00 00 00    	je     8042119099 <LZ4_compress_fast_continue+0x180a>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  804211900c:	4c 89 f8             	mov    %r15,%rax
  804211900f:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  8042119012:	48 8b 9d 40 ff ff ff 	mov    -0xc0(%rbp),%rbx
  8042119019:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  804211901d:	89 c1                	mov    %eax,%ecx
  804211901f:	89 c2                	mov    %eax,%edx
  8042119021:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  8042119027:	49 0f af d0          	imul   %r8,%rdx
  804211902b:	48 c1 ea 27          	shr    $0x27,%rdx
  804211902f:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  8042119034:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  8042119037:	48 39 95 50 ff ff ff 	cmp    %rdx,-0xb0(%rbp)
  804211903e:	0f 82 a6 18 00 00    	jb     804211a8ea <LZ4_compress_fast_continue+0x305b>
            if (litLength >= RUN_MASK) {
  8042119044:	83 f8 0e             	cmp    $0xe,%eax
  8042119047:	77 79                	ja     80421190c2 <LZ4_compress_fast_continue+0x1833>
            else *token = (BYTE)(litLength<<ML_BITS);
  8042119049:	c1 e0 04             	shl    $0x4,%eax
  804211904c:	48 8b 9d 40 ff ff ff 	mov    -0xc0(%rbp),%rbx
  8042119053:	88 03                	mov    %al,(%rbx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042119055:	4c 8d 34 0f          	lea    (%rdi,%rcx,1),%r14
  8042119059:	4c 89 f2             	mov    %r14,%rdx
  804211905c:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042119063:	00 00 00 
  8042119066:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119068:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211906c:	48 83 e8 0c          	sub    $0xc,%rax
  8042119070:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                    lowLimit = (const BYTE*)source;  /* required for match length counter */
  8042119074:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8042119078:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  804211907f:	4c 89 e0             	mov    %r12,%rax
  8042119082:	4c 89 75 b0          	mov    %r14,-0x50(%rbp)
  8042119086:	4c 8b b5 40 ff ff ff 	mov    -0xc0(%rbp),%r14
  804211908d:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
  8042119094:	e9 69 03 00 00       	jmp    8042119402 <LZ4_compress_fast_continue+0x1b73>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042119099:	49 83 ef 01          	sub    $0x1,%r15
  804211909d:	4c 89 e0             	mov    %r12,%rax
  80421190a0:	48 83 e8 01          	sub    $0x1,%rax
  80421190a4:	49 89 c4             	mov    %rax,%r12
  80421190a7:	4c 39 fe             	cmp    %r15,%rsi
  80421190aa:	0f 83 5c ff ff ff    	jae    804211900c <LZ4_compress_fast_continue+0x177d>
  80421190b0:	48 39 85 70 ff ff ff 	cmp    %rax,-0x90(%rbp)
  80421190b7:	0f 82 3f ff ff ff    	jb     8042118ffc <LZ4_compress_fast_continue+0x176d>
  80421190bd:	e9 4a ff ff ff       	jmp    804211900c <LZ4_compress_fast_continue+0x177d>
                int len = (int)(litLength - RUN_MASK);
  80421190c2:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  80421190c5:	c6 03 f0             	movb   $0xf0,(%rbx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  80421190c8:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421190cd:	7e 14                	jle    80421190e3 <LZ4_compress_fast_continue+0x1854>
  80421190cf:	48 83 c7 01          	add    $0x1,%rdi
  80421190d3:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  80421190d7:	2d ff 00 00 00       	sub    $0xff,%eax
  80421190dc:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421190e1:	7f ec                	jg     80421190cf <LZ4_compress_fast_continue+0x1840>
                *op++ = (BYTE)len;
  80421190e3:	88 07                	mov    %al,(%rdi)
  80421190e5:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  80421190e9:	e9 67 ff ff ff       	jmp    8042119055 <LZ4_compress_fast_continue+0x17c6>
                const BYTE* limit = ip + (dictEnd-match);
  80421190ee:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  80421190f5:	48 29 c2             	sub    %rax,%rdx
  80421190f8:	4c 01 fa             	add    %r15,%rdx
                if (limit > matchlimit) limit = matchlimit;
  80421190fb:	48 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%rsi
  8042119102:	48 39 d6             	cmp    %rdx,%rsi
  8042119105:	48 0f 46 d6          	cmovbe %rsi,%rdx
  8042119109:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  804211910d:	4d 8d 6f 04          	lea    0x4(%r15),%r13
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119111:	48 83 ea 07          	sub    $0x7,%rdx
  8042119115:	49 39 d5             	cmp    %rdx,%r13
  8042119118:	0f 83 f0 00 00 00    	jae    804211920e <LZ4_compress_fast_continue+0x197f>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211911e:	48 8b 48 04          	mov    0x4(%rax),%rcx
  8042119122:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  8042119126:	48 39 cf             	cmp    %rcx,%rdi
  8042119129:	0f 85 b6 00 00 00    	jne    80421191e5 <LZ4_compress_fast_continue+0x1956>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211912f:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  8042119133:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119137:	48 39 d3             	cmp    %rdx,%rbx
  804211913a:	0f 83 d5 00 00 00    	jae    8042119215 <LZ4_compress_fast_continue+0x1986>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119140:	48 8b 08             	mov    (%rax),%rcx
  8042119143:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042119146:	48 39 cf             	cmp    %rcx,%rdi
  8042119149:	0f 84 ac 00 00 00    	je     80421191fb <LZ4_compress_fast_continue+0x196c>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211914f:	48 31 cf             	xor    %rcx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042119152:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042119159:	00 00 00 
  804211915c:	ff d0                	call   *%rax
  804211915e:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  8042119161:	44 29 eb             	sub    %r13d,%ebx
                ip += (size_t)matchCode + MINMATCH;
  8042119164:	89 d8                	mov    %ebx,%eax
  8042119166:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                if (ip==limit) {
  804211916b:	4c 39 7d 98          	cmp    %r15,-0x68(%rbp)
  804211916f:	0f 85 ab 01 00 00    	jne    8042119320 <LZ4_compress_fast_continue+0x1a91>
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119175:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042119179:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  804211917d:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042119181:	48 39 d6             	cmp    %rdx,%rsi
  8042119184:	0f 83 10 01 00 00    	jae    804211929a <LZ4_compress_fast_continue+0x1a0b>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211918a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804211918e:	48 8b 01             	mov    (%rcx),%rax
  8042119191:	48 8b 3e             	mov    (%rsi),%rdi
        if (!diff) {
  8042119194:	48 39 c7             	cmp    %rax,%rdi
  8042119197:	0f 85 d3 00 00 00    	jne    8042119270 <LZ4_compress_fast_continue+0x19e1>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211919d:	4c 8d 6e 08          	lea    0x8(%rsi),%r13
  80421191a1:	48 8d 41 08          	lea    0x8(%rcx),%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  80421191a5:	49 39 d5             	cmp    %rdx,%r13
  80421191a8:	0f 83 f4 00 00 00    	jae    80421192a2 <LZ4_compress_fast_continue+0x1a13>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  80421191ae:	48 8b 08             	mov    (%rax),%rcx
  80421191b1:	49 8b 7d 00          	mov    0x0(%r13),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421191b5:	48 39 cf             	cmp    %rcx,%rdi
  80421191b8:	0f 84 c9 00 00 00    	je     8042119287 <LZ4_compress_fast_continue+0x19f8>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421191be:	48 31 cf             	xor    %rcx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  80421191c1:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421191c8:	00 00 00 
  80421191cb:	ff d0                	call   *%rax
  80421191cd:	46 8d 2c 28          	lea    (%rax,%r13,1),%r13d
        return (unsigned)(pIn - pStart);
  80421191d1:	8b 45 98             	mov    -0x68(%rbp),%eax
  80421191d4:	41 29 c5             	sub    %eax,%r13d
                    matchCode += more;
  80421191d7:	44 01 eb             	add    %r13d,%ebx
                    ip += more;
  80421191da:	45 89 ed             	mov    %r13d,%r13d
  80421191dd:	4d 01 ef             	add    %r13,%r15
  80421191e0:	e9 3b 01 00 00       	jmp    8042119320 <LZ4_compress_fast_continue+0x1a91>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  80421191e5:	48 31 cf             	xor    %rcx,%rdi
            return LZ4_NbCommonBytes(diff);
  80421191e8:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  80421191ef:	00 00 00 
  80421191f2:	ff d0                	call   *%rax
  80421191f4:	89 c3                	mov    %eax,%ebx
  80421191f6:	e9 69 ff ff ff       	jmp    8042119164 <LZ4_compress_fast_continue+0x18d5>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  80421191fb:	48 83 c3 08          	add    $0x8,%rbx
  80421191ff:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119203:	48 39 d3             	cmp    %rdx,%rbx
  8042119206:	0f 82 34 ff ff ff    	jb     8042119140 <LZ4_compress_fast_continue+0x18b1>
  804211920c:	eb 07                	jmp    8042119215 <LZ4_compress_fast_continue+0x1986>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  804211920e:	48 83 c0 04          	add    $0x4,%rax
  8042119212:	4c 89 eb             	mov    %r13,%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042119215:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  8042119219:	48 8d 51 fd          	lea    -0x3(%rcx),%rdx
  804211921d:	48 39 d3             	cmp    %rdx,%rbx
  8042119220:	73 06                	jae    8042119228 <LZ4_compress_fast_continue+0x1999>
  8042119222:	8b 30                	mov    (%rax),%esi
  8042119224:	39 33                	cmp    %esi,(%rbx)
  8042119226:	74 34                	je     804211925c <LZ4_compress_fast_continue+0x19cd>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119228:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  804211922c:	48 8d 57 ff          	lea    -0x1(%rdi),%rdx
  8042119230:	48 39 d3             	cmp    %rdx,%rbx
  8042119233:	73 08                	jae    804211923d <LZ4_compress_fast_continue+0x19ae>
  8042119235:	0f b7 38             	movzwl (%rax),%edi
  8042119238:	66 39 3b             	cmp    %di,(%rbx)
  804211923b:	74 29                	je     8042119266 <LZ4_compress_fast_continue+0x19d7>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211923d:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8042119241:	48 39 f3             	cmp    %rsi,%rbx
  8042119244:	73 0e                	jae    8042119254 <LZ4_compress_fast_continue+0x19c5>
  8042119246:	0f b6 0b             	movzbl (%rbx),%ecx
  8042119249:	38 08                	cmp    %cl,(%rax)
  804211924b:	0f 94 c0             	sete   %al
  804211924e:	0f b6 c0             	movzbl %al,%eax
  8042119251:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  8042119254:	44 29 eb             	sub    %r13d,%ebx
  8042119257:	e9 08 ff ff ff       	jmp    8042119164 <LZ4_compress_fast_continue+0x18d5>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211925c:	48 83 c3 04          	add    $0x4,%rbx
  8042119260:	48 83 c0 04          	add    $0x4,%rax
  8042119264:	eb c2                	jmp    8042119228 <LZ4_compress_fast_continue+0x1999>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119266:	48 83 c3 02          	add    $0x2,%rbx
  804211926a:	48 83 c0 02          	add    $0x2,%rax
  804211926e:	eb cd                	jmp    804211923d <LZ4_compress_fast_continue+0x19ae>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119270:	48 31 c7             	xor    %rax,%rdi
            return LZ4_NbCommonBytes(diff);
  8042119273:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211927a:	00 00 00 
  804211927d:	ff d0                	call   *%rax
  804211927f:	41 89 c5             	mov    %eax,%r13d
  8042119282:	e9 50 ff ff ff       	jmp    80421191d7 <LZ4_compress_fast_continue+0x1948>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042119287:	49 83 c5 08          	add    $0x8,%r13
  804211928b:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211928f:	49 39 d5             	cmp    %rdx,%r13
  8042119292:	0f 82 16 ff ff ff    	jb     80421191ae <LZ4_compress_fast_continue+0x191f>
  8042119298:	eb 08                	jmp    80421192a2 <LZ4_compress_fast_continue+0x1a13>
  804211929a:	4c 8b 6d 98          	mov    -0x68(%rbp),%r13
  804211929e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421192a2:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80421192a6:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  80421192aa:	49 39 d5             	cmp    %rdx,%r13
  80421192ad:	73 08                	jae    80421192b7 <LZ4_compress_fast_continue+0x1a28>
  80421192af:	8b 38                	mov    (%rax),%edi
  80421192b1:	41 39 7d 00          	cmp    %edi,0x0(%r13)
  80421192b5:	74 37                	je     80421192ee <LZ4_compress_fast_continue+0x1a5f>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421192b7:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80421192bb:	48 8d 51 fa          	lea    -0x6(%rcx),%rdx
  80421192bf:	49 39 d5             	cmp    %rdx,%r13
  80421192c2:	73 0a                	jae    80421192ce <LZ4_compress_fast_continue+0x1a3f>
  80421192c4:	0f b7 30             	movzwl (%rax),%esi
  80421192c7:	66 41 39 75 00       	cmp    %si,0x0(%r13)
  80421192cc:	74 2a                	je     80421192f8 <LZ4_compress_fast_continue+0x1a69>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  80421192ce:	48 8b bd 18 ff ff ff 	mov    -0xe8(%rbp),%rdi
  80421192d5:	49 39 fd             	cmp    %rdi,%r13
  80421192d8:	73 09                	jae    80421192e3 <LZ4_compress_fast_continue+0x1a54>
  80421192da:	41 0f b6 4d 00       	movzbl 0x0(%r13),%ecx
  80421192df:	38 08                	cmp    %cl,(%rax)
  80421192e1:	74 1f                	je     8042119302 <LZ4_compress_fast_continue+0x1a73>
    return (unsigned)(pIn - pStart);
  80421192e3:	8b 45 98             	mov    -0x68(%rbp),%eax
  80421192e6:	41 29 c5             	sub    %eax,%r13d
  80421192e9:	e9 e9 fe ff ff       	jmp    80421191d7 <LZ4_compress_fast_continue+0x1948>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421192ee:	49 83 c5 04          	add    $0x4,%r13
  80421192f2:	48 83 c0 04          	add    $0x4,%rax
  80421192f6:	eb bf                	jmp    80421192b7 <LZ4_compress_fast_continue+0x1a28>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421192f8:	49 83 c5 02          	add    $0x2,%r13
  80421192fc:	48 83 c0 02          	add    $0x2,%rax
  8042119300:	eb cc                	jmp    80421192ce <LZ4_compress_fast_continue+0x1a3f>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042119302:	49 83 c5 01          	add    $0x1,%r13
  8042119306:	eb db                	jmp    80421192e3 <LZ4_compress_fast_continue+0x1a54>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119308:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211930b:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042119312:	00 00 00 
  8042119315:	ff d0                	call   *%rax
  8042119317:	89 c3                	mov    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  8042119319:	89 d8                	mov    %ebx,%eax
  804211931b:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042119320:	8d 83 f0 00 00 00    	lea    0xf0(%rbx),%eax
  8042119326:	be 81 80 80 80       	mov    $0x80808081,%esi
  804211932b:	48 0f af c6          	imul   %rsi,%rax
  804211932f:	48 c1 e8 27          	shr    $0x27,%rax
  8042119333:	49 8d 44 04 06       	lea    0x6(%r12,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042119338:	48 39 85 50 ff ff ff 	cmp    %rax,-0xb0(%rbp)
  804211933f:	0f 82 ba 15 00 00    	jb     804211a8ff <LZ4_compress_fast_continue+0x3070>
            if (matchCode >= ML_MASK) {
  8042119345:	83 fb 0e             	cmp    $0xe,%ebx
  8042119348:	0f 87 96 01 00 00    	ja     80421194e4 <LZ4_compress_fast_continue+0x1c55>
                *token += (BYTE)(matchCode);
  804211934e:	41 00 1e             	add    %bl,(%r14)
  8042119351:	4d 89 e6             	mov    %r12,%r14
        if (ip >= mflimitPlusOne) break;
  8042119354:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8042119358:	49 39 c7             	cmp    %rax,%r15
  804211935b:	0f 83 30 02 00 00    	jae    8042119591 <LZ4_compress_fast_continue+0x1d02>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042119361:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  8042119365:	be 02 00 00 00       	mov    $0x2,%esi
  804211936a:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  8042119371:	00 00 00 
  8042119374:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042119376:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042119378:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211937c:	4c 8b 65 a8          	mov    -0x58(%rbp),%r12
  8042119380:	4c 29 e2             	sub    %r12,%rdx
  8042119383:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  8042119387:	89 14 87             	mov    %edx,(%rdi,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211938a:	49 8b 3f             	mov    (%r15),%rdi
  804211938d:	be 02 00 00 00       	mov    $0x2,%esi
  8042119392:	ff d3                	call   *%rbx
            U32 const current = (U32)(ip-base);
  8042119394:	4d 89 fd             	mov    %r15,%r13
  8042119397:	4d 29 e5             	sub    %r12,%r13
        return hashTable[h];
  804211939a:	89 c0                	mov    %eax,%eax
  804211939c:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  80421193a0:	48 8d 0c 87          	lea    (%rdi,%rax,4),%rcx
  80421193a4:	8b 11                	mov    (%rcx),%edx
                if (matchIndex < startIndex) {
  80421193a6:	8b 9d 78 ff ff ff    	mov    -0x88(%rbp),%ebx
  80421193ac:	39 da                	cmp    %ebx,%edx
  80421193ae:	0f 83 8c 01 00 00    	jae    8042119540 <LZ4_compress_fast_continue+0x1cb1>
        return hashTable[h];
  80421193b4:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
  80421193b8:	8b 14 83             	mov    (%rbx,%rax,4),%edx
                    match = dictBase + matchIndex;
  80421193bb:	89 d0                	mov    %edx,%eax
  80421193bd:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
  80421193c4:	48 01 f8             	add    %rdi,%rax
                    matchIndex += dictDelta;
  80421193c7:	8b 9d 60 ff ff ff    	mov    -0xa0(%rbp),%ebx
  80421193cd:	01 da                	add    %ebx,%edx
                    lowLimit = dictionary;   /* required for match length counter */
  80421193cf:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  80421193d6:	44 89 29             	mov    %r13d,(%rcx)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  80421193d9:	8d 8a ff ff 00 00    	lea    0xffff(%rdx),%ecx
  80421193df:	44 39 e9             	cmp    %r13d,%ecx
  80421193e2:	0f 82 6d 01 00 00    	jb     8042119555 <LZ4_compress_fast_continue+0x1cc6>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  80421193e8:	8b 18                	mov    (%rax),%ebx
  80421193ea:	41 39 1f             	cmp    %ebx,(%r15)
  80421193ed:	0f 85 62 01 00 00    	jne    8042119555 <LZ4_compress_fast_continue+0x1cc6>
                token=op++;
  80421193f3:	49 8d 5e 01          	lea    0x1(%r14),%rbx
  80421193f7:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
                *token=0;
  80421193fb:	41 c6 06 00          	movb   $0x0,(%r14)
                if (maybe_extMem) offset = current - matchIndex;
  80421193ff:	41 29 d5             	sub    %edx,%r13d
static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
  8042119402:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
  8042119406:	66 44 89 2b          	mov    %r13w,(%rbx)
            LZ4_writeLE16(op, (U16)offset); op+=2;
  804211940a:	4c 8d 63 02          	lea    0x2(%rbx),%r12
                 && (lowLimit==dictionary) /* match within extDict */ ) {
  804211940e:	48 39 b5 68 ff ff ff 	cmp    %rsi,-0x98(%rbp)
  8042119415:	0f 84 d3 fc ff ff    	je     80421190ee <LZ4_compress_fast_continue+0x185f>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211941b:	4d 8d 6f 04          	lea    0x4(%r15),%r13
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211941f:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8042119423:	49 39 f5             	cmp    %rsi,%r13
  8042119426:	73 56                	jae    804211947e <LZ4_compress_fast_continue+0x1bef>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119428:	48 8b 50 04          	mov    0x4(%rax),%rdx
  804211942c:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  8042119430:	48 39 d7             	cmp    %rdx,%rdi
  8042119433:	0f 85 cf fe ff ff    	jne    8042119308 <LZ4_compress_fast_continue+0x1a79>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042119439:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  804211943d:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119441:	48 39 f3             	cmp    %rsi,%rbx
  8042119444:	73 3f                	jae    8042119485 <LZ4_compress_fast_continue+0x1bf6>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119446:	48 8b 10             	mov    (%rax),%rdx
  8042119449:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211944c:	48 39 d7             	cmp    %rdx,%rdi
  804211944f:	74 1a                	je     804211946b <LZ4_compress_fast_continue+0x1bdc>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119451:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042119454:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211945b:	00 00 00 
  804211945e:	ff d0                	call   *%rax
  8042119460:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  8042119463:	44 29 eb             	sub    %r13d,%ebx
  8042119466:	e9 ae fe ff ff       	jmp    8042119319 <LZ4_compress_fast_continue+0x1a8a>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211946b:	48 83 c3 08          	add    $0x8,%rbx
  804211946f:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119473:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8042119477:	48 39 f3             	cmp    %rsi,%rbx
  804211947a:	72 ca                	jb     8042119446 <LZ4_compress_fast_continue+0x1bb7>
  804211947c:	eb 07                	jmp    8042119485 <LZ4_compress_fast_continue+0x1bf6>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211947e:	48 83 c0 04          	add    $0x4,%rax
  8042119482:	4c 89 eb             	mov    %r13,%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042119485:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042119489:	48 8d 51 f8          	lea    -0x8(%rcx),%rdx
  804211948d:	48 39 d3             	cmp    %rdx,%rbx
  8042119490:	73 06                	jae    8042119498 <LZ4_compress_fast_continue+0x1c09>
  8042119492:	8b 08                	mov    (%rax),%ecx
  8042119494:	39 0b                	cmp    %ecx,(%rbx)
  8042119496:	74 38                	je     80421194d0 <LZ4_compress_fast_continue+0x1c41>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119498:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804211949c:	48 8d 51 fa          	lea    -0x6(%rcx),%rdx
  80421194a0:	48 39 d3             	cmp    %rdx,%rbx
  80421194a3:	73 08                	jae    80421194ad <LZ4_compress_fast_continue+0x1c1e>
  80421194a5:	0f b7 38             	movzwl (%rax),%edi
  80421194a8:	66 39 3b             	cmp    %di,(%rbx)
  80421194ab:	74 2d                	je     80421194da <LZ4_compress_fast_continue+0x1c4b>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  80421194ad:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
  80421194b4:	48 39 cb             	cmp    %rcx,%rbx
  80421194b7:	73 0f                	jae    80421194c8 <LZ4_compress_fast_continue+0x1c39>
  80421194b9:	0f b6 33             	movzbl (%rbx),%esi
  80421194bc:	40 38 30             	cmp    %sil,(%rax)
  80421194bf:	0f 94 c0             	sete   %al
  80421194c2:	0f b6 c0             	movzbl %al,%eax
  80421194c5:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  80421194c8:	44 29 eb             	sub    %r13d,%ebx
  80421194cb:	e9 49 fe ff ff       	jmp    8042119319 <LZ4_compress_fast_continue+0x1a8a>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  80421194d0:	48 83 c3 04          	add    $0x4,%rbx
  80421194d4:	48 83 c0 04          	add    $0x4,%rax
  80421194d8:	eb be                	jmp    8042119498 <LZ4_compress_fast_continue+0x1c09>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  80421194da:	48 83 c3 02          	add    $0x2,%rbx
  80421194de:	48 83 c0 02          	add    $0x2,%rax
  80421194e2:	eb c9                	jmp    80421194ad <LZ4_compress_fast_continue+0x1c1e>
                *token += ML_MASK;
  80421194e4:	41 80 06 0f          	addb   $0xf,(%r14)
                matchCode -= ML_MASK;
  80421194e8:	83 eb 0f             	sub    $0xf,%ebx
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  80421194eb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80421194ef:	c7 40 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rax)
                while (matchCode >= 4*255) {
  80421194f6:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  80421194fc:	76 1a                	jbe    8042119518 <LZ4_compress_fast_continue+0x1c89>
                    op+=4;
  80421194fe:	49 83 c4 04          	add    $0x4,%r12
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042119502:	41 c7 04 24 ff ff ff 	movl   $0xffffffff,(%r12)
  8042119509:	ff 
                    matchCode -= 4*255;
  804211950a:	81 eb fc 03 00 00    	sub    $0x3fc,%ebx
                while (matchCode >= 4*255) {
  8042119510:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  8042119516:	77 e6                	ja     80421194fe <LZ4_compress_fast_continue+0x1c6f>
                op += matchCode / 255;
  8042119518:	89 d8                	mov    %ebx,%eax
  804211951a:	ba 81 80 80 80       	mov    $0x80808081,%edx
  804211951f:	48 0f af c2          	imul   %rdx,%rax
  8042119523:	48 c1 e8 27          	shr    $0x27,%rax
  8042119527:	89 c2                	mov    %eax,%edx
  8042119529:	4c 01 e2             	add    %r12,%rdx
                *op++ = (BYTE)(matchCode % 255);
  804211952c:	4c 8d 72 01          	lea    0x1(%rdx),%r14
  8042119530:	89 c1                	mov    %eax,%ecx
  8042119532:	c1 e1 08             	shl    $0x8,%ecx
  8042119535:	29 c1                	sub    %eax,%ecx
  8042119537:	29 cb                	sub    %ecx,%ebx
  8042119539:	88 1a                	mov    %bl,(%rdx)
  804211953b:	e9 14 fe ff ff       	jmp    8042119354 <LZ4_compress_fast_continue+0x1ac5>
                    match = base + matchIndex;
  8042119540:	89 d0                	mov    %edx,%eax
  8042119542:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8042119546:	48 01 f8             	add    %rdi,%rax
                    lowLimit = (const BYTE*)source;  /* required for match length counter */
  8042119549:	48 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%rsi
  8042119550:	e9 81 fe ff ff       	jmp    80421193d6 <LZ4_compress_fast_continue+0x1b47>
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042119555:	4c 89 b5 40 ff ff ff 	mov    %r14,-0xc0(%rbp)
  804211955c:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042119560:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  8042119564:	be 02 00 00 00       	mov    $0x2,%esi
  8042119569:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042119570:	00 00 00 
  8042119573:	ff d0                	call   *%rax
  8042119575:	4c 89 fe             	mov    %r15,%rsi
  8042119578:	49 89 df             	mov    %rbx,%r15
  804211957b:	e9 b6 e6 ff ff       	jmp    8042117c36 <LZ4_compress_fast_continue+0x3a7>
    BYTE* op = (BYTE*) dest;
  8042119580:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042119584:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  804211958b:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211958f:	eb 36                	jmp    80421195c7 <LZ4_compress_fast_continue+0x1d38>
        anchor = ip;
  8042119591:	4c 89 b5 40 ff ff ff 	mov    %r14,-0xc0(%rbp)
  8042119598:	4c 89 fe             	mov    %r15,%rsi
  804211959b:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211959f:	44 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%r15d
  80421195a6:	eb 1f                	jmp    80421195c7 <LZ4_compress_fast_continue+0x1d38>
  80421195a8:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  80421195ac:	44 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%r15d
  80421195b3:	eb 12                	jmp    80421195c7 <LZ4_compress_fast_continue+0x1d38>
  80421195b5:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  80421195bc:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  80421195c0:	44 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%r15d
    {   size_t lastRun = (size_t)(iend - anchor);
  80421195c7:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  80421195cb:	49 29 f4             	sub    %rsi,%r12
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  80421195ce:	49 8d 94 24 f0 00 00 	lea    0xf0(%r12),%rdx
  80421195d5:	00 
  80421195d6:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  80421195dd:	80 80 80 
  80421195e0:	48 89 d0             	mov    %rdx,%rax
  80421195e3:	48 f7 e1             	mul    %rcx
  80421195e6:	48 c1 ea 07          	shr    $0x7,%rdx
  80421195ea:	49 8d 54 14 01       	lea    0x1(%r12,%rdx,1),%rdx
  80421195ef:	48 8b 8d 40 ff ff ff 	mov    -0xc0(%rbp),%rcx
  80421195f6:	48 01 ca             	add    %rcx,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  80421195f9:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  80421195fe:	48 39 95 50 ff ff ff 	cmp    %rdx,-0xb0(%rbp)
  8042119605:	72 55                	jb     804211965c <LZ4_compress_fast_continue+0x1dcd>
        if (lastRun >= RUN_MASK) {
  8042119607:	49 83 fc 0e          	cmp    $0xe,%r12
  804211960b:	76 66                	jbe    8042119673 <LZ4_compress_fast_continue+0x1de4>
            size_t accumulator = lastRun - RUN_MASK;
  804211960d:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042119612:	48 8d 41 01          	lea    0x1(%rcx),%rax
  8042119616:	c6 01 f0             	movb   $0xf0,(%rcx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042119619:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042119620:	76 18                	jbe    804211963a <LZ4_compress_fast_continue+0x1dab>
  8042119622:	48 83 c0 01          	add    $0x1,%rax
  8042119626:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  804211962a:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042119631:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042119638:	77 e8                	ja     8042119622 <LZ4_compress_fast_continue+0x1d93>
            *op++ = (BYTE) accumulator;
  804211963a:	48 8d 58 01          	lea    0x1(%rax),%rbx
  804211963e:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042119640:	4c 89 e2             	mov    %r12,%rdx
  8042119643:	48 89 df             	mov    %rbx,%rdi
  8042119646:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211964d:	00 00 00 
  8042119650:	ff d0                	call   *%rax
        op += lastRun;
  8042119652:	4c 01 e3             	add    %r12,%rbx
    result = (int)(((char*)op) - dest);
  8042119655:	89 d8                	mov    %ebx,%eax
  8042119657:	8b 75 c0             	mov    -0x40(%rbp),%esi
  804211965a:	29 f0                	sub    %esi,%eax
        streamPtr->dictionary = (const BYTE*)source;
  804211965c:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8042119660:	49 89 8e 08 40 00 00 	mov    %rcx,0x4008(%r14)
        streamPtr->dictSize = (U32)inputSize;
  8042119667:	45 89 be 18 40 00 00 	mov    %r15d,0x4018(%r14)
        return result;
  804211966e:	e9 4b e2 ff ff       	jmp    80421178be <LZ4_compress_fast_continue+0x2f>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042119673:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
  804211967a:	48 8d 5f 01          	lea    0x1(%rdi),%rbx
  804211967e:	44 89 e0             	mov    %r12d,%eax
  8042119681:	c1 e0 04             	shl    $0x4,%eax
  8042119684:	88 07                	mov    %al,(%rdi)
  8042119686:	eb b8                	jmp    8042119640 <LZ4_compress_fast_continue+0x1db1>
            if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
  8042119688:	41 8b 96 18 40 00 00 	mov    0x4018(%r14),%edx
  804211968f:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8042119695:	0f 87 31 09 00 00    	ja     8042119fcc <LZ4_compress_fast_continue+0x273d>
  804211969b:	45 8b ae 00 40 00 00 	mov    0x4000(%r14),%r13d
  80421196a2:	44 89 6d 98          	mov    %r13d,-0x68(%rbp)
  80421196a6:	44 39 ea             	cmp    %r13d,%edx
  80421196a9:	0f 83 1d 09 00 00    	jae    8042119fcc <LZ4_compress_fast_continue+0x273d>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  80421196af:	b8 00 00 00 00       	mov    $0x0,%eax
  80421196b4:	41 81 ff 00 00 00 7e 	cmp    $0x7e000000,%r15d
  80421196bb:	77 9f                	ja     804211965c <LZ4_compress_fast_continue+0x1dcd>
            dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
  80421196bd:	4d 8b 9e 08 40 00 00 	mov    0x4008(%r14),%r11
  80421196c4:	4c 89 9d 68 ff ff ff 	mov    %r11,-0x98(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  80421196cb:	4d 63 e4             	movslq %r12d,%r12
  80421196ce:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80421196d2:	4a 8d 0c 20          	lea    (%rax,%r12,1),%rcx
  80421196d6:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
        cctx->dictSize += (U32)inputSize;
  80421196dd:	42 8d 04 3a          	lea    (%rdx,%r15,1),%eax
  80421196e1:	41 89 86 18 40 00 00 	mov    %eax,0x4018(%r14)
    cctx->currentOffset += (U32)inputSize;
  80421196e8:	43 8d 44 3d 00       	lea    0x0(%r13,%r15,1),%eax
  80421196ed:	41 89 86 00 40 00 00 	mov    %eax,0x4000(%r14)
    cctx->tableType = (U16)tableType;
  80421196f4:	66 41 c7 86 06 40 00 	movw   $0x2,0x4006(%r14)
  80421196fb:	00 02 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  80421196fe:	41 83 ff 0c          	cmp    $0xc,%r15d
  8042119702:	0f 8e cb 07 00 00    	jle    8042119ed3 <LZ4_compress_fast_continue+0x2644>
    const BYTE* base = (const BYTE*) source - startIndex;
  8042119708:	44 89 e8             	mov    %r13d,%eax
  804211970b:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211970f:	48 89 f7             	mov    %rsi,%rdi
  8042119712:	48 29 c7             	sub    %rax,%rdi
  8042119715:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
  8042119719:	44 89 e9             	mov    %r13d,%ecx
  804211971c:	29 d1                	sub    %edx,%ecx
  804211971e:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%rbp)
    const BYTE* const dictEnd = dictionary + dictSize;
  8042119724:	89 d2                	mov    %edx,%edx
  8042119726:	49 8d 3c 13          	lea    (%r11,%rdx,1),%rdi
  804211972a:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  8042119731:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042119735:	48 8d 79 f5          	lea    -0xb(%rcx),%rdi
  8042119739:	48 89 7d 80          	mov    %rdi,-0x80(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  804211973d:	48 8d 79 fb          	lea    -0x5(%rcx),%rdi
  8042119741:	48 89 bd 20 ff ff ff 	mov    %rdi,-0xe0(%rbp)
                           dictionary + dictSize - startIndex;
  8042119748:	48 29 c2             	sub    %rax,%rdx
                           dictionary + dictSize - dictCtx->currentOffset :
  804211974b:	49 8d 0c 13          	lea    (%r11,%rdx,1),%rcx
  804211974f:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042119756:	48 8b 3e             	mov    (%rsi),%rdi
  8042119759:	be 02 00 00 00       	mov    $0x2,%esi
  804211975e:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  8042119765:	00 00 00 
  8042119768:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211976b:	89 c0                	mov    %eax,%eax
  804211976d:	45 89 2c 86          	mov    %r13d,(%r14,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  8042119771:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
  8042119775:	49 8d 7d 01          	lea    0x1(%r13),%rdi
  8042119779:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211977d:	49 8b 7d 01          	mov    0x1(%r13),%rdi
  8042119781:	be 02 00 00 00       	mov    $0x2,%esi
  8042119786:	41 ff d4             	call   *%r12
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  8042119789:	c1 e3 06             	shl    $0x6,%ebx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211978c:	8d 4b 01             	lea    0x1(%rbx),%ecx
  804211978f:	89 8d 38 ff ff ff    	mov    %ecx,-0xc8(%rbp)
  8042119795:	c1 fb 06             	sar    $0x6,%ebx
  8042119798:	89 9d 30 ff ff ff    	mov    %ebx,-0xd0(%rbp)
  804211979e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80421197a2:	48 89 b5 48 ff ff ff 	mov    %rsi,-0xb8(%rbp)
  80421197a9:	4c 89 ee             	mov    %r13,%rsi
  80421197ac:	4c 89 75 88          	mov    %r14,-0x78(%rbp)
  80421197b0:	4c 8b 75 b0          	mov    -0x50(%rbp),%r14
  80421197b4:	44 89 bd 40 ff ff ff 	mov    %r15d,-0xc0(%rbp)
                U32 const current = (U32)(forwardIp - base);
  80421197bb:	45 89 f7             	mov    %r14d,%r15d
  80421197be:	8b 5d a0             	mov    -0x60(%rbp),%ebx
  80421197c1:	41 29 df             	sub    %ebx,%r15d
        return hashTable[h];
  80421197c4:	89 c0                	mov    %eax,%eax
  80421197c6:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
  80421197ca:	4c 8d 2c 83          	lea    (%rbx,%rax,4),%r13
  80421197ce:	45 8b 65 00          	mov    0x0(%r13),%r12d
                forwardIp += step;
  80421197d2:	49 8d 5e 01          	lea    0x1(%r14),%rbx
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  80421197d6:	48 39 5d 80          	cmp    %rbx,-0x80(%rbp)
  80421197da:	0f 82 1b 07 00 00    	jb     8042119efb <LZ4_compress_fast_continue+0x266c>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  80421197e0:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
  80421197e6:	89 45 b0             	mov    %eax,-0x50(%rbp)
  80421197e9:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  80421197ef:	89 45 a8             	mov    %eax,-0x58(%rbp)
                        lowLimit = (const BYTE*)source;
  80421197f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80421197f6:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80421197fd:	48 89 b5 28 ff ff ff 	mov    %rsi,-0xd8(%rbp)
  8042119804:	4c 89 75 90          	mov    %r14,-0x70(%rbp)
  8042119808:	eb 3e                	jmp    8042119848 <LZ4_compress_fast_continue+0x1fb9>
                U32 const current = (U32)(forwardIp - base);
  804211980a:	41 89 df             	mov    %ebx,%r15d
  804211980d:	8b 4d a0             	mov    -0x60(%rbp),%ecx
  8042119810:	41 29 cf             	sub    %ecx,%r15d
        return hashTable[h];
  8042119813:	89 c0                	mov    %eax,%eax
  8042119815:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  8042119819:	4c 8d 2c 87          	lea    (%rdi,%rax,4),%r13
  804211981d:	45 8b 65 00          	mov    0x0(%r13),%r12d
                forwardIp += step;
  8042119821:	48 63 45 b0          	movslq -0x50(%rbp),%rax
  8042119825:	48 01 d8             	add    %rbx,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  8042119828:	8b 7d a8             	mov    -0x58(%rbp),%edi
  804211982b:	8d 57 01             	lea    0x1(%rdi),%edx
  804211982e:	c1 ff 06             	sar    $0x6,%edi
  8042119831:	89 7d b0             	mov    %edi,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  8042119834:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
  8042119838:	48 39 45 80          	cmp    %rax,-0x80(%rbp)
  804211983c:	0f 82 c6 06 00 00    	jb     8042119f08 <LZ4_compress_fast_continue+0x2679>
  8042119842:	89 55 a8             	mov    %edx,-0x58(%rbp)
  8042119845:	48 89 c3             	mov    %rax,%rbx
                    if (matchIndex < startIndex) {
  8042119848:	8b 45 98             	mov    -0x68(%rbp),%eax
  804211984b:	41 39 c4             	cmp    %eax,%r12d
  804211984e:	0f 83 26 01 00 00    	jae    804211997a <LZ4_compress_fast_continue+0x20eb>
                        match = dictBase + matchIndex;
  8042119854:	45 89 e6             	mov    %r12d,%r14d
  8042119857:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  804211985e:	49 01 c6             	add    %rax,%r14
                        lowLimit = dictionary;
  8042119861:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8042119868:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211986f:	48 8b 3b             	mov    (%rbx),%rdi
  8042119872:	be 02 00 00 00       	mov    $0x2,%esi
  8042119877:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211987e:	00 00 00 
  8042119881:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042119883:	45 89 7d 00          	mov    %r15d,0x0(%r13)
                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */
  8042119887:	8b 8d 78 ff ff ff    	mov    -0x88(%rbp),%ecx
  804211988d:	41 39 cc             	cmp    %ecx,%r12d
  8042119890:	0f 82 74 ff ff ff    	jb     804211980a <LZ4_compress_fast_continue+0x1f7b>
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  8042119896:	41 8d 94 24 ff ff 00 	lea    0xffff(%r12),%edx
  804211989d:	00 
  804211989e:	44 39 fa             	cmp    %r15d,%edx
  80421198a1:	0f 82 63 ff ff ff    	jb     804211980a <LZ4_compress_fast_continue+0x1f7b>
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  80421198a7:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  80421198ab:	41 8b 36             	mov    (%r14),%esi
  80421198ae:	39 37                	cmp    %esi,(%rdi)
  80421198b0:	0f 85 54 ff ff ff    	jne    804211980a <LZ4_compress_fast_continue+0x1f7b>
                    if (maybe_extMem) offset = current - matchIndex;
  80421198b6:	4c 89 f0             	mov    %r14,%rax
  80421198b9:	4d 89 f5             	mov    %r14,%r13
  80421198bc:	48 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%rsi
  80421198c3:	49 89 fe             	mov    %rdi,%r14
  80421198c6:	44 89 fb             	mov    %r15d,%ebx
  80421198c9:	44 29 e3             	sub    %r12d,%ebx
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  80421198cc:	48 39 fe             	cmp    %rdi,%rsi
  80421198cf:	73 1a                	jae    80421198eb <LZ4_compress_fast_continue+0x205c>
  80421198d1:	48 39 85 70 ff ff ff 	cmp    %rax,-0x90(%rbp)
  80421198d8:	73 11                	jae    80421198eb <LZ4_compress_fast_continue+0x205c>
  80421198da:	0f b6 48 ff          	movzbl -0x1(%rax),%ecx
  80421198de:	41 38 4e ff          	cmp    %cl,-0x1(%r14)
  80421198e2:	0f 84 af 00 00 00    	je     8042119997 <LZ4_compress_fast_continue+0x2108>
  80421198e8:	49 89 c5             	mov    %rax,%r13
        {   unsigned const litLength = (unsigned)(ip - anchor);
  80421198eb:	4c 89 f0             	mov    %r14,%rax
  80421198ee:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  80421198f1:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  80421198f8:	48 83 c7 01          	add    $0x1,%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  80421198fc:	89 c1                	mov    %eax,%ecx
  80421198fe:	89 c2                	mov    %eax,%edx
  8042119900:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  8042119906:	49 0f af d0          	imul   %r8,%rdx
  804211990a:	48 c1 ea 27          	shr    $0x27,%rdx
  804211990e:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  8042119913:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  8042119916:	48 39 95 50 ff ff ff 	cmp    %rdx,-0xb0(%rbp)
  804211991d:	0f 82 f1 0f 00 00    	jb     804211a914 <LZ4_compress_fast_continue+0x3085>
            if (litLength >= RUN_MASK) {
  8042119923:	83 f8 0e             	cmp    $0xe,%eax
  8042119926:	0f 87 95 00 00 00    	ja     80421199c1 <LZ4_compress_fast_continue+0x2132>
            else *token = (BYTE)(litLength<<ML_BITS);
  804211992c:	c1 e0 04             	shl    $0x4,%eax
  804211992f:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  8042119936:	88 02                	mov    %al,(%rdx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  8042119938:	4c 8d 3c 0f          	lea    (%rdi,%rcx,1),%r15
  804211993c:	4c 89 fa             	mov    %r15,%rdx
  804211993f:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  8042119946:	00 00 00 
  8042119949:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211994b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211994f:	48 83 e8 0c          	sub    $0xc,%rax
  8042119953:	48 89 45 90          	mov    %rax,-0x70(%rbp)
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
  8042119957:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211995b:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8042119962:	4c 89 e8             	mov    %r13,%rax
  8042119965:	4c 8b ad 48 ff ff ff 	mov    -0xb8(%rbp),%r13
  804211996c:	89 da                	mov    %ebx,%edx
  804211996e:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
  8042119975:	e9 11 04 00 00       	jmp    8042119d8b <LZ4_compress_fast_continue+0x24fc>
                        match = base + matchIndex;
  804211997a:	45 89 e6             	mov    %r12d,%r14d
  804211997d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8042119981:	49 01 c6             	add    %rax,%r14
                        lowLimit = (const BYTE*)source;
  8042119984:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  804211998b:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8042119992:	e9 d8 fe ff ff       	jmp    804211986f <LZ4_compress_fast_continue+0x1fe0>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  8042119997:	49 83 ee 01          	sub    $0x1,%r14
  804211999b:	48 83 e8 01          	sub    $0x1,%rax
  804211999f:	4c 39 f6             	cmp    %r14,%rsi
  80421199a2:	73 15                	jae    80421199b9 <LZ4_compress_fast_continue+0x212a>
  80421199a4:	48 39 85 70 ff ff ff 	cmp    %rax,-0x90(%rbp)
  80421199ab:	0f 82 29 ff ff ff    	jb     80421198da <LZ4_compress_fast_continue+0x204b>
  80421199b1:	49 89 c5             	mov    %rax,%r13
  80421199b4:	e9 32 ff ff ff       	jmp    80421198eb <LZ4_compress_fast_continue+0x205c>
  80421199b9:	49 89 c5             	mov    %rax,%r13
  80421199bc:	e9 2a ff ff ff       	jmp    80421198eb <LZ4_compress_fast_continue+0x205c>
                int len = (int)(litLength - RUN_MASK);
  80421199c1:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  80421199c4:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  80421199cb:	c6 02 f0             	movb   $0xf0,(%rdx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  80421199ce:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421199d3:	7e 14                	jle    80421199e9 <LZ4_compress_fast_continue+0x215a>
  80421199d5:	48 83 c7 01          	add    $0x1,%rdi
  80421199d9:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  80421199dd:	2d ff 00 00 00       	sub    $0xff,%eax
  80421199e2:	3d fe 00 00 00       	cmp    $0xfe,%eax
  80421199e7:	7f ec                	jg     80421199d5 <LZ4_compress_fast_continue+0x2146>
                *op++ = (BYTE)len;
  80421199e9:	88 07                	mov    %al,(%rdi)
  80421199eb:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  80421199ef:	e9 44 ff ff ff       	jmp    8042119938 <LZ4_compress_fast_continue+0x20a9>
                const BYTE* limit = ip + (dictEnd-match);
  80421199f4:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80421199fb:	48 29 c2             	sub    %rax,%rdx
  80421199fe:	4c 01 f2             	add    %r14,%rdx
                if (limit > matchlimit) limit = matchlimit;
  8042119a01:	48 8b bd 20 ff ff ff 	mov    -0xe0(%rbp),%rdi
  8042119a08:	48 39 d7             	cmp    %rdx,%rdi
  8042119a0b:	48 0f 46 d7          	cmovbe %rdi,%rdx
  8042119a0f:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  8042119a13:	49 8d 5e 04          	lea    0x4(%r14),%rbx
  8042119a17:	48 89 5d a8          	mov    %rbx,-0x58(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119a1b:	48 8d 4a f9          	lea    -0x7(%rdx),%rcx
  8042119a1f:	48 39 cb             	cmp    %rcx,%rbx
  8042119a22:	0f 83 03 01 00 00    	jae    8042119b2b <LZ4_compress_fast_continue+0x229c>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119a28:	48 8b 70 04          	mov    0x4(%rax),%rsi
  8042119a2c:	49 8b 56 04          	mov    0x4(%r14),%rdx
        if (!diff) {
  8042119a30:	48 39 f2             	cmp    %rsi,%rdx
  8042119a33:	0f 85 c6 00 00 00    	jne    8042119aff <LZ4_compress_fast_continue+0x2270>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042119a39:	49 8d 5e 0c          	lea    0xc(%r14),%rbx
  8042119a3d:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119a41:	48 39 cb             	cmp    %rcx,%rbx
  8042119a44:	0f 83 e9 00 00 00    	jae    8042119b33 <LZ4_compress_fast_continue+0x22a4>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119a4a:	48 8b 10             	mov    (%rax),%rdx
  8042119a4d:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042119a50:	48 39 d7             	cmp    %rdx,%rdi
  8042119a53:	0f 84 bf 00 00 00    	je     8042119b18 <LZ4_compress_fast_continue+0x2289>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119a59:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042119a5c:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042119a63:	00 00 00 
  8042119a66:	ff d0                	call   *%rax
  8042119a68:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  8042119a6b:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8042119a6e:	29 c3                	sub    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  8042119a70:	89 d8                	mov    %ebx,%eax
  8042119a72:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
                if (ip==limit) {
  8042119a77:	4c 39 75 b0          	cmp    %r14,-0x50(%rbp)
  8042119a7b:	0f 85 83 03 00 00    	jne    8042119e04 <LZ4_compress_fast_continue+0x2575>
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119a81:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8042119a85:	48 8d 48 f4          	lea    -0xc(%rax),%rcx
  8042119a89:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042119a8d:	48 39 ce             	cmp    %rcx,%rsi
  8042119a90:	0f 83 28 01 00 00    	jae    8042119bbe <LZ4_compress_fast_continue+0x232f>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119a96:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  8042119a9a:	48 8b 17             	mov    (%rdi),%rdx
  8042119a9d:	48 8b 06             	mov    (%rsi),%rax
        if (!diff) {
  8042119aa0:	48 39 d0             	cmp    %rdx,%rax
  8042119aa3:	0f 85 e7 00 00 00    	jne    8042119b90 <LZ4_compress_fast_continue+0x2301>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042119aa9:	48 8d 76 08          	lea    0x8(%rsi),%rsi
  8042119aad:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
  8042119ab1:	48 8d 47 08          	lea    0x8(%rdi),%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119ab5:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8042119ab9:	48 39 ce             	cmp    %rcx,%rsi
  8042119abc:	0f 83 08 01 00 00    	jae    8042119bca <LZ4_compress_fast_continue+0x233b>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119ac2:	48 8b 30             	mov    (%rax),%rsi
  8042119ac5:	48 8b 17             	mov    (%rdi),%rdx
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042119ac8:	48 39 f2             	cmp    %rsi,%rdx
  8042119acb:	0f 84 d6 00 00 00    	je     8042119ba7 <LZ4_compress_fast_continue+0x2318>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119ad1:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8042119ad5:	48 31 f2             	xor    %rsi,%rdx
  8042119ad8:	48 89 d7             	mov    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042119adb:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042119ae2:	00 00 00 
  8042119ae5:	ff d0                	call   *%rax
  8042119ae7:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8042119aeb:	8d 04 38             	lea    (%rax,%rdi,1),%eax
        return (unsigned)(pIn - pStart);
  8042119aee:	8b 4d b0             	mov    -0x50(%rbp),%ecx
  8042119af1:	29 c8                	sub    %ecx,%eax
                    matchCode += more;
  8042119af3:	01 c3                	add    %eax,%ebx
                    ip += more;
  8042119af5:	89 c0                	mov    %eax,%eax
  8042119af7:	49 01 c6             	add    %rax,%r14
  8042119afa:	e9 05 03 00 00       	jmp    8042119e04 <LZ4_compress_fast_continue+0x2575>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119aff:	48 89 d7             	mov    %rdx,%rdi
  8042119b02:	48 31 f7             	xor    %rsi,%rdi
            return LZ4_NbCommonBytes(diff);
  8042119b05:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042119b0c:	00 00 00 
  8042119b0f:	ff d0                	call   *%rax
  8042119b11:	89 c3                	mov    %eax,%ebx
  8042119b13:	e9 58 ff ff ff       	jmp    8042119a70 <LZ4_compress_fast_continue+0x21e1>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042119b18:	48 83 c3 08          	add    $0x8,%rbx
  8042119b1c:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119b20:	48 39 cb             	cmp    %rcx,%rbx
  8042119b23:	0f 82 21 ff ff ff    	jb     8042119a4a <LZ4_compress_fast_continue+0x21bb>
  8042119b29:	eb 08                	jmp    8042119b33 <LZ4_compress_fast_continue+0x22a4>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  8042119b2b:	48 83 c0 04          	add    $0x4,%rax
  8042119b2f:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042119b33:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042119b37:	48 8d 56 fd          	lea    -0x3(%rsi),%rdx
  8042119b3b:	48 39 d3             	cmp    %rdx,%rbx
  8042119b3e:	73 06                	jae    8042119b46 <LZ4_compress_fast_continue+0x22b7>
  8042119b40:	8b 08                	mov    (%rax),%ecx
  8042119b42:	39 0b                	cmp    %ecx,(%rbx)
  8042119b44:	74 30                	je     8042119b76 <LZ4_compress_fast_continue+0x22e7>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119b46:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8042119b4a:	48 8d 56 ff          	lea    -0x1(%rsi),%rdx
  8042119b4e:	48 39 d3             	cmp    %rdx,%rbx
  8042119b51:	73 08                	jae    8042119b5b <LZ4_compress_fast_continue+0x22cc>
  8042119b53:	0f b7 38             	movzwl (%rax),%edi
  8042119b56:	66 39 3b             	cmp    %di,(%rbx)
  8042119b59:	74 25                	je     8042119b80 <LZ4_compress_fast_continue+0x22f1>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042119b5b:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8042119b5f:	48 39 cb             	cmp    %rcx,%rbx
  8042119b62:	73 08                	jae    8042119b6c <LZ4_compress_fast_continue+0x22dd>
  8042119b64:	0f b6 33             	movzbl (%rbx),%esi
  8042119b67:	40 38 30             	cmp    %sil,(%rax)
  8042119b6a:	74 1e                	je     8042119b8a <LZ4_compress_fast_continue+0x22fb>
    return (unsigned)(pIn - pStart);
  8042119b6c:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8042119b6f:	29 c3                	sub    %eax,%ebx
  8042119b71:	e9 fa fe ff ff       	jmp    8042119a70 <LZ4_compress_fast_continue+0x21e1>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042119b76:	48 83 c3 04          	add    $0x4,%rbx
  8042119b7a:	48 83 c0 04          	add    $0x4,%rax
  8042119b7e:	eb c6                	jmp    8042119b46 <LZ4_compress_fast_continue+0x22b7>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119b80:	48 83 c3 02          	add    $0x2,%rbx
  8042119b84:	48 83 c0 02          	add    $0x2,%rax
  8042119b88:	eb d1                	jmp    8042119b5b <LZ4_compress_fast_continue+0x22cc>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042119b8a:	48 83 c3 01          	add    $0x1,%rbx
  8042119b8e:	eb dc                	jmp    8042119b6c <LZ4_compress_fast_continue+0x22dd>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119b90:	48 31 d0             	xor    %rdx,%rax
  8042119b93:	48 89 c7             	mov    %rax,%rdi
            return LZ4_NbCommonBytes(diff);
  8042119b96:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042119b9d:	00 00 00 
  8042119ba0:	ff d0                	call   *%rax
  8042119ba2:	e9 4c ff ff ff       	jmp    8042119af3 <LZ4_compress_fast_continue+0x2264>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042119ba7:	48 83 c7 08          	add    $0x8,%rdi
  8042119bab:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119baf:	48 39 cf             	cmp    %rcx,%rdi
  8042119bb2:	0f 82 0a ff ff ff    	jb     8042119ac2 <LZ4_compress_fast_continue+0x2233>
  8042119bb8:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8042119bbc:	eb 0c                	jmp    8042119bca <LZ4_compress_fast_continue+0x233b>
  8042119bbe:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8042119bc2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8042119bc6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042119bca:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042119bce:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  8042119bd2:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8042119bd6:	48 39 d1             	cmp    %rdx,%rcx
  8042119bd9:	73 06                	jae    8042119be1 <LZ4_compress_fast_continue+0x2352>
  8042119bdb:	8b 38                	mov    (%rax),%edi
  8042119bdd:	39 39                	cmp    %edi,(%rcx)
  8042119bdf:	74 3d                	je     8042119c1e <LZ4_compress_fast_continue+0x238f>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119be1:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8042119be5:	48 8d 51 fa          	lea    -0x6(%rcx),%rdx
  8042119be9:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  8042119bed:	48 39 d6             	cmp    %rdx,%rsi
  8042119bf0:	73 08                	jae    8042119bfa <LZ4_compress_fast_continue+0x236b>
  8042119bf2:	0f b7 38             	movzwl (%rax),%edi
  8042119bf5:	66 39 3e             	cmp    %di,(%rsi)
  8042119bf8:	74 2f                	je     8042119c29 <LZ4_compress_fast_continue+0x239a>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042119bfa:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8042119bfe:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  8042119c05:	48 39 f1             	cmp    %rsi,%rcx
  8042119c08:	73 07                	jae    8042119c11 <LZ4_compress_fast_continue+0x2382>
  8042119c0a:	0f b6 09             	movzbl (%rcx),%ecx
  8042119c0d:	38 08                	cmp    %cl,(%rax)
  8042119c0f:	74 23                	je     8042119c34 <LZ4_compress_fast_continue+0x23a5>
    return (unsigned)(pIn - pStart);
  8042119c11:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8042119c14:	8b 75 b0             	mov    -0x50(%rbp),%esi
  8042119c17:	29 f0                	sub    %esi,%eax
  8042119c19:	e9 d5 fe ff ff       	jmp    8042119af3 <LZ4_compress_fast_continue+0x2264>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042119c1e:	48 83 45 a8 04       	addq   $0x4,-0x58(%rbp)
  8042119c23:	48 83 c0 04          	add    $0x4,%rax
  8042119c27:	eb b8                	jmp    8042119be1 <LZ4_compress_fast_continue+0x2352>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119c29:	48 83 45 a8 02       	addq   $0x2,-0x58(%rbp)
  8042119c2e:	48 83 c0 02          	add    $0x2,%rax
  8042119c32:	eb c6                	jmp    8042119bfa <LZ4_compress_fast_continue+0x236b>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042119c34:	48 83 45 a8 01       	addq   $0x1,-0x58(%rbp)
  8042119c39:	eb d6                	jmp    8042119c11 <LZ4_compress_fast_continue+0x2382>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119c3b:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  8042119c3e:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042119c45:	00 00 00 
  8042119c48:	ff d0                	call   *%rax
  8042119c4a:	89 c3                	mov    %eax,%ebx
  8042119c4c:	e9 ac 01 00 00       	jmp    8042119dfd <LZ4_compress_fast_continue+0x256e>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042119c51:	48 83 c3 08          	add    $0x8,%rbx
  8042119c55:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119c59:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8042119c5d:	48 39 cb             	cmp    %rcx,%rbx
  8042119c60:	0f 82 71 01 00 00    	jb     8042119dd7 <LZ4_compress_fast_continue+0x2548>
  8042119c66:	eb 08                	jmp    8042119c70 <LZ4_compress_fast_continue+0x23e1>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042119c68:	48 83 c0 04          	add    $0x4,%rax
  8042119c6c:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042119c70:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8042119c74:	48 8d 57 f8          	lea    -0x8(%rdi),%rdx
  8042119c78:	48 39 d3             	cmp    %rdx,%rbx
  8042119c7b:	73 06                	jae    8042119c83 <LZ4_compress_fast_continue+0x23f4>
  8042119c7d:	8b 08                	mov    (%rax),%ecx
  8042119c7f:	39 0b                	cmp    %ecx,(%rbx)
  8042119c81:	74 33                	je     8042119cb6 <LZ4_compress_fast_continue+0x2427>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119c83:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8042119c87:	48 8d 56 fa          	lea    -0x6(%rsi),%rdx
  8042119c8b:	48 39 d3             	cmp    %rdx,%rbx
  8042119c8e:	73 08                	jae    8042119c98 <LZ4_compress_fast_continue+0x2409>
  8042119c90:	0f b7 38             	movzwl (%rax),%edi
  8042119c93:	66 39 3b             	cmp    %di,(%rbx)
  8042119c96:	74 28                	je     8042119cc0 <LZ4_compress_fast_continue+0x2431>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042119c98:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
  8042119c9f:	48 39 cb             	cmp    %rcx,%rbx
  8042119ca2:	73 08                	jae    8042119cac <LZ4_compress_fast_continue+0x241d>
  8042119ca4:	0f b6 33             	movzbl (%rbx),%esi
  8042119ca7:	40 38 30             	cmp    %sil,(%rax)
  8042119caa:	74 1e                	je     8042119cca <LZ4_compress_fast_continue+0x243b>
    return (unsigned)(pIn - pStart);
  8042119cac:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042119caf:	29 c3                	sub    %eax,%ebx
  8042119cb1:	e9 47 01 00 00       	jmp    8042119dfd <LZ4_compress_fast_continue+0x256e>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  8042119cb6:	48 83 c3 04          	add    $0x4,%rbx
  8042119cba:	48 83 c0 04          	add    $0x4,%rax
  8042119cbe:	eb c3                	jmp    8042119c83 <LZ4_compress_fast_continue+0x23f4>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  8042119cc0:	48 83 c3 02          	add    $0x2,%rbx
  8042119cc4:	48 83 c0 02          	add    $0x2,%rax
  8042119cc8:	eb ce                	jmp    8042119c98 <LZ4_compress_fast_continue+0x2409>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  8042119cca:	48 83 c3 01          	add    $0x1,%rbx
  8042119cce:	eb dc                	jmp    8042119cac <LZ4_compress_fast_continue+0x241d>
                *token += ML_MASK;
  8042119cd0:	41 80 45 00 0f       	addb   $0xf,0x0(%r13)
                matchCode -= ML_MASK;
  8042119cd5:	83 eb 0f             	sub    $0xf,%ebx
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042119cd8:	41 c7 47 02 ff ff ff 	movl   $0xffffffff,0x2(%r15)
  8042119cdf:	ff 
                while (matchCode >= 4*255) {
  8042119ce0:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  8042119ce6:	76 1a                	jbe    8042119d02 <LZ4_compress_fast_continue+0x2473>
                    op+=4;
  8042119ce8:	49 83 c4 04          	add    $0x4,%r12
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  8042119cec:	41 c7 04 24 ff ff ff 	movl   $0xffffffff,(%r12)
  8042119cf3:	ff 
                    matchCode -= 4*255;
  8042119cf4:	81 eb fc 03 00 00    	sub    $0x3fc,%ebx
                while (matchCode >= 4*255) {
  8042119cfa:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  8042119d00:	77 e6                	ja     8042119ce8 <LZ4_compress_fast_continue+0x2459>
                op += matchCode / 255;
  8042119d02:	89 d8                	mov    %ebx,%eax
  8042119d04:	ba 81 80 80 80       	mov    $0x80808081,%edx
  8042119d09:	48 0f af c2          	imul   %rdx,%rax
  8042119d0d:	48 c1 e8 27          	shr    $0x27,%rax
  8042119d11:	89 c2                	mov    %eax,%edx
  8042119d13:	4c 01 e2             	add    %r12,%rdx
                *op++ = (BYTE)(matchCode % 255);
  8042119d16:	4c 8d 6a 01          	lea    0x1(%rdx),%r13
  8042119d1a:	89 c1                	mov    %eax,%ecx
  8042119d1c:	c1 e1 08             	shl    $0x8,%ecx
  8042119d1f:	29 c1                	sub    %eax,%ecx
  8042119d21:	29 cb                	sub    %ecx,%ebx
  8042119d23:	88 1a                	mov    %bl,(%rdx)
  8042119d25:	e9 0f 01 00 00       	jmp    8042119e39 <LZ4_compress_fast_continue+0x25aa>
  8042119d2a:	4c 89 ad 48 ff ff ff 	mov    %r13,-0xb8(%rbp)
        forwardH = LZ4_hashPosition(++ip, tableType);
  8042119d31:	49 8d 5e 01          	lea    0x1(%r14),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042119d35:	49 8b 7e 01          	mov    0x1(%r14),%rdi
  8042119d39:	be 02 00 00 00       	mov    $0x2,%esi
  8042119d3e:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  8042119d45:	00 00 00 
  8042119d48:	ff d0                	call   *%rax
  8042119d4a:	4c 89 f6             	mov    %r14,%rsi
  8042119d4d:	49 89 de             	mov    %rbx,%r14
  8042119d50:	e9 66 fa ff ff       	jmp    80421197bb <LZ4_compress_fast_continue+0x1f2c>
                    match = base + matchIndex;
  8042119d55:	89 c8                	mov    %ecx,%eax
  8042119d57:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
  8042119d5b:	48 01 d8             	add    %rbx,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042119d5e:	89 16                	mov    %edx,(%rsi)
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
  8042119d60:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  8042119d67:	8d b9 ff ff 00 00    	lea    0xffff(%rcx),%edi
  8042119d6d:	39 d7                	cmp    %edx,%edi
  8042119d6f:	0f 82 46 01 00 00    	jb     8042119ebb <LZ4_compress_fast_continue+0x262c>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  8042119d75:	8b 38                	mov    (%rax),%edi
  8042119d77:	41 39 3e             	cmp    %edi,(%r14)
  8042119d7a:	0f 85 47 01 00 00    	jne    8042119ec7 <LZ4_compress_fast_continue+0x2638>
                token=op++;
  8042119d80:	4d 8d 7d 01          	lea    0x1(%r13),%r15
                *token=0;
  8042119d84:	41 c6 45 00 00       	movb   $0x0,0x0(%r13)
                if (maybe_extMem) offset = current - matchIndex;
  8042119d89:	29 ca                	sub    %ecx,%edx
static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
  8042119d8b:	66 41 89 17          	mov    %dx,(%r15)
            LZ4_writeLE16(op, (U16)offset); op+=2;
  8042119d8f:	4d 8d 67 02          	lea    0x2(%r15),%r12
                 && (lowLimit==dictionary) /* match within extDict */ ) {
  8042119d93:	48 39 b5 68 ff ff ff 	cmp    %rsi,-0x98(%rbp)
  8042119d9a:	0f 84 54 fc ff ff    	je     80421199f4 <LZ4_compress_fast_continue+0x2165>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  8042119da0:	49 8d 5e 04          	lea    0x4(%r14),%rbx
  8042119da4:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119da8:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  8042119dac:	48 39 f3             	cmp    %rsi,%rbx
  8042119daf:	0f 83 b3 fe ff ff    	jae    8042119c68 <LZ4_compress_fast_continue+0x23d9>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119db5:	48 8b 50 04          	mov    0x4(%rax),%rdx
  8042119db9:	49 8b 7e 04          	mov    0x4(%r14),%rdi
        if (!diff) {
  8042119dbd:	48 39 d7             	cmp    %rdx,%rdi
  8042119dc0:	0f 85 75 fe ff ff    	jne    8042119c3b <LZ4_compress_fast_continue+0x23ac>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  8042119dc6:	49 8d 5e 0c          	lea    0xc(%r14),%rbx
  8042119dca:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  8042119dce:	48 39 f3             	cmp    %rsi,%rbx
  8042119dd1:	0f 83 99 fe ff ff    	jae    8042119c70 <LZ4_compress_fast_continue+0x23e1>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  8042119dd7:	48 8b 10             	mov    (%rax),%rdx
  8042119dda:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  8042119ddd:	48 39 d7             	cmp    %rdx,%rdi
  8042119de0:	0f 84 6b fe ff ff    	je     8042119c51 <LZ4_compress_fast_continue+0x23c2>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  8042119de6:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  8042119de9:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  8042119df0:	00 00 00 
  8042119df3:	ff d0                	call   *%rax
  8042119df5:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  8042119df8:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8042119dfb:	29 c3                	sub    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  8042119dfd:	89 d8                	mov    %ebx,%eax
  8042119dff:	4d 8d 74 06 04       	lea    0x4(%r14,%rax,1),%r14
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  8042119e04:	8d 83 f0 00 00 00    	lea    0xf0(%rbx),%eax
  8042119e0a:	be 81 80 80 80       	mov    $0x80808081,%esi
  8042119e0f:	48 0f af c6          	imul   %rsi,%rax
  8042119e13:	48 c1 e8 27          	shr    $0x27,%rax
  8042119e17:	49 8d 44 04 06       	lea    0x6(%r12,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  8042119e1c:	48 39 85 50 ff ff ff 	cmp    %rax,-0xb0(%rbp)
  8042119e23:	0f 82 00 0b 00 00    	jb     804211a929 <LZ4_compress_fast_continue+0x309a>
            if (matchCode >= ML_MASK) {
  8042119e29:	83 fb 0e             	cmp    $0xe,%ebx
  8042119e2c:	0f 87 9e fe ff ff    	ja     8042119cd0 <LZ4_compress_fast_continue+0x2441>
                *token += (BYTE)(matchCode);
  8042119e32:	41 00 5d 00          	add    %bl,0x0(%r13)
  8042119e36:	4d 89 e5             	mov    %r12,%r13
        if (ip >= mflimitPlusOne) break;
  8042119e39:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8042119e3d:	49 39 c6             	cmp    %rax,%r14
  8042119e40:	0f 83 9e 00 00 00    	jae    8042119ee4 <LZ4_compress_fast_continue+0x2655>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042119e46:	49 8b 7e fe          	mov    -0x2(%r14),%rdi
  8042119e4a:	be 02 00 00 00       	mov    $0x2,%esi
  8042119e4f:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  8042119e56:	00 00 00 
  8042119e59:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042119e5b:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  8042119e5d:	49 8d 56 fe          	lea    -0x2(%r14),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  8042119e61:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
  8042119e65:	4c 29 fa             	sub    %r15,%rdx
  8042119e68:	4c 8b 65 88          	mov    -0x78(%rbp),%r12
  8042119e6c:	41 89 14 84          	mov    %edx,(%r12,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  8042119e70:	49 8b 3e             	mov    (%r14),%rdi
  8042119e73:	be 02 00 00 00       	mov    $0x2,%esi
  8042119e78:	ff d3                	call   *%rbx
            U32 const current = (U32)(ip-base);
  8042119e7a:	4c 89 f2             	mov    %r14,%rdx
  8042119e7d:	4c 29 fa             	sub    %r15,%rdx
        return hashTable[h];
  8042119e80:	89 c0                	mov    %eax,%eax
  8042119e82:	49 8d 34 84          	lea    (%r12,%rax,4),%rsi
  8042119e86:	8b 0e                	mov    (%rsi),%ecx
                if (matchIndex < startIndex) {
  8042119e88:	8b 45 98             	mov    -0x68(%rbp),%eax
  8042119e8b:	39 c1                	cmp    %eax,%ecx
  8042119e8d:	0f 83 c2 fe ff ff    	jae    8042119d55 <LZ4_compress_fast_continue+0x24c6>
                    match = dictBase + matchIndex;
  8042119e93:	89 c8                	mov    %ecx,%eax
  8042119e95:	48 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%rbx
  8042119e9c:	48 01 d8             	add    %rbx,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  8042119e9f:	89 16                	mov    %edx,(%rsi)
            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)
  8042119ea1:	8b 9d 78 ff ff ff    	mov    -0x88(%rbp),%ebx
  8042119ea7:	39 d9                	cmp    %ebx,%ecx
  8042119ea9:	0f 82 7b fe ff ff    	jb     8042119d2a <LZ4_compress_fast_continue+0x249b>
  8042119eaf:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  8042119eb6:	e9 ac fe ff ff       	jmp    8042119d67 <LZ4_compress_fast_continue+0x24d8>
  8042119ebb:	4c 89 ad 48 ff ff ff 	mov    %r13,-0xb8(%rbp)
  8042119ec2:	e9 6a fe ff ff       	jmp    8042119d31 <LZ4_compress_fast_continue+0x24a2>
  8042119ec7:	4c 89 ad 48 ff ff ff 	mov    %r13,-0xb8(%rbp)
  8042119ece:	e9 5e fe ff ff       	jmp    8042119d31 <LZ4_compress_fast_continue+0x24a2>
    BYTE* op = (BYTE*) dest;
  8042119ed3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042119ed7:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  8042119ede:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8042119ee2:	eb 36                	jmp    8042119f1a <LZ4_compress_fast_continue+0x268b>
        anchor = ip;
  8042119ee4:	4c 89 ad 48 ff ff ff 	mov    %r13,-0xb8(%rbp)
  8042119eeb:	4c 89 f6             	mov    %r14,%rsi
  8042119eee:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
  8042119ef2:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
  8042119ef9:	eb 1f                	jmp    8042119f1a <LZ4_compress_fast_continue+0x268b>
  8042119efb:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
  8042119eff:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
  8042119f06:	eb 12                	jmp    8042119f1a <LZ4_compress_fast_continue+0x268b>
  8042119f08:	48 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%rsi
  8042119f0f:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
  8042119f13:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
    {   size_t lastRun = (size_t)(iend - anchor);
  8042119f1a:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  8042119f1e:	49 29 f4             	sub    %rsi,%r12
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  8042119f21:	49 8d 94 24 f0 00 00 	lea    0xf0(%r12),%rdx
  8042119f28:	00 
  8042119f29:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  8042119f30:	80 80 80 
  8042119f33:	48 89 d0             	mov    %rdx,%rax
  8042119f36:	48 f7 e1             	mul    %rcx
  8042119f39:	48 c1 ea 07          	shr    $0x7,%rdx
  8042119f3d:	49 8d 54 14 01       	lea    0x1(%r12,%rdx,1),%rdx
  8042119f42:	48 8b 9d 48 ff ff ff 	mov    -0xb8(%rbp),%rbx
  8042119f49:	48 01 da             	add    %rbx,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  8042119f4c:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  8042119f51:	48 39 95 50 ff ff ff 	cmp    %rdx,-0xb0(%rbp)
  8042119f58:	0f 82 fe f6 ff ff    	jb     804211965c <LZ4_compress_fast_continue+0x1dcd>
        if (lastRun >= RUN_MASK) {
  8042119f5e:	49 83 fc 0e          	cmp    $0xe,%r12
  8042119f62:	76 53                	jbe    8042119fb7 <LZ4_compress_fast_continue+0x2728>
            size_t accumulator = lastRun - RUN_MASK;
  8042119f64:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  8042119f69:	48 8d 43 01          	lea    0x1(%rbx),%rax
  8042119f6d:	c6 03 f0             	movb   $0xf0,(%rbx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  8042119f70:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042119f77:	76 18                	jbe    8042119f91 <LZ4_compress_fast_continue+0x2702>
  8042119f79:	48 83 c0 01          	add    $0x1,%rax
  8042119f7d:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  8042119f81:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  8042119f88:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  8042119f8f:	77 e8                	ja     8042119f79 <LZ4_compress_fast_continue+0x26ea>
            *op++ = (BYTE) accumulator;
  8042119f91:	48 8d 58 01          	lea    0x1(%rax),%rbx
  8042119f95:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  8042119f97:	4c 89 e2             	mov    %r12,%rdx
  8042119f9a:	48 89 df             	mov    %rbx,%rdi
  8042119f9d:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  8042119fa4:	00 00 00 
  8042119fa7:	ff d0                	call   *%rax
        op += lastRun;
  8042119fa9:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
    result = (int)(((char*)op) - dest);
  8042119fad:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  8042119fb0:	29 d8                	sub    %ebx,%eax
    return result;
  8042119fb2:	e9 a5 f6 ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  8042119fb7:	48 8b 8d 48 ff ff ff 	mov    -0xb8(%rbp),%rcx
  8042119fbe:	48 8d 59 01          	lea    0x1(%rcx),%rbx
  8042119fc2:	44 89 e0             	mov    %r12d,%eax
  8042119fc5:	c1 e0 04             	shl    $0x4,%eax
  8042119fc8:	88 01                	mov    %al,(%rcx)
  8042119fca:	eb cb                	jmp    8042119f97 <LZ4_compress_fast_continue+0x2708>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  8042119fcc:	b8 00 00 00 00       	mov    $0x0,%eax
  8042119fd1:	41 81 ff 00 00 00 7e 	cmp    $0x7e000000,%r15d
  8042119fd8:	0f 87 7e f6 ff ff    	ja     804211965c <LZ4_compress_fast_continue+0x1dcd>
    U32 const startIndex = cctx->currentOffset;
  8042119fde:	41 8b b6 00 40 00 00 	mov    0x4000(%r14),%esi
            dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
  8042119fe5:	49 8b be 08 40 00 00 	mov    0x4008(%r14),%rdi
  8042119fec:	48 89 bd 70 ff ff ff 	mov    %rdi,-0x90(%rbp)
    BYTE* const olimit = op + maxOutputSize;
  8042119ff3:	4d 63 e4             	movslq %r12d,%r12
  8042119ff6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8042119ffa:	4e 8d 1c 20          	lea    (%rax,%r12,1),%r11
  8042119ffe:	4c 89 9d 60 ff ff ff 	mov    %r11,-0xa0(%rbp)
        cctx->dictSize += (U32)inputSize;
  804211a005:	42 8d 04 3a          	lea    (%rdx,%r15,1),%eax
  804211a009:	41 89 86 18 40 00 00 	mov    %eax,0x4018(%r14)
    cctx->currentOffset += (U32)inputSize;
  804211a010:	42 8d 04 3e          	lea    (%rsi,%r15,1),%eax
  804211a014:	41 89 86 00 40 00 00 	mov    %eax,0x4000(%r14)
    cctx->tableType = (U16)tableType;
  804211a01b:	66 41 c7 86 06 40 00 	movw   $0x2,0x4006(%r14)
  804211a022:	00 02 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  804211a025:	41 83 ff 0c          	cmp    $0xc,%r15d
  804211a029:	0f 8e 97 07 00 00    	jle    804211a7c6 <LZ4_compress_fast_continue+0x2f37>
    const BYTE* base = (const BYTE*) source - startIndex;
  804211a02f:	89 75 88             	mov    %esi,-0x78(%rbp)
  804211a032:	89 f0                	mov    %esi,%eax
  804211a034:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
  804211a038:	4c 89 e9             	mov    %r13,%rcx
  804211a03b:	48 29 c1             	sub    %rax,%rcx
  804211a03e:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    const BYTE* const dictEnd = dictionary + dictSize;
  804211a042:	89 d2                	mov    %edx,%edx
  804211a044:	4c 8d 1c 17          	lea    (%rdi,%rdx,1),%r11
  804211a048:	4c 89 9d 20 ff ff ff 	mov    %r11,-0xe0(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  804211a04f:	4c 8b 5d b8          	mov    -0x48(%rbp),%r11
  804211a053:	4d 8d 53 f5          	lea    -0xb(%r11),%r10
  804211a057:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  804211a05b:	49 83 eb 05          	sub    $0x5,%r11
  804211a05f:	4c 89 9d 28 ff ff ff 	mov    %r11,-0xd8(%rbp)
                           dictionary + dictSize - startIndex;
  804211a066:	48 29 c2             	sub    %rax,%rdx
                           dictionary + dictSize - dictCtx->currentOffset :
  804211a069:	48 01 d7             	add    %rdx,%rdi
  804211a06c:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211a073:	49 8b 7d 00          	mov    0x0(%r13),%rdi
  804211a077:	be 02 00 00 00       	mov    $0x2,%esi
  804211a07c:	49 bc ce 28 11 42 80 	movabs $0x80421128ce,%r12
  804211a083:	00 00 00 
  804211a086:	41 ff d4             	call   *%r12
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211a089:	89 c0                	mov    %eax,%eax
  804211a08b:	8b 75 88             	mov    -0x78(%rbp),%esi
  804211a08e:	41 89 34 86          	mov    %esi,(%r14,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  804211a092:	49 8d 75 01          	lea    0x1(%r13),%rsi
  804211a096:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211a09a:	49 8b 7d 01          	mov    0x1(%r13),%rdi
  804211a09e:	be 02 00 00 00       	mov    $0x2,%esi
  804211a0a3:	41 ff d4             	call   *%r12
            int searchMatchNb = acceleration << LZ4_skipTrigger;
  804211a0a6:	c1 e3 06             	shl    $0x6,%ebx
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211a0a9:	8d 7b 01             	lea    0x1(%rbx),%edi
  804211a0ac:	89 bd 40 ff ff ff    	mov    %edi,-0xc0(%rbp)
  804211a0b2:	c1 fb 06             	sar    $0x6,%ebx
  804211a0b5:	89 9d 38 ff ff ff    	mov    %ebx,-0xc8(%rbp)
  804211a0bb:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  804211a0bf:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  804211a0c6:	4c 89 ee             	mov    %r13,%rsi
  804211a0c9:	4c 89 75 90          	mov    %r14,-0x70(%rbp)
  804211a0cd:	44 89 bd 48 ff ff ff 	mov    %r15d,-0xb8(%rbp)
  804211a0d4:	4c 8b 7d b0          	mov    -0x50(%rbp),%r15
                U32 const current = (U32)(forwardIp - base);
  804211a0d8:	45 89 fc             	mov    %r15d,%r12d
  804211a0db:	8b 5d a8             	mov    -0x58(%rbp),%ebx
  804211a0de:	41 29 dc             	sub    %ebx,%r12d
        return hashTable[h];
  804211a0e1:	89 c0                	mov    %eax,%eax
  804211a0e3:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  804211a0e7:	4c 8d 34 83          	lea    (%rbx,%rax,4),%r14
  804211a0eb:	45 8b 2e             	mov    (%r14),%r13d
                forwardIp += step;
  804211a0ee:	49 8d 5f 01          	lea    0x1(%r15),%rbx
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  804211a0f2:	48 39 5d 80          	cmp    %rbx,-0x80(%rbp)
  804211a0f6:	0f 82 f2 06 00 00    	jb     804211a7ee <LZ4_compress_fast_continue+0x2f5f>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211a0fc:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  804211a102:	89 45 b0             	mov    %eax,-0x50(%rbp)
  804211a105:	8b 85 40 ff ff ff    	mov    -0xc0(%rbp),%eax
  804211a10b:	89 45 a0             	mov    %eax,-0x60(%rbp)
                        lowLimit = (const BYTE*)source;
  804211a10e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211a112:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  804211a119:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
  804211a11d:	48 89 b5 30 ff ff ff 	mov    %rsi,-0xd0(%rbp)
  804211a124:	e9 83 00 00 00       	jmp    804211a1ac <LZ4_compress_fast_continue+0x291d>
                        match = base + matchIndex;
  804211a129:	45 89 ef             	mov    %r13d,%r15d
  804211a12c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211a130:	49 01 c7             	add    %rax,%r15
                        lowLimit = (const BYTE*)source;
  804211a133:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  804211a13a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211a141:	48 8b 3b             	mov    (%rbx),%rdi
  804211a144:	be 02 00 00 00       	mov    $0x2,%esi
  804211a149:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211a150:	00 00 00 
  804211a153:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211a155:	45 89 26             	mov    %r12d,(%r14)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  804211a158:	41 8d 95 ff ff 00 00 	lea    0xffff(%r13),%edx
  804211a15f:	44 39 e2             	cmp    %r12d,%edx
  804211a162:	72 0b                	jb     804211a16f <LZ4_compress_fast_continue+0x28e0>
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  804211a164:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  804211a168:	41 8b 0f             	mov    (%r15),%ecx
  804211a16b:	39 0f                	cmp    %ecx,(%rdi)
  804211a16d:	74 69                	je     804211a1d8 <LZ4_compress_fast_continue+0x2949>
                U32 const current = (U32)(forwardIp - base);
  804211a16f:	41 89 dc             	mov    %ebx,%r12d
  804211a172:	8b 7d a8             	mov    -0x58(%rbp),%edi
  804211a175:	41 29 fc             	sub    %edi,%r12d
        return hashTable[h];
  804211a178:	89 c0                	mov    %eax,%eax
  804211a17a:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  804211a17e:	4c 8d 34 86          	lea    (%rsi,%rax,4),%r14
  804211a182:	45 8b 2e             	mov    (%r14),%r13d
                forwardIp += step;
  804211a185:	48 63 45 b0          	movslq -0x50(%rbp),%rax
  804211a189:	48 01 d8             	add    %rbx,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211a18c:	8b 75 a0             	mov    -0x60(%rbp),%esi
  804211a18f:	8d 56 01             	lea    0x1(%rsi),%edx
  804211a192:	c1 fe 06             	sar    $0x6,%esi
  804211a195:	89 75 b0             	mov    %esi,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  804211a198:	48 89 5d 98          	mov    %rbx,-0x68(%rbp)
  804211a19c:	48 39 45 80          	cmp    %rax,-0x80(%rbp)
  804211a1a0:	0f 82 55 06 00 00    	jb     804211a7fb <LZ4_compress_fast_continue+0x2f6c>
  804211a1a6:	89 55 a0             	mov    %edx,-0x60(%rbp)
  804211a1a9:	48 89 c3             	mov    %rax,%rbx
                    if (matchIndex < startIndex) {
  804211a1ac:	8b 45 88             	mov    -0x78(%rbp),%eax
  804211a1af:	41 39 c5             	cmp    %eax,%r13d
  804211a1b2:	0f 83 71 ff ff ff    	jae    804211a129 <LZ4_compress_fast_continue+0x289a>
                        match = dictBase + matchIndex;
  804211a1b8:	45 89 ef             	mov    %r13d,%r15d
  804211a1bb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  804211a1c2:	49 01 c7             	add    %rax,%r15
                        lowLimit = dictionary;
  804211a1c5:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  804211a1cc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  804211a1d3:	e9 69 ff ff ff       	jmp    804211a141 <LZ4_compress_fast_continue+0x28b2>
                    if (maybe_extMem) offset = current - matchIndex;
  804211a1d8:	4c 89 f8             	mov    %r15,%rax
  804211a1db:	4c 89 7d b0          	mov    %r15,-0x50(%rbp)
  804211a1df:	49 89 ff             	mov    %rdi,%r15
  804211a1e2:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
  804211a1e9:	45 29 ec             	sub    %r13d,%r12d
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211a1ec:	48 39 fe             	cmp    %rdi,%rsi
  804211a1ef:	73 1b                	jae    804211a20c <LZ4_compress_fast_continue+0x297d>
  804211a1f1:	48 39 85 78 ff ff ff 	cmp    %rax,-0x88(%rbp)
  804211a1f8:	73 12                	jae    804211a20c <LZ4_compress_fast_continue+0x297d>
  804211a1fa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211a1fe:	0f b6 40 ff          	movzbl -0x1(%rax),%eax
  804211a202:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  804211a206:	0f 84 87 00 00 00    	je     804211a293 <LZ4_compress_fast_continue+0x2a04>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  804211a20c:	4c 89 f8             	mov    %r15,%rax
  804211a20f:	48 29 f0             	sub    %rsi,%rax
            token = op++;
  804211a212:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  804211a219:	48 83 c7 01          	add    $0x1,%rdi
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
  804211a21d:	89 c1                	mov    %eax,%ecx
  804211a21f:	89 c2                	mov    %eax,%edx
  804211a221:	41 b8 81 80 80 80    	mov    $0x80808081,%r8d
  804211a227:	49 0f af d0          	imul   %r8,%rdx
  804211a22b:	48 c1 ea 27          	shr    $0x27,%rdx
  804211a22f:	48 8d 54 11 08       	lea    0x8(%rcx,%rdx,1),%rdx
  804211a234:	48 01 fa             	add    %rdi,%rdx
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
  804211a237:	48 39 95 60 ff ff ff 	cmp    %rdx,-0xa0(%rbp)
  804211a23e:	0f 82 fa 06 00 00    	jb     804211a93e <LZ4_compress_fast_continue+0x30af>
            if (litLength >= RUN_MASK) {
  804211a244:	83 f8 0e             	cmp    $0xe,%eax
  804211a247:	77 72                	ja     804211a2bb <LZ4_compress_fast_continue+0x2a2c>
            else *token = (BYTE)(litLength<<ML_BITS);
  804211a249:	c1 e0 04             	shl    $0x4,%eax
  804211a24c:	48 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%rbx
  804211a253:	88 03                	mov    %al,(%rbx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  804211a255:	4c 8d 34 0f          	lea    (%rdi,%rcx,1),%r14
  804211a259:	4c 89 f2             	mov    %r14,%rdx
  804211a25c:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211a263:	00 00 00 
  804211a266:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a268:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211a26c:	48 83 e8 0c          	sub    $0xc,%rax
  804211a270:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
  804211a274:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211a278:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  804211a27c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211a280:	4c 8b ad 50 ff ff ff 	mov    -0xb0(%rbp),%r13
  804211a287:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  804211a28e:	e9 b5 03 00 00       	jmp    804211a648 <LZ4_compress_fast_continue+0x2db9>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211a293:	49 83 ef 01          	sub    $0x1,%r15
  804211a297:	48 83 6d b0 01       	subq   $0x1,-0x50(%rbp)
  804211a29c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211a2a0:	4c 39 fe             	cmp    %r15,%rsi
  804211a2a3:	0f 83 63 ff ff ff    	jae    804211a20c <LZ4_compress_fast_continue+0x297d>
  804211a2a9:	48 39 85 78 ff ff ff 	cmp    %rax,-0x88(%rbp)
  804211a2b0:	0f 82 44 ff ff ff    	jb     804211a1fa <LZ4_compress_fast_continue+0x296b>
  804211a2b6:	e9 51 ff ff ff       	jmp    804211a20c <LZ4_compress_fast_continue+0x297d>
                int len = (int)(litLength - RUN_MASK);
  804211a2bb:	83 e8 0f             	sub    $0xf,%eax
                *token = (RUN_MASK<<ML_BITS);
  804211a2be:	48 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%rbx
  804211a2c5:	c6 03 f0             	movb   $0xf0,(%rbx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  804211a2c8:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211a2cd:	7e 14                	jle    804211a2e3 <LZ4_compress_fast_continue+0x2a54>
  804211a2cf:	48 83 c7 01          	add    $0x1,%rdi
  804211a2d3:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  804211a2d7:	2d ff 00 00 00       	sub    $0xff,%eax
  804211a2dc:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211a2e1:	7f ec                	jg     804211a2cf <LZ4_compress_fast_continue+0x2a40>
                *op++ = (BYTE)len;
  804211a2e3:	88 07                	mov    %al,(%rdi)
  804211a2e5:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  804211a2e9:	e9 67 ff ff ff       	jmp    804211a255 <LZ4_compress_fast_continue+0x29c6>
                const BYTE* limit = ip + (dictEnd-match);
  804211a2ee:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  804211a2f5:	48 29 c2             	sub    %rax,%rdx
  804211a2f8:	4c 01 fa             	add    %r15,%rdx
                if (limit > matchlimit) limit = matchlimit;
  804211a2fb:	48 8b 9d 28 ff ff ff 	mov    -0xd8(%rbp),%rbx
  804211a302:	48 39 d3             	cmp    %rdx,%rbx
  804211a305:	48 0f 46 d3          	cmovbe %rbx,%rdx
  804211a309:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  804211a30d:	49 8d 77 04          	lea    0x4(%r15),%rsi
  804211a311:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a318:	48 83 ea 07          	sub    $0x7,%rdx
  804211a31c:	48 39 d6             	cmp    %rdx,%rsi
  804211a31f:	0f 83 0c 01 00 00    	jae    804211a431 <LZ4_compress_fast_continue+0x2ba2>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211a325:	48 8b 48 04          	mov    0x4(%rax),%rcx
  804211a329:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211a32d:	48 39 cf             	cmp    %rcx,%rdi
  804211a330:	0f 85 d2 00 00 00    	jne    804211a408 <LZ4_compress_fast_continue+0x2b79>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211a336:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  804211a33a:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a33e:	48 39 d3             	cmp    %rdx,%rbx
  804211a341:	0f 83 f5 00 00 00    	jae    804211a43c <LZ4_compress_fast_continue+0x2bad>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211a347:	48 8b 08             	mov    (%rax),%rcx
  804211a34a:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211a34d:	48 39 cf             	cmp    %rcx,%rdi
  804211a350:	0f 84 c8 00 00 00    	je     804211a41e <LZ4_compress_fast_continue+0x2b8f>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211a356:	48 31 cf             	xor    %rcx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211a359:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211a360:	00 00 00 
  804211a363:	ff d0                	call   *%rax
  804211a365:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  804211a368:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  804211a36e:	29 c3                	sub    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  804211a370:	89 d8                	mov    %ebx,%eax
  804211a372:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                if (ip==limit) {
  804211a377:	4c 39 7d b0          	cmp    %r15,-0x50(%rbp)
  804211a37b:	0f 85 f9 01 00 00    	jne    804211a57a <LZ4_compress_fast_continue+0x2ceb>
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a381:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211a385:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  804211a389:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211a38d:	48 39 d7             	cmp    %rdx,%rdi
  804211a390:	0f 83 37 01 00 00    	jae    804211a4cd <LZ4_compress_fast_continue+0x2c3e>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211a396:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211a39a:	48 8b 0e             	mov    (%rsi),%rcx
  804211a39d:	48 8b 07             	mov    (%rdi),%rax
        if (!diff) {
  804211a3a0:	48 39 c8             	cmp    %rcx,%rax
  804211a3a3:	0f 85 f3 00 00 00    	jne    804211a49c <LZ4_compress_fast_continue+0x2c0d>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211a3a9:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
  804211a3ad:	48 89 8d 78 ff ff ff 	mov    %rcx,-0x88(%rbp)
  804211a3b4:	48 8d 46 08          	lea    0x8(%rsi),%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a3b8:	48 39 d1             	cmp    %rdx,%rcx
  804211a3bb:	0f 83 1b 01 00 00    	jae    804211a4dc <LZ4_compress_fast_continue+0x2c4d>
  804211a3c1:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211a3c8:	48 8b 08             	mov    (%rax),%rcx
  804211a3cb:	48 8b 3e             	mov    (%rsi),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211a3ce:	48 39 cf             	cmp    %rcx,%rdi
  804211a3d1:	0f 84 dc 00 00 00    	je     804211a4b3 <LZ4_compress_fast_continue+0x2c24>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211a3d7:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
  804211a3de:	48 31 cf             	xor    %rcx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211a3e1:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211a3e8:	00 00 00 
  804211a3eb:	ff d0                	call   *%rax
  804211a3ed:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  804211a3f4:	8d 04 30             	lea    (%rax,%rsi,1),%eax
        return (unsigned)(pIn - pStart);
  804211a3f7:	8b 7d b0             	mov    -0x50(%rbp),%edi
  804211a3fa:	29 f8                	sub    %edi,%eax
                    matchCode += more;
  804211a3fc:	01 c3                	add    %eax,%ebx
                    ip += more;
  804211a3fe:	89 c0                	mov    %eax,%eax
  804211a400:	49 01 c7             	add    %rax,%r15
  804211a403:	e9 72 01 00 00       	jmp    804211a57a <LZ4_compress_fast_continue+0x2ceb>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211a408:	48 31 cf             	xor    %rcx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211a40b:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211a412:	00 00 00 
  804211a415:	ff d0                	call   *%rax
  804211a417:	89 c3                	mov    %eax,%ebx
  804211a419:	e9 52 ff ff ff       	jmp    804211a370 <LZ4_compress_fast_continue+0x2ae1>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211a41e:	48 83 c3 08          	add    $0x8,%rbx
  804211a422:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a426:	48 39 d3             	cmp    %rdx,%rbx
  804211a429:	0f 82 18 ff ff ff    	jb     804211a347 <LZ4_compress_fast_continue+0x2ab8>
  804211a42f:	eb 0b                	jmp    804211a43c <LZ4_compress_fast_continue+0x2bad>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  804211a431:	48 83 c0 04          	add    $0x4,%rax
  804211a435:	48 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211a43c:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211a440:	48 8d 57 fd          	lea    -0x3(%rdi),%rdx
  804211a444:	48 39 d3             	cmp    %rdx,%rbx
  804211a447:	73 06                	jae    804211a44f <LZ4_compress_fast_continue+0x2bc0>
  804211a449:	8b 08                	mov    (%rax),%ecx
  804211a44b:	39 0b                	cmp    %ecx,(%rbx)
  804211a44d:	74 33                	je     804211a482 <LZ4_compress_fast_continue+0x2bf3>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211a44f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211a453:	48 8d 56 ff          	lea    -0x1(%rsi),%rdx
  804211a457:	48 39 d3             	cmp    %rdx,%rbx
  804211a45a:	73 08                	jae    804211a464 <LZ4_compress_fast_continue+0x2bd5>
  804211a45c:	0f b7 38             	movzwl (%rax),%edi
  804211a45f:	66 39 3b             	cmp    %di,(%rbx)
  804211a462:	74 28                	je     804211a48c <LZ4_compress_fast_continue+0x2bfd>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211a464:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  804211a468:	48 39 cb             	cmp    %rcx,%rbx
  804211a46b:	73 08                	jae    804211a475 <LZ4_compress_fast_continue+0x2be6>
  804211a46d:	0f b6 33             	movzbl (%rbx),%esi
  804211a470:	40 38 30             	cmp    %sil,(%rax)
  804211a473:	74 21                	je     804211a496 <LZ4_compress_fast_continue+0x2c07>
    return (unsigned)(pIn - pStart);
  804211a475:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  804211a47b:	29 c3                	sub    %eax,%ebx
  804211a47d:	e9 ee fe ff ff       	jmp    804211a370 <LZ4_compress_fast_continue+0x2ae1>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211a482:	48 83 c3 04          	add    $0x4,%rbx
  804211a486:	48 83 c0 04          	add    $0x4,%rax
  804211a48a:	eb c3                	jmp    804211a44f <LZ4_compress_fast_continue+0x2bc0>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211a48c:	48 83 c3 02          	add    $0x2,%rbx
  804211a490:	48 83 c0 02          	add    $0x2,%rax
  804211a494:	eb ce                	jmp    804211a464 <LZ4_compress_fast_continue+0x2bd5>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211a496:	48 83 c3 01          	add    $0x1,%rbx
  804211a49a:	eb d9                	jmp    804211a475 <LZ4_compress_fast_continue+0x2be6>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211a49c:	48 31 c8             	xor    %rcx,%rax
  804211a49f:	48 89 c7             	mov    %rax,%rdi
            return LZ4_NbCommonBytes(diff);
  804211a4a2:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211a4a9:	00 00 00 
  804211a4ac:	ff d0                	call   *%rax
  804211a4ae:	e9 49 ff ff ff       	jmp    804211a3fc <LZ4_compress_fast_continue+0x2b6d>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211a4b3:	48 83 c6 08          	add    $0x8,%rsi
  804211a4b7:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a4bb:	48 39 d6             	cmp    %rdx,%rsi
  804211a4be:	0f 82 04 ff ff ff    	jb     804211a3c8 <LZ4_compress_fast_continue+0x2b39>
  804211a4c4:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
  804211a4cb:	eb 0f                	jmp    804211a4dc <LZ4_compress_fast_continue+0x2c4d>
  804211a4cd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211a4d1:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  804211a4d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211a4dc:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804211a4e0:	48 8d 57 f8          	lea    -0x8(%rdi),%rdx
  804211a4e4:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
  804211a4eb:	48 39 d7             	cmp    %rdx,%rdi
  804211a4ee:	73 06                	jae    804211a4f6 <LZ4_compress_fast_continue+0x2c67>
  804211a4f0:	8b 08                	mov    (%rax),%ecx
  804211a4f2:	39 0f                	cmp    %ecx,(%rdi)
  804211a4f4:	74 46                	je     804211a53c <LZ4_compress_fast_continue+0x2cad>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211a4f6:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804211a4fa:	48 8d 56 fa          	lea    -0x6(%rsi),%rdx
  804211a4fe:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  804211a505:	48 39 d6             	cmp    %rdx,%rsi
  804211a508:	73 08                	jae    804211a512 <LZ4_compress_fast_continue+0x2c83>
  804211a50a:	0f b7 38             	movzwl (%rax),%edi
  804211a50d:	66 39 3e             	cmp    %di,(%rsi)
  804211a510:	74 38                	je     804211a54a <LZ4_compress_fast_continue+0x2cbb>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211a512:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
  804211a519:	48 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%rsi
  804211a520:	48 39 f1             	cmp    %rsi,%rcx
  804211a523:	73 07                	jae    804211a52c <LZ4_compress_fast_continue+0x2c9d>
  804211a525:	0f b6 09             	movzbl (%rcx),%ecx
  804211a528:	38 08                	cmp    %cl,(%rax)
  804211a52a:	74 2c                	je     804211a558 <LZ4_compress_fast_continue+0x2cc9>
    return (unsigned)(pIn - pStart);
  804211a52c:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  804211a532:	8b 7d b0             	mov    -0x50(%rbp),%edi
  804211a535:	29 f8                	sub    %edi,%eax
  804211a537:	e9 c0 fe ff ff       	jmp    804211a3fc <LZ4_compress_fast_continue+0x2b6d>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211a53c:	48 83 85 78 ff ff ff 	addq   $0x4,-0x88(%rbp)
  804211a543:	04 
  804211a544:	48 83 c0 04          	add    $0x4,%rax
  804211a548:	eb ac                	jmp    804211a4f6 <LZ4_compress_fast_continue+0x2c67>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211a54a:	48 83 85 78 ff ff ff 	addq   $0x2,-0x88(%rbp)
  804211a551:	02 
  804211a552:	48 83 c0 02          	add    $0x2,%rax
  804211a556:	eb ba                	jmp    804211a512 <LZ4_compress_fast_continue+0x2c83>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211a558:	48 83 85 78 ff ff ff 	addq   $0x1,-0x88(%rbp)
  804211a55f:	01 
  804211a560:	eb ca                	jmp    804211a52c <LZ4_compress_fast_continue+0x2c9d>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211a562:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211a565:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211a56c:	00 00 00 
  804211a56f:	ff d0                	call   *%rax
  804211a571:	89 c3                	mov    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  804211a573:	89 d8                	mov    %ebx,%eax
  804211a575:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
  804211a57a:	8d 83 f0 00 00 00    	lea    0xf0(%rbx),%eax
  804211a580:	be 81 80 80 80       	mov    $0x80808081,%esi
  804211a585:	48 0f af c6          	imul   %rsi,%rax
  804211a589:	48 c1 e8 27          	shr    $0x27,%rax
  804211a58d:	49 8d 44 04 06       	lea    0x6(%r12,%rax,1),%rax
            if ((outputDirective) &&    /* Check output buffer overflow */
  804211a592:	48 39 85 60 ff ff ff 	cmp    %rax,-0xa0(%rbp)
  804211a599:	0f 82 b4 03 00 00    	jb     804211a953 <LZ4_compress_fast_continue+0x30c4>
            if (matchCode >= ML_MASK) {
  804211a59f:	83 fb 0e             	cmp    $0xe,%ebx
  804211a5a2:	0f 87 87 01 00 00    	ja     804211a72f <LZ4_compress_fast_continue+0x2ea0>
                *token += (BYTE)(matchCode);
  804211a5a8:	41 00 5d 00          	add    %bl,0x0(%r13)
  804211a5ac:	4d 89 e5             	mov    %r12,%r13
        if (ip >= mflimitPlusOne) break;
  804211a5af:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  804211a5b3:	49 39 c7             	cmp    %rax,%r15
  804211a5b6:	0f 83 1b 02 00 00    	jae    804211a7d7 <LZ4_compress_fast_continue+0x2f48>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211a5bc:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  804211a5c0:	be 02 00 00 00       	mov    $0x2,%esi
  804211a5c5:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  804211a5cc:	00 00 00 
  804211a5cf:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211a5d1:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  804211a5d3:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211a5d7:	4c 8b 75 a8          	mov    -0x58(%rbp),%r14
  804211a5db:	4c 29 f2             	sub    %r14,%rdx
  804211a5de:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  804211a5e2:	89 14 81             	mov    %edx,(%rcx,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211a5e5:	49 8b 3f             	mov    (%r15),%rdi
  804211a5e8:	be 02 00 00 00       	mov    $0x2,%esi
  804211a5ed:	ff d3                	call   *%rbx
            U32 const current = (U32)(ip-base);
  804211a5ef:	4d 89 fc             	mov    %r15,%r12
  804211a5f2:	4d 29 f4             	sub    %r14,%r12
        return hashTable[h];
  804211a5f5:	89 c0                	mov    %eax,%eax
  804211a5f7:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  804211a5fb:	48 8d 0c 81          	lea    (%rcx,%rax,4),%rcx
  804211a5ff:	8b 11                	mov    (%rcx),%edx
                if (matchIndex < startIndex) {
  804211a601:	8b 45 88             	mov    -0x78(%rbp),%eax
  804211a604:	39 c2                	cmp    %eax,%edx
  804211a606:	0f 83 7d 01 00 00    	jae    804211a789 <LZ4_compress_fast_continue+0x2efa>
                    match = dictBase + matchIndex;
  804211a60c:	89 d0                	mov    %edx,%eax
  804211a60e:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  804211a615:	48 01 f0             	add    %rsi,%rax
                    lowLimit = dictionary;   /* required for match length counter */
  804211a618:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211a61f:	44 89 21             	mov    %r12d,(%rcx)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  804211a622:	8d 8a ff ff 00 00    	lea    0xffff(%rdx),%ecx
  804211a628:	44 39 e1             	cmp    %r12d,%ecx
  804211a62b:	0f 82 6a 01 00 00    	jb     804211a79b <LZ4_compress_fast_continue+0x2f0c>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  804211a631:	8b 08                	mov    (%rax),%ecx
  804211a633:	41 39 0f             	cmp    %ecx,(%r15)
  804211a636:	0f 85 5f 01 00 00    	jne    804211a79b <LZ4_compress_fast_continue+0x2f0c>
                token=op++;
  804211a63c:	4d 8d 75 01          	lea    0x1(%r13),%r14
                *token=0;
  804211a640:	41 c6 45 00 00       	movb   $0x0,0x0(%r13)
                if (maybe_extMem) offset = current - matchIndex;
  804211a645:	41 29 d4             	sub    %edx,%r12d
static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
  804211a648:	66 45 89 26          	mov    %r12w,(%r14)
            LZ4_writeLE16(op, (U16)offset); op+=2;
  804211a64c:	4d 8d 66 02          	lea    0x2(%r14),%r12
                 && (lowLimit==dictionary) /* match within extDict */ ) {
  804211a650:	48 39 b5 70 ff ff ff 	cmp    %rsi,-0x90(%rbp)
  804211a657:	0f 84 91 fc ff ff    	je     804211a2ee <LZ4_compress_fast_continue+0x2a5f>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211a65d:	49 8d 77 04          	lea    0x4(%r15),%rsi
  804211a661:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a665:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  804211a669:	48 39 ce             	cmp    %rcx,%rsi
  804211a66c:	73 58                	jae    804211a6c6 <LZ4_compress_fast_continue+0x2e37>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211a66e:	48 8b 50 04          	mov    0x4(%rax),%rdx
  804211a672:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211a676:	48 39 d7             	cmp    %rdx,%rdi
  804211a679:	0f 85 e3 fe ff ff    	jne    804211a562 <LZ4_compress_fast_continue+0x2cd3>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211a67f:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  804211a683:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a687:	48 39 cb             	cmp    %rcx,%rbx
  804211a68a:	73 42                	jae    804211a6ce <LZ4_compress_fast_continue+0x2e3f>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211a68c:	48 8b 10             	mov    (%rax),%rdx
  804211a68f:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211a692:	48 39 d7             	cmp    %rdx,%rdi
  804211a695:	74 1c                	je     804211a6b3 <LZ4_compress_fast_continue+0x2e24>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211a697:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211a69a:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211a6a1:	00 00 00 
  804211a6a4:	ff d0                	call   *%rax
  804211a6a6:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  804211a6a9:	8b 45 b0             	mov    -0x50(%rbp),%eax
  804211a6ac:	29 c3                	sub    %eax,%ebx
  804211a6ae:	e9 c0 fe ff ff       	jmp    804211a573 <LZ4_compress_fast_continue+0x2ce4>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211a6b3:	48 83 c3 08          	add    $0x8,%rbx
  804211a6b7:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211a6bb:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  804211a6bf:	48 39 f3             	cmp    %rsi,%rbx
  804211a6c2:	72 c8                	jb     804211a68c <LZ4_compress_fast_continue+0x2dfd>
  804211a6c4:	eb 08                	jmp    804211a6ce <LZ4_compress_fast_continue+0x2e3f>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211a6c6:	48 83 c0 04          	add    $0x4,%rax
  804211a6ca:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211a6ce:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804211a6d2:	48 8d 57 f8          	lea    -0x8(%rdi),%rdx
  804211a6d6:	48 39 d3             	cmp    %rdx,%rbx
  804211a6d9:	73 06                	jae    804211a6e1 <LZ4_compress_fast_continue+0x2e52>
  804211a6db:	8b 08                	mov    (%rax),%ecx
  804211a6dd:	39 0b                	cmp    %ecx,(%rbx)
  804211a6df:	74 3a                	je     804211a71b <LZ4_compress_fast_continue+0x2e8c>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211a6e1:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804211a6e5:	48 8d 56 fa          	lea    -0x6(%rsi),%rdx
  804211a6e9:	48 39 d3             	cmp    %rdx,%rbx
  804211a6ec:	73 08                	jae    804211a6f6 <LZ4_compress_fast_continue+0x2e67>
  804211a6ee:	0f b7 30             	movzwl (%rax),%esi
  804211a6f1:	66 39 33             	cmp    %si,(%rbx)
  804211a6f4:	74 2f                	je     804211a725 <LZ4_compress_fast_continue+0x2e96>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211a6f6:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
  804211a6fd:	48 39 fb             	cmp    %rdi,%rbx
  804211a700:	73 0f                	jae    804211a711 <LZ4_compress_fast_continue+0x2e82>
  804211a702:	0f b6 3b             	movzbl (%rbx),%edi
  804211a705:	40 38 38             	cmp    %dil,(%rax)
  804211a708:	0f 94 c0             	sete   %al
  804211a70b:	0f b6 c0             	movzbl %al,%eax
  804211a70e:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  804211a711:	8b 45 b0             	mov    -0x50(%rbp),%eax
  804211a714:	29 c3                	sub    %eax,%ebx
  804211a716:	e9 58 fe ff ff       	jmp    804211a573 <LZ4_compress_fast_continue+0x2ce4>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211a71b:	48 83 c3 04          	add    $0x4,%rbx
  804211a71f:	48 83 c0 04          	add    $0x4,%rax
  804211a723:	eb bc                	jmp    804211a6e1 <LZ4_compress_fast_continue+0x2e52>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211a725:	48 83 c3 02          	add    $0x2,%rbx
  804211a729:	48 83 c0 02          	add    $0x2,%rax
  804211a72d:	eb c7                	jmp    804211a6f6 <LZ4_compress_fast_continue+0x2e67>
                *token += ML_MASK;
  804211a72f:	41 80 45 00 0f       	addb   $0xf,0x0(%r13)
                matchCode -= ML_MASK;
  804211a734:	83 eb 0f             	sub    $0xf,%ebx
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211a737:	41 c7 46 02 ff ff ff 	movl   $0xffffffff,0x2(%r14)
  804211a73e:	ff 
                while (matchCode >= 4*255) {
  804211a73f:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  804211a745:	76 1a                	jbe    804211a761 <LZ4_compress_fast_continue+0x2ed2>
                    op+=4;
  804211a747:	49 83 c4 04          	add    $0x4,%r12
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211a74b:	41 c7 04 24 ff ff ff 	movl   $0xffffffff,(%r12)
  804211a752:	ff 
                    matchCode -= 4*255;
  804211a753:	81 eb fc 03 00 00    	sub    $0x3fc,%ebx
                while (matchCode >= 4*255) {
  804211a759:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  804211a75f:	77 e6                	ja     804211a747 <LZ4_compress_fast_continue+0x2eb8>
                op += matchCode / 255;
  804211a761:	89 d8                	mov    %ebx,%eax
  804211a763:	ba 81 80 80 80       	mov    $0x80808081,%edx
  804211a768:	48 0f af c2          	imul   %rdx,%rax
  804211a76c:	48 c1 e8 27          	shr    $0x27,%rax
  804211a770:	89 c2                	mov    %eax,%edx
  804211a772:	4c 01 e2             	add    %r12,%rdx
                *op++ = (BYTE)(matchCode % 255);
  804211a775:	4c 8d 6a 01          	lea    0x1(%rdx),%r13
  804211a779:	89 c1                	mov    %eax,%ecx
  804211a77b:	c1 e1 08             	shl    $0x8,%ecx
  804211a77e:	29 c1                	sub    %eax,%ecx
  804211a780:	29 cb                	sub    %ecx,%ebx
  804211a782:	88 1a                	mov    %bl,(%rdx)
  804211a784:	e9 26 fe ff ff       	jmp    804211a5af <LZ4_compress_fast_continue+0x2d20>
                    match = base + matchIndex;
  804211a789:	89 d0                	mov    %edx,%eax
  804211a78b:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
  804211a78f:	48 01 d8             	add    %rbx,%rax
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
  804211a792:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  804211a796:	e9 84 fe ff ff       	jmp    804211a61f <LZ4_compress_fast_continue+0x2d90>
        forwardH = LZ4_hashPosition(++ip, tableType);
  804211a79b:	4c 89 ad 50 ff ff ff 	mov    %r13,-0xb0(%rbp)
  804211a7a2:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211a7a6:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  804211a7aa:	be 02 00 00 00       	mov    $0x2,%esi
  804211a7af:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211a7b6:	00 00 00 
  804211a7b9:	ff d0                	call   *%rax
  804211a7bb:	4c 89 fe             	mov    %r15,%rsi
  804211a7be:	49 89 df             	mov    %rbx,%r15
  804211a7c1:	e9 12 f9 ff ff       	jmp    804211a0d8 <LZ4_compress_fast_continue+0x2849>
    BYTE* op = (BYTE*) dest;
  804211a7c6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211a7ca:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  804211a7d1:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211a7d5:	eb 36                	jmp    804211a80d <LZ4_compress_fast_continue+0x2f7e>
        anchor = ip;
  804211a7d7:	4c 89 fe             	mov    %r15,%rsi
  804211a7da:	4c 89 ad 50 ff ff ff 	mov    %r13,-0xb0(%rbp)
  804211a7e1:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211a7e5:	44 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%r15d
  804211a7ec:	eb 1f                	jmp    804211a80d <LZ4_compress_fast_continue+0x2f7e>
  804211a7ee:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211a7f2:	44 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%r15d
  804211a7f9:	eb 12                	jmp    804211a80d <LZ4_compress_fast_continue+0x2f7e>
  804211a7fb:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
  804211a802:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211a806:	44 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%r15d
    {   size_t lastRun = (size_t)(iend - anchor);
  804211a80d:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  804211a811:	49 29 f4             	sub    %rsi,%r12
             (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
  804211a814:	49 8d 94 24 f0 00 00 	lea    0xf0(%r12),%rdx
  804211a81b:	00 
  804211a81c:	48 b9 81 80 80 80 80 	movabs $0x8080808080808081,%rcx
  804211a823:	80 80 80 
  804211a826:	48 89 d0             	mov    %rdx,%rax
  804211a829:	48 f7 e1             	mul    %rcx
  804211a82c:	48 c1 ea 07          	shr    $0x7,%rdx
  804211a830:	49 8d 54 14 01       	lea    0x1(%r12,%rdx,1),%rdx
  804211a835:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  804211a83c:	48 01 fa             	add    %rdi,%rdx
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a83f:	b8 00 00 00 00       	mov    $0x0,%eax
        if ( (outputDirective) &&  /* Check output buffer overflow */
  804211a844:	48 39 95 60 ff ff ff 	cmp    %rdx,-0xa0(%rbp)
  804211a84b:	0f 82 0b ee ff ff    	jb     804211965c <LZ4_compress_fast_continue+0x1dcd>
        if (lastRun >= RUN_MASK) {
  804211a851:	49 83 fc 0e          	cmp    $0xe,%r12
  804211a855:	76 54                	jbe    804211a8ab <LZ4_compress_fast_continue+0x301c>
            size_t accumulator = lastRun - RUN_MASK;
  804211a857:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  804211a85c:	48 8d 47 01          	lea    0x1(%rdi),%rax
  804211a860:	c6 07 f0             	movb   $0xf0,(%rdi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  804211a863:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211a86a:	76 18                	jbe    804211a884 <LZ4_compress_fast_continue+0x2ff5>
  804211a86c:	48 83 c0 01          	add    $0x1,%rax
  804211a870:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  804211a874:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  804211a87b:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211a882:	77 e8                	ja     804211a86c <LZ4_compress_fast_continue+0x2fdd>
            *op++ = (BYTE) accumulator;
  804211a884:	48 8d 58 01          	lea    0x1(%rax),%rbx
  804211a888:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  804211a88a:	4c 89 e2             	mov    %r12,%rdx
  804211a88d:	48 89 df             	mov    %rbx,%rdi
  804211a890:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211a897:	00 00 00 
  804211a89a:	ff d0                	call   *%rax
        op += lastRun;
  804211a89c:	4c 01 e3             	add    %r12,%rbx
    result = (int)(((char*)op) - dest);
  804211a89f:	89 d8                	mov    %ebx,%eax
  804211a8a1:	8b 4d c0             	mov    -0x40(%rbp),%ecx
  804211a8a4:	29 c8                	sub    %ecx,%eax
    return result;
  804211a8a6:	e9 b1 ed ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  804211a8ab:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  804211a8b2:	48 8d 5f 01          	lea    0x1(%rdi),%rbx
  804211a8b6:	44 89 e0             	mov    %r12d,%eax
  804211a8b9:	c1 e0 04             	shl    $0x4,%eax
  804211a8bc:	88 07                	mov    %al,(%rdi)
  804211a8be:	eb ca                	jmp    804211a88a <LZ4_compress_fast_continue+0x2ffb>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a8c0:	4c 8b 75 98          	mov    -0x68(%rbp),%r14
  804211a8c4:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
  804211a8cb:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a8d0:	e9 87 ed ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a8d5:	4c 8b 75 98          	mov    -0x68(%rbp),%r14
  804211a8d9:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
  804211a8e0:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a8e5:	e9 72 ed ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a8ea:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211a8ee:	44 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%r15d
  804211a8f5:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a8fa:	e9 5d ed ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a8ff:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211a903:	44 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%r15d
  804211a90a:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a90f:	e9 48 ed ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a914:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
  804211a918:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
  804211a91f:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a924:	e9 33 ed ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a929:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
  804211a92d:	44 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%r15d
  804211a934:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a939:	e9 1e ed ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a93e:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211a942:	44 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%r15d
  804211a949:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a94e:	e9 09 ed ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a953:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211a957:	44 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%r15d
  804211a95e:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a963:	e9 f4 ec ff ff       	jmp    804211965c <LZ4_compress_fast_continue+0x1dcd>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a968:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a96d:	e9 4c cf ff ff       	jmp    80421178be <LZ4_compress_fast_continue+0x2f>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a972:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a977:	e9 42 cf ff ff       	jmp    80421178be <LZ4_compress_fast_continue+0x2f>
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a97c:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a981:	e9 38 cf ff ff       	jmp    80421178be <LZ4_compress_fast_continue+0x2f>
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
  804211a986:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a98b:	e9 2e cf ff ff       	jmp    80421178be <LZ4_compress_fast_continue+0x2f>

000000804211a990 <LZ4_compress_forceExtDict>:
{
  804211a990:	f3 0f 1e fa          	endbr64
  804211a994:	55                   	push   %rbp
  804211a995:	48 89 e5             	mov    %rsp,%rbp
  804211a998:	41 57                	push   %r15
  804211a99a:	41 56                	push   %r14
  804211a99c:	41 55                	push   %r13
  804211a99e:	41 54                	push   %r12
  804211a9a0:	53                   	push   %rbx
  804211a9a1:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
  804211a9a8:	49 89 ff             	mov    %rdi,%r15
  804211a9ab:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  804211a9af:	48 89 f3             	mov    %rsi,%rbx
  804211a9b2:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
  804211a9b6:	49 89 d6             	mov    %rdx,%r14
  804211a9b9:	41 89 cd             	mov    %ecx,%r13d
    LZ4_renormDictT(streamPtr, srcSize);
  804211a9bc:	89 ce                	mov    %ecx,%esi
  804211a9be:	48 b8 75 17 11 42 80 	movabs $0x8042111775,%rax
  804211a9c5:	00 00 00 
  804211a9c8:	ff d0                	call   *%rax
    if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
  804211a9ca:	41 8b 97 18 40 00 00 	mov    0x4018(%r15),%edx
  804211a9d1:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  804211a9d7:	0f 87 3d 08 00 00    	ja     804211b21a <LZ4_compress_forceExtDict+0x88a>
  804211a9dd:	41 8b b7 00 40 00 00 	mov    0x4000(%r15),%esi
  804211a9e4:	39 f2                	cmp    %esi,%edx
  804211a9e6:	0f 83 2e 08 00 00    	jae    804211b21a <LZ4_compress_forceExtDict+0x88a>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  804211a9ec:	b8 00 00 00 00       	mov    $0x0,%eax
  804211a9f1:	41 81 fd 00 00 00 7e 	cmp    $0x7e000000,%r13d
  804211a9f8:	0f 87 de 0f 00 00    	ja     804211b9dc <LZ4_compress_forceExtDict+0x104c>
            dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
  804211a9fe:	4d 8b 97 08 40 00 00 	mov    0x4008(%r15),%r10
  804211aa05:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
    const BYTE* const iend = ip + inputSize;
  804211aa09:	49 63 c5             	movslq %r13d,%rax
  804211aa0c:	49 89 dc             	mov    %rbx,%r12
  804211aa0f:	4c 8d 1c 03          	lea    (%rbx,%rax,1),%r11
  804211aa13:	4c 89 9d 60 ff ff ff 	mov    %r11,-0xa0(%rbp)
        cctx->dictSize += (U32)inputSize;
  804211aa1a:	42 8d 04 2a          	lea    (%rdx,%r13,1),%eax
  804211aa1e:	41 89 87 18 40 00 00 	mov    %eax,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  804211aa25:	89 f1                	mov    %esi,%ecx
  804211aa27:	42 8d 04 2e          	lea    (%rsi,%r13,1),%eax
  804211aa2b:	41 89 87 00 40 00 00 	mov    %eax,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  804211aa32:	66 41 c7 87 06 40 00 	movw   $0x2,0x4006(%r15)
  804211aa39:	00 02 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  804211aa3c:	41 83 fd 0c          	cmp    $0xc,%r13d
  804211aa40:	0f 8e 0b 07 00 00    	jle    804211b151 <LZ4_compress_forceExtDict+0x7c1>
    const BYTE* base = (const BYTE*) source - startIndex;
  804211aa46:	89 f0                	mov    %esi,%eax
  804211aa48:	48 89 de             	mov    %rbx,%rsi
  804211aa4b:	48 29 c6             	sub    %rax,%rsi
  804211aa4e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
  804211aa52:	89 4d 98             	mov    %ecx,-0x68(%rbp)
  804211aa55:	89 cb                	mov    %ecx,%ebx
  804211aa57:	29 d3                	sub    %edx,%ebx
  804211aa59:	89 5d 88             	mov    %ebx,-0x78(%rbp)
    const BYTE* const dictEnd = dictionary + dictSize;
  804211aa5c:	89 d2                	mov    %edx,%edx
  804211aa5e:	49 8d 34 12          	lea    (%r10,%rdx,1),%rsi
  804211aa62:	48 89 b5 38 ff ff ff 	mov    %rsi,-0xc8(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  804211aa69:	49 8d 73 f5          	lea    -0xb(%r11),%rsi
  804211aa6d:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  804211aa71:	49 8d 73 fb          	lea    -0x5(%r11),%rsi
  804211aa75:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
                           dictionary + dictSize - startIndex;
  804211aa7c:	48 29 c2             	sub    %rax,%rdx
                           dictionary + dictSize - dictCtx->currentOffset :
  804211aa7f:	49 8d 04 12          	lea    (%r10,%rdx,1),%rax
  804211aa83:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211aa8a:	49 8b 3c 24          	mov    (%r12),%rdi
  804211aa8e:	be 02 00 00 00       	mov    $0x2,%esi
  804211aa93:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  804211aa9a:	00 00 00 
  804211aa9d:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211aa9f:	89 c0                	mov    %eax,%eax
  804211aaa1:	8b 4d 98             	mov    -0x68(%rbp),%ecx
  804211aaa4:	41 89 0c 87          	mov    %ecx,(%r15,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  804211aaa8:	4d 8d 7c 24 01       	lea    0x1(%r12),%r15
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211aaad:	49 8b 7c 24 01       	mov    0x1(%r12),%rdi
  804211aab2:	be 02 00 00 00       	mov    $0x2,%esi
  804211aab7:	ff d3                	call   *%rbx
  804211aab9:	4c 89 b5 68 ff ff ff 	mov    %r14,-0x98(%rbp)
  804211aac0:	4c 89 e6             	mov    %r12,%rsi
  804211aac3:	4c 89 b5 48 ff ff ff 	mov    %r14,-0xb8(%rbp)
  804211aaca:	44 89 ad 44 ff ff ff 	mov    %r13d,-0xbc(%rbp)
                U32 const current = (U32)(forwardIp - base);
  804211aad1:	45 89 fd             	mov    %r15d,%r13d
  804211aad4:	8b 4d c0             	mov    -0x40(%rbp),%ecx
  804211aad7:	41 29 cd             	sub    %ecx,%r13d
        return hashTable[h];
  804211aada:	89 c0                	mov    %eax,%eax
  804211aadc:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211aae0:	4c 8d 34 87          	lea    (%rdi,%rax,4),%r14
  804211aae4:	45 8b 26             	mov    (%r14),%r12d
                forwardIp += step;
  804211aae7:	49 8d 5f 01          	lea    0x1(%r15),%rbx
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  804211aaeb:	48 39 5d 90          	cmp    %rbx,-0x70(%rbp)
  804211aaef:	0f 82 83 06 00 00    	jb     804211b178 <LZ4_compress_forceExtDict+0x7e8>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211aaf5:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
  804211aafc:	c7 45 a8 41 00 00 00 	movl   $0x41,-0x58(%rbp)
  804211ab03:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  804211ab0a:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
  804211ab0e:	eb 3d                	jmp    804211ab4d <LZ4_compress_forceExtDict+0x1bd>
                U32 const current = (U32)(forwardIp - base);
  804211ab10:	41 89 dd             	mov    %ebx,%r13d
  804211ab13:	8b 75 c0             	mov    -0x40(%rbp),%esi
  804211ab16:	41 29 f5             	sub    %esi,%r13d
        return hashTable[h];
  804211ab19:	89 c0                	mov    %eax,%eax
  804211ab1b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804211ab1f:	4c 8d 34 81          	lea    (%rcx,%rax,4),%r14
  804211ab23:	45 8b 26             	mov    (%r14),%r12d
                forwardIp += step;
  804211ab26:	48 63 45 b0          	movslq -0x50(%rbp),%rax
  804211ab2a:	48 01 d8             	add    %rbx,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211ab2d:	8b 75 a8             	mov    -0x58(%rbp),%esi
  804211ab30:	8d 56 01             	lea    0x1(%rsi),%edx
  804211ab33:	c1 fe 06             	sar    $0x6,%esi
  804211ab36:	89 75 b0             	mov    %esi,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  804211ab39:	48 89 5d a0          	mov    %rbx,-0x60(%rbp)
  804211ab3d:	48 39 45 90          	cmp    %rax,-0x70(%rbp)
  804211ab41:	0f 82 41 06 00 00    	jb     804211b188 <LZ4_compress_forceExtDict+0x7f8>
  804211ab47:	89 55 a8             	mov    %edx,-0x58(%rbp)
  804211ab4a:	48 89 c3             	mov    %rax,%rbx
                    if (matchIndex < startIndex) {
  804211ab4d:	8b 45 98             	mov    -0x68(%rbp),%eax
  804211ab50:	41 39 c4             	cmp    %eax,%r12d
  804211ab53:	0f 83 ec 00 00 00    	jae    804211ac45 <LZ4_compress_forceExtDict+0x2b5>
                        match = dictBase + matchIndex;
  804211ab59:	45 89 e7             	mov    %r12d,%r15d
  804211ab5c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  804211ab63:	49 01 c7             	add    %rax,%r15
                        lowLimit = dictionary;
  804211ab66:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  804211ab6a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211ab71:	48 8b 3b             	mov    (%rbx),%rdi
  804211ab74:	be 02 00 00 00       	mov    $0x2,%esi
  804211ab79:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211ab80:	00 00 00 
  804211ab83:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211ab85:	45 89 2e             	mov    %r13d,(%r14)
                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */
  804211ab88:	8b 4d 88             	mov    -0x78(%rbp),%ecx
  804211ab8b:	41 39 cc             	cmp    %ecx,%r12d
  804211ab8e:	72 80                	jb     804211ab10 <LZ4_compress_forceExtDict+0x180>
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  804211ab90:	41 8d 94 24 ff ff 00 	lea    0xffff(%r12),%edx
  804211ab97:	00 
  804211ab98:	44 39 ea             	cmp    %r13d,%edx
  804211ab9b:	0f 82 6f ff ff ff    	jb     804211ab10 <LZ4_compress_forceExtDict+0x180>
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  804211aba1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  804211aba5:	41 8b 0f             	mov    (%r15),%ecx
  804211aba8:	39 0a                	cmp    %ecx,(%rdx)
  804211abaa:	0f 85 60 ff ff ff    	jne    804211ab10 <LZ4_compress_forceExtDict+0x180>
                    if (maybe_extMem) offset = current - matchIndex;
  804211abb0:	4c 89 f8             	mov    %r15,%rax
  804211abb3:	4c 89 fb             	mov    %r15,%rbx
  804211abb6:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  804211abbd:	49 89 d7             	mov    %rdx,%r15
  804211abc0:	45 29 e5             	sub    %r12d,%r13d
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211abc3:	48 39 d6             	cmp    %rdx,%rsi
  804211abc6:	73 17                	jae    804211abdf <LZ4_compress_forceExtDict+0x24f>
  804211abc8:	48 39 85 78 ff ff ff 	cmp    %rax,-0x88(%rbp)
  804211abcf:	73 0e                	jae    804211abdf <LZ4_compress_forceExtDict+0x24f>
  804211abd1:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
  804211abd5:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  804211abd9:	0f 84 80 00 00 00    	je     804211ac5f <LZ4_compress_forceExtDict+0x2cf>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  804211abdf:	4c 89 fa             	mov    %r15,%rdx
  804211abe2:	48 29 f2             	sub    %rsi,%rdx
            token = op++;
  804211abe5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  804211abec:	48 8d 78 01          	lea    0x1(%rax),%rdi
            if (litLength >= RUN_MASK) {
  804211abf0:	83 fa 0e             	cmp    $0xe,%edx
  804211abf3:	0f 87 8f 00 00 00    	ja     804211ac88 <LZ4_compress_forceExtDict+0x2f8>
            else *token = (BYTE)(litLength<<ML_BITS);
  804211abf9:	89 d0                	mov    %edx,%eax
  804211abfb:	c1 e0 04             	shl    $0x4,%eax
  804211abfe:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  804211ac05:	88 01                	mov    %al,(%rcx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  804211ac07:	89 d2                	mov    %edx,%edx
  804211ac09:	4c 8d 34 17          	lea    (%rdi,%rdx,1),%r14
  804211ac0d:	4c 89 f2             	mov    %r14,%rdx
  804211ac10:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211ac17:	00 00 00 
  804211ac1a:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211ac1c:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  804211ac23:	48 83 e8 0c          	sub    $0xc,%rax
  804211ac27:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211ac2b:	48 89 d8             	mov    %rbx,%rax
  804211ac2e:	4c 89 75 b0          	mov    %r14,-0x50(%rbp)
  804211ac32:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
  804211ac39:	4c 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%r14
  804211ac40:	e9 f1 03 00 00       	jmp    804211b036 <LZ4_compress_forceExtDict+0x6a6>
                        match = base + matchIndex;
  804211ac45:	45 89 e7             	mov    %r12d,%r15d
  804211ac48:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211ac4c:	49 01 c7             	add    %rax,%r15
                        lowLimit = (const BYTE*)source;
  804211ac4f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211ac53:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  804211ac5a:	e9 12 ff ff ff       	jmp    804211ab71 <LZ4_compress_forceExtDict+0x1e1>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211ac5f:	49 83 ef 01          	sub    $0x1,%r15
  804211ac63:	48 89 d8             	mov    %rbx,%rax
  804211ac66:	48 83 e8 01          	sub    $0x1,%rax
  804211ac6a:	48 89 c3             	mov    %rax,%rbx
  804211ac6d:	4c 39 fe             	cmp    %r15,%rsi
  804211ac70:	0f 83 69 ff ff ff    	jae    804211abdf <LZ4_compress_forceExtDict+0x24f>
  804211ac76:	48 39 85 78 ff ff ff 	cmp    %rax,-0x88(%rbp)
  804211ac7d:	0f 82 4e ff ff ff    	jb     804211abd1 <LZ4_compress_forceExtDict+0x241>
  804211ac83:	e9 57 ff ff ff       	jmp    804211abdf <LZ4_compress_forceExtDict+0x24f>
                int len = (int)(litLength - RUN_MASK);
  804211ac88:	8d 42 f1             	lea    -0xf(%rdx),%eax
                *token = (RUN_MASK<<ML_BITS);
  804211ac8b:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  804211ac92:	c6 01 f0             	movb   $0xf0,(%rcx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  804211ac95:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211ac9a:	7e 14                	jle    804211acb0 <LZ4_compress_forceExtDict+0x320>
  804211ac9c:	48 83 c7 01          	add    $0x1,%rdi
  804211aca0:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  804211aca4:	2d ff 00 00 00       	sub    $0xff,%eax
  804211aca9:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211acae:	7f ec                	jg     804211ac9c <LZ4_compress_forceExtDict+0x30c>
                *op++ = (BYTE)len;
  804211acb0:	88 07                	mov    %al,(%rdi)
  804211acb2:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  804211acb6:	e9 4c ff ff ff       	jmp    804211ac07 <LZ4_compress_forceExtDict+0x277>
                const BYTE* limit = ip + (dictEnd-match);
  804211acbb:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
  804211acc2:	48 29 c2             	sub    %rax,%rdx
  804211acc5:	4c 01 fa             	add    %r15,%rdx
                if (limit > matchlimit) limit = matchlimit;
  804211acc8:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
  804211accf:	48 39 d7             	cmp    %rdx,%rdi
  804211acd2:	48 0f 46 d7          	cmovbe %rdi,%rdx
  804211acd6:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  804211acda:	4d 8d 6f 04          	lea    0x4(%r15),%r13
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211acde:	48 83 ea 07          	sub    $0x7,%rdx
  804211ace2:	49 39 d5             	cmp    %rdx,%r13
  804211ace5:	0f 83 ec 00 00 00    	jae    804211add7 <LZ4_compress_forceExtDict+0x447>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211aceb:	48 8b 48 04          	mov    0x4(%rax),%rcx
  804211acef:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211acf3:	48 39 cf             	cmp    %rcx,%rdi
  804211acf6:	0f 85 b2 00 00 00    	jne    804211adae <LZ4_compress_forceExtDict+0x41e>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211acfc:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  804211ad00:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211ad04:	48 39 d3             	cmp    %rdx,%rbx
  804211ad07:	0f 83 d1 00 00 00    	jae    804211adde <LZ4_compress_forceExtDict+0x44e>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211ad0d:	48 8b 08             	mov    (%rax),%rcx
  804211ad10:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211ad13:	48 39 cf             	cmp    %rcx,%rdi
  804211ad16:	0f 84 a8 00 00 00    	je     804211adc4 <LZ4_compress_forceExtDict+0x434>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211ad1c:	48 31 cf             	xor    %rcx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211ad1f:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211ad26:	00 00 00 
  804211ad29:	ff d0                	call   *%rax
  804211ad2b:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  804211ad2e:	44 29 eb             	sub    %r13d,%ebx
                ip += (size_t)matchCode + MINMATCH;
  804211ad31:	89 d8                	mov    %ebx,%eax
  804211ad33:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                if (ip==limit) {
  804211ad38:	4c 39 7d a0          	cmp    %r15,-0x60(%rbp)
  804211ad3c:	0f 85 68 03 00 00    	jne    804211b0aa <LZ4_compress_forceExtDict+0x71a>
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211ad42:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  804211ad46:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  804211ad4a:	48 39 ce             	cmp    %rcx,%rsi
  804211ad4d:	0f 83 14 01 00 00    	jae    804211ae67 <LZ4_compress_forceExtDict+0x4d7>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211ad53:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804211ad57:	48 8b 02             	mov    (%rdx),%rax
  804211ad5a:	48 8b 3e             	mov    (%rsi),%rdi
        if (!diff) {
  804211ad5d:	48 39 c7             	cmp    %rax,%rdi
  804211ad60:	0f 85 d3 00 00 00    	jne    804211ae39 <LZ4_compress_forceExtDict+0x4a9>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211ad66:	4c 8d 6e 08          	lea    0x8(%rsi),%r13
  804211ad6a:	48 8d 42 08          	lea    0x8(%rdx),%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211ad6e:	49 39 cd             	cmp    %rcx,%r13
  804211ad71:	0f 83 f8 00 00 00    	jae    804211ae6f <LZ4_compress_forceExtDict+0x4df>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211ad77:	48 8b 10             	mov    (%rax),%rdx
  804211ad7a:	49 8b 7d 00          	mov    0x0(%r13),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211ad7e:	48 39 d7             	cmp    %rdx,%rdi
  804211ad81:	0f 84 c9 00 00 00    	je     804211ae50 <LZ4_compress_forceExtDict+0x4c0>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211ad87:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211ad8a:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211ad91:	00 00 00 
  804211ad94:	ff d0                	call   *%rax
  804211ad96:	46 8d 2c 28          	lea    (%rax,%r13,1),%r13d
        return (unsigned)(pIn - pStart);
  804211ad9a:	8b 45 a0             	mov    -0x60(%rbp),%eax
  804211ad9d:	41 29 c5             	sub    %eax,%r13d
                    matchCode += more;
  804211ada0:	44 01 eb             	add    %r13d,%ebx
                    ip += more;
  804211ada3:	45 89 ed             	mov    %r13d,%r13d
  804211ada6:	4d 01 ef             	add    %r13,%r15
  804211ada9:	e9 fc 02 00 00       	jmp    804211b0aa <LZ4_compress_forceExtDict+0x71a>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211adae:	48 31 cf             	xor    %rcx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211adb1:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211adb8:	00 00 00 
  804211adbb:	ff d0                	call   *%rax
  804211adbd:	89 c3                	mov    %eax,%ebx
  804211adbf:	e9 6d ff ff ff       	jmp    804211ad31 <LZ4_compress_forceExtDict+0x3a1>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211adc4:	48 83 c3 08          	add    $0x8,%rbx
  804211adc8:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211adcc:	48 39 d3             	cmp    %rdx,%rbx
  804211adcf:	0f 82 38 ff ff ff    	jb     804211ad0d <LZ4_compress_forceExtDict+0x37d>
  804211add5:	eb 07                	jmp    804211adde <LZ4_compress_forceExtDict+0x44e>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  804211add7:	48 83 c0 04          	add    $0x4,%rax
  804211addb:	4c 89 eb             	mov    %r13,%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211adde:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  804211ade2:	48 8d 57 fd          	lea    -0x3(%rdi),%rdx
  804211ade6:	48 39 d3             	cmp    %rdx,%rbx
  804211ade9:	73 06                	jae    804211adf1 <LZ4_compress_forceExtDict+0x461>
  804211adeb:	8b 30                	mov    (%rax),%esi
  804211aded:	39 33                	cmp    %esi,(%rbx)
  804211adef:	74 34                	je     804211ae25 <LZ4_compress_forceExtDict+0x495>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211adf1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  804211adf5:	48 83 ea 01          	sub    $0x1,%rdx
  804211adf9:	48 39 d3             	cmp    %rdx,%rbx
  804211adfc:	73 08                	jae    804211ae06 <LZ4_compress_forceExtDict+0x476>
  804211adfe:	0f b7 30             	movzwl (%rax),%esi
  804211ae01:	66 39 33             	cmp    %si,(%rbx)
  804211ae04:	74 29                	je     804211ae2f <LZ4_compress_forceExtDict+0x49f>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211ae06:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  804211ae0a:	48 39 fb             	cmp    %rdi,%rbx
  804211ae0d:	73 0e                	jae    804211ae1d <LZ4_compress_forceExtDict+0x48d>
  804211ae0f:	0f b6 13             	movzbl (%rbx),%edx
  804211ae12:	38 10                	cmp    %dl,(%rax)
  804211ae14:	0f 94 c0             	sete   %al
  804211ae17:	0f b6 c0             	movzbl %al,%eax
  804211ae1a:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  804211ae1d:	44 29 eb             	sub    %r13d,%ebx
  804211ae20:	e9 0c ff ff ff       	jmp    804211ad31 <LZ4_compress_forceExtDict+0x3a1>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211ae25:	48 83 c3 04          	add    $0x4,%rbx
  804211ae29:	48 83 c0 04          	add    $0x4,%rax
  804211ae2d:	eb c2                	jmp    804211adf1 <LZ4_compress_forceExtDict+0x461>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211ae2f:	48 83 c3 02          	add    $0x2,%rbx
  804211ae33:	48 83 c0 02          	add    $0x2,%rax
  804211ae37:	eb cd                	jmp    804211ae06 <LZ4_compress_forceExtDict+0x476>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211ae39:	48 31 c7             	xor    %rax,%rdi
            return LZ4_NbCommonBytes(diff);
  804211ae3c:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211ae43:	00 00 00 
  804211ae46:	ff d0                	call   *%rax
  804211ae48:	41 89 c5             	mov    %eax,%r13d
  804211ae4b:	e9 50 ff ff ff       	jmp    804211ada0 <LZ4_compress_forceExtDict+0x410>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211ae50:	49 83 c5 08          	add    $0x8,%r13
  804211ae54:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211ae58:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804211ae5c:	49 39 d5             	cmp    %rdx,%r13
  804211ae5f:	0f 82 12 ff ff ff    	jb     804211ad77 <LZ4_compress_forceExtDict+0x3e7>
  804211ae65:	eb 08                	jmp    804211ae6f <LZ4_compress_forceExtDict+0x4df>
  804211ae67:	4c 8b 6d a0          	mov    -0x60(%rbp),%r13
  804211ae6b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211ae6f:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  804211ae76:	48 8d 51 f8          	lea    -0x8(%rcx),%rdx
  804211ae7a:	49 39 d5             	cmp    %rdx,%r13
  804211ae7d:	73 08                	jae    804211ae87 <LZ4_compress_forceExtDict+0x4f7>
  804211ae7f:	8b 30                	mov    (%rax),%esi
  804211ae81:	41 39 75 00          	cmp    %esi,0x0(%r13)
  804211ae85:	74 42                	je     804211aec9 <LZ4_compress_forceExtDict+0x539>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211ae87:	48 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%rdi
  804211ae8e:	48 8d 57 fa          	lea    -0x6(%rdi),%rdx
  804211ae92:	49 39 d5             	cmp    %rdx,%r13
  804211ae95:	73 0a                	jae    804211aea1 <LZ4_compress_forceExtDict+0x511>
  804211ae97:	0f b7 10             	movzwl (%rax),%edx
  804211ae9a:	66 41 39 55 00       	cmp    %dx,0x0(%r13)
  804211ae9f:	74 32                	je     804211aed3 <LZ4_compress_forceExtDict+0x543>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211aea1:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  804211aea8:	49 39 cd             	cmp    %rcx,%r13
  804211aeab:	73 11                	jae    804211aebe <LZ4_compress_forceExtDict+0x52e>
  804211aead:	41 0f b6 75 00       	movzbl 0x0(%r13),%esi
  804211aeb2:	40 38 30             	cmp    %sil,(%rax)
  804211aeb5:	0f 94 c0             	sete   %al
  804211aeb8:	0f b6 c0             	movzbl %al,%eax
  804211aebb:	49 01 c5             	add    %rax,%r13
    return (unsigned)(pIn - pStart);
  804211aebe:	8b 45 a0             	mov    -0x60(%rbp),%eax
  804211aec1:	41 29 c5             	sub    %eax,%r13d
  804211aec4:	e9 d7 fe ff ff       	jmp    804211ada0 <LZ4_compress_forceExtDict+0x410>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211aec9:	49 83 c5 04          	add    $0x4,%r13
  804211aecd:	48 83 c0 04          	add    $0x4,%rax
  804211aed1:	eb b4                	jmp    804211ae87 <LZ4_compress_forceExtDict+0x4f7>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211aed3:	49 83 c5 02          	add    $0x2,%r13
  804211aed7:	48 83 c0 02          	add    $0x2,%rax
  804211aedb:	eb c4                	jmp    804211aea1 <LZ4_compress_forceExtDict+0x511>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211aedd:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211aee0:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211aee7:	00 00 00 
  804211aeea:	ff d0                	call   *%rax
  804211aeec:	89 c3                	mov    %eax,%ebx
  804211aeee:	e9 b0 01 00 00       	jmp    804211b0a3 <LZ4_compress_forceExtDict+0x713>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211aef3:	48 83 c3 08          	add    $0x8,%rbx
  804211aef7:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211aefb:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804211aeff:	48 39 d3             	cmp    %rdx,%rbx
  804211af02:	0f 82 77 01 00 00    	jb     804211b07f <LZ4_compress_forceExtDict+0x6ef>
  804211af08:	eb 07                	jmp    804211af11 <LZ4_compress_forceExtDict+0x581>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211af0a:	48 83 c0 04          	add    $0x4,%rax
  804211af0e:	4c 89 eb             	mov    %r13,%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211af11:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  804211af18:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  804211af1c:	48 39 d3             	cmp    %rdx,%rbx
  804211af1f:	73 06                	jae    804211af27 <LZ4_compress_forceExtDict+0x597>
  804211af21:	8b 10                	mov    (%rax),%edx
  804211af23:	39 13                	cmp    %edx,(%rbx)
  804211af25:	74 3b                	je     804211af62 <LZ4_compress_forceExtDict+0x5d2>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211af27:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  804211af2e:	48 8d 56 fa          	lea    -0x6(%rsi),%rdx
  804211af32:	48 39 d3             	cmp    %rdx,%rbx
  804211af35:	73 08                	jae    804211af3f <LZ4_compress_forceExtDict+0x5af>
  804211af37:	0f b7 30             	movzwl (%rax),%esi
  804211af3a:	66 39 33             	cmp    %si,(%rbx)
  804211af3d:	74 2d                	je     804211af6c <LZ4_compress_forceExtDict+0x5dc>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211af3f:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
  804211af46:	48 39 fb             	cmp    %rdi,%rbx
  804211af49:	73 0f                	jae    804211af5a <LZ4_compress_forceExtDict+0x5ca>
  804211af4b:	0f b6 3b             	movzbl (%rbx),%edi
  804211af4e:	40 38 38             	cmp    %dil,(%rax)
  804211af51:	0f 94 c0             	sete   %al
  804211af54:	0f b6 c0             	movzbl %al,%eax
  804211af57:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  804211af5a:	44 29 eb             	sub    %r13d,%ebx
  804211af5d:	e9 41 01 00 00       	jmp    804211b0a3 <LZ4_compress_forceExtDict+0x713>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211af62:	48 83 c3 04          	add    $0x4,%rbx
  804211af66:	48 83 c0 04          	add    $0x4,%rax
  804211af6a:	eb bb                	jmp    804211af27 <LZ4_compress_forceExtDict+0x597>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211af6c:	48 83 c3 02          	add    $0x2,%rbx
  804211af70:	48 83 c0 02          	add    $0x2,%rax
  804211af74:	eb c9                	jmp    804211af3f <LZ4_compress_forceExtDict+0x5af>
                *token += ML_MASK;
  804211af76:	41 80 06 0f          	addb   $0xf,(%r14)
                matchCode -= ML_MASK;
  804211af7a:	83 eb 0f             	sub    $0xf,%ebx
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211af7d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211af81:	c7 40 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rax)
                while (matchCode >= 4*255) {
  804211af88:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  804211af8e:	76 1a                	jbe    804211afaa <LZ4_compress_forceExtDict+0x61a>
                    op+=4;
  804211af90:	49 83 c4 04          	add    $0x4,%r12
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211af94:	41 c7 04 24 ff ff ff 	movl   $0xffffffff,(%r12)
  804211af9b:	ff 
                    matchCode -= 4*255;
  804211af9c:	81 eb fc 03 00 00    	sub    $0x3fc,%ebx
                while (matchCode >= 4*255) {
  804211afa2:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  804211afa8:	77 e6                	ja     804211af90 <LZ4_compress_forceExtDict+0x600>
                op += matchCode / 255;
  804211afaa:	89 d8                	mov    %ebx,%eax
  804211afac:	b9 81 80 80 80       	mov    $0x80808081,%ecx
  804211afb1:	48 0f af c1          	imul   %rcx,%rax
  804211afb5:	48 c1 e8 27          	shr    $0x27,%rax
  804211afb9:	89 c2                	mov    %eax,%edx
  804211afbb:	4c 01 e2             	add    %r12,%rdx
                *op++ = (BYTE)(matchCode % 255);
  804211afbe:	4c 8d 72 01          	lea    0x1(%rdx),%r14
  804211afc2:	89 c1                	mov    %eax,%ecx
  804211afc4:	c1 e1 08             	shl    $0x8,%ecx
  804211afc7:	29 c1                	sub    %eax,%ecx
  804211afc9:	29 cb                	sub    %ecx,%ebx
  804211afcb:	88 1a                	mov    %bl,(%rdx)
  804211afcd:	e9 e7 00 00 00       	jmp    804211b0b9 <LZ4_compress_forceExtDict+0x729>
  804211afd2:	4c 89 b5 68 ff ff ff 	mov    %r14,-0x98(%rbp)
        forwardH = LZ4_hashPosition(++ip, tableType);
  804211afd9:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211afdd:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  804211afe1:	be 02 00 00 00       	mov    $0x2,%esi
  804211afe6:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211afed:	00 00 00 
  804211aff0:	ff d0                	call   *%rax
  804211aff2:	4c 89 fe             	mov    %r15,%rsi
  804211aff5:	49 89 df             	mov    %rbx,%r15
  804211aff8:	e9 d4 fa ff ff       	jmp    804211aad1 <LZ4_compress_forceExtDict+0x141>
                    match = base + matchIndex;
  804211affd:	89 d0                	mov    %edx,%eax
  804211afff:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211b003:	48 01 f8             	add    %rdi,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211b006:	44 89 29             	mov    %r13d,(%rcx)
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
  804211b009:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  804211b00d:	8d b2 ff ff 00 00    	lea    0xffff(%rdx),%esi
  804211b013:	44 39 ee             	cmp    %r13d,%esi
  804211b016:	0f 82 1d 01 00 00    	jb     804211b139 <LZ4_compress_forceExtDict+0x7a9>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  804211b01c:	8b 30                	mov    (%rax),%esi
  804211b01e:	41 39 37             	cmp    %esi,(%r15)
  804211b021:	0f 85 1e 01 00 00    	jne    804211b145 <LZ4_compress_forceExtDict+0x7b5>
                token=op++;
  804211b027:	49 8d 76 01          	lea    0x1(%r14),%rsi
  804211b02b:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
                *token=0;
  804211b02f:	41 c6 06 00          	movb   $0x0,(%r14)
                if (maybe_extMem) offset = current - matchIndex;
  804211b033:	41 29 d5             	sub    %edx,%r13d
static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
  804211b036:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211b03a:	66 44 89 2f          	mov    %r13w,(%rdi)
            LZ4_writeLE16(op, (U16)offset); op+=2;
  804211b03e:	4c 8d 67 02          	lea    0x2(%rdi),%r12
                 && (lowLimit==dictionary) /* match within extDict */ ) {
  804211b042:	48 39 4d 80          	cmp    %rcx,-0x80(%rbp)
  804211b046:	0f 84 6f fc ff ff    	je     804211acbb <LZ4_compress_forceExtDict+0x32b>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211b04c:	4d 8d 6f 04          	lea    0x4(%r15),%r13
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b050:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  804211b054:	49 39 cd             	cmp    %rcx,%r13
  804211b057:	0f 83 ad fe ff ff    	jae    804211af0a <LZ4_compress_forceExtDict+0x57a>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211b05d:	48 8b 50 04          	mov    0x4(%rax),%rdx
  804211b061:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211b065:	48 39 d7             	cmp    %rdx,%rdi
  804211b068:	0f 85 6f fe ff ff    	jne    804211aedd <LZ4_compress_forceExtDict+0x54d>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211b06e:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  804211b072:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b076:	48 39 cb             	cmp    %rcx,%rbx
  804211b079:	0f 83 92 fe ff ff    	jae    804211af11 <LZ4_compress_forceExtDict+0x581>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211b07f:	48 8b 10             	mov    (%rax),%rdx
  804211b082:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211b085:	48 39 d7             	cmp    %rdx,%rdi
  804211b088:	0f 84 65 fe ff ff    	je     804211aef3 <LZ4_compress_forceExtDict+0x563>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211b08e:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211b091:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211b098:	00 00 00 
  804211b09b:	ff d0                	call   *%rax
  804211b09d:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  804211b0a0:	44 29 eb             	sub    %r13d,%ebx
                ip += (size_t)matchCode + MINMATCH;
  804211b0a3:	89 d8                	mov    %ebx,%eax
  804211b0a5:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
            if (matchCode >= ML_MASK) {
  804211b0aa:	83 fb 0e             	cmp    $0xe,%ebx
  804211b0ad:	0f 87 c3 fe ff ff    	ja     804211af76 <LZ4_compress_forceExtDict+0x5e6>
                *token += (BYTE)(matchCode);
  804211b0b3:	41 00 1e             	add    %bl,(%r14)
  804211b0b6:	4d 89 e6             	mov    %r12,%r14
        if (ip >= mflimitPlusOne) break;
  804211b0b9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211b0bd:	49 39 c7             	cmp    %rax,%r15
  804211b0c0:	0f 83 98 00 00 00    	jae    804211b15e <LZ4_compress_forceExtDict+0x7ce>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b0c6:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  804211b0ca:	be 02 00 00 00       	mov    $0x2,%esi
  804211b0cf:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  804211b0d6:	00 00 00 
  804211b0d9:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211b0db:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  804211b0dd:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211b0e1:	4c 8b 65 c0          	mov    -0x40(%rbp),%r12
  804211b0e5:	4c 29 e2             	sub    %r12,%rdx
  804211b0e8:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211b0ec:	89 14 87             	mov    %edx,(%rdi,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b0ef:	49 8b 3f             	mov    (%r15),%rdi
  804211b0f2:	be 02 00 00 00       	mov    $0x2,%esi
  804211b0f7:	ff d3                	call   *%rbx
            U32 const current = (U32)(ip-base);
  804211b0f9:	4d 89 fd             	mov    %r15,%r13
  804211b0fc:	4d 29 e5             	sub    %r12,%r13
        return hashTable[h];
  804211b0ff:	89 c0                	mov    %eax,%eax
  804211b101:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211b105:	48 8d 0c 87          	lea    (%rdi,%rax,4),%rcx
  804211b109:	8b 11                	mov    (%rcx),%edx
                if (matchIndex < startIndex) {
  804211b10b:	8b 45 98             	mov    -0x68(%rbp),%eax
  804211b10e:	39 c2                	cmp    %eax,%edx
  804211b110:	0f 83 e7 fe ff ff    	jae    804211affd <LZ4_compress_forceExtDict+0x66d>
                    match = dictBase + matchIndex;
  804211b116:	89 d0                	mov    %edx,%eax
  804211b118:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  804211b11f:	48 01 f8             	add    %rdi,%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211b122:	44 89 29             	mov    %r13d,(%rcx)
            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)
  804211b125:	8b 7d 88             	mov    -0x78(%rbp),%edi
  804211b128:	39 fa                	cmp    %edi,%edx
  804211b12a:	0f 82 a2 fe ff ff    	jb     804211afd2 <LZ4_compress_forceExtDict+0x642>
  804211b130:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
  804211b134:	e9 d4 fe ff ff       	jmp    804211b00d <LZ4_compress_forceExtDict+0x67d>
  804211b139:	4c 89 b5 68 ff ff ff 	mov    %r14,-0x98(%rbp)
  804211b140:	e9 94 fe ff ff       	jmp    804211afd9 <LZ4_compress_forceExtDict+0x649>
  804211b145:	4c 89 b5 68 ff ff ff 	mov    %r14,-0x98(%rbp)
  804211b14c:	e9 88 fe ff ff       	jmp    804211afd9 <LZ4_compress_forceExtDict+0x649>
    BYTE* op = (BYTE*) dest;
  804211b151:	4c 89 b5 68 ff ff ff 	mov    %r14,-0x98(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  804211b158:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804211b15c:	eb 3f                	jmp    804211b19d <LZ4_compress_forceExtDict+0x80d>
        anchor = ip;
  804211b15e:	4c 89 b5 68 ff ff ff 	mov    %r14,-0x98(%rbp)
  804211b165:	4c 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%r14
  804211b16c:	44 8b ad 44 ff ff ff 	mov    -0xbc(%rbp),%r13d
  804211b173:	4c 89 fe             	mov    %r15,%rsi
  804211b176:	eb 25                	jmp    804211b19d <LZ4_compress_forceExtDict+0x80d>
  804211b178:	4c 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%r14
  804211b17f:	44 8b ad 44 ff ff ff 	mov    -0xbc(%rbp),%r13d
  804211b186:	eb 15                	jmp    804211b19d <LZ4_compress_forceExtDict+0x80d>
  804211b188:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  804211b18f:	4c 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%r14
  804211b196:	44 8b ad 44 ff ff ff 	mov    -0xbc(%rbp),%r13d
    {   size_t lastRun = (size_t)(iend - anchor);
  804211b19d:	4c 8b a5 60 ff ff ff 	mov    -0xa0(%rbp),%r12
  804211b1a4:	49 29 f4             	sub    %rsi,%r12
        if (lastRun >= RUN_MASK) {
  804211b1a7:	49 83 fc 0e          	cmp    $0xe,%r12
  804211b1ab:	76 58                	jbe    804211b205 <LZ4_compress_forceExtDict+0x875>
            size_t accumulator = lastRun - RUN_MASK;
  804211b1ad:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  804211b1b2:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  804211b1b9:	48 8d 41 01          	lea    0x1(%rcx),%rax
  804211b1bd:	c6 01 f0             	movb   $0xf0,(%rcx)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  804211b1c0:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211b1c7:	76 18                	jbe    804211b1e1 <LZ4_compress_forceExtDict+0x851>
  804211b1c9:	48 83 c0 01          	add    $0x1,%rax
  804211b1cd:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  804211b1d1:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  804211b1d8:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211b1df:	77 e8                	ja     804211b1c9 <LZ4_compress_forceExtDict+0x839>
            *op++ = (BYTE) accumulator;
  804211b1e1:	48 8d 58 01          	lea    0x1(%rax),%rbx
  804211b1e5:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  804211b1e7:	4c 89 e2             	mov    %r12,%rdx
  804211b1ea:	48 89 df             	mov    %rbx,%rdi
  804211b1ed:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211b1f4:	00 00 00 
  804211b1f7:	ff d0                	call   *%rax
        op += lastRun;
  804211b1f9:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
    result = (int)(((char*)op) - dest);
  804211b1fd:	44 29 f0             	sub    %r14d,%eax
    return result;
  804211b200:	e9 d7 07 00 00       	jmp    804211b9dc <LZ4_compress_forceExtDict+0x104c>
            *op++ = (BYTE)(lastRun<<ML_BITS);
  804211b205:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
  804211b20c:	48 8d 5f 01          	lea    0x1(%rdi),%rbx
  804211b210:	44 89 e0             	mov    %r12d,%eax
  804211b213:	c1 e0 04             	shl    $0x4,%eax
  804211b216:	88 07                	mov    %al,(%rdi)
  804211b218:	eb cd                	jmp    804211b1e7 <LZ4_compress_forceExtDict+0x857>
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */
  804211b21a:	b8 00 00 00 00       	mov    $0x0,%eax
  804211b21f:	41 81 fd 00 00 00 7e 	cmp    $0x7e000000,%r13d
  804211b226:	0f 87 b0 07 00 00    	ja     804211b9dc <LZ4_compress_forceExtDict+0x104c>
    U32 const startIndex = cctx->currentOffset;
  804211b22c:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
  804211b230:	41 8b bf 00 40 00 00 	mov    0x4000(%r15),%edi
            dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
  804211b237:	49 8b 8f 08 40 00 00 	mov    0x4008(%r15),%rcx
  804211b23e:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
    const BYTE* const iend = ip + inputSize;
  804211b242:	49 63 c5             	movslq %r13d,%rax
  804211b245:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
  804211b249:	49 8d 1c 04          	lea    (%r12,%rax,1),%rbx
  804211b24d:	48 89 9d 68 ff ff ff 	mov    %rbx,-0x98(%rbp)
        cctx->dictSize += (U32)inputSize;
  804211b254:	42 8d 04 2a          	lea    (%rdx,%r13,1),%eax
  804211b258:	41 89 87 18 40 00 00 	mov    %eax,0x4018(%r15)
    cctx->currentOffset += (U32)inputSize;
  804211b25f:	42 8d 04 2f          	lea    (%rdi,%r13,1),%eax
  804211b263:	41 89 87 00 40 00 00 	mov    %eax,0x4000(%r15)
    cctx->tableType = (U16)tableType;
  804211b26a:	66 41 c7 87 06 40 00 	movw   $0x2,0x4006(%r15)
  804211b271:	00 02 00 
    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */
  804211b274:	41 83 fd 0c          	cmp    $0xc,%r13d
  804211b278:	0f 8e af 06 00 00    	jle    804211b92d <LZ4_compress_forceExtDict+0xf9d>
    const BYTE* base = (const BYTE*) source - startIndex;
  804211b27e:	89 7d a0             	mov    %edi,-0x60(%rbp)
  804211b281:	89 f8                	mov    %edi,%eax
  804211b283:	4c 89 e7             	mov    %r12,%rdi
  804211b286:	48 29 c7             	sub    %rax,%rdi
  804211b289:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
    const BYTE* const dictEnd = dictionary + dictSize;
  804211b28d:	89 d2                	mov    %edx,%edx
  804211b28f:	4c 8d 04 11          	lea    (%rcx,%rdx,1),%r8
  804211b293:	4c 89 85 58 ff ff ff 	mov    %r8,-0xa8(%rbp)
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
  804211b29a:	4c 8d 4b f5          	lea    -0xb(%rbx),%r9
  804211b29e:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    const BYTE* const matchlimit = iend - LASTLITERALS;
  804211b2a2:	48 83 eb 05          	sub    $0x5,%rbx
  804211b2a6:	48 89 9d 60 ff ff ff 	mov    %rbx,-0xa0(%rbp)
                           dictionary + dictSize - startIndex;
  804211b2ad:	48 29 c2             	sub    %rax,%rdx
                           dictionary + dictSize - dictCtx->currentOffset :
  804211b2b0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  804211b2b4:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b2bb:	49 8b 3c 24          	mov    (%r12),%rdi
  804211b2bf:	be 02 00 00 00       	mov    $0x2,%esi
  804211b2c4:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  804211b2cb:	00 00 00 
  804211b2ce:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211b2d0:	89 c0                	mov    %eax,%eax
  804211b2d2:	8b 7d a0             	mov    -0x60(%rbp),%edi
  804211b2d5:	41 89 3c 87          	mov    %edi,(%r15,%rax,4)
    ip++; forwardH = LZ4_hashPosition(ip, tableType);
  804211b2d9:	4d 8d 7c 24 01       	lea    0x1(%r12),%r15
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b2de:	49 8b 7c 24 01       	mov    0x1(%r12),%rdi
  804211b2e3:	be 02 00 00 00       	mov    $0x2,%esi
  804211b2e8:	ff d3                	call   *%rbx
  804211b2ea:	4c 89 b5 70 ff ff ff 	mov    %r14,-0x90(%rbp)
  804211b2f1:	4c 89 e6             	mov    %r12,%rsi
  804211b2f4:	4c 89 b5 48 ff ff ff 	mov    %r14,-0xb8(%rbp)
  804211b2fb:	44 89 ad 44 ff ff ff 	mov    %r13d,-0xbc(%rbp)
                U32 const current = (U32)(forwardIp - base);
  804211b302:	44 89 fb             	mov    %r15d,%ebx
  804211b305:	8b 7d c0             	mov    -0x40(%rbp),%edi
  804211b308:	29 fb                	sub    %edi,%ebx
        return hashTable[h];
  804211b30a:	89 c0                	mov    %eax,%eax
  804211b30c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211b310:	4c 8d 34 82          	lea    (%rdx,%rax,4),%r14
  804211b314:	45 8b 2e             	mov    (%r14),%r13d
                forwardIp += step;
  804211b317:	4d 8d 67 01          	lea    0x1(%r15),%r12
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  804211b31b:	4c 39 65 98          	cmp    %r12,-0x68(%rbp)
  804211b31f:	0f 82 2f 06 00 00    	jb     804211b954 <LZ4_compress_forceExtDict+0xfc4>
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211b325:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
  804211b32c:	c7 45 a8 41 00 00 00 	movl   $0x41,-0x58(%rbp)
  804211b333:	4c 89 7d 90          	mov    %r15,-0x70(%rbp)
  804211b337:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  804211b33e:	eb 7c                	jmp    804211b3bc <LZ4_compress_forceExtDict+0xa2c>
                        match = base + matchIndex;
  804211b340:	45 89 ef             	mov    %r13d,%r15d
  804211b343:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211b347:	49 01 c7             	add    %rax,%r15
                        lowLimit = (const BYTE*)source;
  804211b34a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211b34e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b352:	49 8b 3c 24          	mov    (%r12),%rdi
  804211b356:	be 02 00 00 00       	mov    $0x2,%esi
  804211b35b:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211b362:	00 00 00 
  804211b365:	ff d0                	call   *%rax
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211b367:	41 89 1e             	mov    %ebx,(%r14)
                     && (matchIndex+LZ4_DISTANCE_MAX < current)) {
  804211b36a:	41 8d 95 ff ff 00 00 	lea    0xffff(%r13),%edx
  804211b371:	39 da                	cmp    %ebx,%edx
  804211b373:	72 0b                	jb     804211b380 <LZ4_compress_forceExtDict+0x9f0>
                if (LZ4_read32(match) == LZ4_read32(ip)) {
  804211b375:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  804211b379:	41 8b 0f             	mov    (%r15),%ecx
  804211b37c:	39 0e                	cmp    %ecx,(%rsi)
  804211b37e:	74 62                	je     804211b3e2 <LZ4_compress_forceExtDict+0xa52>
                U32 const current = (U32)(forwardIp - base);
  804211b380:	44 89 e3             	mov    %r12d,%ebx
  804211b383:	8b 75 c0             	mov    -0x40(%rbp),%esi
  804211b386:	29 f3                	sub    %esi,%ebx
        return hashTable[h];
  804211b388:	89 c0                	mov    %eax,%eax
  804211b38a:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211b38e:	4c 8d 34 86          	lea    (%rsi,%rax,4),%r14
  804211b392:	45 8b 2e             	mov    (%r14),%r13d
                forwardIp += step;
  804211b395:	48 63 45 b0          	movslq -0x50(%rbp),%rax
  804211b399:	4c 01 e0             	add    %r12,%rax
                step = (searchMatchNb++ >> LZ4_skipTrigger);
  804211b39c:	8b 4d a8             	mov    -0x58(%rbp),%ecx
  804211b39f:	8d 51 01             	lea    0x1(%rcx),%edx
  804211b3a2:	c1 f9 06             	sar    $0x6,%ecx
  804211b3a5:	89 4d b0             	mov    %ecx,-0x50(%rbp)
                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
  804211b3a8:	4c 89 65 90          	mov    %r12,-0x70(%rbp)
  804211b3ac:	48 39 45 98          	cmp    %rax,-0x68(%rbp)
  804211b3b0:	0f 82 ae 05 00 00    	jb     804211b964 <LZ4_compress_forceExtDict+0xfd4>
  804211b3b6:	89 55 a8             	mov    %edx,-0x58(%rbp)
  804211b3b9:	49 89 c4             	mov    %rax,%r12
                    if (matchIndex < startIndex) {
  804211b3bc:	8b 45 a0             	mov    -0x60(%rbp),%eax
  804211b3bf:	41 39 c5             	cmp    %eax,%r13d
  804211b3c2:	0f 83 78 ff ff ff    	jae    804211b340 <LZ4_compress_forceExtDict+0x9b0>
                        match = dictBase + matchIndex;
  804211b3c8:	45 89 ef             	mov    %r13d,%r15d
  804211b3cb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  804211b3d2:	49 01 c7             	add    %rax,%r15
                        lowLimit = dictionary;
  804211b3d5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  804211b3d9:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  804211b3dd:	e9 70 ff ff ff       	jmp    804211b352 <LZ4_compress_forceExtDict+0x9c2>
                    if (maybe_extMem) offset = current - matchIndex;
  804211b3e2:	4c 89 f8             	mov    %r15,%rax
  804211b3e5:	4d 89 fc             	mov    %r15,%r12
  804211b3e8:	49 89 f7             	mov    %rsi,%r15
  804211b3eb:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  804211b3f2:	44 29 eb             	sub    %r13d,%ebx
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211b3f5:	4c 39 fe             	cmp    %r15,%rsi
  804211b3f8:	73 12                	jae    804211b40c <LZ4_compress_forceExtDict+0xa7c>
  804211b3fa:	48 39 45 80          	cmp    %rax,-0x80(%rbp)
  804211b3fe:	73 0c                	jae    804211b40c <LZ4_compress_forceExtDict+0xa7c>
  804211b400:	41 0f b6 44 24 ff    	movzbl -0x1(%r12),%eax
  804211b406:	41 38 47 ff          	cmp    %al,-0x1(%r15)
  804211b40a:	74 79                	je     804211b485 <LZ4_compress_forceExtDict+0xaf5>
        {   unsigned const litLength = (unsigned)(ip - anchor);
  804211b40c:	4c 89 fa             	mov    %r15,%rdx
  804211b40f:	48 29 f2             	sub    %rsi,%rdx
            token = op++;
  804211b412:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  804211b419:	48 8d 78 01          	lea    0x1(%rax),%rdi
            if (litLength >= RUN_MASK) {
  804211b41d:	83 fa 0e             	cmp    $0xe,%edx
  804211b420:	0f 87 85 00 00 00    	ja     804211b4ab <LZ4_compress_forceExtDict+0xb1b>
            else *token = (BYTE)(litLength<<ML_BITS);
  804211b426:	89 d0                	mov    %edx,%eax
  804211b428:	c1 e0 04             	shl    $0x4,%eax
  804211b42b:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  804211b432:	88 01                	mov    %al,(%rcx)
            LZ4_wildCopy8(op, anchor, op+litLength);
  804211b434:	89 d2                	mov    %edx,%edx
  804211b436:	4c 8d 34 17          	lea    (%rdi,%rdx,1),%r14
  804211b43a:	4c 89 f2             	mov    %r14,%rdx
  804211b43d:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211b444:	00 00 00 
  804211b447:	ff d0                	call   *%rax
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b449:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  804211b450:	48 8d 48 f4          	lea    -0xc(%rax),%rcx
  804211b454:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211b458:	48 8d 78 f8          	lea    -0x8(%rax),%rdi
  804211b45c:	48 89 bd 50 ff ff ff 	mov    %rdi,-0xb0(%rbp)
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211b463:	48 83 e8 06          	sub    $0x6,%rax
  804211b467:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b46e:	4c 89 e0             	mov    %r12,%rax
  804211b471:	4c 89 75 b0          	mov    %r14,-0x50(%rbp)
  804211b475:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  804211b479:	4c 8b ad 70 ff ff ff 	mov    -0x90(%rbp),%r13
  804211b480:	e9 33 03 00 00       	jmp    804211b7b8 <LZ4_compress_forceExtDict+0xe28>
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
  804211b485:	49 83 ef 01          	sub    $0x1,%r15
  804211b489:	4c 89 e0             	mov    %r12,%rax
  804211b48c:	48 83 e8 01          	sub    $0x1,%rax
  804211b490:	49 89 c4             	mov    %rax,%r12
  804211b493:	4c 39 fe             	cmp    %r15,%rsi
  804211b496:	0f 83 70 ff ff ff    	jae    804211b40c <LZ4_compress_forceExtDict+0xa7c>
  804211b49c:	48 39 45 80          	cmp    %rax,-0x80(%rbp)
  804211b4a0:	0f 82 5a ff ff ff    	jb     804211b400 <LZ4_compress_forceExtDict+0xa70>
  804211b4a6:	e9 61 ff ff ff       	jmp    804211b40c <LZ4_compress_forceExtDict+0xa7c>
                int len = (int)(litLength - RUN_MASK);
  804211b4ab:	8d 42 f1             	lea    -0xf(%rdx),%eax
                *token = (RUN_MASK<<ML_BITS);
  804211b4ae:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  804211b4b5:	c6 01 f0             	movb   $0xf0,(%rcx)
                for(; len >= 255 ; len-=255) *op++ = 255;
  804211b4b8:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211b4bd:	7e 14                	jle    804211b4d3 <LZ4_compress_forceExtDict+0xb43>
  804211b4bf:	48 83 c7 01          	add    $0x1,%rdi
  804211b4c3:	c6 47 ff ff          	movb   $0xff,-0x1(%rdi)
  804211b4c7:	2d ff 00 00 00       	sub    $0xff,%eax
  804211b4cc:	3d fe 00 00 00       	cmp    $0xfe,%eax
  804211b4d1:	7f ec                	jg     804211b4bf <LZ4_compress_forceExtDict+0xb2f>
                *op++ = (BYTE)len;
  804211b4d3:	88 07                	mov    %al,(%rdi)
  804211b4d5:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  804211b4d9:	e9 56 ff ff ff       	jmp    804211b434 <LZ4_compress_forceExtDict+0xaa4>
                const BYTE* limit = ip + (dictEnd-match);
  804211b4de:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  804211b4e5:	48 29 c2             	sub    %rax,%rdx
  804211b4e8:	4c 01 fa             	add    %r15,%rdx
                if (limit > matchlimit) limit = matchlimit;
  804211b4eb:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  804211b4f2:	48 39 d6             	cmp    %rdx,%rsi
  804211b4f5:	48 0f 46 d6          	cmovbe %rsi,%rdx
  804211b4f9:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  804211b4fd:	4d 8d 77 04          	lea    0x4(%r15),%r14
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b501:	48 83 ea 07          	sub    $0x7,%rdx
  804211b505:	49 39 d6             	cmp    %rdx,%r14
  804211b508:	0f 83 eb 00 00 00    	jae    804211b5f9 <LZ4_compress_forceExtDict+0xc69>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211b50e:	48 8b 48 04          	mov    0x4(%rax),%rcx
  804211b512:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211b516:	48 39 cf             	cmp    %rcx,%rdi
  804211b519:	0f 85 b1 00 00 00    	jne    804211b5d0 <LZ4_compress_forceExtDict+0xc40>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211b51f:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  804211b523:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b527:	48 39 d3             	cmp    %rdx,%rbx
  804211b52a:	0f 83 d0 00 00 00    	jae    804211b600 <LZ4_compress_forceExtDict+0xc70>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211b530:	48 8b 08             	mov    (%rax),%rcx
  804211b533:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211b536:	48 39 cf             	cmp    %rcx,%rdi
  804211b539:	0f 84 a7 00 00 00    	je     804211b5e6 <LZ4_compress_forceExtDict+0xc56>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211b53f:	48 31 cf             	xor    %rcx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211b542:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211b549:	00 00 00 
  804211b54c:	ff d0                	call   *%rax
  804211b54e:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  804211b551:	44 29 f3             	sub    %r14d,%ebx
                ip += (size_t)matchCode + MINMATCH;
  804211b554:	89 d8                	mov    %ebx,%eax
  804211b556:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
                if (ip==limit) {
  804211b55b:	4c 39 7d 90          	cmp    %r15,-0x70(%rbp)
  804211b55f:	0f 85 af 01 00 00    	jne    804211b714 <LZ4_compress_forceExtDict+0xd84>
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b565:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  804211b569:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804211b56d:	48 39 d6             	cmp    %rdx,%rsi
  804211b570:	0f 83 14 01 00 00    	jae    804211b68a <LZ4_compress_forceExtDict+0xcfa>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211b576:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804211b57a:	48 8b 01             	mov    (%rcx),%rax
  804211b57d:	48 8b 3e             	mov    (%rsi),%rdi
        if (!diff) {
  804211b580:	48 39 c7             	cmp    %rax,%rdi
  804211b583:	0f 85 d3 00 00 00    	jne    804211b65c <LZ4_compress_forceExtDict+0xccc>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211b589:	4c 8d 76 08          	lea    0x8(%rsi),%r14
  804211b58d:	48 8d 41 08          	lea    0x8(%rcx),%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b591:	49 39 d6             	cmp    %rdx,%r14
  804211b594:	0f 83 f8 00 00 00    	jae    804211b692 <LZ4_compress_forceExtDict+0xd02>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211b59a:	48 8b 10             	mov    (%rax),%rdx
  804211b59d:	49 8b 3e             	mov    (%r14),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211b5a0:	48 39 d7             	cmp    %rdx,%rdi
  804211b5a3:	0f 84 ca 00 00 00    	je     804211b673 <LZ4_compress_forceExtDict+0xce3>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211b5a9:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211b5ac:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211b5b3:	00 00 00 
  804211b5b6:	ff d0                	call   *%rax
  804211b5b8:	46 8d 34 30          	lea    (%rax,%r14,1),%r14d
        return (unsigned)(pIn - pStart);
  804211b5bc:	8b 45 90             	mov    -0x70(%rbp),%eax
  804211b5bf:	41 29 c6             	sub    %eax,%r14d
                    matchCode += more;
  804211b5c2:	44 01 f3             	add    %r14d,%ebx
                    ip += more;
  804211b5c5:	45 89 f6             	mov    %r14d,%r14d
  804211b5c8:	4d 01 f7             	add    %r14,%r15
  804211b5cb:	e9 44 01 00 00       	jmp    804211b714 <LZ4_compress_forceExtDict+0xd84>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211b5d0:	48 31 cf             	xor    %rcx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211b5d3:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211b5da:	00 00 00 
  804211b5dd:	ff d0                	call   *%rax
  804211b5df:	89 c3                	mov    %eax,%ebx
  804211b5e1:	e9 6e ff ff ff       	jmp    804211b554 <LZ4_compress_forceExtDict+0xbc4>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211b5e6:	48 83 c3 08          	add    $0x8,%rbx
  804211b5ea:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b5ee:	48 39 d3             	cmp    %rdx,%rbx
  804211b5f1:	0f 82 39 ff ff ff    	jb     804211b530 <LZ4_compress_forceExtDict+0xba0>
  804211b5f7:	eb 07                	jmp    804211b600 <LZ4_compress_forceExtDict+0xc70>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
  804211b5f9:	48 83 c0 04          	add    $0x4,%rax
  804211b5fd:	4c 89 f3             	mov    %r14,%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211b600:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  804211b604:	48 8d 57 fd          	lea    -0x3(%rdi),%rdx
  804211b608:	48 39 d3             	cmp    %rdx,%rbx
  804211b60b:	73 06                	jae    804211b613 <LZ4_compress_forceExtDict+0xc83>
  804211b60d:	8b 38                	mov    (%rax),%edi
  804211b60f:	39 3b                	cmp    %edi,(%rbx)
  804211b611:	74 35                	je     804211b648 <LZ4_compress_forceExtDict+0xcb8>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211b613:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  804211b617:	48 8d 56 ff          	lea    -0x1(%rsi),%rdx
  804211b61b:	48 39 d3             	cmp    %rdx,%rbx
  804211b61e:	73 08                	jae    804211b628 <LZ4_compress_forceExtDict+0xc98>
  804211b620:	0f b7 30             	movzwl (%rax),%esi
  804211b623:	66 39 33             	cmp    %si,(%rbx)
  804211b626:	74 2a                	je     804211b652 <LZ4_compress_forceExtDict+0xcc2>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211b628:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  804211b62c:	48 39 d3             	cmp    %rdx,%rbx
  804211b62f:	73 0f                	jae    804211b640 <LZ4_compress_forceExtDict+0xcb0>
  804211b631:	0f b6 3b             	movzbl (%rbx),%edi
  804211b634:	40 38 38             	cmp    %dil,(%rax)
  804211b637:	0f 94 c0             	sete   %al
  804211b63a:	0f b6 c0             	movzbl %al,%eax
  804211b63d:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  804211b640:	44 29 f3             	sub    %r14d,%ebx
  804211b643:	e9 0c ff ff ff       	jmp    804211b554 <LZ4_compress_forceExtDict+0xbc4>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211b648:	48 83 c3 04          	add    $0x4,%rbx
  804211b64c:	48 83 c0 04          	add    $0x4,%rax
  804211b650:	eb c1                	jmp    804211b613 <LZ4_compress_forceExtDict+0xc83>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211b652:	48 83 c3 02          	add    $0x2,%rbx
  804211b656:	48 83 c0 02          	add    $0x2,%rax
  804211b65a:	eb cc                	jmp    804211b628 <LZ4_compress_forceExtDict+0xc98>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211b65c:	48 31 c7             	xor    %rax,%rdi
            return LZ4_NbCommonBytes(diff);
  804211b65f:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211b666:	00 00 00 
  804211b669:	ff d0                	call   *%rax
  804211b66b:	41 89 c6             	mov    %eax,%r14d
  804211b66e:	e9 4f ff ff ff       	jmp    804211b5c2 <LZ4_compress_forceExtDict+0xc32>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211b673:	49 83 c6 08          	add    $0x8,%r14
  804211b677:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b67b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804211b67f:	49 39 d6             	cmp    %rdx,%r14
  804211b682:	0f 82 12 ff ff ff    	jb     804211b59a <LZ4_compress_forceExtDict+0xc0a>
  804211b688:	eb 08                	jmp    804211b692 <LZ4_compress_forceExtDict+0xd02>
  804211b68a:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211b68e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211b692:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
  804211b699:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
  804211b69d:	49 39 d6             	cmp    %rdx,%r14
  804211b6a0:	73 07                	jae    804211b6a9 <LZ4_compress_forceExtDict+0xd19>
  804211b6a2:	8b 30                	mov    (%rax),%esi
  804211b6a4:	41 39 36             	cmp    %esi,(%r14)
  804211b6a7:	74 3f                	je     804211b6e8 <LZ4_compress_forceExtDict+0xd58>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211b6a9:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
  804211b6b0:	48 8d 57 fa          	lea    -0x6(%rdi),%rdx
  804211b6b4:	49 39 d6             	cmp    %rdx,%r14
  804211b6b7:	73 09                	jae    804211b6c2 <LZ4_compress_forceExtDict+0xd32>
  804211b6b9:	0f b7 38             	movzwl (%rax),%edi
  804211b6bc:	66 41 39 3e          	cmp    %di,(%r14)
  804211b6c0:	74 30                	je     804211b6f2 <LZ4_compress_forceExtDict+0xd62>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211b6c2:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  804211b6c9:	49 39 f6             	cmp    %rsi,%r14
  804211b6cc:	73 0f                	jae    804211b6dd <LZ4_compress_forceExtDict+0xd4d>
  804211b6ce:	41 0f b6 16          	movzbl (%r14),%edx
  804211b6d2:	38 10                	cmp    %dl,(%rax)
  804211b6d4:	0f 94 c0             	sete   %al
  804211b6d7:	0f b6 c0             	movzbl %al,%eax
  804211b6da:	49 01 c6             	add    %rax,%r14
    return (unsigned)(pIn - pStart);
  804211b6dd:	8b 45 90             	mov    -0x70(%rbp),%eax
  804211b6e0:	41 29 c6             	sub    %eax,%r14d
  804211b6e3:	e9 da fe ff ff       	jmp    804211b5c2 <LZ4_compress_forceExtDict+0xc32>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211b6e8:	49 83 c6 04          	add    $0x4,%r14
  804211b6ec:	48 83 c0 04          	add    $0x4,%rax
  804211b6f0:	eb b7                	jmp    804211b6a9 <LZ4_compress_forceExtDict+0xd19>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211b6f2:	49 83 c6 02          	add    $0x2,%r14
  804211b6f6:	48 83 c0 02          	add    $0x2,%rax
  804211b6fa:	eb c6                	jmp    804211b6c2 <LZ4_compress_forceExtDict+0xd32>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211b6fc:	48 31 d7             	xor    %rdx,%rdi
            return LZ4_NbCommonBytes(diff);
  804211b6ff:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211b706:	00 00 00 
  804211b709:	ff d0                	call   *%rax
  804211b70b:	89 c3                	mov    %eax,%ebx
                ip += (size_t)matchCode + MINMATCH;
  804211b70d:	89 d8                	mov    %ebx,%eax
  804211b70f:	4d 8d 7c 07 04       	lea    0x4(%r15,%rax,1),%r15
            if (matchCode >= ML_MASK) {
  804211b714:	83 fb 0e             	cmp    $0xe,%ebx
  804211b717:	0f 87 76 01 00 00    	ja     804211b893 <LZ4_compress_forceExtDict+0xf03>
                *token += (BYTE)(matchCode);
  804211b71d:	41 00 5d 00          	add    %bl,0x0(%r13)
  804211b721:	4d 89 e5             	mov    %r12,%r13
        if (ip >= mflimitPlusOne) break;
  804211b724:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211b728:	49 39 c7             	cmp    %rax,%r15
  804211b72b:	0f 83 09 02 00 00    	jae    804211b93a <LZ4_compress_forceExtDict+0xfaa>
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b731:	49 8b 7f fe          	mov    -0x2(%r15),%rdi
  804211b735:	be 02 00 00 00       	mov    $0x2,%esi
  804211b73a:	48 bb ce 28 11 42 80 	movabs $0x80421128ce,%rbx
  804211b741:	00 00 00 
  804211b744:	ff d3                	call   *%rbx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211b746:	89 c0                	mov    %eax,%eax
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
  804211b748:	49 8d 57 fe          	lea    -0x2(%r15),%rdx
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
  804211b74c:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
  804211b750:	4c 29 f2             	sub    %r14,%rdx
  804211b753:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  804211b757:	41 89 14 84          	mov    %edx,(%r12,%rax,4)
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b75b:	49 8b 3f             	mov    (%r15),%rdi
  804211b75e:	be 02 00 00 00       	mov    $0x2,%esi
  804211b763:	ff d3                	call   *%rbx
            U32 const current = (U32)(ip-base);
  804211b765:	4c 89 fb             	mov    %r15,%rbx
  804211b768:	4c 29 f3             	sub    %r14,%rbx
        return hashTable[h];
  804211b76b:	89 c0                	mov    %eax,%eax
  804211b76d:	49 8d 0c 84          	lea    (%r12,%rax,4),%rcx
  804211b771:	8b 11                	mov    (%rcx),%edx
                if (matchIndex < startIndex) {
  804211b773:	8b 45 a0             	mov    -0x60(%rbp),%eax
  804211b776:	39 c2                	cmp    %eax,%edx
  804211b778:	0f 83 72 01 00 00    	jae    804211b8f0 <LZ4_compress_forceExtDict+0xf60>
                    match = dictBase + matchIndex;
  804211b77e:	89 d0                	mov    %edx,%eax
  804211b780:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  804211b787:	48 01 f0             	add    %rsi,%rax
                    lowLimit = dictionary;   /* required for match length counter */
  804211b78a:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
        case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
  804211b78e:	89 19                	mov    %ebx,(%rcx)
                 && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
  804211b790:	8d 8a ff ff 00 00    	lea    0xffff(%rdx),%ecx
  804211b796:	39 d9                	cmp    %ebx,%ecx
  804211b798:	0f 82 64 01 00 00    	jb     804211b902 <LZ4_compress_forceExtDict+0xf72>
                 && (LZ4_read32(match) == LZ4_read32(ip)) ) {
  804211b79e:	8b 08                	mov    (%rax),%ecx
  804211b7a0:	41 39 0f             	cmp    %ecx,(%r15)
  804211b7a3:	0f 85 59 01 00 00    	jne    804211b902 <LZ4_compress_forceExtDict+0xf72>
                token=op++;
  804211b7a9:	49 8d 7d 01          	lea    0x1(%r13),%rdi
  804211b7ad:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
                *token=0;
  804211b7b1:	41 c6 45 00 00       	movb   $0x0,0x0(%r13)
                if (maybe_extMem) offset = current - matchIndex;
  804211b7b6:	29 d3                	sub    %edx,%ebx
static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
  804211b7b8:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  804211b7bc:	66 89 19             	mov    %bx,(%rcx)
            LZ4_writeLE16(op, (U16)offset); op+=2;
  804211b7bf:	4c 8d 61 02          	lea    0x2(%rcx),%r12
                 && (lowLimit==dictionary) /* match within extDict */ ) {
  804211b7c3:	48 39 75 88          	cmp    %rsi,-0x78(%rbp)
  804211b7c7:	0f 84 11 fd ff ff    	je     804211b4de <LZ4_compress_forceExtDict+0xb4e>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211b7cd:	4d 8d 77 04          	lea    0x4(%r15),%r14
    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b7d1:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  804211b7d5:	49 39 f6             	cmp    %rsi,%r14
  804211b7d8:	73 56                	jae    804211b830 <LZ4_compress_forceExtDict+0xea0>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211b7da:	48 8b 50 04          	mov    0x4(%rax),%rdx
  804211b7de:	49 8b 7f 04          	mov    0x4(%r15),%rdi
        if (!diff) {
  804211b7e2:	48 39 d7             	cmp    %rdx,%rdi
  804211b7e5:	0f 85 11 ff ff ff    	jne    804211b6fc <LZ4_compress_forceExtDict+0xd6c>
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
  804211b7eb:	49 8d 5f 0c          	lea    0xc(%r15),%rbx
  804211b7ef:	48 83 c0 0c          	add    $0xc,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b7f3:	48 39 f3             	cmp    %rsi,%rbx
  804211b7f6:	73 3f                	jae    804211b837 <LZ4_compress_forceExtDict+0xea7>
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
  804211b7f8:	48 8b 10             	mov    (%rax),%rdx
  804211b7fb:	48 8b 3b             	mov    (%rbx),%rdi
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211b7fe:	48 39 d7             	cmp    %rdx,%rdi
  804211b801:	74 1a                	je     804211b81d <LZ4_compress_forceExtDict+0xe8d>
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
  804211b803:	48 31 d7             	xor    %rdx,%rdi
        pIn += LZ4_NbCommonBytes(diff);
  804211b806:	48 b8 bf 28 11 42 80 	movabs $0x80421128bf,%rax
  804211b80d:	00 00 00 
  804211b810:	ff d0                	call   *%rax
  804211b812:	8d 1c 18             	lea    (%rax,%rbx,1),%ebx
        return (unsigned)(pIn - pStart);
  804211b815:	44 29 f3             	sub    %r14d,%ebx
  804211b818:	e9 f0 fe ff ff       	jmp    804211b70d <LZ4_compress_forceExtDict+0xd7d>
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
  804211b81d:	48 83 c3 08          	add    $0x8,%rbx
  804211b821:	48 83 c0 08          	add    $0x8,%rax
    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
  804211b825:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  804211b829:	48 39 f3             	cmp    %rsi,%rbx
  804211b82c:	72 ca                	jb     804211b7f8 <LZ4_compress_forceExtDict+0xe68>
  804211b82e:	eb 07                	jmp    804211b837 <LZ4_compress_forceExtDict+0xea7>
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
  804211b830:	48 83 c0 04          	add    $0x4,%rax
  804211b834:	4c 89 f3             	mov    %r14,%rbx
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211b837:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  804211b83e:	48 39 f3             	cmp    %rsi,%rbx
  804211b841:	73 06                	jae    804211b849 <LZ4_compress_forceExtDict+0xeb9>
  804211b843:	8b 10                	mov    (%rax),%edx
  804211b845:	39 13                	cmp    %edx,(%rbx)
  804211b847:	74 36                	je     804211b87f <LZ4_compress_forceExtDict+0xeef>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211b849:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
  804211b850:	48 39 f3             	cmp    %rsi,%rbx
  804211b853:	73 08                	jae    804211b85d <LZ4_compress_forceExtDict+0xecd>
  804211b855:	0f b7 38             	movzwl (%rax),%edi
  804211b858:	66 39 3b             	cmp    %di,(%rbx)
  804211b85b:	74 2c                	je     804211b889 <LZ4_compress_forceExtDict+0xef9>
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
  804211b85d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  804211b864:	48 39 f3             	cmp    %rsi,%rbx
  804211b867:	73 0e                	jae    804211b877 <LZ4_compress_forceExtDict+0xee7>
  804211b869:	0f b6 13             	movzbl (%rbx),%edx
  804211b86c:	38 10                	cmp    %dl,(%rax)
  804211b86e:	0f 94 c0             	sete   %al
  804211b871:	0f b6 c0             	movzbl %al,%eax
  804211b874:	48 01 c3             	add    %rax,%rbx
    return (unsigned)(pIn - pStart);
  804211b877:	44 29 f3             	sub    %r14d,%ebx
  804211b87a:	e9 8e fe ff ff       	jmp    804211b70d <LZ4_compress_forceExtDict+0xd7d>
    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
  804211b87f:	48 83 c3 04          	add    $0x4,%rbx
  804211b883:	48 83 c0 04          	add    $0x4,%rax
  804211b887:	eb c0                	jmp    804211b849 <LZ4_compress_forceExtDict+0xeb9>
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
  804211b889:	48 83 c3 02          	add    $0x2,%rbx
  804211b88d:	48 83 c0 02          	add    $0x2,%rax
  804211b891:	eb ca                	jmp    804211b85d <LZ4_compress_forceExtDict+0xecd>
                *token += ML_MASK;
  804211b893:	41 80 45 00 0f       	addb   $0xf,0x0(%r13)
                matchCode -= ML_MASK;
  804211b898:	83 eb 0f             	sub    $0xf,%ebx
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211b89b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211b89f:	c7 40 02 ff ff ff ff 	movl   $0xffffffff,0x2(%rax)
                while (matchCode >= 4*255) {
  804211b8a6:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  804211b8ac:	76 1a                	jbe    804211b8c8 <LZ4_compress_forceExtDict+0xf38>
                    op+=4;
  804211b8ae:	49 83 c4 04          	add    $0x4,%r12
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211b8b2:	41 c7 04 24 ff ff ff 	movl   $0xffffffff,(%r12)
  804211b8b9:	ff 
                    matchCode -= 4*255;
  804211b8ba:	81 eb fc 03 00 00    	sub    $0x3fc,%ebx
                while (matchCode >= 4*255) {
  804211b8c0:	81 fb fb 03 00 00    	cmp    $0x3fb,%ebx
  804211b8c6:	77 e6                	ja     804211b8ae <LZ4_compress_forceExtDict+0xf1e>
                op += matchCode / 255;
  804211b8c8:	89 d8                	mov    %ebx,%eax
  804211b8ca:	b9 81 80 80 80       	mov    $0x80808081,%ecx
  804211b8cf:	48 0f af c1          	imul   %rcx,%rax
  804211b8d3:	48 c1 e8 27          	shr    $0x27,%rax
  804211b8d7:	89 c2                	mov    %eax,%edx
  804211b8d9:	4c 01 e2             	add    %r12,%rdx
                *op++ = (BYTE)(matchCode % 255);
  804211b8dc:	4c 8d 6a 01          	lea    0x1(%rdx),%r13
  804211b8e0:	89 c1                	mov    %eax,%ecx
  804211b8e2:	c1 e1 08             	shl    $0x8,%ecx
  804211b8e5:	29 c1                	sub    %eax,%ecx
  804211b8e7:	29 cb                	sub    %ecx,%ebx
  804211b8e9:	88 1a                	mov    %bl,(%rdx)
  804211b8eb:	e9 34 fe ff ff       	jmp    804211b724 <LZ4_compress_forceExtDict+0xd94>
                    match = base + matchIndex;
  804211b8f0:	89 d0                	mov    %edx,%eax
  804211b8f2:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211b8f6:	48 01 f8             	add    %rdi,%rax
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
  804211b8f9:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804211b8fd:	e9 8c fe ff ff       	jmp    804211b78e <LZ4_compress_forceExtDict+0xdfe>
        forwardH = LZ4_hashPosition(++ip, tableType);
  804211b902:	4c 89 ad 70 ff ff ff 	mov    %r13,-0x90(%rbp)
  804211b909:	49 8d 5f 01          	lea    0x1(%r15),%rbx
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
  804211b90d:	49 8b 7f 01          	mov    0x1(%r15),%rdi
  804211b911:	be 02 00 00 00       	mov    $0x2,%esi
  804211b916:	48 b8 ce 28 11 42 80 	movabs $0x80421128ce,%rax
  804211b91d:	00 00 00 
  804211b920:	ff d0                	call   *%rax
  804211b922:	4c 89 fe             	mov    %r15,%rsi
  804211b925:	49 89 df             	mov    %rbx,%r15
  804211b928:	e9 d5 f9 ff ff       	jmp    804211b302 <LZ4_compress_forceExtDict+0x972>
    BYTE* op = (BYTE*) dest;
  804211b92d:	4c 89 b5 70 ff ff ff 	mov    %r14,-0x90(%rbp)
    const BYTE* anchor = (const BYTE*) source;
  804211b934:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  804211b938:	eb 3f                	jmp    804211b979 <LZ4_compress_forceExtDict+0xfe9>
        anchor = ip;
  804211b93a:	4c 89 ad 70 ff ff ff 	mov    %r13,-0x90(%rbp)
  804211b941:	4c 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%r14
  804211b948:	44 8b ad 44 ff ff ff 	mov    -0xbc(%rbp),%r13d
  804211b94f:	4c 89 fe             	mov    %r15,%rsi
  804211b952:	eb 25                	jmp    804211b979 <LZ4_compress_forceExtDict+0xfe9>
  804211b954:	4c 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%r14
  804211b95b:	44 8b ad 44 ff ff ff 	mov    -0xbc(%rbp),%r13d
  804211b962:	eb 15                	jmp    804211b979 <LZ4_compress_forceExtDict+0xfe9>
  804211b964:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  804211b96b:	4c 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%r14
  804211b972:	44 8b ad 44 ff ff ff 	mov    -0xbc(%rbp),%r13d
    {   size_t lastRun = (size_t)(iend - anchor);
  804211b979:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
  804211b980:	49 29 f4             	sub    %rsi,%r12
        if (lastRun >= RUN_MASK) {
  804211b983:	49 83 fc 0e          	cmp    $0xe,%r12
  804211b987:	76 7b                	jbe    804211ba04 <LZ4_compress_forceExtDict+0x1074>
            size_t accumulator = lastRun - RUN_MASK;
  804211b989:	49 8d 54 24 f1       	lea    -0xf(%r12),%rdx
            *op++ = RUN_MASK << ML_BITS;
  804211b98e:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  804211b995:	48 8d 47 01          	lea    0x1(%rdi),%rax
  804211b999:	c6 07 f0             	movb   $0xf0,(%rdi)
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
  804211b99c:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211b9a3:	76 18                	jbe    804211b9bd <LZ4_compress_forceExtDict+0x102d>
  804211b9a5:	48 83 c0 01          	add    $0x1,%rax
  804211b9a9:	c6 40 ff ff          	movb   $0xff,-0x1(%rax)
  804211b9ad:	48 81 ea ff 00 00 00 	sub    $0xff,%rdx
  804211b9b4:	48 81 fa fe 00 00 00 	cmp    $0xfe,%rdx
  804211b9bb:	77 e8                	ja     804211b9a5 <LZ4_compress_forceExtDict+0x1015>
            *op++ = (BYTE) accumulator;
  804211b9bd:	48 8d 58 01          	lea    0x1(%rax),%rbx
  804211b9c1:	88 10                	mov    %dl,(%rax)
        memcpy(op, anchor, lastRun);
  804211b9c3:	4c 89 e2             	mov    %r12,%rdx
  804211b9c6:	48 89 df             	mov    %rbx,%rdi
  804211b9c9:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211b9d0:	00 00 00 
  804211b9d3:	ff d0                	call   *%rax
        op += lastRun;
  804211b9d5:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
    result = (int)(((char*)op) - dest);
  804211b9d9:	44 29 f0             	sub    %r14d,%eax
    streamPtr->dictionary = (const BYTE*)source;
  804211b9dc:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804211b9e0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804211b9e4:	48 89 91 08 40 00 00 	mov    %rdx,0x4008(%rcx)
    streamPtr->dictSize = (U32)srcSize;
  804211b9eb:	44 89 a9 18 40 00 00 	mov    %r13d,0x4018(%rcx)
}
  804211b9f2:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
  804211b9f9:	5b                   	pop    %rbx
  804211b9fa:	41 5c                	pop    %r12
  804211b9fc:	41 5d                	pop    %r13
  804211b9fe:	41 5e                	pop    %r14
  804211ba00:	41 5f                	pop    %r15
  804211ba02:	5d                   	pop    %rbp
  804211ba03:	c3                   	ret
            *op++ = (BYTE)(lastRun<<ML_BITS);
  804211ba04:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  804211ba0b:	48 8d 5a 01          	lea    0x1(%rdx),%rbx
  804211ba0f:	44 89 e0             	mov    %r12d,%eax
  804211ba12:	c1 e0 04             	shl    $0x4,%eax
  804211ba15:	88 02                	mov    %al,(%rdx)
  804211ba17:	eb aa                	jmp    804211b9c3 <LZ4_compress_forceExtDict+0x1033>

000000804211ba19 <LZ4_saveDict>:
{
  804211ba19:	f3 0f 1e fa          	endbr64
  804211ba1d:	55                   	push   %rbp
  804211ba1e:	48 89 e5             	mov    %rsp,%rbp
  804211ba21:	41 55                	push   %r13
  804211ba23:	41 54                	push   %r12
  804211ba25:	53                   	push   %rbx
  804211ba26:	48 83 ec 08          	sub    $0x8,%rsp
  804211ba2a:	49 89 fc             	mov    %rdi,%r12
  804211ba2d:	49 89 f5             	mov    %rsi,%r13
  804211ba30:	89 d3                	mov    %edx,%ebx
    const BYTE* const previousDictEnd = dict->dictionary + dict->dictSize;
  804211ba32:	8b 87 18 40 00 00    	mov    0x4018(%rdi),%eax
  804211ba38:	89 c6                	mov    %eax,%esi
    if ((U32)dictSize > 64 KB) { dictSize = 64 KB; } /* useless to define a dictionary > 64 KB */
  804211ba3a:	ba 00 00 01 00       	mov    $0x10000,%edx
  804211ba3f:	39 d3                	cmp    %edx,%ebx
  804211ba41:	0f 47 da             	cmova  %edx,%ebx
    if ((U32)dictSize > dict->dictSize) { dictSize = (int)dict->dictSize; }
  804211ba44:	39 c3                	cmp    %eax,%ebx
  804211ba46:	0f 47 d8             	cmova  %eax,%ebx
    memmove(safeBuffer, previousDictEnd - dictSize, dictSize);
  804211ba49:	48 63 d3             	movslq %ebx,%rdx
  804211ba4c:	48 29 d6             	sub    %rdx,%rsi
  804211ba4f:	48 03 b7 08 40 00 00 	add    0x4008(%rdi),%rsi
  804211ba56:	4c 89 ef             	mov    %r13,%rdi
  804211ba59:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211ba60:	00 00 00 
  804211ba63:	ff d0                	call   *%rax
    dict->dictionary = (const BYTE*)safeBuffer;
  804211ba65:	4d 89 ac 24 08 40 00 	mov    %r13,0x4008(%r12)
  804211ba6c:	00 
    dict->dictSize = (U32)dictSize;
  804211ba6d:	41 89 9c 24 18 40 00 	mov    %ebx,0x4018(%r12)
  804211ba74:	00 
}
  804211ba75:	89 d8                	mov    %ebx,%eax
  804211ba77:	48 83 c4 08          	add    $0x8,%rsp
  804211ba7b:	5b                   	pop    %rbx
  804211ba7c:	41 5c                	pop    %r12
  804211ba7e:	41 5d                	pop    %r13
  804211ba80:	5d                   	pop    %rbp
  804211ba81:	c3                   	ret

000000804211ba82 <LZ4_decompress_safe>:
{
  804211ba82:	f3 0f 1e fa          	endbr64
  804211ba86:	55                   	push   %rbp
  804211ba87:	48 89 e5             	mov    %rsp,%rbp
  804211ba8a:	41 57                	push   %r15
  804211ba8c:	41 56                	push   %r14
  804211ba8e:	41 55                	push   %r13
  804211ba90:	41 54                	push   %r12
  804211ba92:	53                   	push   %rbx
  804211ba93:	48 83 ec 48          	sub    $0x48,%rsp
  804211ba97:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  804211ba9b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    if (src == NULL) { return -1; }
  804211ba9f:	48 85 ff             	test   %rdi,%rdi
  804211baa2:	0f 84 d7 06 00 00    	je     804211c17f <LZ4_decompress_safe+0x6fd>
        const BYTE* const iend = ip + srcSize;
  804211baa8:	48 63 c2             	movslq %edx,%rax
  804211baab:	48 01 f8             	add    %rdi,%rax
  804211baae:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        BYTE* const oend = op + outputSize;
  804211bab2:	48 63 c1             	movslq %ecx,%rax
  804211bab5:	48 01 f0             	add    %rsi,%rax
  804211bab8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  804211babc:	48 83 e8 20          	sub    $0x20,%rax
  804211bac0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        if ((endOnInput) && (unlikely(outputSize==0))) {
  804211bac4:	85 c9                	test   %ecx,%ecx
  804211bac6:	74 2e                	je     804211baf6 <LZ4_decompress_safe+0x74>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211bac8:	85 d2                	test   %edx,%edx
  804211baca:	0f 84 b6 06 00 00    	je     804211c186 <LZ4_decompress_safe+0x704>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  804211bad0:	83 f9 3f             	cmp    $0x3f,%ecx
  804211bad3:	0f 8e 1a 05 00 00    	jle    804211bff3 <LZ4_decompress_safe+0x571>
    {   const BYTE* ip = (const BYTE*) src;
  804211bad9:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211badd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211bae1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211bae5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211bae9:	48 83 e8 11          	sub    $0x11,%rax
  804211baed:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  804211baf1:	e9 3e 01 00 00       	jmp    804211bc34 <LZ4_decompress_safe+0x1b2>
            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
  804211baf6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211bafb:	83 fa 01             	cmp    $0x1,%edx
  804211bafe:	0f 85 53 06 00 00    	jne    804211c157 <LZ4_decompress_safe+0x6d5>
  804211bb04:	0f b6 07             	movzbl (%rdi),%eax
  804211bb07:	f6 d8                	neg    %al
  804211bb09:	19 c0                	sbb    %eax,%eax
  804211bb0b:	e9 47 06 00 00       	jmp    804211c157 <LZ4_decompress_safe+0x6d5>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211bb10:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211bb14:	48 8d 50 f1          	lea    -0xf(%rax),%rdx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211bb18:	49 39 d5             	cmp    %rdx,%r13
  804211bb1b:	0f 83 27 06 00 00    	jae    804211c148 <LZ4_decompress_safe+0x6c6>
  804211bb21:	41 be 00 00 00 00    	mov    $0x0,%r14d
        s = **ip;
  804211bb27:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  804211bb2c:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  804211bb30:	41 01 c6             	add    %eax,%r14d
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211bb33:	4c 39 ea             	cmp    %r13,%rdx
  804211bb36:	74 07                	je     804211bb3f <LZ4_decompress_safe+0xbd>
    } while (s==255);
  804211bb38:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211bb3d:	74 e8                	je     804211bb27 <LZ4_decompress_safe+0xa5>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211bb3f:	45 89 f6             	mov    %r14d,%r14d
  804211bb42:	49 83 c6 0f          	add    $0xf,%r14
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211bb46:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211bb4a:	48 89 f8             	mov    %rdi,%rax
  804211bb4d:	4c 01 f0             	add    %r14,%rax
  804211bb50:	0f 82 10 06 00 00    	jb     804211c166 <LZ4_decompress_safe+0x6e4>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211bb56:	4c 89 e8             	mov    %r13,%rax
  804211bb59:	4c 01 f0             	add    %r14,%rax
  804211bb5c:	0f 82 09 06 00 00    	jb     804211c16b <LZ4_decompress_safe+0x6e9>
                cpy = op+length;
  804211bb62:	4e 8d 3c 37          	lea    (%rdi,%r14,1),%r15
                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
  804211bb66:	4c 39 7d 98          	cmp    %r15,-0x68(%rbp)
  804211bb6a:	0f 82 0c 03 00 00    	jb     804211be7c <LZ4_decompress_safe+0x3fa>
  804211bb70:	4b 8d 5c 35 00       	lea    0x0(%r13,%r14,1),%rbx
  804211bb75:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211bb79:	48 83 e8 20          	sub    $0x20,%rax
  804211bb7d:	48 39 d8             	cmp    %rbx,%rax
  804211bb80:	0f 82 fe 02 00 00    	jb     804211be84 <LZ4_decompress_safe+0x402>
                    LZ4_wildCopy32(op, ip, cpy);
  804211bb86:	4c 89 fa             	mov    %r15,%rdx
  804211bb89:	4c 89 ee             	mov    %r13,%rsi
  804211bb8c:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211bb93:	00 00 00 
  804211bb96:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211bb98:	e9 df 00 00 00       	jmp    804211bc7c <LZ4_decompress_safe+0x1fa>
                if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211bb9d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211bba1:	49 39 c6             	cmp    %rax,%r14
  804211bba4:	0f 82 a1 05 00 00    	jb     804211c14b <LZ4_decompress_safe+0x6c9>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211bbaa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211bbae:	48 8d 70 fc          	lea    -0x4(%rax),%rsi
  804211bbb2:	b8 00 00 00 00       	mov    $0x0,%eax
        s = **ip;
  804211bbb7:	0f b6 13             	movzbl (%rbx),%edx
        (*ip)++;
  804211bbba:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211bbbe:	01 d0                	add    %edx,%eax
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211bbc0:	48 39 f3             	cmp    %rsi,%rbx
  804211bbc3:	0f 83 82 05 00 00    	jae    804211c14b <LZ4_decompress_safe+0x6c9>
    } while (s==255);
  804211bbc9:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  804211bbcf:	74 e6                	je     804211bbb7 <LZ4_decompress_safe+0x135>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211bbd1:	41 89 c4             	mov    %eax,%r12d
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
  804211bbd4:	4b 8d 44 27 0f       	lea    0xf(%r15,%r12,1),%rax
  804211bbd9:	4c 39 f8             	cmp    %r15,%rax
  804211bbdc:	0f 82 69 05 00 00    	jb     804211c14b <LZ4_decompress_safe+0x6c9>
                length += MINMATCH;
  804211bbe2:	49 83 c4 13          	add    $0x13,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211bbe6:	4b 8d 14 27          	lea    (%r15,%r12,1),%rdx
  804211bbea:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211bbee:	48 83 e8 40          	sub    $0x40,%rax
  804211bbf2:	48 39 c2             	cmp    %rax,%rdx
  804211bbf5:	72 15                	jb     804211bc0c <LZ4_decompress_safe+0x18a>
  804211bbf7:	49 89 cd             	mov    %rcx,%r13
  804211bbfa:	e9 c5 04 00 00       	jmp    804211c0c4 <LZ4_decompress_safe+0x642>
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211bbff:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211bc03:	49 39 c6             	cmp    %rax,%r14
  804211bc06:	0f 82 3f 05 00 00    	jb     804211c14b <LZ4_decompress_safe+0x6c9>
            cpy = op + length;
  804211bc0c:	4b 8d 04 27          	lea    (%r15,%r12,1),%rax
  804211bc10:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<16)) {
  804211bc14:	48 83 f9 0f          	cmp    $0xf,%rcx
  804211bc18:	0f 86 f9 00 00 00    	jbe    804211bd17 <LZ4_decompress_safe+0x295>
                LZ4_wildCopy32(op, match, cpy);
  804211bc1e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211bc22:	4c 89 f6             	mov    %r14,%rsi
  804211bc25:	4c 89 ff             	mov    %r15,%rdi
  804211bc28:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211bc2f:	00 00 00 
  804211bc32:	ff d0                	call   *%rax
            token = *ip++;
  804211bc34:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  804211bc38:	44 0f b6 23          	movzbl (%rbx),%r12d
  804211bc3c:	41 0f b6 cc          	movzbl %r12b,%ecx
            length = token >> ML_BITS;  /* literal length */
  804211bc40:	89 c8                	mov    %ecx,%eax
  804211bc42:	c1 e8 04             	shr    $0x4,%eax
  804211bc45:	41 89 c6             	mov    %eax,%r14d
            if (length == RUN_MASK) {
  804211bc48:	83 f8 0f             	cmp    $0xf,%eax
  804211bc4b:	0f 84 bf fe ff ff    	je     804211bb10 <LZ4_decompress_safe+0x8e>
                cpy = op+length;
  804211bc51:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211bc55:	4e 8d 3c 37          	lea    (%rdi,%r14,1),%r15
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211bc59:	4c 39 6d a0          	cmp    %r13,-0x60(%rbp)
  804211bc5d:	0f 82 29 02 00 00    	jb     804211be8c <LZ4_decompress_safe+0x40a>
                    memcpy(op, ip, 16);
  804211bc63:	ba 10 00 00 00       	mov    $0x10,%edx
  804211bc68:	4c 89 ee             	mov    %r13,%rsi
  804211bc6b:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211bc72:	00 00 00 
  804211bc75:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211bc77:	4b 8d 5c 35 00       	lea    0x0(%r13,%r14,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211bc7c:	48 89 df             	mov    %rbx,%rdi
  804211bc7f:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211bc86:	00 00 00 
  804211bc89:	ff d0                	call   *%rax
  804211bc8b:	0f b7 c8             	movzwl %ax,%ecx
  804211bc8e:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211bc92:	4d 89 fe             	mov    %r15,%r14
  804211bc95:	49 29 ce             	sub    %rcx,%r14
            length = token & ML_MASK;
  804211bc98:	41 83 e4 0f          	and    $0xf,%r12d
            if (length == ML_MASK) {
  804211bc9c:	49 83 fc 0f          	cmp    $0xf,%r12
  804211bca0:	0f 84 f7 fe ff ff    	je     804211bb9d <LZ4_decompress_safe+0x11b>
                length += MINMATCH;
  804211bca6:	49 83 c4 04          	add    $0x4,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211bcaa:	4b 8d 34 27          	lea    (%r15,%r12,1),%rsi
  804211bcae:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  804211bcb2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211bcb6:	48 83 e8 40          	sub    $0x40,%rax
  804211bcba:	48 39 c6             	cmp    %rax,%rsi
  804211bcbd:	0f 83 53 02 00 00    	jae    804211bf16 <LZ4_decompress_safe+0x494>
                    if (offset >= 8) {
  804211bcc3:	48 83 f9 07          	cmp    $0x7,%rcx
  804211bcc7:	0f 86 32 ff ff ff    	jbe    804211bbff <LZ4_decompress_safe+0x17d>
  804211bccd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211bcd1:	49 39 c6             	cmp    %rax,%r14
  804211bcd4:	0f 82 25 ff ff ff    	jb     804211bbff <LZ4_decompress_safe+0x17d>
                        memcpy(op, match, 8);
  804211bcda:	ba 08 00 00 00       	mov    $0x8,%edx
  804211bcdf:	4c 89 f6             	mov    %r14,%rsi
  804211bce2:	4c 89 ff             	mov    %r15,%rdi
  804211bce5:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  804211bcec:	00 00 00 
  804211bcef:	41 ff d4             	call   *%r12
                        memcpy(op+8, match+8, 8);
  804211bcf2:	49 8d 76 08          	lea    0x8(%r14),%rsi
  804211bcf6:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211bcfa:	ba 08 00 00 00       	mov    $0x8,%edx
  804211bcff:	41 ff d4             	call   *%r12
                        memcpy(op+16, match+16, 2);
  804211bd02:	49 8d 76 10          	lea    0x10(%r14),%rsi
  804211bd06:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211bd0a:	ba 02 00 00 00       	mov    $0x2,%edx
  804211bd0f:	41 ff d4             	call   *%r12
                        continue;
  804211bd12:	e9 1d ff ff ff       	jmp    804211bc34 <LZ4_decompress_safe+0x1b2>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  804211bd17:	48 89 c2             	mov    %rax,%rdx
  804211bd1a:	4c 89 f6             	mov    %r14,%rsi
  804211bd1d:	4c 89 ff             	mov    %r15,%rdi
  804211bd20:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  804211bd27:	00 00 00 
  804211bd2a:	ff d0                	call   *%rax
  804211bd2c:	e9 03 ff ff ff       	jmp    804211bc34 <LZ4_decompress_safe+0x1b2>
                    memcpy(op + 0, match + 0, 8);
  804211bd31:	ba 08 00 00 00       	mov    $0x8,%edx
  804211bd36:	4c 89 f6             	mov    %r14,%rsi
  804211bd39:	4c 89 ff             	mov    %r15,%rdi
  804211bd3c:	49 bd 62 0d 11 42 80 	movabs $0x8042110d62,%r13
  804211bd43:	00 00 00 
  804211bd46:	41 ff d5             	call   *%r13
                    memcpy(op + 8, match + 8, 8);
  804211bd49:	49 8d 76 08          	lea    0x8(%r14),%rsi
  804211bd4d:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211bd51:	ba 08 00 00 00       	mov    $0x8,%edx
  804211bd56:	41 ff d5             	call   *%r13
                    memcpy(op +16, match +16, 2);
  804211bd59:	49 8d 76 10          	lea    0x10(%r14),%rsi
  804211bd5d:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211bd61:	ba 02 00 00 00       	mov    $0x2,%edx
  804211bd66:	41 ff d5             	call   *%r13
                    op += length + MINMATCH;
  804211bd69:	4f 8d 7c 27 04       	lea    0x4(%r15,%r12,1),%r15
            token = *ip++;
  804211bd6e:	4c 8d 73 03          	lea    0x3(%rbx),%r14
  804211bd72:	44 0f b6 63 02       	movzbl 0x2(%rbx),%r12d
  804211bd77:	41 0f b6 d4          	movzbl %r12b,%edx
            length = token >> ML_BITS;  /* literal length */
  804211bd7b:	89 d0                	mov    %edx,%eax
  804211bd7d:	c1 e8 04             	shr    $0x4,%eax
  804211bd80:	89 c3                	mov    %eax,%ebx
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211bd82:	83 f8 0f             	cmp    $0xf,%eax
  804211bd85:	74 26                	je     804211bdad <LZ4_decompress_safe+0x32b>
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211bd87:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211bd8b:	49 39 c6             	cmp    %rax,%r14
  804211bd8e:	0f 83 d9 00 00 00    	jae    804211be6d <LZ4_decompress_safe+0x3eb>
  804211bd94:	4c 39 7d 98          	cmp    %r15,-0x68(%rbp)
  804211bd98:	0f 83 ac 02 00 00    	jae    804211c04a <LZ4_decompress_safe+0x5c8>
  804211bd9e:	89 55 a0             	mov    %edx,-0x60(%rbp)
  804211bda1:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211bda5:	4d 89 f5             	mov    %r14,%r13
  804211bda8:	49 89 de             	mov    %rbx,%r14
  804211bdab:	eb 56                	jmp    804211be03 <LZ4_decompress_safe+0x381>
  804211bdad:	89 55 a0             	mov    %edx,-0x60(%rbp)
  804211bdb0:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211bdb4:	4d 89 f5             	mov    %r14,%r13
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211bdb7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211bdbb:	48 8d 48 f1          	lea    -0xf(%rax),%rcx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211bdbf:	49 39 cd             	cmp    %rcx,%r13
  804211bdc2:	0f 83 a8 03 00 00    	jae    804211c170 <LZ4_decompress_safe+0x6ee>
  804211bdc8:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211bdcd:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  804211bdd2:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  804211bdd6:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211bdd8:	4c 39 e9             	cmp    %r13,%rcx
  804211bddb:	74 07                	je     804211bde4 <LZ4_decompress_safe+0x362>
    } while (s==255);
  804211bddd:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211bde2:	74 e9                	je     804211bdcd <LZ4_decompress_safe+0x34b>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211bde4:	89 d2                	mov    %edx,%edx
  804211bde6:	4c 8d 72 0f          	lea    0xf(%rdx),%r14
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211bdea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211bdee:	4c 01 f0             	add    %r14,%rax
  804211bdf1:	0f 82 7e 03 00 00    	jb     804211c175 <LZ4_decompress_safe+0x6f3>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211bdf7:	4c 89 e8             	mov    %r13,%rax
  804211bdfa:	4c 01 f0             	add    %r14,%rax
  804211bdfd:	0f 82 77 03 00 00    	jb     804211c17a <LZ4_decompress_safe+0x6f8>
            cpy = op+length;
  804211be03:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211be07:	4e 8d 3c 30          	lea    (%rax,%r14,1),%r15
  804211be0b:	4c 89 eb             	mov    %r13,%rbx
            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
  804211be0e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211be12:	48 83 e8 0c          	sub    $0xc,%rax
  804211be16:	4c 39 f8             	cmp    %r15,%rax
  804211be19:	72 11                	jb     804211be2c <LZ4_decompress_safe+0x3aa>
  804211be1b:	4e 8d 24 33          	lea    (%rbx,%r14,1),%r12
  804211be1f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211be23:	48 83 e8 08          	sub    $0x8,%rax
  804211be27:	4c 39 e0             	cmp    %r12,%rax
  804211be2a:	73 6b                	jae    804211be97 <LZ4_decompress_safe+0x415>
                    if ((endOnInput) && ((ip+length != iend) || (cpy > oend))) { goto _output_error; }
  804211be2c:	4a 8d 04 33          	lea    (%rbx,%r14,1),%rax
  804211be30:	48 39 45 b8          	cmp    %rax,-0x48(%rbp)
  804211be34:	0f 85 11 03 00 00    	jne    804211c14b <LZ4_decompress_safe+0x6c9>
  804211be3a:	4c 39 7d b0          	cmp    %r15,-0x50(%rbp)
  804211be3e:	0f 82 07 03 00 00    	jb     804211c14b <LZ4_decompress_safe+0x6c9>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  804211be44:	4c 89 f2             	mov    %r14,%rdx
  804211be47:	48 89 de             	mov    %rbx,%rsi
  804211be4a:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804211be4e:	48 89 df             	mov    %rbx,%rdi
  804211be51:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211be58:	00 00 00 
  804211be5b:	ff d0                	call   *%rax
                op += length;
  804211be5d:	48 89 d8             	mov    %rbx,%rax
  804211be60:	4c 01 f0             	add    %r14,%rax
            return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
  804211be63:	8b 4d c0             	mov    -0x40(%rbp),%ecx
  804211be66:	29 c8                	sub    %ecx,%eax
  804211be68:	e9 ea 02 00 00       	jmp    804211c157 <LZ4_decompress_safe+0x6d5>
  804211be6d:	89 55 a0             	mov    %edx,-0x60(%rbp)
  804211be70:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211be74:	4d 89 f5             	mov    %r14,%r13
  804211be77:	49 89 de             	mov    %rbx,%r14
  804211be7a:	eb 87                	jmp    804211be03 <LZ4_decompress_safe+0x381>
  804211be7c:	89 4d a0             	mov    %ecx,-0x60(%rbp)
  804211be7f:	4c 89 eb             	mov    %r13,%rbx
  804211be82:	eb 8a                	jmp    804211be0e <LZ4_decompress_safe+0x38c>
  804211be84:	89 4d a0             	mov    %ecx,-0x60(%rbp)
  804211be87:	4c 89 eb             	mov    %r13,%rbx
  804211be8a:	eb 82                	jmp    804211be0e <LZ4_decompress_safe+0x38c>
            token = *ip++;
  804211be8c:	89 4d a0             	mov    %ecx,-0x60(%rbp)
  804211be8f:	4c 89 eb             	mov    %r13,%rbx
  804211be92:	e9 77 ff ff ff       	jmp    804211be0e <LZ4_decompress_safe+0x38c>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  804211be97:	4c 89 fa             	mov    %r15,%rdx
  804211be9a:	48 89 de             	mov    %rbx,%rsi
  804211be9d:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211bea1:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211bea8:	00 00 00 
  804211beab:	ff d0                	call   *%rax
            offset = LZ4_readLE16(ip); ip+=2;
  804211bead:	4c 89 e7             	mov    %r12,%rdi
  804211beb0:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211beb7:	00 00 00 
  804211beba:	ff d0                	call   *%rax
  804211bebc:	44 0f b7 e8          	movzwl %ax,%r13d
  804211bec0:	49 8d 5c 24 02       	lea    0x2(%r12),%rbx
            match = op - offset;
  804211bec5:	4d 89 fe             	mov    %r15,%r14
  804211bec8:	4d 29 ee             	sub    %r13,%r14
            length = token & ML_MASK;
  804211becb:	44 8b 65 a0          	mov    -0x60(%rbp),%r12d
  804211becf:	41 83 e4 0f          	and    $0xf,%r12d
  804211bed3:	e9 d1 01 00 00       	jmp    804211c0a9 <LZ4_decompress_safe+0x627>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211bed8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211bedc:	48 8d 48 fc          	lea    -0x4(%rax),%rcx
  804211bee0:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211bee5:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211bee8:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211beec:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211beee:	48 39 cb             	cmp    %rcx,%rbx
  804211bef1:	0f 83 54 02 00 00    	jae    804211c14b <LZ4_decompress_safe+0x6c9>
    } while (s==255);
  804211bef7:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211befc:	74 e7                	je     804211bee5 <LZ4_decompress_safe+0x463>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211befe:	41 89 d4             	mov    %edx,%r12d
  804211bf01:	49 83 c4 0f          	add    $0xf,%r12
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
  804211bf05:	4c 89 f8             	mov    %r15,%rax
  804211bf08:	4c 01 e0             	add    %r12,%rax
  804211bf0b:	0f 83 a2 01 00 00    	jae    804211c0b3 <LZ4_decompress_safe+0x631>
  804211bf11:	e9 35 02 00 00       	jmp    804211c14b <LZ4_decompress_safe+0x6c9>
  804211bf16:	49 89 cd             	mov    %rcx,%r13
  804211bf19:	e9 99 01 00 00       	jmp    804211c0b7 <LZ4_decompress_safe+0x635>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211bf1e:	41 c7 07 00 00 00 00 	movl   $0x0,(%r15)
                op[0] = match[0];
  804211bf25:	41 0f b6 06          	movzbl (%r14),%eax
  804211bf29:	41 88 07             	mov    %al,(%r15)
                op[1] = match[1];
  804211bf2c:	41 0f b6 46 01       	movzbl 0x1(%r14),%eax
  804211bf31:	41 88 47 01          	mov    %al,0x1(%r15)
                op[2] = match[2];
  804211bf35:	41 0f b6 46 02       	movzbl 0x2(%r14),%eax
  804211bf3a:	41 88 47 02          	mov    %al,0x2(%r15)
                op[3] = match[3];
  804211bf3e:	41 0f b6 46 03       	movzbl 0x3(%r14),%eax
  804211bf43:	41 88 47 03          	mov    %al,0x3(%r15)
                match += inc32table[offset];
  804211bf47:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  804211bf4e:	00 00 00 
  804211bf51:	42 8b 04 a8          	mov    (%rax,%r13,4),%eax
  804211bf55:	49 01 c6             	add    %rax,%r14
                memcpy(op+4, match, 4);
  804211bf58:	49 8d 7f 04          	lea    0x4(%r15),%rdi
  804211bf5c:	ba 04 00 00 00       	mov    $0x4,%edx
  804211bf61:	4c 89 f6             	mov    %r14,%rsi
  804211bf64:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211bf6b:	00 00 00 
  804211bf6e:	ff d0                	call   *%rax
                match -= dec64table[offset];
  804211bf70:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  804211bf77:	00 00 00 
  804211bf7a:	4a 63 04 a8          	movslq (%rax,%r13,4),%rax
  804211bf7e:	49 29 c6             	sub    %rax,%r14
  804211bf81:	4d 89 f5             	mov    %r14,%r13
  804211bf84:	e9 68 01 00 00       	jmp    804211c0f1 <LZ4_decompress_safe+0x66f>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
  804211bf89:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  804211bf8d:	48 8d 41 fb          	lea    -0x5(%rcx),%rax
  804211bf91:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211bf95:	48 39 f0             	cmp    %rsi,%rax
  804211bf98:	0f 82 ad 01 00 00    	jb     804211c14b <LZ4_decompress_safe+0x6c9>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
  804211bf9e:	4c 8d 61 f9          	lea    -0x7(%rcx),%r12
                if (op < oCopyLimit) {
  804211bfa2:	4d 39 e6             	cmp    %r12,%r14
  804211bfa5:	72 29                	jb     804211bfd0 <LZ4_decompress_safe+0x54e>
                while (op < cpy) { *op++ = *match++; }
  804211bfa7:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211bfab:	48 89 f1             	mov    %rsi,%rcx
  804211bfae:	4c 29 f1             	sub    %r14,%rcx
  804211bfb1:	b8 00 00 00 00       	mov    $0x0,%eax
  804211bfb6:	49 39 f6             	cmp    %rsi,%r14
  804211bfb9:	73 44                	jae    804211bfff <LZ4_decompress_safe+0x57d>
  804211bfbb:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  804211bfc1:	41 88 14 06          	mov    %dl,(%r14,%rax,1)
  804211bfc5:	48 83 c0 01          	add    $0x1,%rax
  804211bfc9:	48 39 c8             	cmp    %rcx,%rax
  804211bfcc:	75 ed                	jne    804211bfbb <LZ4_decompress_safe+0x539>
  804211bfce:	eb 2f                	jmp    804211bfff <LZ4_decompress_safe+0x57d>
                    LZ4_wildCopy8(op, match, oCopyLimit);
  804211bfd0:	4c 89 e2             	mov    %r12,%rdx
  804211bfd3:	4c 89 ee             	mov    %r13,%rsi
  804211bfd6:	4c 89 f7             	mov    %r14,%rdi
  804211bfd9:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211bfe0:	00 00 00 
  804211bfe3:	ff d0                	call   *%rax
                    match += oCopyLimit - op;
  804211bfe5:	4c 89 e0             	mov    %r12,%rax
  804211bfe8:	4c 29 f0             	sub    %r14,%rax
  804211bfeb:	49 01 c5             	add    %rax,%r13
                    op = oCopyLimit;
  804211bfee:	4d 89 e6             	mov    %r12,%r14
  804211bff1:	eb b4                	jmp    804211bfa7 <LZ4_decompress_safe+0x525>
    {   const BYTE* ip = (const BYTE*) src;
  804211bff3:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211bff7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211bffb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            token = *ip++;
  804211bfff:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  804211c003:	44 0f b6 23          	movzbl (%rbx),%r12d
  804211c007:	41 0f b6 c4          	movzbl %r12b,%eax
  804211c00b:	89 45 a0             	mov    %eax,-0x60(%rbp)
            length = token >> ML_BITS;  /* literal length */
  804211c00e:	c1 e8 04             	shr    $0x4,%eax
  804211c011:	41 89 c6             	mov    %eax,%r14d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211c014:	83 f8 0f             	cmp    $0xf,%eax
  804211c017:	0f 84 9a fd ff ff    	je     804211bdb7 <LZ4_decompress_safe+0x335>
        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
  804211c01d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211c021:	48 83 e8 10          	sub    $0x10,%rax
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211c025:	49 39 c5             	cmp    %rax,%r13
  804211c028:	0f 83 d5 fd ff ff    	jae    804211be03 <LZ4_decompress_safe+0x381>
  804211c02e:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211c032:	48 39 75 98          	cmp    %rsi,-0x68(%rbp)
  804211c036:	0f 82 c7 fd ff ff    	jb     804211be03 <LZ4_decompress_safe+0x381>
  804211c03c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  804211c040:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
  804211c044:	4c 89 f3             	mov    %r14,%rbx
  804211c047:	4d 89 ee             	mov    %r13,%r14
                memcpy(op, ip, endOnInput ? 16 : 8);
  804211c04a:	ba 10 00 00 00       	mov    $0x10,%edx
  804211c04f:	4c 89 f6             	mov    %r14,%rsi
  804211c052:	4c 89 ff             	mov    %r15,%rdi
  804211c055:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c05c:	00 00 00 
  804211c05f:	ff d0                	call   *%rax
                op += length; ip += length;
  804211c061:	49 01 df             	add    %rbx,%r15
  804211c064:	4c 01 f3             	add    %r14,%rbx
                length = token & ML_MASK; /* match length */
  804211c067:	41 83 e4 0f          	and    $0xf,%r12d
                offset = LZ4_readLE16(ip); ip += 2;
  804211c06b:	48 89 df             	mov    %rbx,%rdi
  804211c06e:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211c075:	00 00 00 
  804211c078:	ff d0                	call   *%rax
  804211c07a:	0f b7 c0             	movzwl %ax,%eax
                match = op - offset;
  804211c07d:	4d 89 fe             	mov    %r15,%r14
  804211c080:	49 29 c6             	sub    %rax,%r14
                if ( (length != ML_MASK)
  804211c083:	49 83 fc 0f          	cmp    $0xf,%r12
  804211c087:	0f 95 c1             	setne  %cl
                     && (offset >= 8)
  804211c08a:	48 83 f8 07          	cmp    $0x7,%rax
  804211c08e:	0f 97 c2             	seta   %dl
                     && (dict==withPrefix64k || match >= lowPrefix) ) {
  804211c091:	84 d1                	test   %dl,%cl
  804211c093:	74 0d                	je     804211c0a2 <LZ4_decompress_safe+0x620>
  804211c095:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  804211c099:	49 39 ce             	cmp    %rcx,%r14
  804211c09c:	0f 83 8f fc ff ff    	jae    804211bd31 <LZ4_decompress_safe+0x2af>
                offset = LZ4_readLE16(ip); ip += 2;
  804211c0a2:	49 89 c5             	mov    %rax,%r13
  804211c0a5:	48 83 c3 02          	add    $0x2,%rbx
            if (length == ML_MASK) {
  804211c0a9:	49 83 fc 0f          	cmp    $0xf,%r12
  804211c0ad:	0f 84 25 fe ff ff    	je     804211bed8 <LZ4_decompress_safe+0x456>
            length += MINMATCH;
  804211c0b3:	49 83 c4 04          	add    $0x4,%r12
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
  804211c0b7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211c0bb:	49 39 c6             	cmp    %rax,%r14
  804211c0be:	0f 82 87 00 00 00    	jb     804211c14b <LZ4_decompress_safe+0x6c9>
            cpy = op + length;
  804211c0c4:	4b 8d 04 27          	lea    (%r15,%r12,1),%rax
  804211c0c8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<8)) {
  804211c0cc:	49 83 fd 07          	cmp    $0x7,%r13
  804211c0d0:	0f 86 48 fe ff ff    	jbe    804211bf1e <LZ4_decompress_safe+0x49c>
                memcpy(op, match, 8);
  804211c0d6:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c0db:	4c 89 f6             	mov    %r14,%rsi
  804211c0de:	4c 89 ff             	mov    %r15,%rdi
  804211c0e1:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c0e8:	00 00 00 
  804211c0eb:	ff d0                	call   *%rax
                match += 8;
  804211c0ed:	4d 8d 6e 08          	lea    0x8(%r14),%r13
            op += 8;
  804211c0f1:	4d 8d 77 08          	lea    0x8(%r15),%r14
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  804211c0f5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211c0f9:	48 83 e8 0c          	sub    $0xc,%rax
  804211c0fd:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804211c101:	48 39 c8             	cmp    %rcx,%rax
  804211c104:	0f 82 7f fe ff ff    	jb     804211bf89 <LZ4_decompress_safe+0x507>
                memcpy(op, match, 8);
  804211c10a:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c10f:	4c 89 ee             	mov    %r13,%rsi
  804211c112:	4c 89 f7             	mov    %r14,%rdi
  804211c115:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c11c:	00 00 00 
  804211c11f:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211c121:	49 83 fc 10          	cmp    $0x10,%r12
  804211c125:	0f 86 d4 fe ff ff    	jbe    804211bfff <LZ4_decompress_safe+0x57d>
  804211c12b:	49 8d 75 08          	lea    0x8(%r13),%rsi
  804211c12f:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211c133:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211c137:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211c13e:	00 00 00 
  804211c141:	ff d0                	call   *%rax
  804211c143:	e9 b7 fe ff ff       	jmp    804211bfff <LZ4_decompress_safe+0x57d>
            token = *ip++;
  804211c148:	4c 89 eb             	mov    %r13,%rbx
        return (int) (-(((const char*)ip)-src))-1;
  804211c14b:	48 89 d8             	mov    %rbx,%rax
  804211c14e:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  804211c152:	48 29 c8             	sub    %rcx,%rax
  804211c155:	f7 d0                	not    %eax
}
  804211c157:	48 83 c4 48          	add    $0x48,%rsp
  804211c15b:	5b                   	pop    %rbx
  804211c15c:	41 5c                	pop    %r12
  804211c15e:	41 5d                	pop    %r13
  804211c160:	41 5e                	pop    %r14
  804211c162:	41 5f                	pop    %r15
  804211c164:	5d                   	pop    %rbp
  804211c165:	c3                   	ret
  804211c166:	4c 89 eb             	mov    %r13,%rbx
  804211c169:	eb e0                	jmp    804211c14b <LZ4_decompress_safe+0x6c9>
  804211c16b:	4c 89 eb             	mov    %r13,%rbx
  804211c16e:	eb db                	jmp    804211c14b <LZ4_decompress_safe+0x6c9>
            token = *ip++;
  804211c170:	4c 89 eb             	mov    %r13,%rbx
  804211c173:	eb d6                	jmp    804211c14b <LZ4_decompress_safe+0x6c9>
  804211c175:	4c 89 eb             	mov    %r13,%rbx
  804211c178:	eb d1                	jmp    804211c14b <LZ4_decompress_safe+0x6c9>
  804211c17a:	4c 89 eb             	mov    %r13,%rbx
  804211c17d:	eb cc                	jmp    804211c14b <LZ4_decompress_safe+0x6c9>
    if (src == NULL) { return -1; }
  804211c17f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211c184:	eb d1                	jmp    804211c157 <LZ4_decompress_safe+0x6d5>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211c186:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,
  804211c18b:	eb ca                	jmp    804211c157 <LZ4_decompress_safe+0x6d5>

000000804211c18d <LZ4_decompress_safe_partial>:
{
  804211c18d:	f3 0f 1e fa          	endbr64
  804211c191:	55                   	push   %rbp
  804211c192:	48 89 e5             	mov    %rsp,%rbp
  804211c195:	41 57                	push   %r15
  804211c197:	41 56                	push   %r14
  804211c199:	41 55                	push   %r13
  804211c19b:	41 54                	push   %r12
  804211c19d:	53                   	push   %rbx
  804211c19e:	48 83 ec 48          	sub    $0x48,%rsp
  804211c1a2:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  804211c1a6:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    dstCapacity = MIN(targetOutputSize, dstCapacity);
  804211c1aa:	41 39 c8             	cmp    %ecx,%r8d
  804211c1ad:	89 c8                	mov    %ecx,%eax
  804211c1af:	41 0f 4e c0          	cmovle %r8d,%eax
    if (src == NULL) { return -1; }
  804211c1b3:	48 89 fb             	mov    %rdi,%rbx
  804211c1b6:	48 85 ff             	test   %rdi,%rdi
  804211c1b9:	0f 84 f2 06 00 00    	je     804211c8b1 <LZ4_decompress_safe_partial+0x724>
        const BYTE* const iend = ip + srcSize;
  804211c1bf:	48 63 ca             	movslq %edx,%rcx
  804211c1c2:	4c 8d 0c 0f          	lea    (%rdi,%rcx,1),%r9
  804211c1c6:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
        BYTE* const oend = op + outputSize;
  804211c1ca:	48 63 c8             	movslq %eax,%rcx
  804211c1cd:	48 8d 3c 0e          	lea    (%rsi,%rcx,1),%rdi
  804211c1d1:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  804211c1d5:	48 8d 4f e0          	lea    -0x20(%rdi),%rcx
  804211c1d9:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
        if ((endOnInput) && (unlikely(outputSize==0))) {
  804211c1dd:	85 c0                	test   %eax,%eax
  804211c1df:	0f 84 9f 06 00 00    	je     804211c884 <LZ4_decompress_safe_partial+0x6f7>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211c1e5:	85 d2                	test   %edx,%edx
  804211c1e7:	0f 84 cb 06 00 00    	je     804211c8b8 <LZ4_decompress_safe_partial+0x72b>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  804211c1ed:	83 f8 3f             	cmp    $0x3f,%eax
  804211c1f0:	0f 8e 40 05 00 00    	jle    804211c736 <LZ4_decompress_safe_partial+0x5a9>
        BYTE* op = (BYTE*) dst;
  804211c1f6:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211c1fa:	49 8d 41 ef          	lea    -0x11(%r9),%rax
  804211c1fe:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  804211c202:	e9 24 01 00 00       	jmp    804211c32b <LZ4_decompress_safe_partial+0x19e>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211c207:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211c20b:	48 8d 50 f1          	lea    -0xf(%rax),%rdx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211c20f:	49 39 d5             	cmp    %rdx,%r13
  804211c212:	0f 83 5d 06 00 00    	jae    804211c875 <LZ4_decompress_safe_partial+0x6e8>
  804211c218:	41 bf 00 00 00 00    	mov    $0x0,%r15d
        s = **ip;
  804211c21e:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  804211c223:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  804211c227:	41 01 c7             	add    %eax,%r15d
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211c22a:	4c 39 ea             	cmp    %r13,%rdx
  804211c22d:	74 07                	je     804211c236 <LZ4_decompress_safe_partial+0xa9>
    } while (s==255);
  804211c22f:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211c234:	74 e8                	je     804211c21e <LZ4_decompress_safe_partial+0x91>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211c236:	45 89 ff             	mov    %r15d,%r15d
  804211c239:	49 83 c7 0f          	add    $0xf,%r15
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211c23d:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211c241:	48 89 f8             	mov    %rdi,%rax
  804211c244:	4c 01 f8             	add    %r15,%rax
  804211c247:	0f 82 46 06 00 00    	jb     804211c893 <LZ4_decompress_safe_partial+0x706>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211c24d:	4c 89 e8             	mov    %r13,%rax
  804211c250:	4c 01 f8             	add    %r15,%rax
  804211c253:	0f 82 3f 06 00 00    	jb     804211c898 <LZ4_decompress_safe_partial+0x70b>
                cpy = op+length;
  804211c259:	4e 8d 34 3f          	lea    (%rdi,%r15,1),%r14
                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
  804211c25d:	4c 39 75 a0          	cmp    %r14,-0x60(%rbp)
  804211c261:	0f 82 19 03 00 00    	jb     804211c580 <LZ4_decompress_safe_partial+0x3f3>
  804211c267:	4b 8d 5c 3d 00       	lea    0x0(%r13,%r15,1),%rbx
  804211c26c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211c270:	48 83 e8 20          	sub    $0x20,%rax
  804211c274:	48 39 d8             	cmp    %rbx,%rax
  804211c277:	0f 82 0b 03 00 00    	jb     804211c588 <LZ4_decompress_safe_partial+0x3fb>
                    LZ4_wildCopy32(op, ip, cpy);
  804211c27d:	4c 89 f2             	mov    %r14,%rdx
  804211c280:	4c 89 ee             	mov    %r13,%rsi
  804211c283:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211c28a:	00 00 00 
  804211c28d:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211c28f:	e9 df 00 00 00       	jmp    804211c373 <LZ4_decompress_safe_partial+0x1e6>
                if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211c294:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211c298:	49 39 c7             	cmp    %rax,%r15
  804211c29b:	0f 82 d7 05 00 00    	jb     804211c878 <LZ4_decompress_safe_partial+0x6eb>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211c2a1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211c2a5:	48 8d 70 fc          	lea    -0x4(%rax),%rsi
  804211c2a9:	b8 00 00 00 00       	mov    $0x0,%eax
        s = **ip;
  804211c2ae:	0f b6 13             	movzbl (%rbx),%edx
        (*ip)++;
  804211c2b1:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211c2b5:	01 d0                	add    %edx,%eax
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211c2b7:	48 39 f3             	cmp    %rsi,%rbx
  804211c2ba:	0f 83 b8 05 00 00    	jae    804211c878 <LZ4_decompress_safe_partial+0x6eb>
    } while (s==255);
  804211c2c0:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  804211c2c6:	74 e6                	je     804211c2ae <LZ4_decompress_safe_partial+0x121>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211c2c8:	41 89 c4             	mov    %eax,%r12d
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
  804211c2cb:	4b 8d 44 26 0f       	lea    0xf(%r14,%r12,1),%rax
  804211c2d0:	4c 39 f0             	cmp    %r14,%rax
  804211c2d3:	0f 82 9f 05 00 00    	jb     804211c878 <LZ4_decompress_safe_partial+0x6eb>
                length += MINMATCH;
  804211c2d9:	49 83 c4 13          	add    $0x13,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211c2dd:	4b 8d 14 26          	lea    (%r14,%r12,1),%rdx
  804211c2e1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211c2e5:	48 83 e8 40          	sub    $0x40,%rax
  804211c2e9:	48 39 c2             	cmp    %rax,%rdx
  804211c2ec:	72 15                	jb     804211c303 <LZ4_decompress_safe_partial+0x176>
  804211c2ee:	49 89 cd             	mov    %rcx,%r13
  804211c2f1:	e9 0d 05 00 00       	jmp    804211c803 <LZ4_decompress_safe_partial+0x676>
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211c2f6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211c2fa:	49 39 c7             	cmp    %rax,%r15
  804211c2fd:	0f 82 75 05 00 00    	jb     804211c878 <LZ4_decompress_safe_partial+0x6eb>
            cpy = op + length;
  804211c303:	4b 8d 04 26          	lea    (%r14,%r12,1),%rax
  804211c307:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<16)) {
  804211c30b:	48 83 f9 0f          	cmp    $0xf,%rcx
  804211c30f:	0f 86 f9 00 00 00    	jbe    804211c40e <LZ4_decompress_safe_partial+0x281>
                LZ4_wildCopy32(op, match, cpy);
  804211c315:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211c319:	4c 89 fe             	mov    %r15,%rsi
  804211c31c:	4c 89 f7             	mov    %r14,%rdi
  804211c31f:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211c326:	00 00 00 
  804211c329:	ff d0                	call   *%rax
            token = *ip++;
  804211c32b:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  804211c32f:	44 0f b6 23          	movzbl (%rbx),%r12d
  804211c333:	41 0f b6 cc          	movzbl %r12b,%ecx
            length = token >> ML_BITS;  /* literal length */
  804211c337:	89 c8                	mov    %ecx,%eax
  804211c339:	c1 e8 04             	shr    $0x4,%eax
  804211c33c:	41 89 c7             	mov    %eax,%r15d
            if (length == RUN_MASK) {
  804211c33f:	83 f8 0f             	cmp    $0xf,%eax
  804211c342:	0f 84 bf fe ff ff    	je     804211c207 <LZ4_decompress_safe_partial+0x7a>
                cpy = op+length;
  804211c348:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211c34c:	4e 8d 34 3f          	lea    (%rdi,%r15,1),%r14
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211c350:	4c 39 6d a8          	cmp    %r13,-0x58(%rbp)
  804211c354:	0f 82 36 02 00 00    	jb     804211c590 <LZ4_decompress_safe_partial+0x403>
                    memcpy(op, ip, 16);
  804211c35a:	ba 10 00 00 00       	mov    $0x10,%edx
  804211c35f:	4c 89 ee             	mov    %r13,%rsi
  804211c362:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c369:	00 00 00 
  804211c36c:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211c36e:	4b 8d 5c 3d 00       	lea    0x0(%r13,%r15,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211c373:	48 89 df             	mov    %rbx,%rdi
  804211c376:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211c37d:	00 00 00 
  804211c380:	ff d0                	call   *%rax
  804211c382:	0f b7 c8             	movzwl %ax,%ecx
  804211c385:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211c389:	4d 89 f7             	mov    %r14,%r15
  804211c38c:	49 29 cf             	sub    %rcx,%r15
            length = token & ML_MASK;
  804211c38f:	41 83 e4 0f          	and    $0xf,%r12d
            if (length == ML_MASK) {
  804211c393:	49 83 fc 0f          	cmp    $0xf,%r12
  804211c397:	0f 84 f7 fe ff ff    	je     804211c294 <LZ4_decompress_safe_partial+0x107>
                length += MINMATCH;
  804211c39d:	49 83 c4 04          	add    $0x4,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211c3a1:	4b 8d 34 26          	lea    (%r14,%r12,1),%rsi
  804211c3a5:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  804211c3a9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211c3ad:	48 83 e8 40          	sub    $0x40,%rax
  804211c3b1:	48 39 c6             	cmp    %rax,%rsi
  804211c3b4:	0f 83 98 02 00 00    	jae    804211c652 <LZ4_decompress_safe_partial+0x4c5>
                    if (offset >= 8) {
  804211c3ba:	48 83 f9 07          	cmp    $0x7,%rcx
  804211c3be:	0f 86 32 ff ff ff    	jbe    804211c2f6 <LZ4_decompress_safe_partial+0x169>
  804211c3c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211c3c8:	49 39 c7             	cmp    %rax,%r15
  804211c3cb:	0f 82 25 ff ff ff    	jb     804211c2f6 <LZ4_decompress_safe_partial+0x169>
                        memcpy(op, match, 8);
  804211c3d1:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c3d6:	4c 89 fe             	mov    %r15,%rsi
  804211c3d9:	4c 89 f7             	mov    %r14,%rdi
  804211c3dc:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  804211c3e3:	00 00 00 
  804211c3e6:	41 ff d4             	call   *%r12
                        memcpy(op+8, match+8, 8);
  804211c3e9:	49 8d 77 08          	lea    0x8(%r15),%rsi
  804211c3ed:	49 8d 7e 08          	lea    0x8(%r14),%rdi
  804211c3f1:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c3f6:	41 ff d4             	call   *%r12
                        memcpy(op+16, match+16, 2);
  804211c3f9:	49 8d 77 10          	lea    0x10(%r15),%rsi
  804211c3fd:	49 8d 7e 10          	lea    0x10(%r14),%rdi
  804211c401:	ba 02 00 00 00       	mov    $0x2,%edx
  804211c406:	41 ff d4             	call   *%r12
                        continue;
  804211c409:	e9 1d ff ff ff       	jmp    804211c32b <LZ4_decompress_safe_partial+0x19e>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  804211c40e:	48 89 c2             	mov    %rax,%rdx
  804211c411:	4c 89 fe             	mov    %r15,%rsi
  804211c414:	4c 89 f7             	mov    %r14,%rdi
  804211c417:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  804211c41e:	00 00 00 
  804211c421:	ff d0                	call   *%rax
  804211c423:	e9 03 ff ff ff       	jmp    804211c32b <LZ4_decompress_safe_partial+0x19e>
                    memcpy(op + 0, match + 0, 8);
  804211c428:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c42d:	4c 89 fe             	mov    %r15,%rsi
  804211c430:	4c 89 f7             	mov    %r14,%rdi
  804211c433:	49 bd 62 0d 11 42 80 	movabs $0x8042110d62,%r13
  804211c43a:	00 00 00 
  804211c43d:	41 ff d5             	call   *%r13
                    memcpy(op + 8, match + 8, 8);
  804211c440:	49 8d 77 08          	lea    0x8(%r15),%rsi
  804211c444:	49 8d 7e 08          	lea    0x8(%r14),%rdi
  804211c448:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c44d:	41 ff d5             	call   *%r13
                    memcpy(op +16, match +16, 2);
  804211c450:	49 8d 77 10          	lea    0x10(%r15),%rsi
  804211c454:	49 8d 7e 10          	lea    0x10(%r14),%rdi
  804211c458:	ba 02 00 00 00       	mov    $0x2,%edx
  804211c45d:	41 ff d5             	call   *%r13
                    op += length + MINMATCH;
  804211c460:	4f 8d 74 26 04       	lea    0x4(%r14,%r12,1),%r14
            token = *ip++;
  804211c465:	4c 8d 7b 03          	lea    0x3(%rbx),%r15
  804211c469:	44 0f b6 63 02       	movzbl 0x2(%rbx),%r12d
  804211c46e:	41 0f b6 d4          	movzbl %r12b,%edx
            length = token >> ML_BITS;  /* literal length */
  804211c472:	89 d0                	mov    %edx,%eax
  804211c474:	c1 e8 04             	shr    $0x4,%eax
  804211c477:	89 c3                	mov    %eax,%ebx
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211c479:	83 f8 0f             	cmp    $0xf,%eax
  804211c47c:	74 26                	je     804211c4a4 <LZ4_decompress_safe_partial+0x317>
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211c47e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211c482:	49 39 c7             	cmp    %rax,%r15
  804211c485:	0f 83 e3 00 00 00    	jae    804211c56e <LZ4_decompress_safe_partial+0x3e1>
  804211c48b:	4c 39 75 a0          	cmp    %r14,-0x60(%rbp)
  804211c48f:	0f 83 f8 02 00 00    	jae    804211c78d <LZ4_decompress_safe_partial+0x600>
  804211c495:	89 55 a8             	mov    %edx,-0x58(%rbp)
  804211c498:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
  804211c49c:	4d 89 fd             	mov    %r15,%r13
  804211c49f:	49 89 df             	mov    %rbx,%r15
  804211c4a2:	eb 56                	jmp    804211c4fa <LZ4_decompress_safe_partial+0x36d>
  804211c4a4:	89 55 a8             	mov    %edx,-0x58(%rbp)
  804211c4a7:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
  804211c4ab:	4d 89 fd             	mov    %r15,%r13
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211c4ae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211c4b2:	48 8d 48 f1          	lea    -0xf(%rax),%rcx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211c4b6:	49 39 cd             	cmp    %rcx,%r13
  804211c4b9:	0f 83 de 03 00 00    	jae    804211c89d <LZ4_decompress_safe_partial+0x710>
  804211c4bf:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211c4c4:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  804211c4c9:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  804211c4cd:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211c4cf:	4c 39 e9             	cmp    %r13,%rcx
  804211c4d2:	74 07                	je     804211c4db <LZ4_decompress_safe_partial+0x34e>
    } while (s==255);
  804211c4d4:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211c4d9:	74 e9                	je     804211c4c4 <LZ4_decompress_safe_partial+0x337>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211c4db:	89 d2                	mov    %edx,%edx
  804211c4dd:	4c 8d 7a 0f          	lea    0xf(%rdx),%r15
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211c4e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211c4e5:	4c 01 f8             	add    %r15,%rax
  804211c4e8:	0f 82 b4 03 00 00    	jb     804211c8a2 <LZ4_decompress_safe_partial+0x715>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211c4ee:	4c 89 e8             	mov    %r13,%rax
  804211c4f1:	4c 01 f8             	add    %r15,%rax
  804211c4f4:	0f 82 ad 03 00 00    	jb     804211c8a7 <LZ4_decompress_safe_partial+0x71a>
            cpy = op+length;
  804211c4fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211c4fe:	4e 8d 34 38          	lea    (%rax,%r15,1),%r14
            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
  804211c502:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211c506:	48 83 e8 0c          	sub    $0xc,%rax
  804211c50a:	4c 39 f0             	cmp    %r14,%rax
  804211c50d:	72 16                	jb     804211c525 <LZ4_decompress_safe_partial+0x398>
  804211c50f:	4b 8d 5c 3d 00       	lea    0x0(%r13,%r15,1),%rbx
  804211c514:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211c518:	48 83 e8 08          	sub    $0x8,%rax
  804211c51c:	48 39 d8             	cmp    %rbx,%rax
  804211c51f:	0f 83 af 00 00 00    	jae    804211c5d4 <LZ4_decompress_safe_partial+0x447>
                    if ((ip+length>iend-(2+1+LASTLITERALS)) && (ip+length != iend)) { goto _output_error; }
  804211c525:	4b 8d 5c 3d 00       	lea    0x0(%r13,%r15,1),%rbx
  804211c52a:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804211c52e:	48 8d 41 f8          	lea    -0x8(%rcx),%rax
  804211c532:	48 39 d8             	cmp    %rbx,%rax
  804211c535:	73 09                	jae    804211c540 <LZ4_decompress_safe_partial+0x3b3>
  804211c537:	48 39 d9             	cmp    %rbx,%rcx
  804211c53a:	0f 85 6c 03 00 00    	jne    804211c8ac <LZ4_decompress_safe_partial+0x71f>
                    if (cpy > oend) {
  804211c540:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211c544:	4c 39 f0             	cmp    %r14,%rax
  804211c547:	73 4f                	jae    804211c598 <LZ4_decompress_safe_partial+0x40b>
                        length = (size_t)(oend-op);
  804211c549:	48 89 c3             	mov    %rax,%rbx
  804211c54c:	48 89 c2             	mov    %rax,%rdx
  804211c54f:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211c553:	48 29 fa             	sub    %rdi,%rdx
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  804211c556:	4c 89 ee             	mov    %r13,%rsi
  804211c559:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211c560:	00 00 00 
  804211c563:	ff d0                	call   *%rax
                op += length;
  804211c565:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
  804211c569:	e9 fd 02 00 00       	jmp    804211c86b <LZ4_decompress_safe_partial+0x6de>
  804211c56e:	89 55 a8             	mov    %edx,-0x58(%rbp)
  804211c571:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
  804211c575:	4d 89 fd             	mov    %r15,%r13
  804211c578:	49 89 df             	mov    %rbx,%r15
  804211c57b:	e9 7a ff ff ff       	jmp    804211c4fa <LZ4_decompress_safe_partial+0x36d>
  804211c580:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  804211c583:	e9 7a ff ff ff       	jmp    804211c502 <LZ4_decompress_safe_partial+0x375>
  804211c588:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  804211c58b:	e9 72 ff ff ff       	jmp    804211c502 <LZ4_decompress_safe_partial+0x375>
  804211c590:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  804211c593:	e9 6a ff ff ff       	jmp    804211c502 <LZ4_decompress_safe_partial+0x375>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  804211c598:	4c 89 fa             	mov    %r15,%rdx
  804211c59b:	4c 89 ee             	mov    %r13,%rsi
  804211c59e:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  804211c5a2:	4c 89 e7             	mov    %r12,%rdi
  804211c5a5:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211c5ac:	00 00 00 
  804211c5af:	ff d0                	call   *%rax
                op += length;
  804211c5b1:	4c 89 e0             	mov    %r12,%rax
  804211c5b4:	4c 01 f8             	add    %r15,%rax
  804211c5b7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                if (!partialDecoding || (cpy == oend) || (ip == iend)) {
  804211c5bb:	48 39 5d b8          	cmp    %rbx,-0x48(%rbp)
  804211c5bf:	0f 84 a6 02 00 00    	je     804211c86b <LZ4_decompress_safe_partial+0x6de>
  804211c5c5:	4c 39 75 b0          	cmp    %r14,-0x50(%rbp)
  804211c5c9:	0f 84 9c 02 00 00    	je     804211c86b <LZ4_decompress_safe_partial+0x6de>
                op += length;
  804211c5cf:	49 89 c6             	mov    %rax,%r14
  804211c5d2:	eb 16                	jmp    804211c5ea <LZ4_decompress_safe_partial+0x45d>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  804211c5d4:	4c 89 f2             	mov    %r14,%rdx
  804211c5d7:	4c 89 ee             	mov    %r13,%rsi
  804211c5da:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211c5de:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211c5e5:	00 00 00 
  804211c5e8:	ff d0                	call   *%rax
            offset = LZ4_readLE16(ip); ip+=2;
  804211c5ea:	48 89 df             	mov    %rbx,%rdi
  804211c5ed:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211c5f4:	00 00 00 
  804211c5f7:	ff d0                	call   *%rax
  804211c5f9:	44 0f b7 e8          	movzwl %ax,%r13d
  804211c5fd:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211c601:	4d 89 f7             	mov    %r14,%r15
  804211c604:	4d 29 ef             	sub    %r13,%r15
            length = token & ML_MASK;
  804211c607:	44 8b 65 a8          	mov    -0x58(%rbp),%r12d
  804211c60b:	41 83 e4 0f          	and    $0xf,%r12d
  804211c60f:	e9 d8 01 00 00       	jmp    804211c7ec <LZ4_decompress_safe_partial+0x65f>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211c614:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211c618:	48 8d 48 fc          	lea    -0x4(%rax),%rcx
  804211c61c:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211c621:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211c624:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211c628:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211c62a:	48 39 cb             	cmp    %rcx,%rbx
  804211c62d:	0f 83 45 02 00 00    	jae    804211c878 <LZ4_decompress_safe_partial+0x6eb>
    } while (s==255);
  804211c633:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211c638:	74 e7                	je     804211c621 <LZ4_decompress_safe_partial+0x494>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211c63a:	41 89 d4             	mov    %edx,%r12d
  804211c63d:	49 83 c4 0f          	add    $0xf,%r12
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
  804211c641:	4c 89 f0             	mov    %r14,%rax
  804211c644:	4c 01 e0             	add    %r12,%rax
  804211c647:	0f 83 a9 01 00 00    	jae    804211c7f6 <LZ4_decompress_safe_partial+0x669>
  804211c64d:	e9 26 02 00 00       	jmp    804211c878 <LZ4_decompress_safe_partial+0x6eb>
  804211c652:	49 89 cd             	mov    %rcx,%r13
  804211c655:	e9 a0 01 00 00       	jmp    804211c7fa <LZ4_decompress_safe_partial+0x66d>
                    memcpy(op, match, mlen);
  804211c65a:	4c 89 fe             	mov    %r15,%rsi
  804211c65d:	4c 89 f7             	mov    %r14,%rdi
  804211c660:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c667:	00 00 00 
  804211c66a:	ff d0                	call   *%rax
  804211c66c:	e9 ec 01 00 00       	jmp    804211c85d <LZ4_decompress_safe_partial+0x6d0>
            if (unlikely(offset<8)) {
  804211c671:	49 83 fd 07          	cmp    $0x7,%r13
  804211c675:	76 57                	jbe    804211c6ce <LZ4_decompress_safe_partial+0x541>
                memcpy(op, match, 8);
  804211c677:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c67c:	4c 89 fe             	mov    %r15,%rsi
  804211c67f:	4c 89 f7             	mov    %r14,%rdi
  804211c682:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c689:	00 00 00 
  804211c68c:	ff d0                	call   *%rax
                match += 8;
  804211c68e:	49 83 c7 08          	add    $0x8,%r15
            op += 8;
  804211c692:	49 8d 7e 08          	lea    0x8(%r14),%rdi
                memcpy(op, match, 8);
  804211c696:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c69b:	4c 89 fe             	mov    %r15,%rsi
  804211c69e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c6a5:	00 00 00 
  804211c6a8:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211c6aa:	49 83 fc 10          	cmp    $0x10,%r12
  804211c6ae:	0f 86 8e 00 00 00    	jbe    804211c742 <LZ4_decompress_safe_partial+0x5b5>
  804211c6b4:	49 8d 77 08          	lea    0x8(%r15),%rsi
  804211c6b8:	49 8d 7e 10          	lea    0x10(%r14),%rdi
  804211c6bc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211c6c0:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211c6c7:	00 00 00 
  804211c6ca:	ff d0                	call   *%rax
  804211c6cc:	eb 74                	jmp    804211c742 <LZ4_decompress_safe_partial+0x5b5>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211c6ce:	41 c7 06 00 00 00 00 	movl   $0x0,(%r14)
                op[0] = match[0];
  804211c6d5:	41 0f b6 07          	movzbl (%r15),%eax
  804211c6d9:	41 88 06             	mov    %al,(%r14)
                op[1] = match[1];
  804211c6dc:	41 0f b6 47 01       	movzbl 0x1(%r15),%eax
  804211c6e1:	41 88 46 01          	mov    %al,0x1(%r14)
                op[2] = match[2];
  804211c6e5:	41 0f b6 47 02       	movzbl 0x2(%r15),%eax
  804211c6ea:	41 88 46 02          	mov    %al,0x2(%r14)
                op[3] = match[3];
  804211c6ee:	41 0f b6 47 03       	movzbl 0x3(%r15),%eax
  804211c6f3:	41 88 46 03          	mov    %al,0x3(%r14)
                match += inc32table[offset];
  804211c6f7:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  804211c6fe:	00 00 00 
  804211c701:	42 8b 04 a8          	mov    (%rax,%r13,4),%eax
  804211c705:	49 01 c7             	add    %rax,%r15
                memcpy(op+4, match, 4);
  804211c708:	49 8d 7e 04          	lea    0x4(%r14),%rdi
  804211c70c:	ba 04 00 00 00       	mov    $0x4,%edx
  804211c711:	4c 89 fe             	mov    %r15,%rsi
  804211c714:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c71b:	00 00 00 
  804211c71e:	ff d0                	call   *%rax
                match -= dec64table[offset];
  804211c720:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  804211c727:	00 00 00 
  804211c72a:	4a 63 04 a8          	movslq (%rax,%r13,4),%rax
  804211c72e:	49 29 c7             	sub    %rax,%r15
  804211c731:	e9 5c ff ff ff       	jmp    804211c692 <LZ4_decompress_safe_partial+0x505>
    {   const BYTE* ip = (const BYTE*) src;
  804211c736:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211c73a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211c73e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            token = *ip++;
  804211c742:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  804211c746:	44 0f b6 23          	movzbl (%rbx),%r12d
  804211c74a:	41 0f b6 c4          	movzbl %r12b,%eax
  804211c74e:	89 45 a8             	mov    %eax,-0x58(%rbp)
            length = token >> ML_BITS;  /* literal length */
  804211c751:	c1 e8 04             	shr    $0x4,%eax
  804211c754:	41 89 c7             	mov    %eax,%r15d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211c757:	83 f8 0f             	cmp    $0xf,%eax
  804211c75a:	0f 84 4e fd ff ff    	je     804211c4ae <LZ4_decompress_safe_partial+0x321>
        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
  804211c760:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211c764:	48 83 e8 10          	sub    $0x10,%rax
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211c768:	49 39 c5             	cmp    %rax,%r13
  804211c76b:	0f 83 89 fd ff ff    	jae    804211c4fa <LZ4_decompress_safe_partial+0x36d>
  804211c771:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211c775:	48 39 75 a0          	cmp    %rsi,-0x60(%rbp)
  804211c779:	0f 82 7b fd ff ff    	jb     804211c4fa <LZ4_decompress_safe_partial+0x36d>
  804211c77f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  804211c783:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
  804211c787:	4c 89 fb             	mov    %r15,%rbx
  804211c78a:	4d 89 ef             	mov    %r13,%r15
                memcpy(op, ip, endOnInput ? 16 : 8);
  804211c78d:	ba 10 00 00 00       	mov    $0x10,%edx
  804211c792:	4c 89 fe             	mov    %r15,%rsi
  804211c795:	4c 89 f7             	mov    %r14,%rdi
  804211c798:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c79f:	00 00 00 
  804211c7a2:	ff d0                	call   *%rax
                op += length; ip += length;
  804211c7a4:	49 01 de             	add    %rbx,%r14
  804211c7a7:	4c 01 fb             	add    %r15,%rbx
                length = token & ML_MASK; /* match length */
  804211c7aa:	41 83 e4 0f          	and    $0xf,%r12d
                offset = LZ4_readLE16(ip); ip += 2;
  804211c7ae:	48 89 df             	mov    %rbx,%rdi
  804211c7b1:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211c7b8:	00 00 00 
  804211c7bb:	ff d0                	call   *%rax
  804211c7bd:	0f b7 c0             	movzwl %ax,%eax
                match = op - offset;
  804211c7c0:	4d 89 f7             	mov    %r14,%r15
  804211c7c3:	49 29 c7             	sub    %rax,%r15
                if ( (length != ML_MASK)
  804211c7c6:	49 83 fc 0f          	cmp    $0xf,%r12
  804211c7ca:	0f 95 c1             	setne  %cl
                     && (offset >= 8)
  804211c7cd:	48 83 f8 07          	cmp    $0x7,%rax
  804211c7d1:	0f 97 c2             	seta   %dl
                     && (dict==withPrefix64k || match >= lowPrefix) ) {
  804211c7d4:	84 d1                	test   %dl,%cl
  804211c7d6:	74 0d                	je     804211c7e5 <LZ4_decompress_safe_partial+0x658>
  804211c7d8:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  804211c7dc:	49 39 cf             	cmp    %rcx,%r15
  804211c7df:	0f 83 43 fc ff ff    	jae    804211c428 <LZ4_decompress_safe_partial+0x29b>
                offset = LZ4_readLE16(ip); ip += 2;
  804211c7e5:	49 89 c5             	mov    %rax,%r13
  804211c7e8:	48 83 c3 02          	add    $0x2,%rbx
            if (length == ML_MASK) {
  804211c7ec:	49 83 fc 0f          	cmp    $0xf,%r12
  804211c7f0:	0f 84 1e fe ff ff    	je     804211c614 <LZ4_decompress_safe_partial+0x487>
            length += MINMATCH;
  804211c7f6:	49 83 c4 04          	add    $0x4,%r12
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
  804211c7fa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211c7fe:	49 39 c7             	cmp    %rax,%r15
  804211c801:	72 75                	jb     804211c878 <LZ4_decompress_safe_partial+0x6eb>
            cpy = op + length;
  804211c803:	4b 8d 0c 26          	lea    (%r14,%r12,1),%rcx
  804211c807:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
            if (partialDecoding && (cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  804211c80b:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211c80f:	48 8d 46 f4          	lea    -0xc(%rsi),%rax
  804211c813:	48 39 c8             	cmp    %rcx,%rax
  804211c816:	0f 83 55 fe ff ff    	jae    804211c671 <LZ4_decompress_safe_partial+0x4e4>
                size_t const mlen = MIN(length, (size_t)(oend-op));
  804211c81c:	4c 29 f6             	sub    %r14,%rsi
  804211c81f:	48 89 f2             	mov    %rsi,%rdx
  804211c822:	4c 39 e6             	cmp    %r12,%rsi
  804211c825:	49 0f 47 d4          	cmova  %r12,%rdx
                BYTE* const copyEnd = op + mlen;
  804211c829:	49 8d 04 16          	lea    (%r14,%rdx,1),%rax
  804211c82d:	48 89 c1             	mov    %rax,%rcx
  804211c830:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                const BYTE* const matchEnd = match + mlen;
  804211c834:	49 8d 04 17          	lea    (%r15,%rdx,1),%rax
                if (matchEnd > op) {   /* overlap copy */
  804211c838:	49 39 c6             	cmp    %rax,%r14
  804211c83b:	0f 83 19 fe ff ff    	jae    804211c65a <LZ4_decompress_safe_partial+0x4cd>
                    while (op < copyEnd) { *op++ = *match++; }
  804211c841:	49 39 ce             	cmp    %rcx,%r14
  804211c844:	73 17                	jae    804211c85d <LZ4_decompress_safe_partial+0x6d0>
  804211c846:	b8 00 00 00 00       	mov    $0x0,%eax
  804211c84b:	41 0f b6 0c 07       	movzbl (%r15,%rax,1),%ecx
  804211c850:	41 88 0c 06          	mov    %cl,(%r14,%rax,1)
  804211c854:	48 83 c0 01          	add    $0x1,%rax
  804211c858:	48 39 c2             	cmp    %rax,%rdx
  804211c85b:	75 ee                	jne    804211c84b <LZ4_decompress_safe_partial+0x6be>
                if (op == oend) { break; }
  804211c85d:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804211c861:	48 39 4d b0          	cmp    %rcx,-0x50(%rbp)
  804211c865:	0f 85 d7 fe ff ff    	jne    804211c742 <LZ4_decompress_safe_partial+0x5b5>
            return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
  804211c86b:	8b 45 c8             	mov    -0x38(%rbp),%eax
  804211c86e:	8b 55 c0             	mov    -0x40(%rbp),%edx
  804211c871:	29 d0                	sub    %edx,%eax
  804211c873:	eb 0f                	jmp    804211c884 <LZ4_decompress_safe_partial+0x6f7>
            token = *ip++;
  804211c875:	4c 89 eb             	mov    %r13,%rbx
        return (int) (-(((const char*)ip)-src))-1;
  804211c878:	48 89 d8             	mov    %rbx,%rax
  804211c87b:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  804211c87f:	48 29 c8             	sub    %rcx,%rax
  804211c882:	f7 d0                	not    %eax
}
  804211c884:	48 83 c4 48          	add    $0x48,%rsp
  804211c888:	5b                   	pop    %rbx
  804211c889:	41 5c                	pop    %r12
  804211c88b:	41 5d                	pop    %r13
  804211c88d:	41 5e                	pop    %r14
  804211c88f:	41 5f                	pop    %r15
  804211c891:	5d                   	pop    %rbp
  804211c892:	c3                   	ret
  804211c893:	4c 89 eb             	mov    %r13,%rbx
  804211c896:	eb e0                	jmp    804211c878 <LZ4_decompress_safe_partial+0x6eb>
  804211c898:	4c 89 eb             	mov    %r13,%rbx
  804211c89b:	eb db                	jmp    804211c878 <LZ4_decompress_safe_partial+0x6eb>
            token = *ip++;
  804211c89d:	4c 89 eb             	mov    %r13,%rbx
  804211c8a0:	eb d6                	jmp    804211c878 <LZ4_decompress_safe_partial+0x6eb>
  804211c8a2:	4c 89 eb             	mov    %r13,%rbx
  804211c8a5:	eb d1                	jmp    804211c878 <LZ4_decompress_safe_partial+0x6eb>
  804211c8a7:	4c 89 eb             	mov    %r13,%rbx
  804211c8aa:	eb cc                	jmp    804211c878 <LZ4_decompress_safe_partial+0x6eb>
  804211c8ac:	4c 89 eb             	mov    %r13,%rbx
  804211c8af:	eb c7                	jmp    804211c878 <LZ4_decompress_safe_partial+0x6eb>
    if (src == NULL) { return -1; }
  804211c8b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211c8b6:	eb cc                	jmp    804211c884 <LZ4_decompress_safe_partial+0x6f7>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211c8b8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return LZ4_decompress_generic(src, dst, compressedSize, dstCapacity,
  804211c8bd:	eb c5                	jmp    804211c884 <LZ4_decompress_safe_partial+0x6f7>

000000804211c8bf <LZ4_decompress_fast>:
{
  804211c8bf:	f3 0f 1e fa          	endbr64
  804211c8c3:	55                   	push   %rbp
  804211c8c4:	48 89 e5             	mov    %rsp,%rbp
  804211c8c7:	41 57                	push   %r15
  804211c8c9:	41 56                	push   %r14
  804211c8cb:	41 55                	push   %r13
  804211c8cd:	41 54                	push   %r12
  804211c8cf:	53                   	push   %rbx
  804211c8d0:	48 83 ec 38          	sub    $0x38,%rsp
  804211c8d4:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
  804211c8d8:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    if (src == NULL) { return -1; }
  804211c8dc:	48 85 ff             	test   %rdi,%rdi
  804211c8df:	0f 84 6c 05 00 00    	je     804211ce51 <LZ4_decompress_fast+0x592>
        BYTE* const oend = op + outputSize;
  804211c8e5:	48 63 c2             	movslq %edx,%rax
  804211c8e8:	48 01 f0             	add    %rsi,%rax
  804211c8eb:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  804211c8ef:	48 83 e8 1a          	sub    $0x1a,%rax
  804211c8f3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
  804211c8f7:	85 d2                	test   %edx,%edx
  804211c8f9:	74 12                	je     804211c90d <LZ4_decompress_fast+0x4e>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  804211c8fb:	83 fa 3f             	cmp    $0x3f,%edx
  804211c8fe:	0f 8e 30 05 00 00    	jle    804211ce34 <LZ4_decompress_fast+0x575>
    {   const BYTE* ip = (const BYTE*) src;
  804211c904:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
  804211c908:	e9 d8 00 00 00       	jmp    804211c9e5 <LZ4_decompress_fast+0x126>
        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
  804211c90d:	80 3f 01             	cmpb   $0x1,(%rdi)
  804211c910:	19 c0                	sbb    %eax,%eax
  804211c912:	83 e0 02             	and    $0x2,%eax
  804211c915:	83 e8 01             	sub    $0x1,%eax
  804211c918:	e9 2c 02 00 00       	jmp    804211cb49 <LZ4_decompress_fast+0x28a>
  804211c91d:	bb 00 00 00 00       	mov    $0x0,%ebx
        s = **ip;
  804211c922:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  804211c927:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  804211c92b:	01 c3                	add    %eax,%ebx
    } while (s==255);
  804211c92d:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211c932:	74 ee                	je     804211c922 <LZ4_decompress_fast+0x63>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211c934:	89 db                	mov    %ebx,%ebx
  804211c936:	48 83 c3 0f          	add    $0xf,%rbx
                cpy = op+length;
  804211c93a:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211c93e:	4c 8d 3c 1f          	lea    (%rdi,%rbx,1),%r15
                    if (cpy>oend-8) { goto safe_literal_copy; }
  804211c942:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211c946:	48 83 e8 08          	sub    $0x8,%rax
  804211c94a:	4c 39 f8             	cmp    %r15,%rax
  804211c94d:	0f 82 cc 01 00 00    	jb     804211cb1f <LZ4_decompress_fast+0x260>
                    LZ4_wildCopy8(op, ip, cpy); /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
  804211c953:	4c 89 fa             	mov    %r15,%rdx
  804211c956:	4c 89 ee             	mov    %r13,%rsi
  804211c959:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211c960:	00 00 00 
  804211c963:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211c965:	4c 01 eb             	add    %r13,%rbx
  804211c968:	e9 c0 00 00 00       	jmp    804211ca2d <LZ4_decompress_fast+0x16e>
                    if (length > 8) { memcpy(op+8, ip+8, 8); }
  804211c96d:	48 8d 73 09          	lea    0x9(%rbx),%rsi
  804211c971:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211c975:	48 83 c7 08          	add    $0x8,%rdi
  804211c979:	ba 08 00 00 00       	mov    $0x8,%edx
  804211c97e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211c985:	00 00 00 
  804211c988:	ff d0                	call   *%rax
  804211c98a:	e9 99 00 00 00       	jmp    804211ca28 <LZ4_decompress_fast+0x169>
  804211c98f:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211c994:	0f b6 0b             	movzbl (%rbx),%ecx
        (*ip)++;
  804211c997:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211c99b:	01 ca                	add    %ecx,%edx
    } while (s==255);
  804211c99d:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  804211c9a3:	74 ef                	je     804211c994 <LZ4_decompress_fast+0xd5>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211c9a5:	41 89 d6             	mov    %edx,%r14d
                length += MINMATCH;
  804211c9a8:	49 83 c6 13          	add    $0x13,%r14
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211c9ac:	4b 8d 34 37          	lea    (%r15,%r14,1),%rsi
  804211c9b0:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  804211c9b4:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211c9b8:	48 8d 57 c0          	lea    -0x40(%rdi),%rdx
  804211c9bc:	48 39 d6             	cmp    %rdx,%rsi
  804211c9bf:	0f 83 d3 00 00 00    	jae    804211ca98 <LZ4_decompress_fast+0x1d9>
            if (unlikely(offset<16)) {
  804211c9c5:	48 83 f8 0f          	cmp    $0xf,%rax
  804211c9c9:	0f 86 ab 00 00 00    	jbe    804211ca7a <LZ4_decompress_fast+0x1bb>
                LZ4_wildCopy32(op, match, cpy);
  804211c9cf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211c9d3:	4c 89 e6             	mov    %r12,%rsi
  804211c9d6:	4c 89 ff             	mov    %r15,%rdi
  804211c9d9:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211c9e0:	00 00 00 
  804211c9e3:	ff d0                	call   *%rax
            token = *ip++;
  804211c9e5:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  804211c9e9:	44 0f b6 33          	movzbl (%rbx),%r14d
            length = token >> ML_BITS;  /* literal length */
  804211c9ed:	4d 89 f4             	mov    %r14,%r12
  804211c9f0:	49 c1 ec 04          	shr    $0x4,%r12
  804211c9f4:	41 83 e4 0f          	and    $0xf,%r12d
            if (length == RUN_MASK) {
  804211c9f8:	49 83 fc 0f          	cmp    $0xf,%r12
  804211c9fc:	0f 84 1b ff ff ff    	je     804211c91d <LZ4_decompress_fast+0x5e>
                cpy = op+length;
  804211ca02:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211ca06:	4e 8d 3c 27          	lea    (%rdi,%r12,1),%r15
                    memcpy(op, ip, 8);
  804211ca0a:	ba 08 00 00 00       	mov    $0x8,%edx
  804211ca0f:	4c 89 ee             	mov    %r13,%rsi
  804211ca12:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211ca19:	00 00 00 
  804211ca1c:	ff d0                	call   *%rax
                    if (length > 8) { memcpy(op+8, ip+8, 8); }
  804211ca1e:	49 83 fc 08          	cmp    $0x8,%r12
  804211ca22:	0f 87 45 ff ff ff    	ja     804211c96d <LZ4_decompress_fast+0xae>
                ip += length; op = cpy;
  804211ca28:	4b 8d 5c 25 00       	lea    0x0(%r13,%r12,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211ca2d:	48 89 df             	mov    %rbx,%rdi
  804211ca30:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211ca37:	00 00 00 
  804211ca3a:	ff d0                	call   *%rax
  804211ca3c:	0f b7 c0             	movzwl %ax,%eax
  804211ca3f:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211ca43:	4d 89 fc             	mov    %r15,%r12
  804211ca46:	49 29 c4             	sub    %rax,%r12
            length = token & ML_MASK;
  804211ca49:	41 83 e6 0f          	and    $0xf,%r14d
            if (length == ML_MASK) {
  804211ca4d:	49 83 fe 0f          	cmp    $0xf,%r14
  804211ca51:	0f 84 38 ff ff ff    	je     804211c98f <LZ4_decompress_fast+0xd0>
                length += MINMATCH;
  804211ca57:	49 83 c6 04          	add    $0x4,%r14
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211ca5b:	4b 8d 34 37          	lea    (%r15,%r14,1),%rsi
  804211ca5f:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  804211ca63:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211ca67:	48 8d 57 c0          	lea    -0x40(%rdi),%rdx
  804211ca6b:	48 39 d6             	cmp    %rdx,%rsi
  804211ca6e:	0f 83 05 01 00 00    	jae    804211cb79 <LZ4_decompress_fast+0x2ba>
                    if (offset >= 8) {
  804211ca74:	48 83 f8 07          	cmp    $0x7,%rax
  804211ca78:	77 26                	ja     804211caa0 <LZ4_decompress_fast+0x1e1>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  804211ca7a:	48 89 c1             	mov    %rax,%rcx
  804211ca7d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211ca81:	4c 89 e6             	mov    %r12,%rsi
  804211ca84:	4c 89 ff             	mov    %r15,%rdi
  804211ca87:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  804211ca8e:	00 00 00 
  804211ca91:	ff d0                	call   *%rax
  804211ca93:	e9 4d ff ff ff       	jmp    804211c9e5 <LZ4_decompress_fast+0x126>
  804211ca98:	49 89 c5             	mov    %rax,%r13
  804211ca9b:	e9 dc 00 00 00       	jmp    804211cb7c <LZ4_decompress_fast+0x2bd>
                        memcpy(op, match, 8);
  804211caa0:	ba 08 00 00 00       	mov    $0x8,%edx
  804211caa5:	4c 89 e6             	mov    %r12,%rsi
  804211caa8:	4c 89 ff             	mov    %r15,%rdi
  804211caab:	49 be 62 0d 11 42 80 	movabs $0x8042110d62,%r14
  804211cab2:	00 00 00 
  804211cab5:	41 ff d6             	call   *%r14
                        memcpy(op+8, match+8, 8);
  804211cab8:	49 8d 74 24 08       	lea    0x8(%r12),%rsi
  804211cabd:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211cac1:	ba 08 00 00 00       	mov    $0x8,%edx
  804211cac6:	41 ff d6             	call   *%r14
                        memcpy(op+16, match+16, 2);
  804211cac9:	49 8d 74 24 10       	lea    0x10(%r12),%rsi
  804211cace:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211cad2:	ba 02 00 00 00       	mov    $0x2,%edx
  804211cad7:	41 ff d6             	call   *%r14
                        continue;
  804211cada:	e9 06 ff ff ff       	jmp    804211c9e5 <LZ4_decompress_fast+0x126>
                offset = LZ4_readLE16(ip); ip += 2;
  804211cadf:	4c 89 e2             	mov    %r12,%rdx
  804211cae2:	4d 89 ec             	mov    %r13,%r12
  804211cae5:	49 89 c5             	mov    %rax,%r13
  804211cae8:	48 83 c3 02          	add    $0x2,%rbx
  804211caec:	e9 33 02 00 00       	jmp    804211cd24 <LZ4_decompress_fast+0x465>
  804211caf1:	89 55 ac             	mov    %edx,-0x54(%rbp)
  804211caf4:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211caf8:	e9 c8 01 00 00       	jmp    804211ccc5 <LZ4_decompress_fast+0x406>
  804211cafd:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211cb02:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  804211cb07:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  804211cb0b:	01 c2                	add    %eax,%edx
    } while (s==255);
  804211cb0d:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211cb12:	74 ee                	je     804211cb02 <LZ4_decompress_fast+0x243>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211cb14:	89 d2                	mov    %edx,%edx
  804211cb16:	48 8d 5a 0f          	lea    0xf(%rdx),%rbx
                if (error == initial_error) { goto _output_error; }
  804211cb1a:	e9 b0 01 00 00       	jmp    804211cccf <LZ4_decompress_fast+0x410>
                    if ((!endOnInput) && (cpy != oend)) { goto _output_error; }
  804211cb1f:	4c 39 7d c0          	cmp    %r15,-0x40(%rbp)
  804211cb23:	0f 85 17 03 00 00    	jne    804211ce40 <LZ4_decompress_fast+0x581>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  804211cb29:	48 89 da             	mov    %rbx,%rdx
  804211cb2c:	4c 89 ee             	mov    %r13,%rsi
  804211cb2f:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211cb33:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211cb3a:	00 00 00 
  804211cb3d:	ff d0                	call   *%rax
                ip += length;
  804211cb3f:	49 8d 44 1d 00       	lea    0x0(%r13,%rbx,1),%rax
            return (int) (((const char*)ip)-src);   /* Nb of input bytes read */
  804211cb44:	8b 75 b0             	mov    -0x50(%rbp),%esi
  804211cb47:	29 f0                	sub    %esi,%eax
}
  804211cb49:	48 83 c4 38          	add    $0x38,%rsp
  804211cb4d:	5b                   	pop    %rbx
  804211cb4e:	41 5c                	pop    %r12
  804211cb50:	41 5d                	pop    %r13
  804211cb52:	41 5e                	pop    %r14
  804211cb54:	41 5f                	pop    %r15
  804211cb56:	5d                   	pop    %rbp
  804211cb57:	c3                   	ret
  804211cb58:	b8 00 00 00 00       	mov    $0x0,%eax
        s = **ip;
  804211cb5d:	0f b6 13             	movzbl (%rbx),%edx
        (*ip)++;
  804211cb60:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211cb64:	01 d0                	add    %edx,%eax
    } while (s==255);
  804211cb66:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  804211cb6c:	74 ef                	je     804211cb5d <LZ4_decompress_fast+0x29e>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211cb6e:	89 c0                	mov    %eax,%eax
  804211cb70:	48 8d 50 0f          	lea    0xf(%rax),%rdx
                if (error != ok) goto _output_error;
  804211cb74:	e9 b5 01 00 00       	jmp    804211cd2e <LZ4_decompress_fast+0x46f>
  804211cb79:	49 89 c5             	mov    %rax,%r13
            cpy = op + length;
  804211cb7c:	4b 8d 04 37          	lea    (%r15,%r14,1),%rax
  804211cb80:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<8)) {
  804211cb84:	49 83 fd 07          	cmp    $0x7,%r13
  804211cb88:	0f 86 a9 01 00 00    	jbe    804211cd37 <LZ4_decompress_fast+0x478>
                memcpy(op, match, 8);
  804211cb8e:	ba 08 00 00 00       	mov    $0x8,%edx
  804211cb93:	4c 89 e6             	mov    %r12,%rsi
  804211cb96:	4c 89 ff             	mov    %r15,%rdi
  804211cb99:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211cba0:	00 00 00 
  804211cba3:	ff d0                	call   *%rax
                match += 8;
  804211cba5:	4d 8d 6c 24 08       	lea    0x8(%r12),%r13
            op += 8;
  804211cbaa:	4d 8d 67 08          	lea    0x8(%r15),%r12
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  804211cbae:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211cbb2:	48 83 e8 0c          	sub    $0xc,%rax
  804211cbb6:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211cbba:	48 39 f0             	cmp    %rsi,%rax
  804211cbbd:	0f 82 e3 01 00 00    	jb     804211cda6 <LZ4_decompress_fast+0x4e7>
                memcpy(op, match, 8);
  804211cbc3:	ba 08 00 00 00       	mov    $0x8,%edx
  804211cbc8:	4c 89 ee             	mov    %r13,%rsi
  804211cbcb:	4c 89 e7             	mov    %r12,%rdi
  804211cbce:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211cbd5:	00 00 00 
  804211cbd8:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211cbda:	49 83 fe 10          	cmp    $0x10,%r14
  804211cbde:	0f 87 33 02 00 00    	ja     804211ce17 <LZ4_decompress_fast+0x558>
            token = *ip++;
  804211cbe4:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  804211cbe8:	44 0f b6 23          	movzbl (%rbx),%r12d
  804211cbec:	41 0f b6 c4          	movzbl %r12b,%eax
  804211cbf0:	89 45 ac             	mov    %eax,-0x54(%rbp)
            length = token >> ML_BITS;  /* literal length */
  804211cbf3:	89 c3                	mov    %eax,%ebx
  804211cbf5:	c1 eb 04             	shr    $0x4,%ebx
  804211cbf8:	89 db                	mov    %ebx,%ebx
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211cbfa:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211cbfe:	48 39 75 b8          	cmp    %rsi,-0x48(%rbp)
  804211cc02:	0f 82 bd 00 00 00    	jb     804211ccc5 <LZ4_decompress_fast+0x406>
                memcpy(op, ip, endOnInput ? 16 : 8);
  804211cc08:	49 be 62 0d 11 42 80 	movabs $0x8042110d62,%r14
  804211cc0f:	00 00 00 
  804211cc12:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211cc16:	48 83 fb 08          	cmp    $0x8,%rbx
  804211cc1a:	0f 87 a5 00 00 00    	ja     804211ccc5 <LZ4_decompress_fast+0x406>
                memcpy(op, ip, endOnInput ? 16 : 8);
  804211cc20:	ba 08 00 00 00       	mov    $0x8,%edx
  804211cc25:	4c 89 ee             	mov    %r13,%rsi
  804211cc28:	4c 89 ff             	mov    %r15,%rdi
  804211cc2b:	41 ff d6             	call   *%r14
                op += length; ip += length;
  804211cc2e:	49 01 df             	add    %rbx,%r15
  804211cc31:	4c 01 eb             	add    %r13,%rbx
                length = token & ML_MASK; /* match length */
  804211cc34:	41 83 e4 0f          	and    $0xf,%r12d
                offset = LZ4_readLE16(ip); ip += 2;
  804211cc38:	48 89 df             	mov    %rbx,%rdi
  804211cc3b:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211cc42:	00 00 00 
  804211cc45:	ff d0                	call   *%rax
  804211cc47:	0f b7 c0             	movzwl %ax,%eax
                match = op - offset;
  804211cc4a:	4d 89 fd             	mov    %r15,%r13
  804211cc4d:	49 29 c5             	sub    %rax,%r13
                if ( (length != ML_MASK)
  804211cc50:	49 83 fc 0f          	cmp    $0xf,%r12
  804211cc54:	0f 84 85 fe ff ff    	je     804211cadf <LZ4_decompress_fast+0x220>
  804211cc5a:	48 83 f8 07          	cmp    $0x7,%rax
  804211cc5e:	0f 86 7b fe ff ff    	jbe    804211cadf <LZ4_decompress_fast+0x220>
                    memcpy(op + 0, match + 0, 8);
  804211cc64:	ba 08 00 00 00       	mov    $0x8,%edx
  804211cc69:	4c 89 ee             	mov    %r13,%rsi
  804211cc6c:	4c 89 ff             	mov    %r15,%rdi
  804211cc6f:	41 ff d6             	call   *%r14
                    memcpy(op + 8, match + 8, 8);
  804211cc72:	49 8d 75 08          	lea    0x8(%r13),%rsi
  804211cc76:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211cc7a:	ba 08 00 00 00       	mov    $0x8,%edx
  804211cc7f:	41 ff d6             	call   *%r14
                    memcpy(op +16, match +16, 2);
  804211cc82:	49 8d 75 10          	lea    0x10(%r13),%rsi
  804211cc86:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211cc8a:	ba 02 00 00 00       	mov    $0x2,%edx
  804211cc8f:	41 ff d6             	call   *%r14
                    op += length + MINMATCH;
  804211cc92:	4f 8d 7c 27 04       	lea    0x4(%r15,%r12,1),%r15
            token = *ip++;
  804211cc97:	4c 8d 6b 03          	lea    0x3(%rbx),%r13
  804211cc9b:	44 0f b6 63 02       	movzbl 0x2(%rbx),%r12d
  804211cca0:	41 0f b6 d4          	movzbl %r12b,%edx
            length = token >> ML_BITS;  /* literal length */
  804211cca4:	89 d0                	mov    %edx,%eax
  804211cca6:	c1 e8 04             	shr    $0x4,%eax
  804211cca9:	89 c3                	mov    %eax,%ebx
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211ccab:	83 f8 08             	cmp    $0x8,%eax
  804211ccae:	0f 87 3d fe ff ff    	ja     804211caf1 <LZ4_decompress_fast+0x232>
  804211ccb4:	4c 39 7d b8          	cmp    %r15,-0x48(%rbp)
  804211ccb8:	0f 83 62 ff ff ff    	jae    804211cc20 <LZ4_decompress_fast+0x361>
  804211ccbe:	89 55 ac             	mov    %edx,-0x54(%rbp)
  804211ccc1:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
            if (length == RUN_MASK) {
  804211ccc5:	48 83 fb 0f          	cmp    $0xf,%rbx
  804211ccc9:	0f 84 2e fe ff ff    	je     804211cafd <LZ4_decompress_fast+0x23e>
            cpy = op+length;
  804211cccf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211ccd3:	4c 8d 3c 18          	lea    (%rax,%rbx,1),%r15
                 || ((!endOnInput) && (cpy>oend-WILDCOPYLENGTH)) )
  804211ccd7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211ccdb:	48 83 e8 08          	sub    $0x8,%rax
  804211ccdf:	4c 39 f8             	cmp    %r15,%rax
  804211cce2:	0f 82 37 fe ff ff    	jb     804211cb1f <LZ4_decompress_fast+0x260>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  804211cce8:	4c 89 fa             	mov    %r15,%rdx
  804211cceb:	4c 89 ee             	mov    %r13,%rsi
  804211ccee:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211ccf2:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211ccf9:	00 00 00 
  804211ccfc:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211ccfe:	4c 01 eb             	add    %r13,%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211cd01:	48 89 df             	mov    %rbx,%rdi
  804211cd04:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211cd0b:	00 00 00 
  804211cd0e:	ff d0                	call   *%rax
  804211cd10:	44 0f b7 e8          	movzwl %ax,%r13d
  804211cd14:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211cd18:	4d 89 fc             	mov    %r15,%r12
  804211cd1b:	4d 29 ec             	sub    %r13,%r12
            length = token & ML_MASK;
  804211cd1e:	8b 55 ac             	mov    -0x54(%rbp),%edx
  804211cd21:	83 e2 0f             	and    $0xf,%edx
            if (length == ML_MASK) {
  804211cd24:	48 83 fa 0f          	cmp    $0xf,%rdx
  804211cd28:	0f 84 2a fe ff ff    	je     804211cb58 <LZ4_decompress_fast+0x299>
            length += MINMATCH;
  804211cd2e:	4c 8d 72 04          	lea    0x4(%rdx),%r14
  804211cd32:	e9 45 fe ff ff       	jmp    804211cb7c <LZ4_decompress_fast+0x2bd>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211cd37:	41 c7 07 00 00 00 00 	movl   $0x0,(%r15)
                op[0] = match[0];
  804211cd3e:	41 0f b6 04 24       	movzbl (%r12),%eax
  804211cd43:	41 88 07             	mov    %al,(%r15)
                op[1] = match[1];
  804211cd46:	41 0f b6 44 24 01    	movzbl 0x1(%r12),%eax
  804211cd4c:	41 88 47 01          	mov    %al,0x1(%r15)
                op[2] = match[2];
  804211cd50:	41 0f b6 44 24 02    	movzbl 0x2(%r12),%eax
  804211cd56:	41 88 47 02          	mov    %al,0x2(%r15)
                op[3] = match[3];
  804211cd5a:	41 0f b6 44 24 03    	movzbl 0x3(%r12),%eax
  804211cd60:	41 88 47 03          	mov    %al,0x3(%r15)
                match += inc32table[offset];
  804211cd64:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  804211cd6b:	00 00 00 
  804211cd6e:	42 8b 04 a8          	mov    (%rax,%r13,4),%eax
  804211cd72:	49 01 c4             	add    %rax,%r12
                memcpy(op+4, match, 4);
  804211cd75:	49 8d 7f 04          	lea    0x4(%r15),%rdi
  804211cd79:	ba 04 00 00 00       	mov    $0x4,%edx
  804211cd7e:	4c 89 e6             	mov    %r12,%rsi
  804211cd81:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211cd88:	00 00 00 
  804211cd8b:	ff d0                	call   *%rax
                match -= dec64table[offset];
  804211cd8d:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  804211cd94:	00 00 00 
  804211cd97:	4a 63 04 a8          	movslq (%rax,%r13,4),%rax
  804211cd9b:	49 29 c4             	sub    %rax,%r12
  804211cd9e:	4d 89 e5             	mov    %r12,%r13
  804211cda1:	e9 04 fe ff ff       	jmp    804211cbaa <LZ4_decompress_fast+0x2eb>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
  804211cda6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804211cdaa:	48 8d 46 fb          	lea    -0x5(%rsi),%rax
  804211cdae:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211cdb2:	48 39 f8             	cmp    %rdi,%rax
  804211cdb5:	0f 82 82 00 00 00    	jb     804211ce3d <LZ4_decompress_fast+0x57e>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
  804211cdbb:	4c 8d 76 f9          	lea    -0x7(%rsi),%r14
                if (op < oCopyLimit) {
  804211cdbf:	4d 39 f4             	cmp    %r14,%r12
  804211cdc2:	72 30                	jb     804211cdf4 <LZ4_decompress_fast+0x535>
                while (op < cpy) { *op++ = *match++; }
  804211cdc4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211cdc8:	49 39 c4             	cmp    %rax,%r12
  804211cdcb:	0f 83 13 fe ff ff    	jae    804211cbe4 <LZ4_decompress_fast+0x325>
  804211cdd1:	4c 29 e0             	sub    %r12,%rax
  804211cdd4:	48 89 c1             	mov    %rax,%rcx
  804211cdd7:	b8 00 00 00 00       	mov    $0x0,%eax
  804211cddc:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
  804211cde2:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
  804211cde6:	48 83 c0 01          	add    $0x1,%rax
  804211cdea:	48 39 c8             	cmp    %rcx,%rax
  804211cded:	75 ed                	jne    804211cddc <LZ4_decompress_fast+0x51d>
  804211cdef:	e9 f0 fd ff ff       	jmp    804211cbe4 <LZ4_decompress_fast+0x325>
                    LZ4_wildCopy8(op, match, oCopyLimit);
  804211cdf4:	4c 89 f2             	mov    %r14,%rdx
  804211cdf7:	4c 89 ee             	mov    %r13,%rsi
  804211cdfa:	4c 89 e7             	mov    %r12,%rdi
  804211cdfd:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211ce04:	00 00 00 
  804211ce07:	ff d0                	call   *%rax
                    match += oCopyLimit - op;
  804211ce09:	4c 89 f0             	mov    %r14,%rax
  804211ce0c:	4c 29 e0             	sub    %r12,%rax
  804211ce0f:	49 01 c5             	add    %rax,%r13
                    op = oCopyLimit;
  804211ce12:	4d 89 f4             	mov    %r14,%r12
  804211ce15:	eb ad                	jmp    804211cdc4 <LZ4_decompress_fast+0x505>
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211ce17:	49 8d 75 08          	lea    0x8(%r13),%rsi
  804211ce1b:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211ce1f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211ce23:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211ce2a:	00 00 00 
  804211ce2d:	ff d0                	call   *%rax
  804211ce2f:	e9 b0 fd ff ff       	jmp    804211cbe4 <LZ4_decompress_fast+0x325>
    {   const BYTE* ip = (const BYTE*) src;
  804211ce34:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
  804211ce38:	e9 a7 fd ff ff       	jmp    804211cbe4 <LZ4_decompress_fast+0x325>
  804211ce3d:	49 89 dd             	mov    %rbx,%r13
        return (int) (-(((const char*)ip)-src))-1;
  804211ce40:	4c 89 e8             	mov    %r13,%rax
  804211ce43:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211ce47:	48 29 f0             	sub    %rsi,%rax
  804211ce4a:	f7 d0                	not    %eax
  804211ce4c:	e9 f8 fc ff ff       	jmp    804211cb49 <LZ4_decompress_fast+0x28a>
    if (src == NULL) { return -1; }
  804211ce51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211ce56:	e9 ee fc ff ff       	jmp    804211cb49 <LZ4_decompress_fast+0x28a>

000000804211ce5b <LZ4_decompress_safe_withPrefix64k>:
{
  804211ce5b:	f3 0f 1e fa          	endbr64
  804211ce5f:	55                   	push   %rbp
  804211ce60:	48 89 e5             	mov    %rsp,%rbp
  804211ce63:	41 57                	push   %r15
  804211ce65:	41 56                	push   %r14
  804211ce67:	41 55                	push   %r13
  804211ce69:	41 54                	push   %r12
  804211ce6b:	53                   	push   %rbx
  804211ce6c:	48 83 ec 58          	sub    $0x58,%rsp
  804211ce70:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
  804211ce74:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
  804211ce78:	48 8d 86 00 00 ff ff 	lea    -0x10000(%rsi),%rax
  804211ce7f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if (src == NULL) { return -1; }
  804211ce83:	48 85 ff             	test   %rdi,%rdi
  804211ce86:	0f 84 e3 06 00 00    	je     804211d56f <LZ4_decompress_safe_withPrefix64k+0x714>
        const BYTE* const iend = ip + srcSize;
  804211ce8c:	48 63 c2             	movslq %edx,%rax
  804211ce8f:	48 01 f8             	add    %rdi,%rax
  804211ce92:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        BYTE* const oend = op + outputSize;
  804211ce96:	48 63 c1             	movslq %ecx,%rax
  804211ce99:	48 01 f0             	add    %rsi,%rax
  804211ce9c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  804211cea0:	48 83 e8 20          	sub    $0x20,%rax
  804211cea4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        if ((endOnInput) && (unlikely(outputSize==0))) {
  804211cea8:	85 c9                	test   %ecx,%ecx
  804211ceaa:	74 2e                	je     804211ceda <LZ4_decompress_safe_withPrefix64k+0x7f>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211ceac:	85 d2                	test   %edx,%edx
  804211ceae:	0f 84 c5 06 00 00    	je     804211d579 <LZ4_decompress_safe_withPrefix64k+0x71e>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  804211ceb4:	83 f9 3f             	cmp    $0x3f,%ecx
  804211ceb7:	0f 8e 56 05 00 00    	jle    804211d413 <LZ4_decompress_safe_withPrefix64k+0x5b8>
    {   const BYTE* ip = (const BYTE*) src;
  804211cebd:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211cec1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211cec5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211cec9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211cecd:	48 83 e8 11          	sub    $0x11,%rax
  804211ced1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  804211ced5:	e9 27 01 00 00       	jmp    804211d001 <LZ4_decompress_safe_withPrefix64k+0x1a6>
            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
  804211ceda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211cedf:	83 fa 01             	cmp    $0x1,%edx
  804211cee2:	0f 85 c2 01 00 00    	jne    804211d0aa <LZ4_decompress_safe_withPrefix64k+0x24f>
  804211cee8:	0f b6 07             	movzbl (%rdi),%eax
  804211ceeb:	f6 d8                	neg    %al
  804211ceed:	19 c0                	sbb    %eax,%eax
  804211ceef:	e9 b6 01 00 00       	jmp    804211d0aa <LZ4_decompress_safe_withPrefix64k+0x24f>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211cef4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211cef8:	48 8d 50 f1          	lea    -0xf(%rax),%rdx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211cefc:	49 39 d6             	cmp    %rdx,%r14
  804211ceff:	0f 83 40 06 00 00    	jae    804211d545 <LZ4_decompress_safe_withPrefix64k+0x6ea>
  804211cf05:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        s = **ip;
  804211cf0b:	41 0f b6 06          	movzbl (%r14),%eax
        (*ip)++;
  804211cf0f:	49 83 c6 01          	add    $0x1,%r14
        length += s;
  804211cf13:	41 01 c4             	add    %eax,%r12d
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211cf16:	4c 39 f2             	cmp    %r14,%rdx
  804211cf19:	74 07                	je     804211cf22 <LZ4_decompress_safe_withPrefix64k+0xc7>
    } while (s==255);
  804211cf1b:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211cf20:	74 e9                	je     804211cf0b <LZ4_decompress_safe_withPrefix64k+0xb0>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211cf22:	45 89 e4             	mov    %r12d,%r12d
  804211cf25:	49 83 c4 0f          	add    $0xf,%r12
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211cf29:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211cf2d:	48 89 f8             	mov    %rdi,%rax
  804211cf30:	4c 01 e0             	add    %r12,%rax
  804211cf33:	0f 82 14 06 00 00    	jb     804211d54d <LZ4_decompress_safe_withPrefix64k+0x6f2>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211cf39:	4c 89 f0             	mov    %r14,%rax
  804211cf3c:	4c 01 e0             	add    %r12,%rax
  804211cf3f:	0f 82 10 06 00 00    	jb     804211d555 <LZ4_decompress_safe_withPrefix64k+0x6fa>
                cpy = op+length;
  804211cf45:	4e 8d 3c 27          	lea    (%rdi,%r12,1),%r15
                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
  804211cf49:	4c 39 7d b0          	cmp    %r15,-0x50(%rbp)
  804211cf4d:	0f 82 96 02 00 00    	jb     804211d1e9 <LZ4_decompress_safe_withPrefix64k+0x38e>
  804211cf53:	4b 8d 1c 26          	lea    (%r14,%r12,1),%rbx
  804211cf57:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211cf5b:	48 83 e8 20          	sub    $0x20,%rax
  804211cf5f:	48 39 d8             	cmp    %rbx,%rax
  804211cf62:	0f 82 89 02 00 00    	jb     804211d1f1 <LZ4_decompress_safe_withPrefix64k+0x396>
                    LZ4_wildCopy32(op, ip, cpy);
  804211cf68:	4c 89 fa             	mov    %r15,%rdx
  804211cf6b:	4c 89 f6             	mov    %r14,%rsi
  804211cf6e:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211cf75:	00 00 00 
  804211cf78:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211cf7a:	e9 c9 00 00 00       	jmp    804211d048 <LZ4_decompress_safe_withPrefix64k+0x1ed>
                if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211cf7f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211cf83:	49 39 c4             	cmp    %rax,%r12
  804211cf86:	0f 82 12 01 00 00    	jb     804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211cf8c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211cf90:	48 8d 70 fc          	lea    -0x4(%rax),%rsi
  804211cf94:	b8 00 00 00 00       	mov    $0x0,%eax
        s = **ip;
  804211cf99:	0f b6 13             	movzbl (%rbx),%edx
        (*ip)++;
  804211cf9c:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211cfa0:	01 d0                	add    %edx,%eax
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211cfa2:	48 39 f3             	cmp    %rsi,%rbx
  804211cfa5:	0f 83 f3 00 00 00    	jae    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
    } while (s==255);
  804211cfab:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  804211cfb1:	74 e6                	je     804211cf99 <LZ4_decompress_safe_withPrefix64k+0x13e>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211cfb3:	41 89 c5             	mov    %eax,%r13d
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
  804211cfb6:	4b 8d 44 2f 0f       	lea    0xf(%r15,%r13,1),%rax
  804211cfbb:	4c 39 f8             	cmp    %r15,%rax
  804211cfbe:	0f 82 da 00 00 00    	jb     804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
                length += MINMATCH;
  804211cfc4:	49 83 c5 13          	add    $0x13,%r13
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211cfc8:	4b 8d 14 2f          	lea    (%r15,%r13,1),%rdx
  804211cfcc:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  804211cfd0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211cfd4:	48 83 e8 40          	sub    $0x40,%rax
  804211cfd8:	48 39 c2             	cmp    %rax,%rdx
  804211cfdb:	0f 83 52 03 00 00    	jae    804211d333 <LZ4_decompress_safe_withPrefix64k+0x4d8>
            if (unlikely(offset<16)) {
  804211cfe1:	48 83 f9 0f          	cmp    $0xf,%rcx
  804211cfe5:	0f 86 0d 01 00 00    	jbe    804211d0f8 <LZ4_decompress_safe_withPrefix64k+0x29d>
                LZ4_wildCopy32(op, match, cpy);
  804211cfeb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211cfef:	4c 89 e6             	mov    %r12,%rsi
  804211cff2:	4c 89 ff             	mov    %r15,%rdi
  804211cff5:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211cffc:	00 00 00 
  804211cfff:	ff d0                	call   *%rax
            token = *ip++;
  804211d001:	4c 8d 73 01          	lea    0x1(%rbx),%r14
  804211d005:	44 0f b6 2b          	movzbl (%rbx),%r13d
  804211d009:	41 0f b6 cd          	movzbl %r13b,%ecx
            length = token >> ML_BITS;  /* literal length */
  804211d00d:	89 c8                	mov    %ecx,%eax
  804211d00f:	c1 e8 04             	shr    $0x4,%eax
  804211d012:	41 89 c4             	mov    %eax,%r12d
            if (length == RUN_MASK) {
  804211d015:	83 f8 0f             	cmp    $0xf,%eax
  804211d018:	0f 84 d6 fe ff ff    	je     804211cef4 <LZ4_decompress_safe_withPrefix64k+0x99>
                cpy = op+length;
  804211d01e:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211d022:	4e 8d 3c 27          	lea    (%rdi,%r12,1),%r15
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211d026:	4c 39 75 98          	cmp    %r14,-0x68(%rbp)
  804211d02a:	0f 82 c9 01 00 00    	jb     804211d1f9 <LZ4_decompress_safe_withPrefix64k+0x39e>
                    memcpy(op, ip, 16);
  804211d030:	ba 10 00 00 00       	mov    $0x10,%edx
  804211d035:	4c 89 f6             	mov    %r14,%rsi
  804211d038:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d03f:	00 00 00 
  804211d042:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211d044:	4b 8d 1c 26          	lea    (%r14,%r12,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211d048:	48 89 df             	mov    %rbx,%rdi
  804211d04b:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211d052:	00 00 00 
  804211d055:	ff d0                	call   *%rax
  804211d057:	0f b7 c8             	movzwl %ax,%ecx
  804211d05a:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211d05e:	4d 89 fc             	mov    %r15,%r12
  804211d061:	49 29 cc             	sub    %rcx,%r12
            length = token & ML_MASK;
  804211d064:	41 83 e5 0f          	and    $0xf,%r13d
            if (length == ML_MASK) {
  804211d068:	49 83 fd 0f          	cmp    $0xf,%r13
  804211d06c:	0f 84 0d ff ff ff    	je     804211cf7f <LZ4_decompress_safe_withPrefix64k+0x124>
                length += MINMATCH;
  804211d072:	49 83 c5 04          	add    $0x4,%r13
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211d076:	4b 8d 34 2f          	lea    (%r15,%r13,1),%rsi
  804211d07a:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  804211d07e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211d082:	48 83 e8 40          	sub    $0x40,%rax
  804211d086:	48 39 c6             	cmp    %rax,%rsi
  804211d089:	0f 83 98 02 00 00    	jae    804211d327 <LZ4_decompress_safe_withPrefix64k+0x4cc>
                    if (offset >= 8) {
  804211d08f:	48 83 f9 07          	cmp    $0x7,%rcx
  804211d093:	77 24                	ja     804211d0b9 <LZ4_decompress_safe_withPrefix64k+0x25e>
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211d095:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211d099:	49 39 c4             	cmp    %rax,%r12
  804211d09c:	73 5a                	jae    804211d0f8 <LZ4_decompress_safe_withPrefix64k+0x29d>
        return (int) (-(((const char*)ip)-src))-1;
  804211d09e:	48 89 d8             	mov    %rbx,%rax
  804211d0a1:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  804211d0a5:	48 29 c8             	sub    %rcx,%rax
  804211d0a8:	f7 d0                	not    %eax
}
  804211d0aa:	48 83 c4 58          	add    $0x58,%rsp
  804211d0ae:	5b                   	pop    %rbx
  804211d0af:	41 5c                	pop    %r12
  804211d0b1:	41 5d                	pop    %r13
  804211d0b3:	41 5e                	pop    %r14
  804211d0b5:	41 5f                	pop    %r15
  804211d0b7:	5d                   	pop    %rbp
  804211d0b8:	c3                   	ret
                        memcpy(op, match, 8);
  804211d0b9:	ba 08 00 00 00       	mov    $0x8,%edx
  804211d0be:	4c 89 e6             	mov    %r12,%rsi
  804211d0c1:	4c 89 ff             	mov    %r15,%rdi
  804211d0c4:	49 bd 62 0d 11 42 80 	movabs $0x8042110d62,%r13
  804211d0cb:	00 00 00 
  804211d0ce:	41 ff d5             	call   *%r13
                        memcpy(op+8, match+8, 8);
  804211d0d1:	49 8d 74 24 08       	lea    0x8(%r12),%rsi
  804211d0d6:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211d0da:	ba 08 00 00 00       	mov    $0x8,%edx
  804211d0df:	41 ff d5             	call   *%r13
                        memcpy(op+16, match+16, 2);
  804211d0e2:	49 8d 74 24 10       	lea    0x10(%r12),%rsi
  804211d0e7:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211d0eb:	ba 02 00 00 00       	mov    $0x2,%edx
  804211d0f0:	41 ff d5             	call   *%r13
                        continue;
  804211d0f3:	e9 09 ff ff ff       	jmp    804211d001 <LZ4_decompress_safe_withPrefix64k+0x1a6>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  804211d0f8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211d0fc:	4c 89 e6             	mov    %r12,%rsi
  804211d0ff:	4c 89 ff             	mov    %r15,%rdi
  804211d102:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  804211d109:	00 00 00 
  804211d10c:	ff d0                	call   *%rax
  804211d10e:	e9 ee fe ff ff       	jmp    804211d001 <LZ4_decompress_safe_withPrefix64k+0x1a6>
                offset = LZ4_readLE16(ip); ip += 2;
  804211d113:	49 89 c6             	mov    %rax,%r14
  804211d116:	4c 89 e0             	mov    %r12,%rax
  804211d119:	49 89 dc             	mov    %rbx,%r12
  804211d11c:	48 83 c0 02          	add    $0x2,%rax
  804211d120:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  804211d124:	e9 17 01 00 00       	jmp    804211d240 <LZ4_decompress_safe_withPrefix64k+0x3e5>
  804211d129:	89 55 8c             	mov    %edx,-0x74(%rbp)
  804211d12c:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211d130:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211d134:	48 8d 48 f1          	lea    -0xf(%rax),%rcx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211d138:	48 39 cb             	cmp    %rcx,%rbx
  804211d13b:	0f 83 5d ff ff ff    	jae    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
  804211d141:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211d146:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211d149:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211d14d:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211d14f:	48 39 d9             	cmp    %rbx,%rcx
  804211d152:	74 07                	je     804211d15b <LZ4_decompress_safe_withPrefix64k+0x300>
    } while (s==255);
  804211d154:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211d159:	74 eb                	je     804211d146 <LZ4_decompress_safe_withPrefix64k+0x2eb>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211d15b:	89 d2                	mov    %edx,%edx
  804211d15d:	4c 8d 62 0f          	lea    0xf(%rdx),%r12
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211d161:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211d165:	4c 01 e0             	add    %r12,%rax
  804211d168:	0f 82 30 ff ff ff    	jb     804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211d16e:	48 89 d8             	mov    %rbx,%rax
  804211d171:	4c 01 e0             	add    %r12,%rax
  804211d174:	73 0c                	jae    804211d182 <LZ4_decompress_safe_withPrefix64k+0x327>
  804211d176:	e9 23 ff ff ff       	jmp    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
  804211d17b:	89 55 8c             	mov    %edx,-0x74(%rbp)
  804211d17e:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
            cpy = op+length;
  804211d182:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211d186:	4e 8d 3c 20          	lea    (%rax,%r12,1),%r15
            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
  804211d18a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211d18e:	48 83 e8 0c          	sub    $0xc,%rax
  804211d192:	4c 39 f8             	cmp    %r15,%rax
  804211d195:	72 11                	jb     804211d1a8 <LZ4_decompress_safe_withPrefix64k+0x34d>
  804211d197:	4e 8d 2c 23          	lea    (%rbx,%r12,1),%r13
  804211d19b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211d19f:	48 83 e8 08          	sub    $0x8,%rax
  804211d1a3:	4c 39 e8             	cmp    %r13,%rax
  804211d1a6:	73 59                	jae    804211d201 <LZ4_decompress_safe_withPrefix64k+0x3a6>
                    if ((endOnInput) && ((ip+length != iend) || (cpy > oend))) { goto _output_error; }
  804211d1a8:	4a 8d 04 23          	lea    (%rbx,%r12,1),%rax
  804211d1ac:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  804211d1b0:	0f 85 e8 fe ff ff    	jne    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
  804211d1b6:	4c 39 7d b8          	cmp    %r15,-0x48(%rbp)
  804211d1ba:	0f 82 de fe ff ff    	jb     804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  804211d1c0:	4c 89 e2             	mov    %r12,%rdx
  804211d1c3:	48 89 de             	mov    %rbx,%rsi
  804211d1c6:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804211d1ca:	48 89 df             	mov    %rbx,%rdi
  804211d1cd:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211d1d4:	00 00 00 
  804211d1d7:	ff d0                	call   *%rax
                op += length;
  804211d1d9:	48 89 d8             	mov    %rbx,%rax
  804211d1dc:	4c 01 e0             	add    %r12,%rax
            return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
  804211d1df:	8b 4d 90             	mov    -0x70(%rbp),%ecx
  804211d1e2:	29 c8                	sub    %ecx,%eax
  804211d1e4:	e9 c1 fe ff ff       	jmp    804211d0aa <LZ4_decompress_safe_withPrefix64k+0x24f>
  804211d1e9:	89 4d 8c             	mov    %ecx,-0x74(%rbp)
  804211d1ec:	4c 89 f3             	mov    %r14,%rbx
  804211d1ef:	eb 99                	jmp    804211d18a <LZ4_decompress_safe_withPrefix64k+0x32f>
  804211d1f1:	89 4d 8c             	mov    %ecx,-0x74(%rbp)
  804211d1f4:	4c 89 f3             	mov    %r14,%rbx
  804211d1f7:	eb 91                	jmp    804211d18a <LZ4_decompress_safe_withPrefix64k+0x32f>
            token = *ip++;
  804211d1f9:	89 4d 8c             	mov    %ecx,-0x74(%rbp)
  804211d1fc:	4c 89 f3             	mov    %r14,%rbx
  804211d1ff:	eb 89                	jmp    804211d18a <LZ4_decompress_safe_withPrefix64k+0x32f>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  804211d201:	4c 89 fa             	mov    %r15,%rdx
  804211d204:	48 89 de             	mov    %rbx,%rsi
  804211d207:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211d20b:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211d212:	00 00 00 
  804211d215:	ff d0                	call   *%rax
            offset = LZ4_readLE16(ip); ip+=2;
  804211d217:	4c 89 ef             	mov    %r13,%rdi
  804211d21a:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211d221:	00 00 00 
  804211d224:	ff d0                	call   *%rax
  804211d226:	44 0f b7 f0          	movzwl %ax,%r14d
  804211d22a:	49 8d 45 02          	lea    0x2(%r13),%rax
  804211d22e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
            match = op - offset;
  804211d232:	4d 89 fc             	mov    %r15,%r12
  804211d235:	4d 29 f4             	sub    %r14,%r12
            length = token & ML_MASK;
  804211d238:	44 8b 6d 8c          	mov    -0x74(%rbp),%r13d
  804211d23c:	41 83 e5 0f          	and    $0xf,%r13d
            if (length == ML_MASK) {
  804211d240:	49 83 fd 0f          	cmp    $0xf,%r13
  804211d244:	0f 84 96 00 00 00    	je     804211d2e0 <LZ4_decompress_safe_withPrefix64k+0x485>
            length += MINMATCH;
  804211d24a:	49 83 c5 04          	add    $0x4,%r13
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
  804211d24e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211d252:	49 39 c4             	cmp    %rax,%r12
  804211d255:	0f 82 02 03 00 00    	jb     804211d55d <LZ4_decompress_safe_withPrefix64k+0x702>
            cpy = op + length;
  804211d25b:	4b 8d 04 2f          	lea    (%r15,%r13,1),%rax
  804211d25f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<8)) {
  804211d263:	49 83 fe 07          	cmp    $0x7,%r14
  804211d267:	0f 86 d2 00 00 00    	jbe    804211d33f <LZ4_decompress_safe_withPrefix64k+0x4e4>
                memcpy(op, match, 8);
  804211d26d:	ba 08 00 00 00       	mov    $0x8,%edx
  804211d272:	4c 89 e6             	mov    %r12,%rsi
  804211d275:	4c 89 ff             	mov    %r15,%rdi
  804211d278:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d27f:	00 00 00 
  804211d282:	ff d0                	call   *%rax
                match += 8;
  804211d284:	49 83 c4 08          	add    $0x8,%r12
            op += 8;
  804211d288:	49 8d 5f 08          	lea    0x8(%r15),%rbx
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  804211d28c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211d290:	48 83 e8 0c          	sub    $0xc,%rax
  804211d294:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804211d298:	48 39 c8             	cmp    %rcx,%rax
  804211d29b:	0f 82 0a 01 00 00    	jb     804211d3ab <LZ4_decompress_safe_withPrefix64k+0x550>
                memcpy(op, match, 8);
  804211d2a1:	ba 08 00 00 00       	mov    $0x8,%edx
  804211d2a6:	4c 89 e6             	mov    %r12,%rsi
  804211d2a9:	48 89 df             	mov    %rbx,%rdi
  804211d2ac:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d2b3:	00 00 00 
  804211d2b6:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211d2b8:	49 83 fd 10          	cmp    $0x10,%r13
  804211d2bc:	0f 86 61 01 00 00    	jbe    804211d423 <LZ4_decompress_safe_withPrefix64k+0x5c8>
  804211d2c2:	49 8d 74 24 08       	lea    0x8(%r12),%rsi
  804211d2c7:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211d2cb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211d2cf:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211d2d6:	00 00 00 
  804211d2d9:	ff d0                	call   *%rax
  804211d2db:	e9 43 01 00 00       	jmp    804211d423 <LZ4_decompress_safe_withPrefix64k+0x5c8>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211d2e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211d2e4:	48 8d 48 fc          	lea    -0x4(%rax),%rcx
  804211d2e8:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  804211d2ec:	b8 00 00 00 00       	mov    $0x0,%eax
        s = **ip;
  804211d2f1:	0f b6 13             	movzbl (%rbx),%edx
        (*ip)++;
  804211d2f4:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211d2f8:	01 d0                	add    %edx,%eax
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211d2fa:	48 39 cb             	cmp    %rcx,%rbx
  804211d2fd:	0f 83 9b fd ff ff    	jae    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
    } while (s==255);
  804211d303:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  804211d309:	74 e6                	je     804211d2f1 <LZ4_decompress_safe_withPrefix64k+0x496>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211d30b:	41 89 c5             	mov    %eax,%r13d
  804211d30e:	49 83 c5 0f          	add    $0xf,%r13
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
  804211d312:	4c 89 f8             	mov    %r15,%rax
  804211d315:	4c 01 e8             	add    %r13,%rax
  804211d318:	0f 82 80 fd ff ff    	jb     804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
        (*ip)++;
  804211d31e:	48 89 5d 98          	mov    %rbx,-0x68(%rbp)
  804211d322:	e9 23 ff ff ff       	jmp    804211d24a <LZ4_decompress_safe_withPrefix64k+0x3ef>
            offset = LZ4_readLE16(ip); ip+=2;
  804211d327:	49 89 ce             	mov    %rcx,%r14
  804211d32a:	48 89 5d 98          	mov    %rbx,-0x68(%rbp)
  804211d32e:	e9 1b ff ff ff       	jmp    804211d24e <LZ4_decompress_safe_withPrefix64k+0x3f3>
  804211d333:	49 89 ce             	mov    %rcx,%r14
        (*ip)++;
  804211d336:	48 89 5d 98          	mov    %rbx,-0x68(%rbp)
  804211d33a:	e9 1c ff ff ff       	jmp    804211d25b <LZ4_decompress_safe_withPrefix64k+0x400>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211d33f:	41 c7 07 00 00 00 00 	movl   $0x0,(%r15)
                op[0] = match[0];
  804211d346:	41 0f b6 04 24       	movzbl (%r12),%eax
  804211d34b:	41 88 07             	mov    %al,(%r15)
                op[1] = match[1];
  804211d34e:	41 0f b6 44 24 01    	movzbl 0x1(%r12),%eax
  804211d354:	41 88 47 01          	mov    %al,0x1(%r15)
                op[2] = match[2];
  804211d358:	41 0f b6 44 24 02    	movzbl 0x2(%r12),%eax
  804211d35e:	41 88 47 02          	mov    %al,0x2(%r15)
                op[3] = match[3];
  804211d362:	41 0f b6 44 24 03    	movzbl 0x3(%r12),%eax
  804211d368:	41 88 47 03          	mov    %al,0x3(%r15)
                match += inc32table[offset];
  804211d36c:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  804211d373:	00 00 00 
  804211d376:	42 8b 04 b0          	mov    (%rax,%r14,4),%eax
  804211d37a:	49 01 c4             	add    %rax,%r12
                memcpy(op+4, match, 4);
  804211d37d:	49 8d 7f 04          	lea    0x4(%r15),%rdi
  804211d381:	ba 04 00 00 00       	mov    $0x4,%edx
  804211d386:	4c 89 e6             	mov    %r12,%rsi
  804211d389:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d390:	00 00 00 
  804211d393:	ff d0                	call   *%rax
                match -= dec64table[offset];
  804211d395:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  804211d39c:	00 00 00 
  804211d39f:	4a 63 04 b0          	movslq (%rax,%r14,4),%rax
  804211d3a3:	49 29 c4             	sub    %rax,%r12
  804211d3a6:	e9 dd fe ff ff       	jmp    804211d288 <LZ4_decompress_safe_withPrefix64k+0x42d>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
  804211d3ab:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804211d3af:	48 8d 41 fb          	lea    -0x5(%rcx),%rax
  804211d3b3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211d3b7:	48 39 d0             	cmp    %rdx,%rax
  804211d3ba:	0f 82 a6 01 00 00    	jb     804211d566 <LZ4_decompress_safe_withPrefix64k+0x70b>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
  804211d3c0:	4c 8d 69 f9          	lea    -0x7(%rcx),%r13
                if (op < oCopyLimit) {
  804211d3c4:	4c 39 eb             	cmp    %r13,%rbx
  804211d3c7:	72 27                	jb     804211d3f0 <LZ4_decompress_safe_withPrefix64k+0x595>
                while (op < cpy) { *op++ = *match++; }
  804211d3c9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211d3cd:	48 89 d1             	mov    %rdx,%rcx
  804211d3d0:	48 29 d9             	sub    %rbx,%rcx
  804211d3d3:	b8 00 00 00 00       	mov    $0x0,%eax
  804211d3d8:	48 39 d3             	cmp    %rdx,%rbx
  804211d3db:	73 46                	jae    804211d423 <LZ4_decompress_safe_withPrefix64k+0x5c8>
  804211d3dd:	41 0f b6 14 04       	movzbl (%r12,%rax,1),%edx
  804211d3e2:	88 14 03             	mov    %dl,(%rbx,%rax,1)
  804211d3e5:	48 83 c0 01          	add    $0x1,%rax
  804211d3e9:	48 39 c8             	cmp    %rcx,%rax
  804211d3ec:	75 ef                	jne    804211d3dd <LZ4_decompress_safe_withPrefix64k+0x582>
  804211d3ee:	eb 33                	jmp    804211d423 <LZ4_decompress_safe_withPrefix64k+0x5c8>
                    LZ4_wildCopy8(op, match, oCopyLimit);
  804211d3f0:	4c 89 ea             	mov    %r13,%rdx
  804211d3f3:	4c 89 e6             	mov    %r12,%rsi
  804211d3f6:	48 89 df             	mov    %rbx,%rdi
  804211d3f9:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211d400:	00 00 00 
  804211d403:	ff d0                	call   *%rax
                    match += oCopyLimit - op;
  804211d405:	4c 89 e8             	mov    %r13,%rax
  804211d408:	48 29 d8             	sub    %rbx,%rax
  804211d40b:	49 01 c4             	add    %rax,%r12
                    op = oCopyLimit;
  804211d40e:	4c 89 eb             	mov    %r13,%rbx
  804211d411:	eb b6                	jmp    804211d3c9 <LZ4_decompress_safe_withPrefix64k+0x56e>
    {   const BYTE* ip = (const BYTE*) src;
  804211d413:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211d417:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        BYTE* op = (BYTE*) dst;
  804211d41b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211d41f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            token = *ip++;
  804211d423:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211d427:	48 8d 58 01          	lea    0x1(%rax),%rbx
  804211d42b:	44 0f b6 28          	movzbl (%rax),%r13d
  804211d42f:	41 0f b6 c5          	movzbl %r13b,%eax
  804211d433:	89 45 8c             	mov    %eax,-0x74(%rbp)
            length = token >> ML_BITS;  /* literal length */
  804211d436:	c1 e8 04             	shr    $0x4,%eax
  804211d439:	41 89 c4             	mov    %eax,%r12d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211d43c:	83 f8 0f             	cmp    $0xf,%eax
  804211d43f:	0f 84 eb fc ff ff    	je     804211d130 <LZ4_decompress_safe_withPrefix64k+0x2d5>
        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
  804211d445:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211d449:	48 8d 50 f0          	lea    -0x10(%rax),%rdx
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211d44d:	48 39 d3             	cmp    %rdx,%rbx
  804211d450:	0f 83 2c fd ff ff    	jae    804211d182 <LZ4_decompress_safe_withPrefix64k+0x327>
  804211d456:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804211d45a:	48 39 4d b0          	cmp    %rcx,-0x50(%rbp)
  804211d45e:	0f 82 1e fd ff ff    	jb     804211d182 <LZ4_decompress_safe_withPrefix64k+0x327>
  804211d464:	49 89 d6             	mov    %rdx,%r14
  804211d467:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
                memcpy(op, ip, endOnInput ? 16 : 8);
  804211d46b:	ba 10 00 00 00       	mov    $0x10,%edx
  804211d470:	48 89 de             	mov    %rbx,%rsi
  804211d473:	4c 89 ff             	mov    %r15,%rdi
  804211d476:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d47d:	00 00 00 
  804211d480:	ff d0                	call   *%rax
                op += length; ip += length;
  804211d482:	4d 01 e7             	add    %r12,%r15
  804211d485:	49 01 dc             	add    %rbx,%r12
                length = token & ML_MASK; /* match length */
  804211d488:	41 83 e5 0f          	and    $0xf,%r13d
                offset = LZ4_readLE16(ip); ip += 2;
  804211d48c:	4c 89 e7             	mov    %r12,%rdi
  804211d48f:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211d496:	00 00 00 
  804211d499:	ff d0                	call   *%rax
  804211d49b:	0f b7 c0             	movzwl %ax,%eax
                match = op - offset;
  804211d49e:	4c 89 fb             	mov    %r15,%rbx
  804211d4a1:	48 29 c3             	sub    %rax,%rbx
                if ( (length != ML_MASK)
  804211d4a4:	49 83 fd 0f          	cmp    $0xf,%r13
  804211d4a8:	0f 84 65 fc ff ff    	je     804211d113 <LZ4_decompress_safe_withPrefix64k+0x2b8>
  804211d4ae:	48 83 f8 07          	cmp    $0x7,%rax
  804211d4b2:	0f 86 5b fc ff ff    	jbe    804211d113 <LZ4_decompress_safe_withPrefix64k+0x2b8>
                    memcpy(op + 0, match + 0, 8);
  804211d4b8:	ba 08 00 00 00       	mov    $0x8,%edx
  804211d4bd:	48 89 de             	mov    %rbx,%rsi
  804211d4c0:	4c 89 ff             	mov    %r15,%rdi
  804211d4c3:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d4ca:	00 00 00 
  804211d4cd:	ff d0                	call   *%rax
                    memcpy(op + 8, match + 8, 8);
  804211d4cf:	48 8d 73 08          	lea    0x8(%rbx),%rsi
  804211d4d3:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211d4d7:	ba 08 00 00 00       	mov    $0x8,%edx
  804211d4dc:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d4e3:	00 00 00 
  804211d4e6:	ff d0                	call   *%rax
                    memcpy(op +16, match +16, 2);
  804211d4e8:	48 8d 73 10          	lea    0x10(%rbx),%rsi
  804211d4ec:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211d4f0:	ba 02 00 00 00       	mov    $0x2,%edx
  804211d4f5:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d4fc:	00 00 00 
  804211d4ff:	ff d0                	call   *%rax
                    op += length + MINMATCH;
  804211d501:	4f 8d 7c 2f 04       	lea    0x4(%r15,%r13,1),%r15
            token = *ip++;
  804211d506:	49 8d 5c 24 03       	lea    0x3(%r12),%rbx
  804211d50b:	45 0f b6 6c 24 02    	movzbl 0x2(%r12),%r13d
  804211d511:	41 0f b6 d5          	movzbl %r13b,%edx
            length = token >> ML_BITS;  /* literal length */
  804211d515:	89 d0                	mov    %edx,%eax
  804211d517:	c1 e8 04             	shr    $0x4,%eax
  804211d51a:	41 89 c4             	mov    %eax,%r12d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211d51d:	83 f8 0f             	cmp    $0xf,%eax
  804211d520:	0f 84 03 fc ff ff    	je     804211d129 <LZ4_decompress_safe_withPrefix64k+0x2ce>
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211d526:	4c 39 f3             	cmp    %r14,%rbx
  804211d529:	0f 83 4c fc ff ff    	jae    804211d17b <LZ4_decompress_safe_withPrefix64k+0x320>
  804211d52f:	4c 39 7d b0          	cmp    %r15,-0x50(%rbp)
  804211d533:	0f 83 32 ff ff ff    	jae    804211d46b <LZ4_decompress_safe_withPrefix64k+0x610>
  804211d539:	89 55 8c             	mov    %edx,-0x74(%rbp)
  804211d53c:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211d540:	e9 3d fc ff ff       	jmp    804211d182 <LZ4_decompress_safe_withPrefix64k+0x327>
            token = *ip++;
  804211d545:	4c 89 f3             	mov    %r14,%rbx
  804211d548:	e9 51 fb ff ff       	jmp    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
  804211d54d:	4c 89 f3             	mov    %r14,%rbx
  804211d550:	e9 49 fb ff ff       	jmp    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
  804211d555:	4c 89 f3             	mov    %r14,%rbx
  804211d558:	e9 41 fb ff ff       	jmp    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
  804211d55d:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  804211d561:	e9 38 fb ff ff       	jmp    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
  804211d566:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
  804211d56a:	e9 2f fb ff ff       	jmp    804211d09e <LZ4_decompress_safe_withPrefix64k+0x243>
    if (src == NULL) { return -1; }
  804211d56f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211d574:	e9 31 fb ff ff       	jmp    804211d0aa <LZ4_decompress_safe_withPrefix64k+0x24f>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211d579:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
  804211d57e:	e9 27 fb ff ff       	jmp    804211d0aa <LZ4_decompress_safe_withPrefix64k+0x24f>

000000804211d583 <LZ4_decompress_fast_withPrefix64k>:
{
  804211d583:	f3 0f 1e fa          	endbr64
  804211d587:	55                   	push   %rbp
  804211d588:	48 89 e5             	mov    %rsp,%rbp
    return LZ4_decompress_fast(source, dest, originalSize);
  804211d58b:	48 b8 bf c8 11 42 80 	movabs $0x804211c8bf,%rax
  804211d592:	00 00 00 
  804211d595:	ff d0                	call   *%rax
}
  804211d597:	5d                   	pop    %rbp
  804211d598:	c3                   	ret

000000804211d599 <LZ4_decompress_safe_forceExtDict>:
{
  804211d599:	f3 0f 1e fa          	endbr64
  804211d59d:	55                   	push   %rbp
  804211d59e:	48 89 e5             	mov    %rsp,%rbp
  804211d5a1:	41 57                	push   %r15
  804211d5a3:	41 56                	push   %r14
  804211d5a5:	41 55                	push   %r13
  804211d5a7:	41 54                	push   %r12
  804211d5a9:	53                   	push   %rbx
  804211d5aa:	48 83 ec 58          	sub    $0x58,%rsp
  804211d5ae:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
  804211d5b2:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  804211d5b6:	4c 89 4d a8          	mov    %r9,-0x58(%rbp)
    if (src == NULL) { return -1; }
  804211d5ba:	48 85 ff             	test   %rdi,%rdi
  804211d5bd:	0f 84 98 08 00 00    	je     804211de5b <LZ4_decompress_safe_forceExtDict+0x8c2>
        const BYTE* const iend = ip + srcSize;
  804211d5c3:	48 63 c2             	movslq %edx,%rax
  804211d5c6:	48 01 f8             	add    %rdi,%rax
  804211d5c9:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        BYTE* const oend = op + outputSize;
  804211d5cd:	48 63 c1             	movslq %ecx,%rax
  804211d5d0:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  804211d5d4:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
        const BYTE* const dictEnd = (dictStart == NULL) ? NULL : dictStart + dictSize;
  804211d5d8:	4b 8d 04 08          	lea    (%r8,%r9,1),%rax
  804211d5dc:	4d 85 c0             	test   %r8,%r8
  804211d5df:	49 0f 44 c0          	cmove  %r8,%rax
  804211d5e3:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  804211d5e7:	48 8d 47 e0          	lea    -0x20(%rdi),%rax
  804211d5eb:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        if ((endOnInput) && (unlikely(outputSize==0))) {
  804211d5ef:	85 c9                	test   %ecx,%ecx
  804211d5f1:	74 2e                	je     804211d621 <LZ4_decompress_safe_forceExtDict+0x88>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211d5f3:	85 d2                	test   %edx,%edx
  804211d5f5:	0f 84 67 08 00 00    	je     804211de62 <LZ4_decompress_safe_forceExtDict+0x8c9>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  804211d5fb:	83 f9 3f             	cmp    $0x3f,%ecx
  804211d5fe:	0f 8e 45 03 00 00    	jle    804211d949 <LZ4_decompress_safe_forceExtDict+0x3b0>
    {   const BYTE* ip = (const BYTE*) src;
  804211d604:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211d608:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211d60c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211d610:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211d614:	48 83 e8 11          	sub    $0x11,%rax
  804211d618:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  804211d61c:	e9 fd 01 00 00       	jmp    804211d81e <LZ4_decompress_safe_forceExtDict+0x285>
            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
  804211d621:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211d626:	83 fa 01             	cmp    $0x1,%edx
  804211d629:	0f 85 04 08 00 00    	jne    804211de33 <LZ4_decompress_safe_forceExtDict+0x89a>
  804211d62f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211d633:	0f b6 00             	movzbl (%rax),%eax
  804211d636:	f6 d8                	neg    %al
  804211d638:	19 c0                	sbb    %eax,%eax
  804211d63a:	e9 f4 07 00 00       	jmp    804211de33 <LZ4_decompress_safe_forceExtDict+0x89a>
                    op += copySize;
  804211d63f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  804211d643:	e9 d6 01 00 00       	jmp    804211d81e <LZ4_decompress_safe_forceExtDict+0x285>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211d648:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211d64c:	48 8d 50 f1          	lea    -0xf(%rax),%rdx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211d650:	49 39 d5             	cmp    %rdx,%r13
  804211d653:	0f 83 cb 07 00 00    	jae    804211de24 <LZ4_decompress_safe_forceExtDict+0x88b>
  804211d659:	41 be 00 00 00 00    	mov    $0x0,%r14d
        s = **ip;
  804211d65f:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  804211d664:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  804211d668:	41 01 c6             	add    %eax,%r14d
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211d66b:	4c 39 ea             	cmp    %r13,%rdx
  804211d66e:	74 07                	je     804211d677 <LZ4_decompress_safe_forceExtDict+0xde>
    } while (s==255);
  804211d670:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211d675:	74 e8                	je     804211d65f <LZ4_decompress_safe_forceExtDict+0xc6>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211d677:	45 89 f6             	mov    %r14d,%r14d
  804211d67a:	49 83 c6 0f          	add    $0xf,%r14
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211d67e:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211d682:	48 89 f8             	mov    %rdi,%rax
  804211d685:	4c 01 f0             	add    %r14,%rax
  804211d688:	0f 82 b4 07 00 00    	jb     804211de42 <LZ4_decompress_safe_forceExtDict+0x8a9>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211d68e:	4c 89 e8             	mov    %r13,%rax
  804211d691:	4c 01 f0             	add    %r14,%rax
  804211d694:	0f 82 ad 07 00 00    	jb     804211de47 <LZ4_decompress_safe_forceExtDict+0x8ae>
                cpy = op+length;
  804211d69a:	4e 8d 3c 37          	lea    (%rdi,%r14,1),%r15
                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
  804211d69e:	4c 39 7d 90          	cmp    %r15,-0x70(%rbp)
  804211d6a2:	0f 82 18 05 00 00    	jb     804211dbc0 <LZ4_decompress_safe_forceExtDict+0x627>
  804211d6a8:	4b 8d 5c 35 00       	lea    0x0(%r13,%r14,1),%rbx
  804211d6ad:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211d6b1:	48 83 e8 20          	sub    $0x20,%rax
  804211d6b5:	48 39 d8             	cmp    %rbx,%rax
  804211d6b8:	0f 82 0a 05 00 00    	jb     804211dbc8 <LZ4_decompress_safe_forceExtDict+0x62f>
                    LZ4_wildCopy32(op, ip, cpy);
  804211d6be:	4c 89 fa             	mov    %r15,%rdx
  804211d6c1:	4c 89 ee             	mov    %r13,%rsi
  804211d6c4:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211d6cb:	00 00 00 
  804211d6ce:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211d6d0:	e9 91 01 00 00       	jmp    804211d866 <LZ4_decompress_safe_forceExtDict+0x2cd>
                if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211d6d5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211d6d9:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
  804211d6df:	77 10                	ja     804211d6f1 <LZ4_decompress_safe_forceExtDict+0x158>
  804211d6e1:	4c 01 f0             	add    %r14,%rax
  804211d6e4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211d6e8:	48 39 d0             	cmp    %rdx,%rax
  804211d6eb:	0f 82 36 07 00 00    	jb     804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211d6f1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211d6f5:	48 8d 50 fc          	lea    -0x4(%rax),%rdx
  804211d6f9:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        s = **ip;
  804211d6ff:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211d702:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211d706:	41 01 c4             	add    %eax,%r12d
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211d709:	48 39 d3             	cmp    %rdx,%rbx
  804211d70c:	0f 83 15 07 00 00    	jae    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
    } while (s==255);
  804211d712:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211d717:	74 e6                	je     804211d6ff <LZ4_decompress_safe_forceExtDict+0x166>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211d719:	45 89 e4             	mov    %r12d,%r12d
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
  804211d71c:	4b 8d 44 27 0f       	lea    0xf(%r15,%r12,1),%rax
  804211d721:	4c 39 f8             	cmp    %r15,%rax
  804211d724:	0f 82 fd 06 00 00    	jb     804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
                length += MINMATCH;
  804211d72a:	49 83 c4 13          	add    $0x13,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211d72e:	4b 8d 14 27          	lea    (%r15,%r12,1),%rdx
  804211d732:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211d736:	48 83 e8 40          	sub    $0x40,%rax
  804211d73a:	48 39 c2             	cmp    %rax,%rdx
  804211d73d:	0f 82 7d 01 00 00    	jb     804211d8c0 <LZ4_decompress_safe_forceExtDict+0x327>
  804211d743:	49 89 cd             	mov    %rcx,%r13
  804211d746:	e9 c4 02 00 00       	jmp    804211da0f <LZ4_decompress_safe_forceExtDict+0x476>
                        memcpy(op, match, 8);
  804211d74b:	ba 08 00 00 00       	mov    $0x8,%edx
  804211d750:	4c 89 f6             	mov    %r14,%rsi
  804211d753:	4c 89 ff             	mov    %r15,%rdi
  804211d756:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  804211d75d:	00 00 00 
  804211d760:	41 ff d4             	call   *%r12
                        memcpy(op+8, match+8, 8);
  804211d763:	49 8d 76 08          	lea    0x8(%r14),%rsi
  804211d767:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211d76b:	ba 08 00 00 00       	mov    $0x8,%edx
  804211d770:	41 ff d4             	call   *%r12
                        memcpy(op+16, match+16, 2);
  804211d773:	49 8d 76 10          	lea    0x10(%r14),%rsi
  804211d777:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211d77b:	ba 02 00 00 00       	mov    $0x2,%edx
  804211d780:	41 ff d4             	call   *%r12
                        continue;
  804211d783:	e9 96 00 00 00       	jmp    804211d81e <LZ4_decompress_safe_forceExtDict+0x285>
                    size_t const restSize = length - copySize;
  804211d788:	4d 89 e6             	mov    %r12,%r14
  804211d78b:	49 29 f6             	sub    %rsi,%r14
                    memcpy(op, dictEnd - copySize, copySize);
  804211d78e:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
  804211d792:	4c 29 ee             	sub    %r13,%rsi
  804211d795:	4c 89 ea             	mov    %r13,%rdx
  804211d798:	4c 89 ff             	mov    %r15,%rdi
  804211d79b:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d7a2:	00 00 00 
  804211d7a5:	ff d0                	call   *%rax
                    op += copySize;
  804211d7a7:	4b 8d 3c 2f          	lea    (%r15,%r13,1),%rdi
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
  804211d7ab:	48 89 f8             	mov    %rdi,%rax
  804211d7ae:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  804211d7b2:	48 29 c8             	sub    %rcx,%rax
  804211d7b5:	4c 39 f0             	cmp    %r14,%rax
  804211d7b8:	72 15                	jb     804211d7cf <LZ4_decompress_safe_forceExtDict+0x236>
                        memcpy(op, lowPrefix, restSize);
  804211d7ba:	4c 89 f2             	mov    %r14,%rdx
  804211d7bd:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804211d7c1:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d7c8:	00 00 00 
  804211d7cb:	ff d0                	call   *%rax
                        op += restSize;
  804211d7cd:	eb 4f                	jmp    804211d81e <LZ4_decompress_safe_forceExtDict+0x285>
                        while (op < endOfMatch) { *op++ = *copyFrom++; }
  804211d7cf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211d7d3:	48 39 c7             	cmp    %rax,%rdi
  804211d7d6:	0f 83 63 fe ff ff    	jae    804211d63f <LZ4_decompress_safe_forceExtDict+0xa6>
  804211d7dc:	4d 89 f4             	mov    %r14,%r12
  804211d7df:	b8 00 00 00 00       	mov    $0x0,%eax
  804211d7e4:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  804211d7e8:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  804211d7eb:	48 83 c0 01          	add    $0x1,%rax
  804211d7ef:	4c 39 e0             	cmp    %r12,%rax
  804211d7f2:	75 f0                	jne    804211d7e4 <LZ4_decompress_safe_forceExtDict+0x24b>
  804211d7f4:	eb 28                	jmp    804211d81e <LZ4_decompress_safe_forceExtDict+0x285>
            cpy = op + length;
  804211d7f6:	4b 8d 04 27          	lea    (%r15,%r12,1),%rax
  804211d7fa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<16)) {
  804211d7fe:	48 83 f9 0f          	cmp    $0xf,%rcx
  804211d802:	0f 86 27 01 00 00    	jbe    804211d92f <LZ4_decompress_safe_forceExtDict+0x396>
                LZ4_wildCopy32(op, match, cpy);
  804211d808:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211d80c:	4c 89 f6             	mov    %r14,%rsi
  804211d80f:	4c 89 ff             	mov    %r15,%rdi
  804211d812:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211d819:	00 00 00 
  804211d81c:	ff d0                	call   *%rax
            token = *ip++;
  804211d81e:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  804211d822:	44 0f b6 23          	movzbl (%rbx),%r12d
  804211d826:	41 0f b6 cc          	movzbl %r12b,%ecx
            length = token >> ML_BITS;  /* literal length */
  804211d82a:	89 c8                	mov    %ecx,%eax
  804211d82c:	c1 e8 04             	shr    $0x4,%eax
  804211d82f:	41 89 c6             	mov    %eax,%r14d
            if (length == RUN_MASK) {
  804211d832:	83 f8 0f             	cmp    $0xf,%eax
  804211d835:	0f 84 0d fe ff ff    	je     804211d648 <LZ4_decompress_safe_forceExtDict+0xaf>
                cpy = op+length;
  804211d83b:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211d83f:	4e 8d 3c 37          	lea    (%rdi,%r14,1),%r15
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211d843:	4c 39 6d 98          	cmp    %r13,-0x68(%rbp)
  804211d847:	0f 82 83 03 00 00    	jb     804211dbd0 <LZ4_decompress_safe_forceExtDict+0x637>
                    memcpy(op, ip, 16);
  804211d84d:	ba 10 00 00 00       	mov    $0x10,%edx
  804211d852:	4c 89 ee             	mov    %r13,%rsi
  804211d855:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d85c:	00 00 00 
  804211d85f:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211d861:	4b 8d 5c 35 00       	lea    0x0(%r13,%r14,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211d866:	48 89 df             	mov    %rbx,%rdi
  804211d869:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211d870:	00 00 00 
  804211d873:	ff d0                	call   *%rax
  804211d875:	0f b7 c8             	movzwl %ax,%ecx
  804211d878:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211d87c:	4d 89 fe             	mov    %r15,%r14
  804211d87f:	49 29 ce             	sub    %rcx,%r14
            length = token & ML_MASK;
  804211d882:	41 83 e4 0f          	and    $0xf,%r12d
            if (length == ML_MASK) {
  804211d886:	49 83 fc 0f          	cmp    $0xf,%r12
  804211d88a:	0f 84 45 fe ff ff    	je     804211d6d5 <LZ4_decompress_safe_forceExtDict+0x13c>
                length += MINMATCH;
  804211d890:	49 83 c4 04          	add    $0x4,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211d894:	4b 8d 34 27          	lea    (%r15,%r12,1),%rsi
  804211d898:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  804211d89c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211d8a0:	48 83 e8 40          	sub    $0x40,%rax
  804211d8a4:	48 39 c6             	cmp    %rax,%rsi
  804211d8a7:	0f 83 a9 03 00 00    	jae    804211dc56 <LZ4_decompress_safe_forceExtDict+0x6bd>
                    if (offset >= 8) {
  804211d8ad:	48 83 f9 07          	cmp    $0x7,%rcx
  804211d8b1:	76 0d                	jbe    804211d8c0 <LZ4_decompress_safe_forceExtDict+0x327>
  804211d8b3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211d8b7:	49 39 c6             	cmp    %rax,%r14
  804211d8ba:	0f 83 8b fe ff ff    	jae    804211d74b <LZ4_decompress_safe_forceExtDict+0x1b2>
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211d8c0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211d8c4:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
  804211d8ca:	77 10                	ja     804211d8dc <LZ4_decompress_safe_forceExtDict+0x343>
  804211d8cc:	4c 01 f0             	add    %r14,%rax
  804211d8cf:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211d8d3:	48 39 d0             	cmp    %rdx,%rax
  804211d8d6:	0f 82 4b 05 00 00    	jb     804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
            if ((dict==usingExtDict) && (match < lowPrefix)) {
  804211d8dc:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804211d8e0:	49 39 f6             	cmp    %rsi,%r14
  804211d8e3:	0f 83 0d ff ff ff    	jae    804211d7f6 <LZ4_decompress_safe_forceExtDict+0x25d>
                if (unlikely(op+length > oend-LASTLITERALS)) {
  804211d8e9:	4b 8d 0c 27          	lea    (%r15,%r12,1),%rcx
  804211d8ed:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  804211d8f1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211d8f5:	48 83 e8 05          	sub    $0x5,%rax
  804211d8f9:	48 39 c8             	cmp    %rcx,%rax
  804211d8fc:	0f 82 25 05 00 00    	jb     804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
                if (length <= (size_t)(lowPrefix-match)) {
  804211d902:	4c 29 f6             	sub    %r14,%rsi
  804211d905:	49 89 f5             	mov    %rsi,%r13
  804211d908:	4c 39 e6             	cmp    %r12,%rsi
  804211d90b:	0f 82 77 fe ff ff    	jb     804211d788 <LZ4_decompress_safe_forceExtDict+0x1ef>
                    memmove(op, dictEnd - (lowPrefix-match), length);
  804211d911:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
  804211d915:	4c 29 ee             	sub    %r13,%rsi
  804211d918:	4c 89 e2             	mov    %r12,%rdx
  804211d91b:	4c 89 ff             	mov    %r15,%rdi
  804211d91e:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211d925:	00 00 00 
  804211d928:	ff d0                	call   *%rax
                    op += length;
  804211d92a:	e9 ef fe ff ff       	jmp    804211d81e <LZ4_decompress_safe_forceExtDict+0x285>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  804211d92f:	48 89 c2             	mov    %rax,%rdx
  804211d932:	4c 89 f6             	mov    %r14,%rsi
  804211d935:	4c 89 ff             	mov    %r15,%rdi
  804211d938:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  804211d93f:	00 00 00 
  804211d942:	ff d0                	call   *%rax
  804211d944:	e9 d5 fe ff ff       	jmp    804211d81e <LZ4_decompress_safe_forceExtDict+0x285>
    {   const BYTE* ip = (const BYTE*) src;
  804211d949:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211d94d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211d951:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            token = *ip++;
  804211d955:	4c 8d 63 01          	lea    0x1(%rbx),%r12
  804211d959:	0f b6 1b             	movzbl (%rbx),%ebx
  804211d95c:	0f b6 c3             	movzbl %bl,%eax
  804211d95f:	89 45 98             	mov    %eax,-0x68(%rbp)
            length = token >> ML_BITS;  /* literal length */
  804211d962:	c1 e8 04             	shr    $0x4,%eax
  804211d965:	41 89 c6             	mov    %eax,%r14d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211d968:	83 f8 0f             	cmp    $0xf,%eax
  804211d96b:	0f 84 90 01 00 00    	je     804211db01 <LZ4_decompress_safe_forceExtDict+0x568>
        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
  804211d971:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211d975:	48 83 e8 10          	sub    $0x10,%rax
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211d979:	49 39 c4             	cmp    %rax,%r12
  804211d97c:	0f 83 cb 01 00 00    	jae    804211db4d <LZ4_decompress_safe_forceExtDict+0x5b4>
  804211d982:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  804211d986:	48 39 4d 90          	cmp    %rcx,-0x70(%rbp)
  804211d98a:	0f 82 bd 01 00 00    	jb     804211db4d <LZ4_decompress_safe_forceExtDict+0x5b4>
  804211d990:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  804211d994:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
                memcpy(op, ip, endOnInput ? 16 : 8);
  804211d998:	ba 10 00 00 00       	mov    $0x10,%edx
  804211d99d:	4c 89 e6             	mov    %r12,%rsi
  804211d9a0:	4c 89 ff             	mov    %r15,%rdi
  804211d9a3:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211d9aa:	00 00 00 
  804211d9ad:	ff d0                	call   *%rax
                op += length; ip += length;
  804211d9af:	4d 01 f7             	add    %r14,%r15
  804211d9b2:	4f 8d 2c 34          	lea    (%r12,%r14,1),%r13
                length = token & ML_MASK; /* match length */
  804211d9b6:	49 89 dc             	mov    %rbx,%r12
  804211d9b9:	41 83 e4 0f          	and    $0xf,%r12d
                offset = LZ4_readLE16(ip); ip += 2;
  804211d9bd:	4c 89 ef             	mov    %r13,%rdi
  804211d9c0:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211d9c7:	00 00 00 
  804211d9ca:	ff d0                	call   *%rax
  804211d9cc:	0f b7 c0             	movzwl %ax,%eax
                match = op - offset;
  804211d9cf:	4d 89 fe             	mov    %r15,%r14
  804211d9d2:	49 29 c6             	sub    %rax,%r14
                if ( (length != ML_MASK)
  804211d9d5:	49 83 fc 0f          	cmp    $0xf,%r12
  804211d9d9:	0f 95 c1             	setne  %cl
                     && (offset >= 8)
  804211d9dc:	48 83 f8 07          	cmp    $0x7,%rax
  804211d9e0:	0f 97 c2             	seta   %dl
                     && (dict==withPrefix64k || match >= lowPrefix) ) {
  804211d9e3:	84 d1                	test   %dl,%cl
  804211d9e5:	74 0d                	je     804211d9f4 <LZ4_decompress_safe_forceExtDict+0x45b>
  804211d9e7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211d9eb:	49 39 d6             	cmp    %rdx,%r14
  804211d9ee:	0f 83 93 00 00 00    	jae    804211da87 <LZ4_decompress_safe_forceExtDict+0x4ee>
                offset = LZ4_readLE16(ip); ip += 2;
  804211d9f4:	4c 89 e9             	mov    %r13,%rcx
  804211d9f7:	49 89 c5             	mov    %rax,%r13
  804211d9fa:	48 83 c1 02          	add    $0x2,%rcx
  804211d9fe:	48 89 cb             	mov    %rcx,%rbx
            if (length == ML_MASK) {
  804211da01:	49 83 fc 0f          	cmp    $0xf,%r12
  804211da05:	0f 84 0e 02 00 00    	je     804211dc19 <LZ4_decompress_safe_forceExtDict+0x680>
            length += MINMATCH;
  804211da0b:	49 83 c4 04          	add    $0x4,%r12
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
  804211da0f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211da13:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
  804211da19:	77 10                	ja     804211da2b <LZ4_decompress_safe_forceExtDict+0x492>
  804211da1b:	4c 01 f0             	add    %r14,%rax
  804211da1e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211da22:	48 39 d0             	cmp    %rdx,%rax
  804211da25:	0f 82 fc 03 00 00    	jb     804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
            if ((dict==usingExtDict) && (match < lowPrefix)) {
  804211da2b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211da2f:	49 39 d6             	cmp    %rdx,%r14
  804211da32:	0f 83 97 02 00 00    	jae    804211dccf <LZ4_decompress_safe_forceExtDict+0x736>
                if (unlikely(op+length > oend-LASTLITERALS)) {
  804211da38:	4b 8d 0c 27          	lea    (%r15,%r12,1),%rcx
  804211da3c:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  804211da40:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211da44:	48 83 e8 05          	sub    $0x5,%rax
  804211da48:	48 39 c8             	cmp    %rcx,%rax
  804211da4b:	0f 82 d6 03 00 00    	jb     804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
                if (length <= (size_t)(lowPrefix-match)) {
  804211da51:	4c 29 f2             	sub    %r14,%rdx
  804211da54:	49 89 d5             	mov    %rdx,%r13
  804211da57:	4c 39 e2             	cmp    %r12,%rdx
  804211da5a:	0f 82 fe 01 00 00    	jb     804211dc5e <LZ4_decompress_safe_forceExtDict+0x6c5>
                    memmove(op, dictEnd - (lowPrefix-match), length);
  804211da60:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
  804211da64:	48 29 d6             	sub    %rdx,%rsi
  804211da67:	4c 89 e2             	mov    %r12,%rdx
  804211da6a:	4c 89 ff             	mov    %r15,%rdi
  804211da6d:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211da74:	00 00 00 
  804211da77:	ff d0                	call   *%rax
                    op += length;
  804211da79:	e9 d7 fe ff ff       	jmp    804211d955 <LZ4_decompress_safe_forceExtDict+0x3bc>
                    op += copySize;
  804211da7e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  804211da82:	e9 ce fe ff ff       	jmp    804211d955 <LZ4_decompress_safe_forceExtDict+0x3bc>
                    memcpy(op + 0, match + 0, 8);
  804211da87:	ba 08 00 00 00       	mov    $0x8,%edx
  804211da8c:	4c 89 f6             	mov    %r14,%rsi
  804211da8f:	4c 89 ff             	mov    %r15,%rdi
  804211da92:	48 bb 62 0d 11 42 80 	movabs $0x8042110d62,%rbx
  804211da99:	00 00 00 
  804211da9c:	ff d3                	call   *%rbx
                    memcpy(op + 8, match + 8, 8);
  804211da9e:	49 8d 76 08          	lea    0x8(%r14),%rsi
  804211daa2:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211daa6:	ba 08 00 00 00       	mov    $0x8,%edx
  804211daab:	ff d3                	call   *%rbx
                    memcpy(op +16, match +16, 2);
  804211daad:	49 8d 76 10          	lea    0x10(%r14),%rsi
  804211dab1:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211dab5:	ba 02 00 00 00       	mov    $0x2,%edx
  804211daba:	ff d3                	call   *%rbx
                    op += length + MINMATCH;
  804211dabc:	4f 8d 7c 27 04       	lea    0x4(%r15,%r12,1),%r15
            token = *ip++;
  804211dac1:	4d 8d 65 03          	lea    0x3(%r13),%r12
  804211dac5:	41 0f b6 5d 02       	movzbl 0x2(%r13),%ebx
  804211daca:	0f b6 d3             	movzbl %bl,%edx
            length = token >> ML_BITS;  /* literal length */
  804211dacd:	89 d0                	mov    %edx,%eax
  804211dacf:	c1 e8 04             	shr    $0x4,%eax
  804211dad2:	41 89 c6             	mov    %eax,%r14d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211dad5:	83 f8 0f             	cmp    $0xf,%eax
  804211dad8:	74 20                	je     804211dafa <LZ4_decompress_safe_forceExtDict+0x561>
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211dada:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211dade:	49 39 c4             	cmp    %rax,%r12
  804211dae1:	0f 83 d0 00 00 00    	jae    804211dbb7 <LZ4_decompress_safe_forceExtDict+0x61e>
  804211dae7:	4c 39 7d 90          	cmp    %r15,-0x70(%rbp)
  804211daeb:	0f 83 a7 fe ff ff    	jae    804211d998 <LZ4_decompress_safe_forceExtDict+0x3ff>
  804211daf1:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211daf5:	89 55 98             	mov    %edx,-0x68(%rbp)
  804211daf8:	eb 53                	jmp    804211db4d <LZ4_decompress_safe_forceExtDict+0x5b4>
  804211dafa:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211dafe:	89 55 98             	mov    %edx,-0x68(%rbp)
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211db01:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211db05:	48 8d 48 f1          	lea    -0xf(%rax),%rcx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211db09:	49 39 cc             	cmp    %rcx,%r12
  804211db0c:	0f 83 3a 03 00 00    	jae    804211de4c <LZ4_decompress_safe_forceExtDict+0x8b3>
  804211db12:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211db17:	41 0f b6 04 24       	movzbl (%r12),%eax
        (*ip)++;
  804211db1c:	49 83 c4 01          	add    $0x1,%r12
        length += s;
  804211db20:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211db22:	4c 39 e1             	cmp    %r12,%rcx
  804211db25:	74 07                	je     804211db2e <LZ4_decompress_safe_forceExtDict+0x595>
    } while (s==255);
  804211db27:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211db2c:	74 e9                	je     804211db17 <LZ4_decompress_safe_forceExtDict+0x57e>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211db2e:	89 d2                	mov    %edx,%edx
  804211db30:	4c 8d 72 0f          	lea    0xf(%rdx),%r14
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211db34:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211db38:	4c 01 f0             	add    %r14,%rax
  804211db3b:	0f 82 10 03 00 00    	jb     804211de51 <LZ4_decompress_safe_forceExtDict+0x8b8>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211db41:	4c 89 e0             	mov    %r12,%rax
  804211db44:	4c 01 f0             	add    %r14,%rax
  804211db47:	0f 82 09 03 00 00    	jb     804211de56 <LZ4_decompress_safe_forceExtDict+0x8bd>
            cpy = op+length;
  804211db4d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211db51:	4e 8d 3c 30          	lea    (%rax,%r14,1),%r15
  804211db55:	4c 89 e3             	mov    %r12,%rbx
            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
  804211db58:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211db5c:	48 83 e8 0c          	sub    $0xc,%rax
  804211db60:	4c 39 f8             	cmp    %r15,%rax
  804211db63:	72 11                	jb     804211db76 <LZ4_decompress_safe_forceExtDict+0x5dd>
  804211db65:	4e 8d 24 33          	lea    (%rbx,%r14,1),%r12
  804211db69:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211db6d:	48 83 e8 08          	sub    $0x8,%rax
  804211db71:	4c 39 e0             	cmp    %r12,%rax
  804211db74:	73 62                	jae    804211dbd8 <LZ4_decompress_safe_forceExtDict+0x63f>
                    if ((endOnInput) && ((ip+length != iend) || (cpy > oend))) { goto _output_error; }
  804211db76:	4a 8d 04 33          	lea    (%rbx,%r14,1),%rax
  804211db7a:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  804211db7e:	0f 85 a3 02 00 00    	jne    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
  804211db84:	4c 39 7d b8          	cmp    %r15,-0x48(%rbp)
  804211db88:	0f 82 99 02 00 00    	jb     804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  804211db8e:	4c 89 f2             	mov    %r14,%rdx
  804211db91:	48 89 de             	mov    %rbx,%rsi
  804211db94:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804211db98:	48 89 df             	mov    %rbx,%rdi
  804211db9b:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211dba2:	00 00 00 
  804211dba5:	ff d0                	call   *%rax
                op += length;
  804211dba7:	48 89 d8             	mov    %rbx,%rax
  804211dbaa:	4c 01 f0             	add    %r14,%rax
            return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
  804211dbad:	8b 55 c0             	mov    -0x40(%rbp),%edx
  804211dbb0:	29 d0                	sub    %edx,%eax
  804211dbb2:	e9 7c 02 00 00       	jmp    804211de33 <LZ4_decompress_safe_forceExtDict+0x89a>
  804211dbb7:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
  804211dbbb:	89 55 98             	mov    %edx,-0x68(%rbp)
  804211dbbe:	eb 8d                	jmp    804211db4d <LZ4_decompress_safe_forceExtDict+0x5b4>
  804211dbc0:	89 4d 98             	mov    %ecx,-0x68(%rbp)
  804211dbc3:	4c 89 eb             	mov    %r13,%rbx
  804211dbc6:	eb 90                	jmp    804211db58 <LZ4_decompress_safe_forceExtDict+0x5bf>
  804211dbc8:	89 4d 98             	mov    %ecx,-0x68(%rbp)
  804211dbcb:	4c 89 eb             	mov    %r13,%rbx
  804211dbce:	eb 88                	jmp    804211db58 <LZ4_decompress_safe_forceExtDict+0x5bf>
            token = *ip++;
  804211dbd0:	89 4d 98             	mov    %ecx,-0x68(%rbp)
  804211dbd3:	4c 89 eb             	mov    %r13,%rbx
  804211dbd6:	eb 80                	jmp    804211db58 <LZ4_decompress_safe_forceExtDict+0x5bf>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  804211dbd8:	4c 89 fa             	mov    %r15,%rdx
  804211dbdb:	48 89 de             	mov    %rbx,%rsi
  804211dbde:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211dbe2:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211dbe9:	00 00 00 
  804211dbec:	ff d0                	call   *%rax
            offset = LZ4_readLE16(ip); ip+=2;
  804211dbee:	4c 89 e7             	mov    %r12,%rdi
  804211dbf1:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211dbf8:	00 00 00 
  804211dbfb:	ff d0                	call   *%rax
  804211dbfd:	44 0f b7 e8          	movzwl %ax,%r13d
  804211dc01:	49 8d 5c 24 02       	lea    0x2(%r12),%rbx
            match = op - offset;
  804211dc06:	4d 89 fe             	mov    %r15,%r14
  804211dc09:	4d 29 ee             	sub    %r13,%r14
            length = token & ML_MASK;
  804211dc0c:	44 8b 65 98          	mov    -0x68(%rbp),%r12d
  804211dc10:	41 83 e4 0f          	and    $0xf,%r12d
  804211dc14:	e9 e8 fd ff ff       	jmp    804211da01 <LZ4_decompress_safe_forceExtDict+0x468>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211dc19:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211dc1d:	48 8d 48 fc          	lea    -0x4(%rax),%rcx
  804211dc21:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211dc26:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211dc29:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211dc2d:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211dc2f:	48 39 cb             	cmp    %rcx,%rbx
  804211dc32:	0f 83 ef 01 00 00    	jae    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
    } while (s==255);
  804211dc38:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211dc3d:	74 e7                	je     804211dc26 <LZ4_decompress_safe_forceExtDict+0x68d>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211dc3f:	89 d2                	mov    %edx,%edx
  804211dc41:	4c 8d 62 0f          	lea    0xf(%rdx),%r12
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
  804211dc45:	4c 89 f8             	mov    %r15,%rax
  804211dc48:	4c 01 e0             	add    %r12,%rax
  804211dc4b:	0f 83 ba fd ff ff    	jae    804211da0b <LZ4_decompress_safe_forceExtDict+0x472>
  804211dc51:	e9 d1 01 00 00       	jmp    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
  804211dc56:	49 89 cd             	mov    %rcx,%r13
  804211dc59:	e9 b1 fd ff ff       	jmp    804211da0f <LZ4_decompress_safe_forceExtDict+0x476>
                    size_t const restSize = length - copySize;
  804211dc5e:	4d 89 e6             	mov    %r12,%r14
  804211dc61:	49 29 d6             	sub    %rdx,%r14
                    memcpy(op, dictEnd - copySize, copySize);
  804211dc64:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
  804211dc68:	48 29 d6             	sub    %rdx,%rsi
  804211dc6b:	4c 89 ff             	mov    %r15,%rdi
  804211dc6e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211dc75:	00 00 00 
  804211dc78:	ff d0                	call   *%rax
                    op += copySize;
  804211dc7a:	4b 8d 3c 2f          	lea    (%r15,%r13,1),%rdi
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
  804211dc7e:	48 89 f8             	mov    %rdi,%rax
  804211dc81:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  804211dc85:	48 29 c8             	sub    %rcx,%rax
  804211dc88:	4c 39 f0             	cmp    %r14,%rax
  804211dc8b:	73 2a                	jae    804211dcb7 <LZ4_decompress_safe_forceExtDict+0x71e>
                        while (op < endOfMatch) *op++ = *copyFrom++;
  804211dc8d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211dc91:	48 39 c7             	cmp    %rax,%rdi
  804211dc94:	0f 83 e4 fd ff ff    	jae    804211da7e <LZ4_decompress_safe_forceExtDict+0x4e5>
  804211dc9a:	4d 89 f4             	mov    %r14,%r12
  804211dc9d:	b8 00 00 00 00       	mov    $0x0,%eax
  804211dca2:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  804211dca6:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  804211dca9:	48 83 c0 01          	add    $0x1,%rax
  804211dcad:	49 39 c4             	cmp    %rax,%r12
  804211dcb0:	75 f0                	jne    804211dca2 <LZ4_decompress_safe_forceExtDict+0x709>
  804211dcb2:	e9 9e fc ff ff       	jmp    804211d955 <LZ4_decompress_safe_forceExtDict+0x3bc>
                        memcpy(op, lowPrefix, restSize);
  804211dcb7:	4c 89 f2             	mov    %r14,%rdx
  804211dcba:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804211dcbe:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211dcc5:	00 00 00 
  804211dcc8:	ff d0                	call   *%rax
                        op += restSize;
  804211dcca:	e9 86 fc ff ff       	jmp    804211d955 <LZ4_decompress_safe_forceExtDict+0x3bc>
            cpy = op + length;
  804211dccf:	4b 8d 04 27          	lea    (%r15,%r12,1),%rax
  804211dcd3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            if (unlikely(offset<8)) {
  804211dcd7:	49 83 fd 07          	cmp    $0x7,%r13
  804211dcdb:	76 72                	jbe    804211dd4f <LZ4_decompress_safe_forceExtDict+0x7b6>
                memcpy(op, match, 8);
  804211dcdd:	ba 08 00 00 00       	mov    $0x8,%edx
  804211dce2:	4c 89 f6             	mov    %r14,%rsi
  804211dce5:	4c 89 ff             	mov    %r15,%rdi
  804211dce8:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211dcef:	00 00 00 
  804211dcf2:	ff d0                	call   *%rax
                match += 8;
  804211dcf4:	49 83 c6 08          	add    $0x8,%r14
            op += 8;
  804211dcf8:	4d 8d 6f 08          	lea    0x8(%r15),%r13
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  804211dcfc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211dd00:	48 83 e8 0c          	sub    $0xc,%rax
  804211dd04:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211dd08:	48 39 d0             	cmp    %rdx,%rax
  804211dd0b:	0f 82 a6 00 00 00    	jb     804211ddb7 <LZ4_decompress_safe_forceExtDict+0x81e>
                memcpy(op, match, 8);
  804211dd11:	ba 08 00 00 00       	mov    $0x8,%edx
  804211dd16:	4c 89 f6             	mov    %r14,%rsi
  804211dd19:	4c 89 ef             	mov    %r13,%rdi
  804211dd1c:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211dd23:	00 00 00 
  804211dd26:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211dd28:	49 83 fc 10          	cmp    $0x10,%r12
  804211dd2c:	0f 86 23 fc ff ff    	jbe    804211d955 <LZ4_decompress_safe_forceExtDict+0x3bc>
  804211dd32:	49 8d 76 08          	lea    0x8(%r14),%rsi
  804211dd36:	49 8d 7f 10          	lea    0x10(%r15),%rdi
  804211dd3a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211dd3e:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211dd45:	00 00 00 
  804211dd48:	ff d0                	call   *%rax
  804211dd4a:	e9 06 fc ff ff       	jmp    804211d955 <LZ4_decompress_safe_forceExtDict+0x3bc>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211dd4f:	41 c7 07 00 00 00 00 	movl   $0x0,(%r15)
                op[0] = match[0];
  804211dd56:	41 0f b6 06          	movzbl (%r14),%eax
  804211dd5a:	41 88 07             	mov    %al,(%r15)
                op[1] = match[1];
  804211dd5d:	41 0f b6 46 01       	movzbl 0x1(%r14),%eax
  804211dd62:	41 88 47 01          	mov    %al,0x1(%r15)
                op[2] = match[2];
  804211dd66:	41 0f b6 46 02       	movzbl 0x2(%r14),%eax
  804211dd6b:	41 88 47 02          	mov    %al,0x2(%r15)
                op[3] = match[3];
  804211dd6f:	41 0f b6 46 03       	movzbl 0x3(%r14),%eax
  804211dd74:	41 88 47 03          	mov    %al,0x3(%r15)
                match += inc32table[offset];
  804211dd78:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  804211dd7f:	00 00 00 
  804211dd82:	42 8b 04 a8          	mov    (%rax,%r13,4),%eax
  804211dd86:	49 01 c6             	add    %rax,%r14
                memcpy(op+4, match, 4);
  804211dd89:	49 8d 7f 04          	lea    0x4(%r15),%rdi
  804211dd8d:	ba 04 00 00 00       	mov    $0x4,%edx
  804211dd92:	4c 89 f6             	mov    %r14,%rsi
  804211dd95:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211dd9c:	00 00 00 
  804211dd9f:	ff d0                	call   *%rax
                match -= dec64table[offset];
  804211dda1:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  804211dda8:	00 00 00 
  804211ddab:	4a 63 04 a8          	movslq (%rax,%r13,4),%rax
  804211ddaf:	49 29 c6             	sub    %rax,%r14
  804211ddb2:	e9 41 ff ff ff       	jmp    804211dcf8 <LZ4_decompress_safe_forceExtDict+0x75f>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
  804211ddb7:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804211ddbb:	48 8d 42 fb          	lea    -0x5(%rdx),%rax
  804211ddbf:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211ddc3:	48 39 f0             	cmp    %rsi,%rax
  804211ddc6:	72 5f                	jb     804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
  804211ddc8:	4c 8d 62 f9          	lea    -0x7(%rdx),%r12
                if (op < oCopyLimit) {
  804211ddcc:	4d 39 e5             	cmp    %r12,%r13
  804211ddcf:	72 30                	jb     804211de01 <LZ4_decompress_safe_forceExtDict+0x868>
                while (op < cpy) { *op++ = *match++; }
  804211ddd1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211ddd5:	48 89 d1             	mov    %rdx,%rcx
  804211ddd8:	4c 29 e9             	sub    %r13,%rcx
  804211dddb:	b8 00 00 00 00       	mov    $0x0,%eax
  804211dde0:	49 39 d5             	cmp    %rdx,%r13
  804211dde3:	0f 83 6c fb ff ff    	jae    804211d955 <LZ4_decompress_safe_forceExtDict+0x3bc>
  804211dde9:	41 0f b6 14 06       	movzbl (%r14,%rax,1),%edx
  804211ddee:	41 88 54 05 00       	mov    %dl,0x0(%r13,%rax,1)
  804211ddf3:	48 83 c0 01          	add    $0x1,%rax
  804211ddf7:	48 39 c1             	cmp    %rax,%rcx
  804211ddfa:	75 ed                	jne    804211dde9 <LZ4_decompress_safe_forceExtDict+0x850>
  804211ddfc:	e9 54 fb ff ff       	jmp    804211d955 <LZ4_decompress_safe_forceExtDict+0x3bc>
                    LZ4_wildCopy8(op, match, oCopyLimit);
  804211de01:	4c 89 e2             	mov    %r12,%rdx
  804211de04:	4c 89 f6             	mov    %r14,%rsi
  804211de07:	4c 89 ef             	mov    %r13,%rdi
  804211de0a:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211de11:	00 00 00 
  804211de14:	ff d0                	call   *%rax
                    match += oCopyLimit - op;
  804211de16:	4c 89 e0             	mov    %r12,%rax
  804211de19:	4c 29 e8             	sub    %r13,%rax
  804211de1c:	49 01 c6             	add    %rax,%r14
                    op = oCopyLimit;
  804211de1f:	4d 89 e5             	mov    %r12,%r13
  804211de22:	eb ad                	jmp    804211ddd1 <LZ4_decompress_safe_forceExtDict+0x838>
            token = *ip++;
  804211de24:	4c 89 eb             	mov    %r13,%rbx
        return (int) (-(((const char*)ip)-src))-1;
  804211de27:	48 89 d8             	mov    %rbx,%rax
  804211de2a:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  804211de2e:	48 29 c8             	sub    %rcx,%rax
  804211de31:	f7 d0                	not    %eax
}
  804211de33:	48 83 c4 58          	add    $0x58,%rsp
  804211de37:	5b                   	pop    %rbx
  804211de38:	41 5c                	pop    %r12
  804211de3a:	41 5d                	pop    %r13
  804211de3c:	41 5e                	pop    %r14
  804211de3e:	41 5f                	pop    %r15
  804211de40:	5d                   	pop    %rbp
  804211de41:	c3                   	ret
  804211de42:	4c 89 eb             	mov    %r13,%rbx
  804211de45:	eb e0                	jmp    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
  804211de47:	4c 89 eb             	mov    %r13,%rbx
  804211de4a:	eb db                	jmp    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
            token = *ip++;
  804211de4c:	4c 89 e3             	mov    %r12,%rbx
  804211de4f:	eb d6                	jmp    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
  804211de51:	4c 89 e3             	mov    %r12,%rbx
  804211de54:	eb d1                	jmp    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
  804211de56:	4c 89 e3             	mov    %r12,%rbx
  804211de59:	eb cc                	jmp    804211de27 <LZ4_decompress_safe_forceExtDict+0x88e>
    if (src == NULL) { return -1; }
  804211de5b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211de60:	eb d1                	jmp    804211de33 <LZ4_decompress_safe_forceExtDict+0x89a>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211de62:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
  804211de67:	eb ca                	jmp    804211de33 <LZ4_decompress_safe_forceExtDict+0x89a>

000000804211de69 <LZ4_setStreamDecode>:
 *  This function is not necessary if previous data is still available where it was decoded.
 *  Loading a size of 0 is allowed (same effect as no dictionary).
 * @return : 1 if OK, 0 if error
 */
int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dictionary, int dictSize)
{
  804211de69:	f3 0f 1e fa          	endbr64
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    lz4sd->prefixSize = (size_t) dictSize;
  804211de6d:	48 63 d2             	movslq %edx,%rdx
  804211de70:	48 89 57 18          	mov    %rdx,0x18(%rdi)
    lz4sd->prefixEnd = (const BYTE*) dictionary + dictSize;
  804211de74:	48 01 d6             	add    %rdx,%rsi
  804211de77:	48 89 77 10          	mov    %rsi,0x10(%rdi)
    lz4sd->externalDict = NULL;
  804211de7b:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
    lz4sd->extDictSize  = 0;
  804211de82:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  804211de89:	00 
    return 1;
}
  804211de8a:	b8 01 00 00 00       	mov    $0x1,%eax
  804211de8f:	c3                   	ret

000000804211de90 <LZ4_decoderRingBufferSize>:
 *  decoding resumes from beginning of ring buffer.
 * @return : minimum ring buffer size,
 *           or 0 if there is an error (invalid maxBlockSize).
 */
int LZ4_decoderRingBufferSize(int maxBlockSize)
{
  804211de90:	f3 0f 1e fa          	endbr64
    if (maxBlockSize < 0) return 0;
    if (maxBlockSize > LZ4_MAX_INPUT_SIZE) return 0;
    if (maxBlockSize < 16) maxBlockSize = 16;
    return LZ4_DECODER_RING_BUFFER_SIZE(maxBlockSize);
  804211de94:	b8 10 00 00 00       	mov    $0x10,%eax
  804211de99:	39 c7                	cmp    %eax,%edi
  804211de9b:	0f 4d c7             	cmovge %edi,%eax
  804211de9e:	05 0e 00 01 00       	add    $0x1000e,%eax
  804211dea3:	81 ff 01 00 00 7e    	cmp    $0x7e000001,%edi
  804211dea9:	ba 00 00 00 00       	mov    $0x0,%edx
  804211deae:	0f 43 c2             	cmovae %edx,%eax
}
  804211deb1:	c3                   	ret

000000804211deb2 <LZ4_decompress_safe_continue>:
    If it's not possible, save the relevant part of decoded data into a safe buffer,
    and indicate where it stands using LZ4_setStreamDecode()
*/
LZ4_FORCE_O2_GCC_PPC64LE
int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int compressedSize, int maxOutputSize)
{
  804211deb2:	f3 0f 1e fa          	endbr64
  804211deb6:	55                   	push   %rbp
  804211deb7:	48 89 e5             	mov    %rsp,%rbp
  804211deba:	41 57                	push   %r15
  804211debc:	41 56                	push   %r14
  804211debe:	41 55                	push   %r13
  804211dec0:	41 54                	push   %r12
  804211dec2:	53                   	push   %rbx
  804211dec3:	48 83 ec 68          	sub    $0x68,%rsp
  804211dec7:	49 89 fc             	mov    %rdi,%r12
  804211deca:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  804211dece:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  804211ded2:	89 ca                	mov    %ecx,%edx
  804211ded4:	44 89 c1             	mov    %r8d,%ecx
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    int result;

    if (lz4sd->prefixSize == 0) {
  804211ded7:	4c 8b 4f 18          	mov    0x18(%rdi),%r9
  804211dedb:	4d 85 c9             	test   %r9,%r9
  804211dede:	74 51                	je     804211df31 <LZ4_decompress_safe_continue+0x7f>
        assert(lz4sd->extDictSize == 0);
        result = LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)result;
        lz4sd->prefixEnd = (BYTE*)dest + result;
    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
  804211dee0:	4c 8b 47 10          	mov    0x10(%rdi),%r8
  804211dee4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211dee8:	49 39 c0             	cmp    %rax,%r8
  804211deeb:	74 71                	je     804211df5e <LZ4_decompress_safe_continue+0xac>
        if (result <= 0) return result;
        lz4sd->prefixSize += (size_t)result;
        lz4sd->prefixEnd  += result;
    } else {
        /* The buffer wraps around, or they're switching to another buffer. */
        lz4sd->extDictSize = lz4sd->prefixSize;
  804211deed:	4c 89 4f 08          	mov    %r9,0x8(%rdi)
        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
  804211def1:	4d 29 c8             	sub    %r9,%r8
  804211def4:	4c 89 07             	mov    %r8,(%rdi)
        result = LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize,
  804211def7:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804211defb:	48 89 de             	mov    %rbx,%rsi
  804211defe:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211df02:	48 b8 99 d5 11 42 80 	movabs $0x804211d599,%rax
  804211df09:	00 00 00 
  804211df0c:	ff d0                	call   *%rax
                                                  lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
  804211df0e:	85 c0                	test   %eax,%eax
  804211df10:	7e 10                	jle    804211df22 <LZ4_decompress_safe_continue+0x70>
        lz4sd->prefixSize = (size_t)result;
  804211df12:	48 63 d0             	movslq %eax,%rdx
  804211df15:	49 89 54 24 18       	mov    %rdx,0x18(%r12)
        lz4sd->prefixEnd  = (BYTE*)dest + result;
  804211df1a:	48 01 d3             	add    %rdx,%rbx
  804211df1d:	49 89 5c 24 10       	mov    %rbx,0x10(%r12)
    }

    return result;
}
  804211df22:	48 83 c4 68          	add    $0x68,%rsp
  804211df26:	5b                   	pop    %rbx
  804211df27:	41 5c                	pop    %r12
  804211df29:	41 5d                	pop    %r13
  804211df2b:	41 5e                	pop    %r14
  804211df2d:	41 5f                	pop    %r15
  804211df2f:	5d                   	pop    %rbp
  804211df30:	c3                   	ret
        result = LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
  804211df31:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
  804211df35:	48 89 de             	mov    %rbx,%rsi
  804211df38:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211df3c:	48 b8 82 ba 11 42 80 	movabs $0x804211ba82,%rax
  804211df43:	00 00 00 
  804211df46:	ff d0                	call   *%rax
        if (result <= 0) return result;
  804211df48:	85 c0                	test   %eax,%eax
  804211df4a:	7e d6                	jle    804211df22 <LZ4_decompress_safe_continue+0x70>
        lz4sd->prefixSize = (size_t)result;
  804211df4c:	48 63 d0             	movslq %eax,%rdx
  804211df4f:	49 89 54 24 18       	mov    %rdx,0x18(%r12)
        lz4sd->prefixEnd = (BYTE*)dest + result;
  804211df54:	48 01 d3             	add    %rdx,%rbx
  804211df57:	49 89 5c 24 10       	mov    %rbx,0x10(%r12)
  804211df5c:	eb c4                	jmp    804211df22 <LZ4_decompress_safe_continue+0x70>
        if (lz4sd->prefixSize >= 64 KB - 1)
  804211df5e:	49 81 f9 fe ff 00 00 	cmp    $0xfffe,%r9
  804211df65:	0f 87 96 00 00 00    	ja     804211e001 <LZ4_decompress_safe_continue+0x14f>
        else if (lz4sd->extDictSize == 0)
  804211df6b:	48 8b 47 08          	mov    0x8(%rdi),%rax
  804211df6f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  804211df73:	48 85 c0             	test   %rax,%rax
  804211df76:	0f 84 b2 00 00 00    	je     804211e02e <LZ4_decompress_safe_continue+0x17c>
                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
  804211df7c:	48 8b 3f             	mov    (%rdi),%rdi
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
  804211df7f:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211df83:	48 89 f0             	mov    %rsi,%rax
  804211df86:	4c 29 c8             	sub    %r9,%rax
  804211df89:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    if (src == NULL) { return -1; }
  804211df8d:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
  804211df91:	48 85 db             	test   %rbx,%rbx
  804211df94:	0f 84 aa 09 00 00    	je     804211e944 <LZ4_decompress_safe_continue+0xa92>
        const BYTE* const iend = ip + srcSize;
  804211df9a:	48 63 c2             	movslq %edx,%rax
  804211df9d:	48 01 d8             	add    %rbx,%rax
  804211dfa0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        BYTE* const oend = op + outputSize;
  804211dfa4:	48 63 c1             	movslq %ecx,%rax
  804211dfa7:	48 01 c6             	add    %rax,%rsi
  804211dfaa:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
        const BYTE* const dictEnd = (dictStart == NULL) ? NULL : dictStart + dictSize;
  804211dfae:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211dfb2:	48 01 f8             	add    %rdi,%rax
  804211dfb5:	48 85 ff             	test   %rdi,%rdi
  804211dfb8:	48 0f 44 c7          	cmove  %rdi,%rax
  804211dfbc:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  804211dfc0:	48 8d 46 e0          	lea    -0x20(%rsi),%rax
  804211dfc4:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        if ((endOnInput) && (unlikely(outputSize==0))) {
  804211dfc8:	85 c9                	test   %ecx,%ecx
  804211dfca:	74 7b                	je     804211e047 <LZ4_decompress_safe_continue+0x195>
        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
  804211dfcc:	85 d2                	test   %edx,%edx
  804211dfce:	0f 84 7a 09 00 00    	je     804211e94e <LZ4_decompress_safe_continue+0xa9c>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  804211dfd4:	83 f9 3f             	cmp    $0x3f,%ecx
  804211dfd7:	0f 8e 98 03 00 00    	jle    804211e375 <LZ4_decompress_safe_continue+0x4c3>
    {   const BYTE* ip = (const BYTE*) src;
  804211dfdd:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211dfe1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211dfe5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211dfe9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211dfed:	48 83 e8 11          	sub    $0x11,%rax
  804211dff1:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  804211dff5:	4c 89 a5 78 ff ff ff 	mov    %r12,-0x88(%rbp)
  804211dffc:	e9 4a 02 00 00       	jmp    804211e24b <LZ4_decompress_safe_continue+0x399>
            result = LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);
  804211e001:	48 89 c6             	mov    %rax,%rsi
  804211e004:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211e008:	48 b8 5b ce 11 42 80 	movabs $0x804211ce5b,%rax
  804211e00f:	00 00 00 
  804211e012:	ff d0                	call   *%rax
        if (result <= 0) return result;
  804211e014:	85 c0                	test   %eax,%eax
  804211e016:	0f 8e 06 ff ff ff    	jle    804211df22 <LZ4_decompress_safe_continue+0x70>
        lz4sd->prefixSize += (size_t)result;
  804211e01c:	48 63 d0             	movslq %eax,%rdx
  804211e01f:	49 01 54 24 18       	add    %rdx,0x18(%r12)
        lz4sd->prefixEnd  += result;
  804211e024:	49 01 54 24 10       	add    %rdx,0x10(%r12)
  804211e029:	e9 f4 fe ff ff       	jmp    804211df22 <LZ4_decompress_safe_continue+0x70>
            result = LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize,
  804211e02e:	4d 89 c8             	mov    %r9,%r8
  804211e031:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  804211e035:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211e039:	48 b8 54 1a 11 42 80 	movabs $0x8042111a54,%rax
  804211e040:	00 00 00 
  804211e043:	ff d0                	call   *%rax
  804211e045:	eb cd                	jmp    804211e014 <LZ4_decompress_safe_continue+0x162>
            result = LZ4_decompress_safe_doubleDict(source, dest, compressedSize, maxOutputSize,
  804211e047:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
  804211e04c:	83 fa 01             	cmp    $0x1,%edx
  804211e04f:	0f 85 cd fe ff ff    	jne    804211df22 <LZ4_decompress_safe_continue+0x70>
  804211e055:	0f b6 03             	movzbl (%rbx),%eax
  804211e058:	f6 d8                	neg    %al
  804211e05a:	19 c0                	sbb    %eax,%eax
  804211e05c:	e9 c1 fe ff ff       	jmp    804211df22 <LZ4_decompress_safe_continue+0x70>
                    op += copySize;
  804211e061:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  804211e065:	e9 e1 01 00 00       	jmp    804211e24b <LZ4_decompress_safe_continue+0x399>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211e06a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211e06e:	48 8d 50 f1          	lea    -0xf(%rax),%rdx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211e072:	49 39 d6             	cmp    %rdx,%r14
  804211e075:	0f 83 5a 08 00 00    	jae    804211e8d5 <LZ4_decompress_safe_continue+0xa23>
  804211e07b:	41 bf 00 00 00 00    	mov    $0x0,%r15d
        s = **ip;
  804211e081:	41 0f b6 06          	movzbl (%r14),%eax
        (*ip)++;
  804211e085:	49 83 c6 01          	add    $0x1,%r14
        length += s;
  804211e089:	41 01 c7             	add    %eax,%r15d
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211e08c:	4c 39 f2             	cmp    %r14,%rdx
  804211e08f:	74 07                	je     804211e098 <LZ4_decompress_safe_continue+0x1e6>
    } while (s==255);
  804211e091:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211e096:	74 e9                	je     804211e081 <LZ4_decompress_safe_continue+0x1cf>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211e098:	45 89 ff             	mov    %r15d,%r15d
  804211e09b:	49 83 c7 0f          	add    $0xf,%r15
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211e09f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804211e0a3:	48 89 f8             	mov    %rdi,%rax
  804211e0a6:	4c 01 f8             	add    %r15,%rax
  804211e0a9:	0f 82 32 08 00 00    	jb     804211e8e1 <LZ4_decompress_safe_continue+0xa2f>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211e0af:	4c 89 f0             	mov    %r14,%rax
  804211e0b2:	4c 01 f8             	add    %r15,%rax
  804211e0b5:	0f 82 32 08 00 00    	jb     804211e8ed <LZ4_decompress_safe_continue+0xa3b>
                cpy = op+length;
  804211e0bb:	4e 8d 24 3f          	lea    (%rdi,%r15,1),%r12
                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
  804211e0bf:	4c 39 65 88          	cmp    %r12,-0x78(%rbp)
  804211e0c3:	0f 82 4e 05 00 00    	jb     804211e617 <LZ4_decompress_safe_continue+0x765>
  804211e0c9:	4b 8d 1c 3e          	lea    (%r14,%r15,1),%rbx
  804211e0cd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211e0d1:	48 83 e8 20          	sub    $0x20,%rax
  804211e0d5:	48 39 d8             	cmp    %rbx,%rax
  804211e0d8:	0f 82 52 05 00 00    	jb     804211e630 <LZ4_decompress_safe_continue+0x77e>
                    LZ4_wildCopy32(op, ip, cpy);
  804211e0de:	4c 89 e2             	mov    %r12,%rdx
  804211e0e1:	4c 89 f6             	mov    %r14,%rsi
  804211e0e4:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211e0eb:	00 00 00 
  804211e0ee:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211e0f0:	e9 9d 01 00 00       	jmp    804211e292 <LZ4_decompress_safe_continue+0x3e0>
                if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211e0f5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211e0f9:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
  804211e0ff:	77 10                	ja     804211e111 <LZ4_decompress_safe_continue+0x25f>
  804211e101:	4c 01 f8             	add    %r15,%rax
  804211e104:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211e108:	48 39 f8             	cmp    %rdi,%rax
  804211e10b:	0f 82 f7 07 00 00    	jb     804211e908 <LZ4_decompress_safe_continue+0xa56>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211e111:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211e115:	48 8d 50 fc          	lea    -0x4(%rax),%rdx
  804211e119:	41 bd 00 00 00 00    	mov    $0x0,%r13d
        s = **ip;
  804211e11f:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211e122:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211e126:	41 01 c5             	add    %eax,%r13d
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211e129:	48 39 d3             	cmp    %rdx,%rbx
  804211e12c:	0f 83 df 07 00 00    	jae    804211e911 <LZ4_decompress_safe_continue+0xa5f>
    } while (s==255);
  804211e132:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211e137:	74 e6                	je     804211e11f <LZ4_decompress_safe_continue+0x26d>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211e139:	45 89 ed             	mov    %r13d,%r13d
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
  804211e13c:	4b 8d 44 2c 0f       	lea    0xf(%r12,%r13,1),%rax
  804211e141:	4c 39 e0             	cmp    %r12,%rax
  804211e144:	0f 82 df 07 00 00    	jb     804211e929 <LZ4_decompress_safe_continue+0xa77>
                length += MINMATCH;
  804211e14a:	49 83 c5 13          	add    $0x13,%r13
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211e14e:	4b 8d 14 2c          	lea    (%r12,%r13,1),%rdx
  804211e152:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211e156:	48 83 e8 40          	sub    $0x40,%rax
  804211e15a:	48 39 c2             	cmp    %rax,%rdx
  804211e15d:	0f 82 89 01 00 00    	jb     804211e2ec <LZ4_decompress_safe_continue+0x43a>
  804211e163:	4c 89 65 90          	mov    %r12,-0x70(%rbp)
  804211e167:	49 89 ce             	mov    %rcx,%r14
  804211e16a:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e171:	e9 d2 02 00 00       	jmp    804211e448 <LZ4_decompress_safe_continue+0x596>
                        memcpy(op, match, 8);
  804211e176:	ba 08 00 00 00       	mov    $0x8,%edx
  804211e17b:	4c 89 fe             	mov    %r15,%rsi
  804211e17e:	4c 89 e7             	mov    %r12,%rdi
  804211e181:	49 bd 62 0d 11 42 80 	movabs $0x8042110d62,%r13
  804211e188:	00 00 00 
  804211e18b:	41 ff d5             	call   *%r13
                        memcpy(op+8, match+8, 8);
  804211e18e:	49 8d 77 08          	lea    0x8(%r15),%rsi
  804211e192:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
  804211e197:	ba 08 00 00 00       	mov    $0x8,%edx
  804211e19c:	41 ff d5             	call   *%r13
                        memcpy(op+16, match+16, 2);
  804211e19f:	49 8d 77 10          	lea    0x10(%r15),%rsi
  804211e1a3:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
  804211e1a8:	ba 02 00 00 00       	mov    $0x2,%edx
  804211e1ad:	41 ff d5             	call   *%r13
                        continue;
  804211e1b0:	e9 96 00 00 00       	jmp    804211e24b <LZ4_decompress_safe_continue+0x399>
                    size_t const restSize = length - copySize;
  804211e1b5:	4d 89 ef             	mov    %r13,%r15
  804211e1b8:	49 29 f7             	sub    %rsi,%r15
                    memcpy(op, dictEnd - copySize, copySize);
  804211e1bb:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  804211e1bf:	4c 29 f6             	sub    %r14,%rsi
  804211e1c2:	4c 89 f2             	mov    %r14,%rdx
  804211e1c5:	4c 89 e7             	mov    %r12,%rdi
  804211e1c8:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e1cf:	00 00 00 
  804211e1d2:	ff d0                	call   *%rax
                    op += copySize;
  804211e1d4:	4b 8d 3c 34          	lea    (%r12,%r14,1),%rdi
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
  804211e1d8:	48 89 f8             	mov    %rdi,%rax
  804211e1db:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  804211e1df:	48 29 c8             	sub    %rcx,%rax
  804211e1e2:	4c 39 f8             	cmp    %r15,%rax
  804211e1e5:	72 15                	jb     804211e1fc <LZ4_decompress_safe_continue+0x34a>
                        memcpy(op, lowPrefix, restSize);
  804211e1e7:	4c 89 fa             	mov    %r15,%rdx
  804211e1ea:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211e1ee:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e1f5:	00 00 00 
  804211e1f8:	ff d0                	call   *%rax
                        op += restSize;
  804211e1fa:	eb 4f                	jmp    804211e24b <LZ4_decompress_safe_continue+0x399>
                        while (op < endOfMatch) { *op++ = *copyFrom++; }
  804211e1fc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211e200:	48 39 c7             	cmp    %rax,%rdi
  804211e203:	0f 83 58 fe ff ff    	jae    804211e061 <LZ4_decompress_safe_continue+0x1af>
  804211e209:	4d 89 fd             	mov    %r15,%r13
  804211e20c:	b8 00 00 00 00       	mov    $0x0,%eax
  804211e211:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  804211e215:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  804211e218:	48 83 c0 01          	add    $0x1,%rax
  804211e21c:	49 39 c5             	cmp    %rax,%r13
  804211e21f:	75 f0                	jne    804211e211 <LZ4_decompress_safe_continue+0x35f>
  804211e221:	eb 28                	jmp    804211e24b <LZ4_decompress_safe_continue+0x399>
            cpy = op + length;
  804211e223:	4b 8d 04 2c          	lea    (%r12,%r13,1),%rax
  804211e227:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            if (unlikely(offset<16)) {
  804211e22b:	48 83 f9 0f          	cmp    $0xf,%rcx
  804211e22f:	0f 86 26 01 00 00    	jbe    804211e35b <LZ4_decompress_safe_continue+0x4a9>
                LZ4_wildCopy32(op, match, cpy);
  804211e235:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804211e239:	4c 89 fe             	mov    %r15,%rsi
  804211e23c:	4c 89 e7             	mov    %r12,%rdi
  804211e23f:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211e246:	00 00 00 
  804211e249:	ff d0                	call   *%rax
            token = *ip++;
  804211e24b:	4c 8d 73 01          	lea    0x1(%rbx),%r14
  804211e24f:	44 0f b6 2b          	movzbl (%rbx),%r13d
  804211e253:	41 0f b6 cd          	movzbl %r13b,%ecx
            length = token >> ML_BITS;  /* literal length */
  804211e257:	89 c8                	mov    %ecx,%eax
  804211e259:	c1 e8 04             	shr    $0x4,%eax
  804211e25c:	41 89 c7             	mov    %eax,%r15d
            if (length == RUN_MASK) {
  804211e25f:	83 f8 0f             	cmp    $0xf,%eax
  804211e262:	0f 84 02 fe ff ff    	je     804211e06a <LZ4_decompress_safe_continue+0x1b8>
                cpy = op+length;
  804211e268:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804211e26c:	4e 8d 24 3f          	lea    (%rdi,%r15,1),%r12
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
  804211e270:	4c 39 75 90          	cmp    %r14,-0x70(%rbp)
  804211e274:	0f 82 cf 03 00 00    	jb     804211e649 <LZ4_decompress_safe_continue+0x797>
                    memcpy(op, ip, 16);
  804211e27a:	ba 10 00 00 00       	mov    $0x10,%edx
  804211e27f:	4c 89 f6             	mov    %r14,%rsi
  804211e282:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e289:	00 00 00 
  804211e28c:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211e28e:	4b 8d 1c 3e          	lea    (%r14,%r15,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211e292:	48 89 df             	mov    %rbx,%rdi
  804211e295:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211e29c:	00 00 00 
  804211e29f:	ff d0                	call   *%rax
  804211e2a1:	0f b7 c8             	movzwl %ax,%ecx
  804211e2a4:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211e2a8:	4d 89 e7             	mov    %r12,%r15
  804211e2ab:	49 29 cf             	sub    %rcx,%r15
            length = token & ML_MASK;
  804211e2ae:	41 83 e5 0f          	and    $0xf,%r13d
            if (length == ML_MASK) {
  804211e2b2:	49 83 fd 0f          	cmp    $0xf,%r13
  804211e2b6:	0f 84 39 fe ff ff    	je     804211e0f5 <LZ4_decompress_safe_continue+0x243>
                length += MINMATCH;
  804211e2bc:	49 83 c5 04          	add    $0x4,%r13
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211e2c0:	4b 8d 34 2c          	lea    (%r12,%r13,1),%rsi
  804211e2c4:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
  804211e2c8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211e2cc:	48 83 e8 40          	sub    $0x40,%rax
  804211e2d0:	48 39 c6             	cmp    %rax,%rsi
  804211e2d3:	0f 83 0b 04 00 00    	jae    804211e6e4 <LZ4_decompress_safe_continue+0x832>
                    if (offset >= 8) {
  804211e2d9:	48 83 f9 07          	cmp    $0x7,%rcx
  804211e2dd:	76 0d                	jbe    804211e2ec <LZ4_decompress_safe_continue+0x43a>
  804211e2df:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211e2e3:	49 39 c7             	cmp    %rax,%r15
  804211e2e6:	0f 83 8a fe ff ff    	jae    804211e176 <LZ4_decompress_safe_continue+0x2c4>
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
  804211e2ec:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211e2f0:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
  804211e2f6:	77 10                	ja     804211e308 <LZ4_decompress_safe_continue+0x456>
  804211e2f8:	4c 01 f8             	add    %r15,%rax
  804211e2fb:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211e2ff:	48 39 f0             	cmp    %rsi,%rax
  804211e302:	0f 82 2a 06 00 00    	jb     804211e932 <LZ4_decompress_safe_continue+0xa80>
            if ((dict==usingExtDict) && (match < lowPrefix)) {
  804211e308:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211e30c:	49 39 f7             	cmp    %rsi,%r15
  804211e30f:	0f 83 0e ff ff ff    	jae    804211e223 <LZ4_decompress_safe_continue+0x371>
                if (unlikely(op+length > oend-LASTLITERALS)) {
  804211e315:	4b 8d 0c 2c          	lea    (%r12,%r13,1),%rcx
  804211e319:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  804211e31d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211e321:	48 83 e8 05          	sub    $0x5,%rax
  804211e325:	48 39 c8             	cmp    %rcx,%rax
  804211e328:	0f 82 0d 06 00 00    	jb     804211e93b <LZ4_decompress_safe_continue+0xa89>
                if (length <= (size_t)(lowPrefix-match)) {
  804211e32e:	4c 29 fe             	sub    %r15,%rsi
  804211e331:	49 89 f6             	mov    %rsi,%r14
  804211e334:	4c 39 ee             	cmp    %r13,%rsi
  804211e337:	0f 82 78 fe ff ff    	jb     804211e1b5 <LZ4_decompress_safe_continue+0x303>
                    memmove(op, dictEnd - (lowPrefix-match), length);
  804211e33d:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  804211e341:	4c 29 f6             	sub    %r14,%rsi
  804211e344:	4c 89 ea             	mov    %r13,%rdx
  804211e347:	4c 89 e7             	mov    %r12,%rdi
  804211e34a:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211e351:	00 00 00 
  804211e354:	ff d0                	call   *%rax
                    op += length;
  804211e356:	e9 f0 fe ff ff       	jmp    804211e24b <LZ4_decompress_safe_continue+0x399>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  804211e35b:	48 89 c2             	mov    %rax,%rdx
  804211e35e:	4c 89 fe             	mov    %r15,%rsi
  804211e361:	4c 89 e7             	mov    %r12,%rdi
  804211e364:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  804211e36b:	00 00 00 
  804211e36e:	ff d0                	call   *%rax
  804211e370:	e9 d6 fe ff ff       	jmp    804211e24b <LZ4_decompress_safe_continue+0x399>
    {   const BYTE* ip = (const BYTE*) src;
  804211e375:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
        BYTE* op = (BYTE*) dst;
  804211e379:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211e37d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            token = *ip++;
  804211e381:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
  804211e385:	0f b6 1b             	movzbl (%rbx),%ebx
  804211e388:	0f b6 c3             	movzbl %bl,%eax
  804211e38b:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
            length = token >> ML_BITS;  /* literal length */
  804211e391:	c1 e8 04             	shr    $0x4,%eax
  804211e394:	41 89 c7             	mov    %eax,%r15d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211e397:	83 f8 0f             	cmp    $0xf,%eax
  804211e39a:	0f 84 a7 01 00 00    	je     804211e547 <LZ4_decompress_safe_continue+0x695>
        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
  804211e3a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211e3a4:	48 83 e8 10          	sub    $0x10,%rax
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211e3a8:	49 39 c5             	cmp    %rax,%r13
  804211e3ab:	0f 83 e2 01 00 00    	jae    804211e593 <LZ4_decompress_safe_continue+0x6e1>
  804211e3b1:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804211e3b5:	48 39 4d 88          	cmp    %rcx,-0x78(%rbp)
  804211e3b9:	0f 82 d4 01 00 00    	jb     804211e593 <LZ4_decompress_safe_continue+0x6e1>
  804211e3bf:	48 89 45 90          	mov    %rax,-0x70(%rbp)
                memcpy(op, ip, endOnInput ? 16 : 8);
  804211e3c3:	ba 10 00 00 00       	mov    $0x10,%edx
  804211e3c8:	4c 89 ee             	mov    %r13,%rsi
  804211e3cb:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
  804211e3cf:	4c 89 f7             	mov    %r14,%rdi
  804211e3d2:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e3d9:	00 00 00 
  804211e3dc:	ff d0                	call   *%rax
                op += length; ip += length;
  804211e3de:	4d 01 fe             	add    %r15,%r14
  804211e3e1:	4b 8d 7c 3d 00       	lea    0x0(%r13,%r15,1),%rdi
  804211e3e6:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
                length = token & ML_MASK; /* match length */
  804211e3ed:	49 89 dd             	mov    %rbx,%r13
  804211e3f0:	41 83 e5 0f          	and    $0xf,%r13d
                offset = LZ4_readLE16(ip); ip += 2;
  804211e3f4:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211e3fb:	00 00 00 
  804211e3fe:	ff d0                	call   *%rax
  804211e400:	0f b7 c0             	movzwl %ax,%eax
                match = op - offset;
  804211e403:	4d 89 f7             	mov    %r14,%r15
  804211e406:	49 29 c7             	sub    %rax,%r15
                if ( (length != ML_MASK)
  804211e409:	49 83 fd 0f          	cmp    $0xf,%r13
  804211e40d:	0f 95 c1             	setne  %cl
                     && (offset >= 8)
  804211e410:	48 83 f8 07          	cmp    $0x7,%rax
  804211e414:	0f 97 c2             	seta   %dl
                     && (dict==withPrefix64k || match >= lowPrefix) ) {
  804211e417:	84 d1                	test   %dl,%cl
  804211e419:	74 0d                	je     804211e428 <LZ4_decompress_safe_continue+0x576>
  804211e41b:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211e41f:	49 39 ff             	cmp    %rdi,%r15
  804211e422:	0f 83 99 00 00 00    	jae    804211e4c1 <LZ4_decompress_safe_continue+0x60f>
                offset = LZ4_readLE16(ip); ip += 2;
  804211e428:	4c 89 75 90          	mov    %r14,-0x70(%rbp)
  804211e42c:	49 89 c6             	mov    %rax,%r14
  804211e42f:	48 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%rbx
  804211e436:	48 83 c3 02          	add    $0x2,%rbx
            if (length == ML_MASK) {
  804211e43a:	49 83 fd 0f          	cmp    $0xf,%r13
  804211e43e:	0f 84 62 02 00 00    	je     804211e6a6 <LZ4_decompress_safe_continue+0x7f4>
            length += MINMATCH;
  804211e444:	49 83 c5 04          	add    $0x4,%r13
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
  804211e448:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211e44c:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
  804211e452:	77 10                	ja     804211e464 <LZ4_decompress_safe_continue+0x5b2>
  804211e454:	4c 01 f8             	add    %r15,%rax
  804211e457:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211e45b:	48 39 f8             	cmp    %rdi,%rax
  804211e45e:	0f 82 b4 04 00 00    	jb     804211e918 <LZ4_decompress_safe_continue+0xa66>
            if ((dict==usingExtDict) && (match < lowPrefix)) {
  804211e464:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211e468:	49 39 f7             	cmp    %rsi,%r15
  804211e46b:	0f 83 fe 02 00 00    	jae    804211e76f <LZ4_decompress_safe_continue+0x8bd>
                if (unlikely(op+length > oend-LASTLITERALS)) {
  804211e471:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  804211e475:	4a 8d 0c 2f          	lea    (%rdi,%r13,1),%rcx
  804211e479:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  804211e47d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211e481:	48 83 e8 05          	sub    $0x5,%rax
  804211e485:	48 39 c8             	cmp    %rcx,%rax
  804211e488:	0f 82 8a 04 00 00    	jb     804211e918 <LZ4_decompress_safe_continue+0xa66>
                if (length <= (size_t)(lowPrefix-match)) {
  804211e48e:	4c 29 fe             	sub    %r15,%rsi
  804211e491:	49 89 f6             	mov    %rsi,%r14
  804211e494:	4c 39 ee             	cmp    %r13,%rsi
  804211e497:	0f 82 5a 02 00 00    	jb     804211e6f7 <LZ4_decompress_safe_continue+0x845>
                    memmove(op, dictEnd - (lowPrefix-match), length);
  804211e49d:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  804211e4a1:	4c 29 f6             	sub    %r14,%rsi
  804211e4a4:	4c 89 ea             	mov    %r13,%rdx
  804211e4a7:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211e4ae:	00 00 00 
  804211e4b1:	ff d0                	call   *%rax
                    op += length;
  804211e4b3:	e9 c9 fe ff ff       	jmp    804211e381 <LZ4_decompress_safe_continue+0x4cf>
                    op += copySize;
  804211e4b8:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  804211e4bc:	e9 c0 fe ff ff       	jmp    804211e381 <LZ4_decompress_safe_continue+0x4cf>
                    memcpy(op + 0, match + 0, 8);
  804211e4c1:	ba 08 00 00 00       	mov    $0x8,%edx
  804211e4c6:	4c 89 fe             	mov    %r15,%rsi
  804211e4c9:	4c 89 f7             	mov    %r14,%rdi
  804211e4cc:	48 bb 62 0d 11 42 80 	movabs $0x8042110d62,%rbx
  804211e4d3:	00 00 00 
  804211e4d6:	ff d3                	call   *%rbx
                    memcpy(op + 8, match + 8, 8);
  804211e4d8:	49 8d 77 08          	lea    0x8(%r15),%rsi
  804211e4dc:	49 8d 7e 08          	lea    0x8(%r14),%rdi
  804211e4e0:	ba 08 00 00 00       	mov    $0x8,%edx
  804211e4e5:	ff d3                	call   *%rbx
                    memcpy(op +16, match +16, 2);
  804211e4e7:	49 8d 77 10          	lea    0x10(%r15),%rsi
  804211e4eb:	49 8d 7e 10          	lea    0x10(%r14),%rdi
  804211e4ef:	ba 02 00 00 00       	mov    $0x2,%edx
  804211e4f4:	ff d3                	call   *%rbx
                    op += length + MINMATCH;
  804211e4f6:	4b 8d 44 2e 04       	lea    0x4(%r14,%r13,1),%rax
  804211e4fb:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            token = *ip++;
  804211e4ff:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  804211e506:	4c 8d 68 03          	lea    0x3(%rax),%r13
  804211e50a:	0f b6 58 02          	movzbl 0x2(%rax),%ebx
  804211e50e:	0f b6 d3             	movzbl %bl,%edx
            length = token >> ML_BITS;  /* literal length */
  804211e511:	89 d0                	mov    %edx,%eax
  804211e513:	c1 e8 04             	shr    $0x4,%eax
  804211e516:	41 89 c7             	mov    %eax,%r15d
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
  804211e519:	83 f8 0f             	cmp    $0xf,%eax
  804211e51c:	74 23                	je     804211e541 <LZ4_decompress_safe_continue+0x68f>
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211e51e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211e522:	49 39 c5             	cmp    %rax,%r13
  804211e525:	0f 83 e1 00 00 00    	jae    804211e60c <LZ4_decompress_safe_continue+0x75a>
  804211e52b:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804211e52f:	48 39 7d 88          	cmp    %rdi,-0x78(%rbp)
  804211e533:	0f 83 8a fe ff ff    	jae    804211e3c3 <LZ4_decompress_safe_continue+0x511>
  804211e539:	89 95 74 ff ff ff    	mov    %edx,-0x8c(%rbp)
  804211e53f:	eb 52                	jmp    804211e593 <LZ4_decompress_safe_continue+0x6e1>
  804211e541:	89 95 74 ff ff ff    	mov    %edx,-0x8c(%rbp)
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211e547:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211e54b:	48 8d 48 f1          	lea    -0xf(%rax),%rcx
    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211e54f:	49 39 cd             	cmp    %rcx,%r13
  804211e552:	0f 83 a1 03 00 00    	jae    804211e8f9 <LZ4_decompress_safe_continue+0xa47>
  804211e558:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211e55d:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
        (*ip)++;
  804211e562:	49 83 c5 01          	add    $0x1,%r13
        length += s;
  804211e566:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211e568:	4c 39 e9             	cmp    %r13,%rcx
  804211e56b:	74 07                	je     804211e574 <LZ4_decompress_safe_continue+0x6c2>
    } while (s==255);
  804211e56d:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211e572:	74 e9                	je     804211e55d <LZ4_decompress_safe_continue+0x6ab>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211e574:	89 d2                	mov    %edx,%edx
  804211e576:	4c 8d 7a 0f          	lea    0xf(%rdx),%r15
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
  804211e57a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211e57e:	4c 01 f8             	add    %r15,%rax
  804211e581:	0f 82 77 03 00 00    	jb     804211e8fe <LZ4_decompress_safe_continue+0xa4c>
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
  804211e587:	4c 89 e8             	mov    %r13,%rax
  804211e58a:	4c 01 f8             	add    %r15,%rax
  804211e58d:	0f 82 70 03 00 00    	jb     804211e903 <LZ4_decompress_safe_continue+0xa51>
            cpy = op+length;
  804211e593:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211e597:	4c 01 f8             	add    %r15,%rax
  804211e59a:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  804211e59e:	4c 89 eb             	mov    %r13,%rbx
            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
  804211e5a1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211e5a5:	48 83 e8 0c          	sub    $0xc,%rax
  804211e5a9:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  804211e5ad:	48 39 c8             	cmp    %rcx,%rax
  804211e5b0:	72 15                	jb     804211e5c7 <LZ4_decompress_safe_continue+0x715>
  804211e5b2:	4e 8d 2c 3b          	lea    (%rbx,%r15,1),%r13
  804211e5b6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211e5ba:	48 83 e8 08          	sub    $0x8,%rax
  804211e5be:	4c 39 e8             	cmp    %r13,%rax
  804211e5c1:	0f 83 9b 00 00 00    	jae    804211e662 <LZ4_decompress_safe_continue+0x7b0>
                    if ((endOnInput) && ((ip+length != iend) || (cpy > oend))) { goto _output_error; }
  804211e5c7:	4a 8d 04 3b          	lea    (%rbx,%r15,1),%rax
  804211e5cb:	48 39 45 98          	cmp    %rax,-0x68(%rbp)
  804211e5cf:	0f 85 43 03 00 00    	jne    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e5d5:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  804211e5d9:	48 39 4d a0          	cmp    %rcx,-0x60(%rbp)
  804211e5dd:	0f 82 35 03 00 00    	jb     804211e918 <LZ4_decompress_safe_continue+0xa66>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  804211e5e3:	4c 89 fa             	mov    %r15,%rdx
  804211e5e6:	48 89 de             	mov    %rbx,%rsi
  804211e5e9:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
  804211e5ed:	48 89 df             	mov    %rbx,%rdi
  804211e5f0:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211e5f7:	00 00 00 
  804211e5fa:	ff d0                	call   *%rax
                op += length;
  804211e5fc:	48 89 d8             	mov    %rbx,%rax
  804211e5ff:	4c 01 f8             	add    %r15,%rax
            return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
  804211e602:	8b 5d c8             	mov    -0x38(%rbp),%ebx
  804211e605:	29 d8                	sub    %ebx,%eax
  804211e607:	e9 08 fa ff ff       	jmp    804211e014 <LZ4_decompress_safe_continue+0x162>
  804211e60c:	89 95 74 ff ff ff    	mov    %edx,-0x8c(%rbp)
  804211e612:	e9 7c ff ff ff       	jmp    804211e593 <LZ4_decompress_safe_continue+0x6e1>
  804211e617:	4c 89 65 90          	mov    %r12,-0x70(%rbp)
  804211e61b:	89 8d 74 ff ff ff    	mov    %ecx,-0x8c(%rbp)
  804211e621:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e628:	4c 89 f3             	mov    %r14,%rbx
  804211e62b:	e9 71 ff ff ff       	jmp    804211e5a1 <LZ4_decompress_safe_continue+0x6ef>
  804211e630:	4c 89 65 90          	mov    %r12,-0x70(%rbp)
  804211e634:	89 8d 74 ff ff ff    	mov    %ecx,-0x8c(%rbp)
  804211e63a:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e641:	4c 89 f3             	mov    %r14,%rbx
  804211e644:	e9 58 ff ff ff       	jmp    804211e5a1 <LZ4_decompress_safe_continue+0x6ef>
            token = *ip++;
  804211e649:	4c 89 65 90          	mov    %r12,-0x70(%rbp)
  804211e64d:	89 8d 74 ff ff ff    	mov    %ecx,-0x8c(%rbp)
  804211e653:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e65a:	4c 89 f3             	mov    %r14,%rbx
  804211e65d:	e9 3f ff ff ff       	jmp    804211e5a1 <LZ4_decompress_safe_continue+0x6ef>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  804211e662:	4c 8b 7d 90          	mov    -0x70(%rbp),%r15
  804211e666:	4c 89 fa             	mov    %r15,%rdx
  804211e669:	48 89 de             	mov    %rbx,%rsi
  804211e66c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804211e670:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211e677:	00 00 00 
  804211e67a:	ff d0                	call   *%rax
            offset = LZ4_readLE16(ip); ip+=2;
  804211e67c:	4c 89 ef             	mov    %r13,%rdi
  804211e67f:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211e686:	00 00 00 
  804211e689:	ff d0                	call   *%rax
  804211e68b:	44 0f b7 f0          	movzwl %ax,%r14d
  804211e68f:	49 8d 5d 02          	lea    0x2(%r13),%rbx
            match = op - offset;
  804211e693:	4d 29 f7             	sub    %r14,%r15
            length = token & ML_MASK;
  804211e696:	44 8b ad 74 ff ff ff 	mov    -0x8c(%rbp),%r13d
  804211e69d:	41 83 e5 0f          	and    $0xf,%r13d
  804211e6a1:	e9 94 fd ff ff       	jmp    804211e43a <LZ4_decompress_safe_continue+0x588>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211e6a6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  804211e6aa:	48 8d 48 fc          	lea    -0x4(%rax),%rcx
  804211e6ae:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211e6b3:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211e6b6:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211e6ba:	01 c2                	add    %eax,%edx
        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
  804211e6bc:	48 39 cb             	cmp    %rcx,%rbx
  804211e6bf:	0f 83 53 02 00 00    	jae    804211e918 <LZ4_decompress_safe_continue+0xa66>
    } while (s==255);
  804211e6c5:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211e6ca:	74 e7                	je     804211e6b3 <LZ4_decompress_safe_continue+0x801>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211e6cc:	89 d2                	mov    %edx,%edx
  804211e6ce:	4c 8d 6a 0f          	lea    0xf(%rdx),%r13
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
  804211e6d2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211e6d6:	4c 01 e8             	add    %r13,%rax
  804211e6d9:	0f 83 65 fd ff ff    	jae    804211e444 <LZ4_decompress_safe_continue+0x592>
  804211e6df:	e9 34 02 00 00       	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e6e4:	4c 89 65 90          	mov    %r12,-0x70(%rbp)
  804211e6e8:	49 89 ce             	mov    %rcx,%r14
  804211e6eb:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e6f2:	e9 51 fd ff ff       	jmp    804211e448 <LZ4_decompress_safe_continue+0x596>
                    size_t const restSize = length - copySize;
  804211e6f7:	4d 89 ef             	mov    %r13,%r15
  804211e6fa:	49 29 f7             	sub    %rsi,%r15
                    memcpy(op, dictEnd - copySize, copySize);
  804211e6fd:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  804211e701:	4c 29 f6             	sub    %r14,%rsi
  804211e704:	4c 89 f2             	mov    %r14,%rdx
  804211e707:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  804211e70b:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e712:	00 00 00 
  804211e715:	ff d0                	call   *%rax
                    op += copySize;
  804211e717:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  804211e71b:	4c 01 f7             	add    %r14,%rdi
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
  804211e71e:	48 89 f8             	mov    %rdi,%rax
  804211e721:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211e725:	48 29 f0             	sub    %rsi,%rax
  804211e728:	4c 39 f8             	cmp    %r15,%rax
  804211e72b:	73 2a                	jae    804211e757 <LZ4_decompress_safe_continue+0x8a5>
                        while (op < endOfMatch) *op++ = *copyFrom++;
  804211e72d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  804211e731:	48 39 c7             	cmp    %rax,%rdi
  804211e734:	0f 83 7e fd ff ff    	jae    804211e4b8 <LZ4_decompress_safe_continue+0x606>
  804211e73a:	4c 89 fa             	mov    %r15,%rdx
  804211e73d:	b8 00 00 00 00       	mov    $0x0,%eax
  804211e742:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
  804211e746:	88 0c 07             	mov    %cl,(%rdi,%rax,1)
  804211e749:	48 83 c0 01          	add    $0x1,%rax
  804211e74d:	48 39 d0             	cmp    %rdx,%rax
  804211e750:	75 f0                	jne    804211e742 <LZ4_decompress_safe_continue+0x890>
  804211e752:	e9 2a fc ff ff       	jmp    804211e381 <LZ4_decompress_safe_continue+0x4cf>
                        memcpy(op, lowPrefix, restSize);
  804211e757:	4c 89 fa             	mov    %r15,%rdx
  804211e75a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  804211e75e:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e765:	00 00 00 
  804211e768:	ff d0                	call   *%rax
                        op += restSize;
  804211e76a:	e9 12 fc ff ff       	jmp    804211e381 <LZ4_decompress_safe_continue+0x4cf>
            cpy = op + length;
  804211e76f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211e773:	4c 01 e8             	add    %r13,%rax
  804211e776:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            if (unlikely(offset<8)) {
  804211e77a:	49 83 fe 07          	cmp    $0x7,%r14
  804211e77e:	76 7b                	jbe    804211e7fb <LZ4_decompress_safe_continue+0x949>
                memcpy(op, match, 8);
  804211e780:	ba 08 00 00 00       	mov    $0x8,%edx
  804211e785:	4c 89 fe             	mov    %r15,%rsi
  804211e788:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  804211e78c:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e793:	00 00 00 
  804211e796:	ff d0                	call   *%rax
                match += 8;
  804211e798:	4d 8d 77 08          	lea    0x8(%r15),%r14
            op += 8;
  804211e79c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211e7a0:	4c 8d 78 08          	lea    0x8(%rax),%r15
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  804211e7a4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211e7a8:	48 83 e8 0c          	sub    $0xc,%rax
  804211e7ac:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804211e7b0:	48 39 f8             	cmp    %rdi,%rax
  804211e7b3:	0f 82 ac 00 00 00    	jb     804211e865 <LZ4_decompress_safe_continue+0x9b3>
                memcpy(op, match, 8);
  804211e7b9:	ba 08 00 00 00       	mov    $0x8,%edx
  804211e7be:	4c 89 f6             	mov    %r14,%rsi
  804211e7c1:	4c 89 ff             	mov    %r15,%rdi
  804211e7c4:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e7cb:	00 00 00 
  804211e7ce:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211e7d0:	49 83 fd 10          	cmp    $0x10,%r13
  804211e7d4:	0f 86 a7 fb ff ff    	jbe    804211e381 <LZ4_decompress_safe_continue+0x4cf>
  804211e7da:	49 8d 76 08          	lea    0x8(%r14),%rsi
  804211e7de:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  804211e7e2:	48 83 c7 10          	add    $0x10,%rdi
  804211e7e6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  804211e7ea:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211e7f1:	00 00 00 
  804211e7f4:	ff d0                	call   *%rax
  804211e7f6:	e9 86 fb ff ff       	jmp    804211e381 <LZ4_decompress_safe_continue+0x4cf>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211e7fb:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  804211e7ff:	c7 01 00 00 00 00    	movl   $0x0,(%rcx)
                op[0] = match[0];
  804211e805:	41 0f b6 07          	movzbl (%r15),%eax
  804211e809:	88 01                	mov    %al,(%rcx)
                op[1] = match[1];
  804211e80b:	41 0f b6 47 01       	movzbl 0x1(%r15),%eax
  804211e810:	88 41 01             	mov    %al,0x1(%rcx)
                op[2] = match[2];
  804211e813:	41 0f b6 47 02       	movzbl 0x2(%r15),%eax
  804211e818:	88 41 02             	mov    %al,0x2(%rcx)
                op[3] = match[3];
  804211e81b:	41 0f b6 47 03       	movzbl 0x3(%r15),%eax
  804211e820:	88 41 03             	mov    %al,0x3(%rcx)
                match += inc32table[offset];
  804211e823:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  804211e82a:	00 00 00 
  804211e82d:	42 8b 04 b0          	mov    (%rax,%r14,4),%eax
  804211e831:	49 01 c7             	add    %rax,%r15
                memcpy(op+4, match, 4);
  804211e834:	48 8d 79 04          	lea    0x4(%rcx),%rdi
  804211e838:	ba 04 00 00 00       	mov    $0x4,%edx
  804211e83d:	4c 89 fe             	mov    %r15,%rsi
  804211e840:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211e847:	00 00 00 
  804211e84a:	ff d0                	call   *%rax
                match -= dec64table[offset];
  804211e84c:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  804211e853:	00 00 00 
  804211e856:	4a 63 04 b0          	movslq (%rax,%r14,4),%rax
  804211e85a:	4d 89 fe             	mov    %r15,%r14
  804211e85d:	49 29 c6             	sub    %rax,%r14
  804211e860:	e9 37 ff ff ff       	jmp    804211e79c <LZ4_decompress_safe_continue+0x8ea>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
  804211e865:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  804211e869:	48 8d 47 fb          	lea    -0x5(%rdi),%rax
  804211e86d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  804211e871:	48 39 c8             	cmp    %rcx,%rax
  804211e874:	0f 82 9e 00 00 00    	jb     804211e918 <LZ4_decompress_safe_continue+0xa66>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
  804211e87a:	4c 8d 6f f9          	lea    -0x7(%rdi),%r13
                if (op < oCopyLimit) {
  804211e87e:	4d 39 ef             	cmp    %r13,%r15
  804211e881:	72 2f                	jb     804211e8b2 <LZ4_decompress_safe_continue+0xa00>
                while (op < cpy) { *op++ = *match++; }
  804211e883:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  804211e887:	48 89 f9             	mov    %rdi,%rcx
  804211e88a:	4c 29 f9             	sub    %r15,%rcx
  804211e88d:	b8 00 00 00 00       	mov    $0x0,%eax
  804211e892:	49 39 ff             	cmp    %rdi,%r15
  804211e895:	0f 83 e6 fa ff ff    	jae    804211e381 <LZ4_decompress_safe_continue+0x4cf>
  804211e89b:	41 0f b6 14 06       	movzbl (%r14,%rax,1),%edx
  804211e8a0:	41 88 14 07          	mov    %dl,(%r15,%rax,1)
  804211e8a4:	48 83 c0 01          	add    $0x1,%rax
  804211e8a8:	48 39 c8             	cmp    %rcx,%rax
  804211e8ab:	75 ee                	jne    804211e89b <LZ4_decompress_safe_continue+0x9e9>
  804211e8ad:	e9 cf fa ff ff       	jmp    804211e381 <LZ4_decompress_safe_continue+0x4cf>
                    LZ4_wildCopy8(op, match, oCopyLimit);
  804211e8b2:	4c 89 ea             	mov    %r13,%rdx
  804211e8b5:	4c 89 f6             	mov    %r14,%rsi
  804211e8b8:	4c 89 ff             	mov    %r15,%rdi
  804211e8bb:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211e8c2:	00 00 00 
  804211e8c5:	ff d0                	call   *%rax
                    match += oCopyLimit - op;
  804211e8c7:	4c 89 e8             	mov    %r13,%rax
  804211e8ca:	4c 29 f8             	sub    %r15,%rax
  804211e8cd:	49 01 c6             	add    %rax,%r14
                    op = oCopyLimit;
  804211e8d0:	4d 89 ef             	mov    %r13,%r15
  804211e8d3:	eb ae                	jmp    804211e883 <LZ4_decompress_safe_continue+0x9d1>
            token = *ip++;
  804211e8d5:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e8dc:	4c 89 f3             	mov    %r14,%rbx
  804211e8df:	eb 37                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e8e1:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e8e8:	4c 89 f3             	mov    %r14,%rbx
  804211e8eb:	eb 2b                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e8ed:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e8f4:	4c 89 f3             	mov    %r14,%rbx
  804211e8f7:	eb 1f                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
            token = *ip++;
  804211e8f9:	4c 89 eb             	mov    %r13,%rbx
  804211e8fc:	eb 1a                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e8fe:	4c 89 eb             	mov    %r13,%rbx
  804211e901:	eb 15                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e903:	4c 89 eb             	mov    %r13,%rbx
  804211e906:	eb 10                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e908:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e90f:	eb 07                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e911:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
        return (int) (-(((const char*)ip)-src))-1;
  804211e918:	48 89 d8             	mov    %rbx,%rax
  804211e91b:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  804211e91f:	48 29 f8             	sub    %rdi,%rax
  804211e922:	f7 d0                	not    %eax
  804211e924:	e9 eb f6 ff ff       	jmp    804211e014 <LZ4_decompress_safe_continue+0x162>
  804211e929:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e930:	eb e6                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e932:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e939:	eb dd                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
  804211e93b:	4c 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12
  804211e942:	eb d4                	jmp    804211e918 <LZ4_decompress_safe_continue+0xa66>
            result = LZ4_decompress_safe_doubleDict(source, dest, compressedSize, maxOutputSize,
  804211e944:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211e949:	e9 d4 f5 ff ff       	jmp    804211df22 <LZ4_decompress_safe_continue+0x70>
  804211e94e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211e953:	e9 ca f5 ff ff       	jmp    804211df22 <LZ4_decompress_safe_continue+0x70>

000000804211e958 <LZ4_decompress_fast_continue>:

LZ4_FORCE_O2_GCC_PPC64LE
int LZ4_decompress_fast_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int originalSize)
{
  804211e958:	f3 0f 1e fa          	endbr64
  804211e95c:	55                   	push   %rbp
  804211e95d:	48 89 e5             	mov    %rsp,%rbp
  804211e960:	41 57                	push   %r15
  804211e962:	41 56                	push   %r14
  804211e964:	41 55                	push   %r13
  804211e966:	41 54                	push   %r12
  804211e968:	53                   	push   %rbx
  804211e969:	48 83 ec 48          	sub    $0x48,%rsp
  804211e96d:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  804211e971:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  804211e975:	49 89 d7             	mov    %rdx,%r15
  804211e978:	89 4d bc             	mov    %ecx,-0x44(%rbp)
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    int result;
    assert(originalSize >= 0);

    if (lz4sd->prefixSize == 0) {
  804211e97b:	4c 8b 47 18          	mov    0x18(%rdi),%r8
  804211e97f:	4d 85 c0             	test   %r8,%r8
  804211e982:	74 56                	je     804211e9da <LZ4_decompress_fast_continue+0x82>
        assert(lz4sd->extDictSize == 0);
        result = LZ4_decompress_fast(source, dest, originalSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)originalSize;
        lz4sd->prefixEnd = (BYTE*)dest + originalSize;
    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
  804211e984:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804211e988:	48 8b 48 10          	mov    0x10(%rax),%rcx
  804211e98c:	48 39 d1             	cmp    %rdx,%rcx
  804211e98f:	74 78                	je     804211ea09 <LZ4_decompress_fast_continue+0xb1>
                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize += (size_t)originalSize;
        lz4sd->prefixEnd  += originalSize;
    } else {
        lz4sd->extDictSize = lz4sd->prefixSize;
  804211e991:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
  804211e995:	4c 89 43 08          	mov    %r8,0x8(%rbx)
        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
  804211e999:	4c 29 c1             	sub    %r8,%rcx
  804211e99c:	48 89 0b             	mov    %rcx,(%rbx)
        result = LZ4_decompress_fast_extDict(source, dest, originalSize,
  804211e99f:	44 8b 75 bc          	mov    -0x44(%rbp),%r14d
  804211e9a3:	44 89 f2             	mov    %r14d,%edx
  804211e9a6:	4c 89 fe             	mov    %r15,%rsi
  804211e9a9:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211e9ad:	48 b8 69 21 11 42 80 	movabs $0x8042112169,%rax
  804211e9b4:	00 00 00 
  804211e9b7:	ff d0                	call   *%rax
                                             lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
  804211e9b9:	85 c0                	test   %eax,%eax
  804211e9bb:	7e 0e                	jle    804211e9cb <LZ4_decompress_fast_continue+0x73>
        lz4sd->prefixSize = (size_t)originalSize;
  804211e9bd:	49 63 d6             	movslq %r14d,%rdx
  804211e9c0:	48 89 53 18          	mov    %rdx,0x18(%rbx)
        lz4sd->prefixEnd  = (BYTE*)dest + originalSize;
  804211e9c4:	49 01 d7             	add    %rdx,%r15
  804211e9c7:	4c 89 7b 10          	mov    %r15,0x10(%rbx)
    }

    return result;
}
  804211e9cb:	48 83 c4 48          	add    $0x48,%rsp
  804211e9cf:	5b                   	pop    %rbx
  804211e9d0:	41 5c                	pop    %r12
  804211e9d2:	41 5d                	pop    %r13
  804211e9d4:	41 5e                	pop    %r14
  804211e9d6:	41 5f                	pop    %r15
  804211e9d8:	5d                   	pop    %rbp
  804211e9d9:	c3                   	ret
        result = LZ4_decompress_fast(source, dest, originalSize);
  804211e9da:	89 cb                	mov    %ecx,%ebx
  804211e9dc:	89 ca                	mov    %ecx,%edx
  804211e9de:	4c 89 fe             	mov    %r15,%rsi
  804211e9e1:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211e9e5:	48 b8 bf c8 11 42 80 	movabs $0x804211c8bf,%rax
  804211e9ec:	00 00 00 
  804211e9ef:	ff d0                	call   *%rax
        if (result <= 0) return result;
  804211e9f1:	85 c0                	test   %eax,%eax
  804211e9f3:	7e d6                	jle    804211e9cb <LZ4_decompress_fast_continue+0x73>
        lz4sd->prefixSize = (size_t)originalSize;
  804211e9f5:	48 63 d3             	movslq %ebx,%rdx
  804211e9f8:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  804211e9fc:	48 89 56 18          	mov    %rdx,0x18(%rsi)
        lz4sd->prefixEnd = (BYTE*)dest + originalSize;
  804211ea00:	4c 01 fa             	add    %r15,%rdx
  804211ea03:	48 89 56 10          	mov    %rdx,0x10(%rsi)
  804211ea07:	eb c2                	jmp    804211e9cb <LZ4_decompress_fast_continue+0x73>
        if (lz4sd->prefixSize >= 64 KB - 1 || lz4sd->extDictSize == 0)
  804211ea09:	49 81 f8 fe ff 00 00 	cmp    $0xfffe,%r8
  804211ea10:	77 09                	ja     804211ea1b <LZ4_decompress_fast_continue+0xc3>
  804211ea12:	48 8b 40 08          	mov    0x8(%rax),%rax
  804211ea16:	48 85 c0             	test   %rax,%rax
  804211ea19:	75 2c                	jne    804211ea47 <LZ4_decompress_fast_continue+0xef>
            result = LZ4_decompress_fast(source, dest, originalSize);
  804211ea1b:	8b 55 bc             	mov    -0x44(%rbp),%edx
  804211ea1e:	4c 89 fe             	mov    %r15,%rsi
  804211ea21:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  804211ea25:	48 b8 bf c8 11 42 80 	movabs $0x804211c8bf,%rax
  804211ea2c:	00 00 00 
  804211ea2f:	ff d0                	call   *%rax
        if (result <= 0) return result;
  804211ea31:	85 c0                	test   %eax,%eax
  804211ea33:	7e 96                	jle    804211e9cb <LZ4_decompress_fast_continue+0x73>
        lz4sd->prefixSize += (size_t)originalSize;
  804211ea35:	48 63 55 bc          	movslq -0x44(%rbp),%rdx
  804211ea39:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  804211ea3d:	48 01 51 18          	add    %rdx,0x18(%rcx)
        lz4sd->prefixEnd  += originalSize;
  804211ea41:	48 01 51 10          	add    %rdx,0x10(%rcx)
  804211ea45:	eb 84                	jmp    804211e9cb <LZ4_decompress_fast_continue+0x73>
                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
  804211ea47:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  804211ea4b:	48 8b 32             	mov    (%rdx),%rsi
    return LZ4_decompress_generic(source, dest, 0, originalSize,
  804211ea4e:	4c 89 fa             	mov    %r15,%rdx
  804211ea51:	4c 29 c2             	sub    %r8,%rdx
  804211ea54:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    if (src == NULL) { return -1; }
  804211ea58:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  804211ea5d:	0f 84 36 07 00 00    	je     804211f199 <LZ4_decompress_fast_continue+0x841>
        BYTE* const oend = op + outputSize;
  804211ea63:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  804211ea66:	48 63 d1             	movslq %ecx,%rdx
  804211ea69:	4c 01 fa             	add    %r15,%rdx
  804211ea6c:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
        const BYTE* const dictEnd = (dictStart == NULL) ? NULL : dictStart + dictSize;
  804211ea70:	48 01 f0             	add    %rsi,%rax
  804211ea73:	48 85 f6             	test   %rsi,%rsi
  804211ea76:	48 0f 44 c6          	cmove  %rsi,%rax
  804211ea7a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
  804211ea7e:	85 c9                	test   %ecx,%ecx
  804211ea80:	74 13                	je     804211ea95 <LZ4_decompress_fast_continue+0x13d>
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
  804211ea82:	83 7d bc 3f          	cmpl   $0x3f,-0x44(%rbp)
  804211ea86:	0f 8e eb 05 00 00    	jle    804211f077 <LZ4_decompress_fast_continue+0x71f>
    {   const BYTE* ip = (const BYTE*) src;
  804211ea8c:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
  804211ea90:	e9 b7 01 00 00       	jmp    804211ec4c <LZ4_decompress_fast_continue+0x2f4>
        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
  804211ea95:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  804211ea99:	80 38 00             	cmpb   $0x0,(%rax)
  804211ea9c:	0f 84 ed 06 00 00    	je     804211f18f <LZ4_decompress_fast_continue+0x837>
            result = LZ4_decompress_fast_doubleDict(source, dest, originalSize,
  804211eaa2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211eaa7:	e9 1f ff ff ff       	jmp    804211e9cb <LZ4_decompress_fast_continue+0x73>
                    op += copySize;
  804211eaac:	49 89 ff             	mov    %rdi,%r15
  804211eaaf:	e9 98 01 00 00       	jmp    804211ec4c <LZ4_decompress_fast_continue+0x2f4>
  804211eab4:	bb 00 00 00 00       	mov    $0x0,%ebx
        s = **ip;
  804211eab9:	41 0f b6 06          	movzbl (%r14),%eax
        (*ip)++;
  804211eabd:	49 83 c6 01          	add    $0x1,%r14
        length += s;
  804211eac1:	01 c3                	add    %eax,%ebx
    } while (s==255);
  804211eac3:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211eac8:	74 ef                	je     804211eab9 <LZ4_decompress_fast_continue+0x161>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211eaca:	89 db                	mov    %ebx,%ebx
  804211eacc:	48 83 c3 0f          	add    $0xf,%rbx
                cpy = op+length;
  804211ead0:	49 8d 0c 1f          	lea    (%r15,%rbx,1),%rcx
  804211ead4:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
                    if (cpy>oend-8) { goto safe_literal_copy; }
  804211ead8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211eadc:	48 83 e8 08          	sub    $0x8,%rax
  804211eae0:	48 39 c8             	cmp    %rcx,%rax
  804211eae3:	0f 82 5b 03 00 00    	jb     804211ee44 <LZ4_decompress_fast_continue+0x4ec>
                    LZ4_wildCopy8(op, ip, cpy); /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
  804211eae9:	48 89 ca             	mov    %rcx,%rdx
  804211eaec:	4c 89 f6             	mov    %r14,%rsi
  804211eaef:	4c 89 ff             	mov    %r15,%rdi
  804211eaf2:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211eaf9:	00 00 00 
  804211eafc:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211eafe:	4c 01 f3             	add    %r14,%rbx
  804211eb01:	e9 90 01 00 00       	jmp    804211ec96 <LZ4_decompress_fast_continue+0x33e>
                    if (length > 8) { memcpy(op+8, ip+8, 8); }
  804211eb06:	48 8d 73 09          	lea    0x9(%rbx),%rsi
  804211eb0a:	49 8d 7f 08          	lea    0x8(%r15),%rdi
  804211eb0e:	ba 08 00 00 00       	mov    $0x8,%edx
  804211eb13:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211eb1a:	00 00 00 
  804211eb1d:	ff d0                	call   *%rax
  804211eb1f:	e9 6e 01 00 00       	jmp    804211ec92 <LZ4_decompress_fast_continue+0x33a>
  804211eb24:	41 bc 00 00 00 00    	mov    $0x0,%r12d
        s = **ip;
  804211eb2a:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211eb2d:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211eb31:	41 01 c4             	add    %eax,%r12d
    } while (s==255);
  804211eb34:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211eb39:	74 ef                	je     804211eb2a <LZ4_decompress_fast_continue+0x1d2>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211eb3b:	45 89 e4             	mov    %r12d,%r12d
                length += MINMATCH;
  804211eb3e:	49 83 c4 13          	add    $0x13,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211eb42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211eb46:	4a 8d 14 20          	lea    (%rax,%r12,1),%rdx
  804211eb4a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211eb4e:	48 83 e8 40          	sub    $0x40,%rax
  804211eb52:	48 39 c2             	cmp    %rax,%rdx
  804211eb55:	73 4c                	jae    804211eba3 <LZ4_decompress_fast_continue+0x24b>
            if ((dict==usingExtDict) && (match < lowPrefix)) {
  804211eb57:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  804211eb5b:	49 39 f6             	cmp    %rsi,%r14
  804211eb5e:	0f 83 c0 00 00 00    	jae    804211ec24 <LZ4_decompress_fast_continue+0x2cc>
                if (unlikely(op+length > oend-LASTLITERALS)) {
  804211eb64:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211eb68:	4e 8d 3c 27          	lea    (%rdi,%r12,1),%r15
  804211eb6c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211eb70:	48 83 e8 05          	sub    $0x5,%rax
  804211eb74:	4c 39 f8             	cmp    %r15,%rax
  804211eb77:	0f 82 01 06 00 00    	jb     804211f17e <LZ4_decompress_fast_continue+0x826>
                if (length <= (size_t)(lowPrefix-match)) {
  804211eb7d:	4c 29 f6             	sub    %r14,%rsi
  804211eb80:	49 89 f5             	mov    %rsi,%r13
  804211eb83:	4c 39 e6             	cmp    %r12,%rsi
  804211eb86:	72 2e                	jb     804211ebb6 <LZ4_decompress_fast_continue+0x25e>
                    memmove(op, dictEnd - (lowPrefix-match), length);
  804211eb88:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  804211eb8c:	4c 29 ee             	sub    %r13,%rsi
  804211eb8f:	4c 89 e2             	mov    %r12,%rdx
  804211eb92:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211eb99:	00 00 00 
  804211eb9c:	ff d0                	call   *%rax
                    op += length;
  804211eb9e:	e9 a9 00 00 00       	jmp    804211ec4c <LZ4_decompress_fast_continue+0x2f4>
  804211eba3:	4c 89 75 90          	mov    %r14,-0x70(%rbp)
  804211eba7:	49 89 ce             	mov    %rcx,%r14
  804211ebaa:	4d 89 e5             	mov    %r12,%r13
  804211ebad:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  804211ebb1:	e9 6e 05 00 00       	jmp    804211f124 <LZ4_decompress_fast_continue+0x7cc>
                    size_t const restSize = length - copySize;
  804211ebb6:	4d 89 e6             	mov    %r12,%r14
  804211ebb9:	49 29 f6             	sub    %rsi,%r14
                    memcpy(op, dictEnd - copySize, copySize);
  804211ebbc:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  804211ebc0:	4c 29 ee             	sub    %r13,%rsi
  804211ebc3:	4c 89 ea             	mov    %r13,%rdx
  804211ebc6:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211ebca:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211ebd1:	00 00 00 
  804211ebd4:	ff d0                	call   *%rax
                    op += copySize;
  804211ebd6:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211ebda:	4c 01 ef             	add    %r13,%rdi
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
  804211ebdd:	48 89 f8             	mov    %rdi,%rax
  804211ebe0:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  804211ebe4:	48 29 c8             	sub    %rcx,%rax
  804211ebe7:	4c 39 f0             	cmp    %r14,%rax
  804211ebea:	72 15                	jb     804211ec01 <LZ4_decompress_fast_continue+0x2a9>
                        memcpy(op, lowPrefix, restSize);
  804211ebec:	4c 89 f2             	mov    %r14,%rdx
  804211ebef:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  804211ebf3:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211ebfa:	00 00 00 
  804211ebfd:	ff d0                	call   *%rax
                        op += restSize;
  804211ebff:	eb 4b                	jmp    804211ec4c <LZ4_decompress_fast_continue+0x2f4>
                        while (op < endOfMatch) { *op++ = *copyFrom++; }
  804211ec01:	4c 39 ff             	cmp    %r15,%rdi
  804211ec04:	0f 83 a2 fe ff ff    	jae    804211eaac <LZ4_decompress_fast_continue+0x154>
  804211ec0a:	4d 89 f4             	mov    %r14,%r12
  804211ec0d:	b8 00 00 00 00       	mov    $0x0,%eax
  804211ec12:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  804211ec16:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  804211ec19:	48 83 c0 01          	add    $0x1,%rax
  804211ec1d:	4c 39 e0             	cmp    %r12,%rax
  804211ec20:	75 f0                	jne    804211ec12 <LZ4_decompress_fast_continue+0x2ba>
  804211ec22:	eb 28                	jmp    804211ec4c <LZ4_decompress_fast_continue+0x2f4>
            cpy = op + length;
  804211ec24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211ec28:	4e 8d 3c 20          	lea    (%rax,%r12,1),%r15
            if (unlikely(offset<16)) {
  804211ec2c:	48 83 f9 0f          	cmp    $0xf,%rcx
  804211ec30:	0f 86 00 01 00 00    	jbe    804211ed36 <LZ4_decompress_fast_continue+0x3de>
                LZ4_wildCopy32(op, match, cpy);
  804211ec36:	4c 89 fa             	mov    %r15,%rdx
  804211ec39:	4c 89 f6             	mov    %r14,%rsi
  804211ec3c:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  804211ec40:	48 b8 4f 18 11 42 80 	movabs $0x804211184f,%rax
  804211ec47:	00 00 00 
  804211ec4a:	ff d0                	call   *%rax
            token = *ip++;
  804211ec4c:	4c 8d 73 01          	lea    0x1(%rbx),%r14
  804211ec50:	44 0f b6 23          	movzbl (%rbx),%r12d
            length = token >> ML_BITS;  /* literal length */
  804211ec54:	4d 89 e5             	mov    %r12,%r13
  804211ec57:	49 c1 ed 04          	shr    $0x4,%r13
  804211ec5b:	41 83 e5 0f          	and    $0xf,%r13d
            if (length == RUN_MASK) {
  804211ec5f:	49 83 fd 0f          	cmp    $0xf,%r13
  804211ec63:	0f 84 4b fe ff ff    	je     804211eab4 <LZ4_decompress_fast_continue+0x15c>
                cpy = op+length;
  804211ec69:	4b 8d 04 2f          	lea    (%r15,%r13,1),%rax
  804211ec6d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                    memcpy(op, ip, 8);
  804211ec71:	ba 08 00 00 00       	mov    $0x8,%edx
  804211ec76:	4c 89 f6             	mov    %r14,%rsi
  804211ec79:	4c 89 ff             	mov    %r15,%rdi
  804211ec7c:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211ec83:	00 00 00 
  804211ec86:	ff d0                	call   *%rax
                    if (length > 8) { memcpy(op+8, ip+8, 8); }
  804211ec88:	49 83 fd 08          	cmp    $0x8,%r13
  804211ec8c:	0f 87 74 fe ff ff    	ja     804211eb06 <LZ4_decompress_fast_continue+0x1ae>
                ip += length; op = cpy;
  804211ec92:	4b 8d 1c 2e          	lea    (%r14,%r13,1),%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211ec96:	48 89 df             	mov    %rbx,%rdi
  804211ec99:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211eca0:	00 00 00 
  804211eca3:	ff d0                	call   *%rax
  804211eca5:	0f b7 c8             	movzwl %ax,%ecx
  804211eca8:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211ecac:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
  804211ecb0:	49 29 ce             	sub    %rcx,%r14
            length = token & ML_MASK;
  804211ecb3:	41 83 e4 0f          	and    $0xf,%r12d
            if (length == ML_MASK) {
  804211ecb7:	49 83 fc 0f          	cmp    $0xf,%r12
  804211ecbb:	0f 84 63 fe ff ff    	je     804211eb24 <LZ4_decompress_fast_continue+0x1cc>
                length += MINMATCH;
  804211ecc1:	49 83 c4 04          	add    $0x4,%r12
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
  804211ecc5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804211ecc9:	4e 8d 3c 20          	lea    (%rax,%r12,1),%r15
  804211eccd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211ecd1:	48 83 e8 40          	sub    $0x40,%rax
  804211ecd5:	49 39 c7             	cmp    %rax,%r15
  804211ecd8:	0f 83 ba 01 00 00    	jae    804211ee98 <LZ4_decompress_fast_continue+0x540>
                    if (offset >= 8) {
  804211ecde:	48 83 f9 07          	cmp    $0x7,%rcx
  804211ece2:	0f 86 6f fe ff ff    	jbe    804211eb57 <LZ4_decompress_fast_continue+0x1ff>
  804211ece8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  804211ecec:	49 39 c6             	cmp    %rax,%r14
  804211ecef:	0f 82 62 fe ff ff    	jb     804211eb57 <LZ4_decompress_fast_continue+0x1ff>
                        memcpy(op, match, 8);
  804211ecf5:	ba 08 00 00 00       	mov    $0x8,%edx
  804211ecfa:	4c 89 f6             	mov    %r14,%rsi
  804211ecfd:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
  804211ed01:	4c 89 ef             	mov    %r13,%rdi
  804211ed04:	49 bc 62 0d 11 42 80 	movabs $0x8042110d62,%r12
  804211ed0b:	00 00 00 
  804211ed0e:	41 ff d4             	call   *%r12
                        memcpy(op+8, match+8, 8);
  804211ed11:	49 8d 76 08          	lea    0x8(%r14),%rsi
  804211ed15:	49 8d 7d 08          	lea    0x8(%r13),%rdi
  804211ed19:	ba 08 00 00 00       	mov    $0x8,%edx
  804211ed1e:	41 ff d4             	call   *%r12
                        memcpy(op+16, match+16, 2);
  804211ed21:	49 8d 76 10          	lea    0x10(%r14),%rsi
  804211ed25:	49 8d 7d 10          	lea    0x10(%r13),%rdi
  804211ed29:	ba 02 00 00 00       	mov    $0x2,%edx
  804211ed2e:	41 ff d4             	call   *%r12
                        continue;
  804211ed31:	e9 16 ff ff ff       	jmp    804211ec4c <LZ4_decompress_fast_continue+0x2f4>
                LZ4_memcpy_using_offset(op, match, cpy, offset);
  804211ed36:	4c 89 fa             	mov    %r15,%rdx
  804211ed39:	4c 89 f6             	mov    %r14,%rsi
  804211ed3c:	48 89 c7             	mov    %rax,%rdi
  804211ed3f:	48 b8 a6 18 11 42 80 	movabs $0x80421118a6,%rax
  804211ed46:	00 00 00 
  804211ed49:	ff d0                	call   *%rax
  804211ed4b:	e9 fc fe ff ff       	jmp    804211ec4c <LZ4_decompress_fast_continue+0x2f4>
                    memcpy(op + 0, match + 0, 8);
  804211ed50:	ba 08 00 00 00       	mov    $0x8,%edx
  804211ed55:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  804211ed59:	4c 89 e7             	mov    %r12,%rdi
  804211ed5c:	49 be 62 0d 11 42 80 	movabs $0x8042110d62,%r14
  804211ed63:	00 00 00 
  804211ed66:	41 ff d6             	call   *%r14
                    memcpy(op + 8, match + 8, 8);
  804211ed69:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211ed6d:	48 8d 70 08          	lea    0x8(%rax),%rsi
  804211ed71:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
  804211ed76:	ba 08 00 00 00       	mov    $0x8,%edx
  804211ed7b:	41 ff d6             	call   *%r14
                    memcpy(op +16, match +16, 2);
  804211ed7e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  804211ed82:	48 8d 70 10          	lea    0x10(%rax),%rsi
  804211ed86:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
  804211ed8b:	ba 02 00 00 00       	mov    $0x2,%edx
  804211ed90:	41 ff d6             	call   *%r14
                    op += length + MINMATCH;
  804211ed93:	4f 8d 64 2c 04       	lea    0x4(%r12,%r13,1),%r12
            token = *ip++;
  804211ed98:	4c 8d 73 03          	lea    0x3(%rbx),%r14
  804211ed9c:	44 0f b6 6b 02       	movzbl 0x2(%rbx),%r13d
  804211eda1:	41 0f b6 c5          	movzbl %r13b,%eax
            length = token >> ML_BITS;  /* literal length */
  804211eda5:	89 c3                	mov    %eax,%ebx
  804211eda7:	c1 eb 04             	shr    $0x4,%ebx
  804211edaa:	89 db                	mov    %ebx,%ebx
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211edac:	4d 39 e7             	cmp    %r12,%r15
  804211edaf:	72 6d                	jb     804211ee1e <LZ4_decompress_fast_continue+0x4c6>
  804211edb1:	48 83 fb 08          	cmp    $0x8,%rbx
  804211edb5:	0f 86 f7 02 00 00    	jbe    804211f0b2 <LZ4_decompress_fast_continue+0x75a>
  804211edbb:	89 45 c8             	mov    %eax,-0x38(%rbp)
  804211edbe:	4d 89 e7             	mov    %r12,%r15
            if (length == RUN_MASK) {
  804211edc1:	48 83 fb 0f          	cmp    $0xf,%rbx
  804211edc5:	74 5f                	je     804211ee26 <LZ4_decompress_fast_continue+0x4ce>
            cpy = op+length;
  804211edc7:	4d 8d 24 1f          	lea    (%r15,%rbx,1),%r12
                 || ((!endOnInput) && (cpy>oend-WILDCOPYLENGTH)) )
  804211edcb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211edcf:	48 83 e8 08          	sub    $0x8,%rax
  804211edd3:	4c 39 e0             	cmp    %r12,%rax
  804211edd6:	72 70                	jb     804211ee48 <LZ4_decompress_fast_continue+0x4f0>
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
  804211edd8:	4c 89 e2             	mov    %r12,%rdx
  804211eddb:	4c 89 f6             	mov    %r14,%rsi
  804211edde:	4c 89 ff             	mov    %r15,%rdi
  804211ede1:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211ede8:	00 00 00 
  804211edeb:	ff d0                	call   *%rax
                ip += length; op = cpy;
  804211eded:	4c 01 f3             	add    %r14,%rbx
            offset = LZ4_readLE16(ip); ip+=2;
  804211edf0:	48 89 df             	mov    %rbx,%rdi
  804211edf3:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211edfa:	00 00 00 
  804211edfd:	ff d0                	call   *%rax
  804211edff:	44 0f b7 f0          	movzwl %ax,%r14d
  804211ee03:	48 83 c3 02          	add    $0x2,%rbx
            match = op - offset;
  804211ee07:	4c 89 e0             	mov    %r12,%rax
  804211ee0a:	4c 29 f0             	sub    %r14,%rax
  804211ee0d:	48 89 45 90          	mov    %rax,-0x70(%rbp)
            length = token & ML_MASK;
  804211ee11:	44 8b 6d c8          	mov    -0x38(%rbp),%r13d
  804211ee15:	41 83 e5 0f          	and    $0xf,%r13d
  804211ee19:	e9 f8 02 00 00       	jmp    804211f116 <LZ4_decompress_fast_continue+0x7be>
  804211ee1e:	89 45 c8             	mov    %eax,-0x38(%rbp)
  804211ee21:	4d 89 e7             	mov    %r12,%r15
  804211ee24:	eb 9b                	jmp    804211edc1 <LZ4_decompress_fast_continue+0x469>
  804211ee26:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211ee2b:	41 0f b6 06          	movzbl (%r14),%eax
        (*ip)++;
  804211ee2f:	49 83 c6 01          	add    $0x1,%r14
        length += s;
  804211ee33:	01 c2                	add    %eax,%edx
    } while (s==255);
  804211ee35:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211ee3a:	74 ef                	je     804211ee2b <LZ4_decompress_fast_continue+0x4d3>
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
  804211ee3c:	89 d2                	mov    %edx,%edx
  804211ee3e:	48 8d 5a 0f          	lea    0xf(%rdx),%rbx
                if (error == initial_error) { goto _output_error; }
  804211ee42:	eb 83                	jmp    804211edc7 <LZ4_decompress_fast_continue+0x46f>
  804211ee44:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
                    if ((!endOnInput) && (cpy != oend)) { goto _output_error; }
  804211ee48:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211ee4c:	49 39 c4             	cmp    %rax,%r12
  804211ee4f:	0f 85 26 03 00 00    	jne    804211f17b <LZ4_decompress_fast_continue+0x823>
                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
  804211ee55:	48 89 da             	mov    %rbx,%rdx
  804211ee58:	4c 89 f6             	mov    %r14,%rsi
  804211ee5b:	4c 89 ff             	mov    %r15,%rdi
  804211ee5e:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211ee65:	00 00 00 
  804211ee68:	ff d0                	call   *%rax
                ip += length;
  804211ee6a:	49 8d 04 1e          	lea    (%r14,%rbx,1),%rax
            return (int) (((const char*)ip)-src);   /* Nb of input bytes read */
  804211ee6e:	8b 55 b0             	mov    -0x50(%rbp),%edx
  804211ee71:	29 d0                	sub    %edx,%eax
  804211ee73:	e9 b9 fb ff ff       	jmp    804211ea31 <LZ4_decompress_fast_continue+0xd9>
  804211ee78:	ba 00 00 00 00       	mov    $0x0,%edx
        s = **ip;
  804211ee7d:	0f b6 03             	movzbl (%rbx),%eax
        (*ip)++;
  804211ee80:	48 83 c3 01          	add    $0x1,%rbx
        length += s;
  804211ee84:	01 c2                	add    %eax,%edx
    } while (s==255);
  804211ee86:	3d ff 00 00 00       	cmp    $0xff,%eax
  804211ee8b:	74 f0                	je     804211ee7d <LZ4_decompress_fast_continue+0x525>
                length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
  804211ee8d:	89 d2                	mov    %edx,%edx
  804211ee8f:	4c 8d 6a 0f          	lea    0xf(%rdx),%r13
                if (error != ok) goto _output_error;
  804211ee93:	e9 88 02 00 00       	jmp    804211f120 <LZ4_decompress_fast_continue+0x7c8>
  804211ee98:	4c 89 75 90          	mov    %r14,-0x70(%rbp)
  804211ee9c:	49 89 ce             	mov    %rcx,%r14
  804211ee9f:	4d 89 e5             	mov    %r12,%r13
  804211eea2:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
  804211eea6:	e9 79 02 00 00       	jmp    804211f124 <LZ4_decompress_fast_continue+0x7cc>
                    size_t const restSize = length - copySize;
  804211eeab:	4c 89 e8             	mov    %r13,%rax
  804211eeae:	48 29 d0             	sub    %rdx,%rax
  804211eeb1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                    memcpy(op, dictEnd - copySize, copySize);
  804211eeb5:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  804211eeb9:	48 29 d6             	sub    %rdx,%rsi
  804211eebc:	4c 89 e7             	mov    %r12,%rdi
  804211eebf:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211eec6:	00 00 00 
  804211eec9:	ff d0                	call   *%rax
                    op += copySize;
  804211eecb:	4b 8d 3c 34          	lea    (%r12,%r14,1),%rdi
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
  804211eecf:	48 89 f8             	mov    %rdi,%rax
  804211eed2:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  804211eed6:	48 29 c8             	sub    %rcx,%rax
  804211eed9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211eedd:	48 39 d0             	cmp    %rdx,%rax
  804211eee0:	73 26                	jae    804211ef08 <LZ4_decompress_fast_continue+0x5b0>
                        while (op < endOfMatch) *op++ = *copyFrom++;
  804211eee2:	4c 39 ff             	cmp    %r15,%rdi
  804211eee5:	0f 83 88 02 00 00    	jae    804211f173 <LZ4_decompress_fast_continue+0x81b>
  804211eeeb:	4d 29 f5             	sub    %r14,%r13
  804211eeee:	b8 00 00 00 00       	mov    $0x0,%eax
  804211eef3:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
  804211eef7:	88 14 07             	mov    %dl,(%rdi,%rax,1)
  804211eefa:	48 83 c0 01          	add    $0x1,%rax
  804211eefe:	4c 39 e8             	cmp    %r13,%rax
  804211ef01:	75 f0                	jne    804211eef3 <LZ4_decompress_fast_continue+0x59b>
  804211ef03:	e9 73 01 00 00       	jmp    804211f07b <LZ4_decompress_fast_continue+0x723>
                        memcpy(op, lowPrefix, restSize);
  804211ef08:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804211ef0c:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  804211ef10:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211ef17:	00 00 00 
  804211ef1a:	ff d0                	call   *%rax
                        op += restSize;
  804211ef1c:	e9 5a 01 00 00       	jmp    804211f07b <LZ4_decompress_fast_continue+0x723>
            cpy = op + length;
  804211ef21:	4f 8d 3c 2c          	lea    (%r12,%r13,1),%r15
            if (unlikely(offset<8)) {
  804211ef25:	49 83 fe 07          	cmp    $0x7,%r14
  804211ef29:	76 73                	jbe    804211ef9e <LZ4_decompress_fast_continue+0x646>
                memcpy(op, match, 8);
  804211ef2b:	ba 08 00 00 00       	mov    $0x8,%edx
  804211ef30:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
  804211ef34:	4c 89 f6             	mov    %r14,%rsi
  804211ef37:	4c 89 e7             	mov    %r12,%rdi
  804211ef3a:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211ef41:	00 00 00 
  804211ef44:	ff d0                	call   *%rax
                match += 8;
  804211ef46:	49 83 c6 08          	add    $0x8,%r14
            op += 8;
  804211ef4a:	49 8d 44 24 08       	lea    0x8(%r12),%rax
  804211ef4f:	48 89 c7             	mov    %rax,%rdi
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
  804211ef52:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211ef56:	48 83 e8 0c          	sub    $0xc,%rax
  804211ef5a:	4c 39 f8             	cmp    %r15,%rax
  804211ef5d:	0f 82 b1 00 00 00    	jb     804211f014 <LZ4_decompress_fast_continue+0x6bc>
                memcpy(op, match, 8);
  804211ef63:	ba 08 00 00 00       	mov    $0x8,%edx
  804211ef68:	4c 89 f6             	mov    %r14,%rsi
  804211ef6b:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211ef72:	00 00 00 
  804211ef75:	ff d0                	call   *%rax
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
  804211ef77:	49 83 fd 10          	cmp    $0x10,%r13
  804211ef7b:	0f 86 fa 00 00 00    	jbe    804211f07b <LZ4_decompress_fast_continue+0x723>
  804211ef81:	49 8d 76 08          	lea    0x8(%r14),%rsi
  804211ef85:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
  804211ef8a:	4c 89 fa             	mov    %r15,%rdx
  804211ef8d:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211ef94:	00 00 00 
  804211ef97:	ff d0                	call   *%rax
  804211ef99:	e9 dd 00 00 00       	jmp    804211f07b <LZ4_decompress_fast_continue+0x723>
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
  804211ef9e:	41 c7 04 24 00 00 00 	movl   $0x0,(%r12)
  804211efa5:	00 
                op[0] = match[0];
  804211efa6:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  804211efaa:	0f b6 02             	movzbl (%rdx),%eax
  804211efad:	41 88 04 24          	mov    %al,(%r12)
                op[1] = match[1];
  804211efb1:	0f b6 42 01          	movzbl 0x1(%rdx),%eax
  804211efb5:	41 88 44 24 01       	mov    %al,0x1(%r12)
                op[2] = match[2];
  804211efba:	0f b6 42 02          	movzbl 0x2(%rdx),%eax
  804211efbe:	41 88 44 24 02       	mov    %al,0x2(%r12)
                op[3] = match[3];
  804211efc3:	0f b6 42 03          	movzbl 0x3(%rdx),%eax
  804211efc7:	41 88 44 24 03       	mov    %al,0x3(%r12)
                match += inc32table[offset];
  804211efcc:	48 b8 40 22 12 42 80 	movabs $0x8042122240,%rax
  804211efd3:	00 00 00 
  804211efd6:	42 8b 04 b0          	mov    (%rax,%r14,4),%eax
  804211efda:	48 01 d0             	add    %rdx,%rax
                memcpy(op+4, match, 4);
  804211efdd:	49 8d 7c 24 04       	lea    0x4(%r12),%rdi
  804211efe2:	ba 04 00 00 00       	mov    $0x4,%edx
  804211efe7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  804211efeb:	48 89 c6             	mov    %rax,%rsi
  804211efee:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211eff5:	00 00 00 
  804211eff8:	ff d0                	call   *%rax
                match -= dec64table[offset];
  804211effa:	48 b8 20 22 12 42 80 	movabs $0x8042122220,%rax
  804211f001:	00 00 00 
  804211f004:	4a 63 04 b0          	movslq (%rax,%r14,4),%rax
  804211f008:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
  804211f00c:	49 29 c6             	sub    %rax,%r14
  804211f00f:	e9 36 ff ff ff       	jmp    804211ef4a <LZ4_decompress_fast_continue+0x5f2>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
  804211f014:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804211f018:	48 8d 42 fb          	lea    -0x5(%rdx),%rax
  804211f01c:	4c 39 f8             	cmp    %r15,%rax
  804211f01f:	0f 82 59 01 00 00    	jb     804211f17e <LZ4_decompress_fast_continue+0x826>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
  804211f025:	4c 8d 6a f9          	lea    -0x7(%rdx),%r13
                if (op < oCopyLimit) {
  804211f029:	4c 39 ef             	cmp    %r13,%rdi
  804211f02c:	72 26                	jb     804211f054 <LZ4_decompress_fast_continue+0x6fc>
                while (op < cpy) { *op++ = *match++; }
  804211f02e:	48 89 fe             	mov    %rdi,%rsi
  804211f031:	4c 39 ff             	cmp    %r15,%rdi
  804211f034:	73 45                	jae    804211f07b <LZ4_decompress_fast_continue+0x723>
  804211f036:	4c 89 f9             	mov    %r15,%rcx
  804211f039:	48 29 f9             	sub    %rdi,%rcx
  804211f03c:	b8 00 00 00 00       	mov    $0x0,%eax
  804211f041:	41 0f b6 14 06       	movzbl (%r14,%rax,1),%edx
  804211f046:	88 14 06             	mov    %dl,(%rsi,%rax,1)
  804211f049:	48 83 c0 01          	add    $0x1,%rax
  804211f04d:	48 39 c8             	cmp    %rcx,%rax
  804211f050:	75 ef                	jne    804211f041 <LZ4_decompress_fast_continue+0x6e9>
  804211f052:	eb 27                	jmp    804211f07b <LZ4_decompress_fast_continue+0x723>
                    LZ4_wildCopy8(op, match, oCopyLimit);
  804211f054:	4c 89 ea             	mov    %r13,%rdx
  804211f057:	4c 89 f6             	mov    %r14,%rsi
  804211f05a:	49 89 fc             	mov    %rdi,%r12
  804211f05d:	48 b8 09 18 11 42 80 	movabs $0x8042111809,%rax
  804211f064:	00 00 00 
  804211f067:	ff d0                	call   *%rax
                    match += oCopyLimit - op;
  804211f069:	4c 89 e8             	mov    %r13,%rax
  804211f06c:	4c 29 e0             	sub    %r12,%rax
  804211f06f:	49 01 c6             	add    %rax,%r14
                    op = oCopyLimit;
  804211f072:	4c 89 ef             	mov    %r13,%rdi
  804211f075:	eb b7                	jmp    804211f02e <LZ4_decompress_fast_continue+0x6d6>
    {   const BYTE* ip = (const BYTE*) src;
  804211f077:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
  804211f07b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211f07f:	48 83 e8 1a          	sub    $0x1a,%rax
            token = *ip++;
  804211f083:	4c 8d 73 01          	lea    0x1(%rbx),%r14
  804211f087:	44 0f b6 2b          	movzbl (%rbx),%r13d
  804211f08b:	41 0f b6 d5          	movzbl %r13b,%edx
  804211f08f:	89 55 c8             	mov    %edx,-0x38(%rbp)
            length = token >> ML_BITS;  /* literal length */
  804211f092:	89 d3                	mov    %edx,%ebx
  804211f094:	c1 eb 04             	shr    $0x4,%ebx
  804211f097:	89 db                	mov    %ebx,%ebx
                 && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
  804211f099:	4c 39 f8             	cmp    %r15,%rax
  804211f09c:	0f 82 1f fd ff ff    	jb     804211edc1 <LZ4_decompress_fast_continue+0x469>
  804211f0a2:	48 83 fb 08          	cmp    $0x8,%rbx
  804211f0a6:	0f 87 15 fd ff ff    	ja     804211edc1 <LZ4_decompress_fast_continue+0x469>
  804211f0ac:	4d 89 fc             	mov    %r15,%r12
  804211f0af:	49 89 c7             	mov    %rax,%r15
                memcpy(op, ip, endOnInput ? 16 : 8);
  804211f0b2:	ba 08 00 00 00       	mov    $0x8,%edx
  804211f0b7:	4c 89 f6             	mov    %r14,%rsi
  804211f0ba:	4c 89 e7             	mov    %r12,%rdi
  804211f0bd:	48 b8 62 0d 11 42 80 	movabs $0x8042110d62,%rax
  804211f0c4:	00 00 00 
  804211f0c7:	ff d0                	call   *%rax
                op += length; ip += length;
  804211f0c9:	49 01 dc             	add    %rbx,%r12
  804211f0cc:	4c 01 f3             	add    %r14,%rbx
                length = token & ML_MASK; /* match length */
  804211f0cf:	41 83 e5 0f          	and    $0xf,%r13d
                offset = LZ4_readLE16(ip); ip += 2;
  804211f0d3:	48 89 df             	mov    %rbx,%rdi
  804211f0d6:	48 b8 6d 17 11 42 80 	movabs $0x804211176d,%rax
  804211f0dd:	00 00 00 
  804211f0e0:	ff d0                	call   *%rax
  804211f0e2:	44 0f b7 f0          	movzwl %ax,%r14d
                match = op - offset;
  804211f0e6:	4c 89 e0             	mov    %r12,%rax
  804211f0e9:	4c 29 f0             	sub    %r14,%rax
  804211f0ec:	48 89 c7             	mov    %rax,%rdi
  804211f0ef:	48 89 45 90          	mov    %rax,-0x70(%rbp)
                if ( (length != ML_MASK)
  804211f0f3:	49 83 fd 0f          	cmp    $0xf,%r13
  804211f0f7:	0f 95 c2             	setne  %dl
                     && (offset >= 8)
  804211f0fa:	49 83 fe 07          	cmp    $0x7,%r14
  804211f0fe:	0f 97 c0             	seta   %al
                     && (dict==withPrefix64k || match >= lowPrefix) ) {
  804211f101:	84 c2                	test   %al,%dl
  804211f103:	74 0d                	je     804211f112 <LZ4_decompress_fast_continue+0x7ba>
  804211f105:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  804211f109:	48 39 d7             	cmp    %rdx,%rdi
  804211f10c:	0f 83 3e fc ff ff    	jae    804211ed50 <LZ4_decompress_fast_continue+0x3f8>
                offset = LZ4_readLE16(ip); ip += 2;
  804211f112:	48 83 c3 02          	add    $0x2,%rbx
            if (length == ML_MASK) {
  804211f116:	49 83 fd 0f          	cmp    $0xf,%r13
  804211f11a:	0f 84 58 fd ff ff    	je     804211ee78 <LZ4_decompress_fast_continue+0x520>
            length += MINMATCH;
  804211f120:	49 83 c5 04          	add    $0x4,%r13
            if ((dict==usingExtDict) && (match < lowPrefix)) {
  804211f124:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
  804211f128:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  804211f12c:	48 39 d7             	cmp    %rdx,%rdi
  804211f12f:	0f 83 ec fd ff ff    	jae    804211ef21 <LZ4_decompress_fast_continue+0x5c9>
                if (unlikely(op+length > oend-LASTLITERALS)) {
  804211f135:	4f 8d 3c 2c          	lea    (%r12,%r13,1),%r15
  804211f139:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804211f13d:	48 83 e8 05          	sub    $0x5,%rax
  804211f141:	4c 39 f8             	cmp    %r15,%rax
  804211f144:	72 38                	jb     804211f17e <LZ4_decompress_fast_continue+0x826>
                if (length <= (size_t)(lowPrefix-match)) {
  804211f146:	48 29 fa             	sub    %rdi,%rdx
  804211f149:	49 89 d6             	mov    %rdx,%r14
  804211f14c:	4c 39 ea             	cmp    %r13,%rdx
  804211f14f:	0f 82 56 fd ff ff    	jb     804211eeab <LZ4_decompress_fast_continue+0x553>
                    memmove(op, dictEnd - (lowPrefix-match), length);
  804211f155:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  804211f159:	48 29 d6             	sub    %rdx,%rsi
  804211f15c:	4c 89 ea             	mov    %r13,%rdx
  804211f15f:	4c 89 e7             	mov    %r12,%rdi
  804211f162:	48 b8 f7 0c 11 42 80 	movabs $0x8042110cf7,%rax
  804211f169:	00 00 00 
  804211f16c:	ff d0                	call   *%rax
                    op += length;
  804211f16e:	e9 08 ff ff ff       	jmp    804211f07b <LZ4_decompress_fast_continue+0x723>
                    op += copySize;
  804211f173:	49 89 ff             	mov    %rdi,%r15
  804211f176:	e9 00 ff ff ff       	jmp    804211f07b <LZ4_decompress_fast_continue+0x723>
  804211f17b:	4c 89 f3             	mov    %r14,%rbx
        return (int) (-(((const char*)ip)-src))-1;
  804211f17e:	48 89 d8             	mov    %rbx,%rax
  804211f181:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  804211f185:	48 29 d0             	sub    %rdx,%rax
  804211f188:	f7 d0                	not    %eax
  804211f18a:	e9 a2 f8 ff ff       	jmp    804211ea31 <LZ4_decompress_fast_continue+0xd9>
            result = LZ4_decompress_fast_doubleDict(source, dest, originalSize,
  804211f18f:	b8 01 00 00 00       	mov    $0x1,%eax
  804211f194:	e9 9c f8 ff ff       	jmp    804211ea35 <LZ4_decompress_fast_continue+0xdd>
  804211f199:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804211f19e:	e9 28 f8 ff ff       	jmp    804211e9cb <LZ4_decompress_fast_continue+0x73>

000000804211f1a3 <LZ4_decompress_safe_usingDict>:
    These decoding functions work the same as "_continue" ones,
    the dictionary must be explicitly provided within parameters
*/

int LZ4_decompress_safe_usingDict(const char* source, char* dest, int compressedSize, int maxOutputSize, const char* dictStart, int dictSize)
{
  804211f1a3:	f3 0f 1e fa          	endbr64
  804211f1a7:	55                   	push   %rbp
  804211f1a8:	48 89 e5             	mov    %rsp,%rbp
    if (dictSize==0)
  804211f1ab:	45 85 c9             	test   %r9d,%r9d
  804211f1ae:	74 1d                	je     804211f1cd <LZ4_decompress_safe_usingDict+0x2a>
  804211f1b0:	44 89 c8             	mov    %r9d,%eax
        return LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
    if (dictStart+dictSize == dest) {
  804211f1b3:	4d 63 c9             	movslq %r9d,%r9
  804211f1b6:	4f 8d 14 08          	lea    (%r8,%r9,1),%r10
  804211f1ba:	4c 39 d6             	cmp    %r10,%rsi
  804211f1bd:	74 1c                	je     804211f1db <LZ4_decompress_safe_usingDict+0x38>
        }
        assert(dictSize >= 0);
        return LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize, (size_t)dictSize);
    }
    assert(dictSize >= 0);
    return LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize, dictStart, (size_t)dictSize);
  804211f1bf:	48 b8 99 d5 11 42 80 	movabs $0x804211d599,%rax
  804211f1c6:	00 00 00 
  804211f1c9:	ff d0                	call   *%rax
}
  804211f1cb:	5d                   	pop    %rbp
  804211f1cc:	c3                   	ret
        return LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
  804211f1cd:	48 b8 82 ba 11 42 80 	movabs $0x804211ba82,%rax
  804211f1d4:	00 00 00 
  804211f1d7:	ff d0                	call   *%rax
  804211f1d9:	eb f0                	jmp    804211f1cb <LZ4_decompress_safe_usingDict+0x28>
        if (dictSize >= 64 KB - 1) {
  804211f1db:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  804211f1e0:	7e 0e                	jle    804211f1f0 <LZ4_decompress_safe_usingDict+0x4d>
            return LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);
  804211f1e2:	48 b8 5b ce 11 42 80 	movabs $0x804211ce5b,%rax
  804211f1e9:	00 00 00 
  804211f1ec:	ff d0                	call   *%rax
  804211f1ee:	eb db                	jmp    804211f1cb <LZ4_decompress_safe_usingDict+0x28>
        return LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize, (size_t)dictSize);
  804211f1f0:	4d 89 c8             	mov    %r9,%r8
  804211f1f3:	48 b8 54 1a 11 42 80 	movabs $0x8042111a54,%rax
  804211f1fa:	00 00 00 
  804211f1fd:	ff d0                	call   *%rax
  804211f1ff:	eb ca                	jmp    804211f1cb <LZ4_decompress_safe_usingDict+0x28>

000000804211f201 <LZ4_decompress_fast_usingDict>:

int LZ4_decompress_fast_usingDict(const char* source, char* dest, int originalSize, const char* dictStart, int dictSize)
{
  804211f201:	f3 0f 1e fa          	endbr64
  804211f205:	55                   	push   %rbp
  804211f206:	48 89 e5             	mov    %rsp,%rbp
    if (dictSize==0 || dictStart+dictSize == dest)
  804211f209:	45 85 c0             	test   %r8d,%r8d
  804211f20c:	74 1a                	je     804211f228 <LZ4_decompress_fast_usingDict+0x27>
  804211f20e:	4d 63 c0             	movslq %r8d,%r8
  804211f211:	4a 8d 04 01          	lea    (%rcx,%r8,1),%rax
  804211f215:	48 39 c6             	cmp    %rax,%rsi
  804211f218:	74 0e                	je     804211f228 <LZ4_decompress_fast_usingDict+0x27>
        return LZ4_decompress_fast(source, dest, originalSize);
    assert(dictSize >= 0);
    return LZ4_decompress_fast_extDict(source, dest, originalSize, dictStart, (size_t)dictSize);
  804211f21a:	48 b8 69 21 11 42 80 	movabs $0x8042112169,%rax
  804211f221:	00 00 00 
  804211f224:	ff d0                	call   *%rax
}
  804211f226:	5d                   	pop    %rbp
  804211f227:	c3                   	ret
        return LZ4_decompress_fast(source, dest, originalSize);
  804211f228:	48 b8 bf c8 11 42 80 	movabs $0x804211c8bf,%rax
  804211f22f:	00 00 00 
  804211f232:	ff d0                	call   *%rax
  804211f234:	eb f0                	jmp    804211f226 <LZ4_decompress_fast_usingDict+0x25>

000000804211f236 <LZ4_compress_limitedOutput>:
/*=*************************************************
*  Obsolete Functions
***************************************************/
/* obsolete compression functions */
int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize)
{
  804211f236:	f3 0f 1e fa          	endbr64
  804211f23a:	55                   	push   %rbp
  804211f23b:	48 89 e5             	mov    %rsp,%rbp
    return LZ4_compress_default(source, dest, inputSize, maxOutputSize);
  804211f23e:	48 b8 6d 5d 11 42 80 	movabs $0x8042115d6d,%rax
  804211f245:	00 00 00 
  804211f248:	ff d0                	call   *%rax
}
  804211f24a:	5d                   	pop    %rbp
  804211f24b:	c3                   	ret

000000804211f24c <LZ4_compress>:
int LZ4_compress(const char* src, char* dest, int srcSize)
{
  804211f24c:	f3 0f 1e fa          	endbr64
  804211f250:	55                   	push   %rbp
  804211f251:	48 89 e5             	mov    %rsp,%rbp
  804211f254:	41 55                	push   %r13
  804211f256:	41 54                	push   %r12
  804211f258:	53                   	push   %rbx
  804211f259:	48 83 ec 08          	sub    $0x8,%rsp
  804211f25d:	49 89 fc             	mov    %rdi,%r12
  804211f260:	49 89 f5             	mov    %rsi,%r13
  804211f263:	89 d3                	mov    %edx,%ebx
    return LZ4_compress_default(src, dest, srcSize, LZ4_compressBound(srcSize));
  804211f265:	89 d7                	mov    %edx,%edi
  804211f267:	48 b8 10 29 11 42 80 	movabs $0x8042112910,%rax
  804211f26e:	00 00 00 
  804211f271:	ff d0                	call   *%rax
  804211f273:	89 c1                	mov    %eax,%ecx
  804211f275:	89 da                	mov    %ebx,%edx
  804211f277:	4c 89 ee             	mov    %r13,%rsi
  804211f27a:	4c 89 e7             	mov    %r12,%rdi
  804211f27d:	48 b8 6d 5d 11 42 80 	movabs $0x8042115d6d,%rax
  804211f284:	00 00 00 
  804211f287:	ff d0                	call   *%rax
}
  804211f289:	48 83 c4 08          	add    $0x8,%rsp
  804211f28d:	5b                   	pop    %rbx
  804211f28e:	41 5c                	pop    %r12
  804211f290:	41 5d                	pop    %r13
  804211f292:	5d                   	pop    %rbp
  804211f293:	c3                   	ret

000000804211f294 <LZ4_compress_limitedOutput_withState>:
int LZ4_compress_limitedOutput_withState (void* state, const char* src, char* dst, int srcSize, int dstSize)
{
  804211f294:	f3 0f 1e fa          	endbr64
  804211f298:	55                   	push   %rbp
  804211f299:	48 89 e5             	mov    %rsp,%rbp
    return LZ4_compress_fast_extState(state, src, dst, srcSize, dstSize, 1);
  804211f29c:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  804211f2a2:	48 b8 9f 49 11 42 80 	movabs $0x804211499f,%rax
  804211f2a9:	00 00 00 
  804211f2ac:	ff d0                	call   *%rax
}
  804211f2ae:	5d                   	pop    %rbp
  804211f2af:	c3                   	ret

000000804211f2b0 <LZ4_compress_withState>:
int LZ4_compress_withState (void* state, const char* src, char* dst, int srcSize)
{
  804211f2b0:	f3 0f 1e fa          	endbr64
  804211f2b4:	55                   	push   %rbp
  804211f2b5:	48 89 e5             	mov    %rsp,%rbp
  804211f2b8:	41 56                	push   %r14
  804211f2ba:	41 55                	push   %r13
  804211f2bc:	41 54                	push   %r12
  804211f2be:	53                   	push   %rbx
  804211f2bf:	49 89 fc             	mov    %rdi,%r12
  804211f2c2:	49 89 f5             	mov    %rsi,%r13
  804211f2c5:	49 89 d6             	mov    %rdx,%r14
  804211f2c8:	89 cb                	mov    %ecx,%ebx
    return LZ4_compress_fast_extState(state, src, dst, srcSize, LZ4_compressBound(srcSize), 1);
  804211f2ca:	89 cf                	mov    %ecx,%edi
  804211f2cc:	48 b8 10 29 11 42 80 	movabs $0x8042112910,%rax
  804211f2d3:	00 00 00 
  804211f2d6:	ff d0                	call   *%rax
  804211f2d8:	41 89 c0             	mov    %eax,%r8d
  804211f2db:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  804211f2e1:	89 d9                	mov    %ebx,%ecx
  804211f2e3:	4c 89 f2             	mov    %r14,%rdx
  804211f2e6:	4c 89 ee             	mov    %r13,%rsi
  804211f2e9:	4c 89 e7             	mov    %r12,%rdi
  804211f2ec:	48 b8 9f 49 11 42 80 	movabs $0x804211499f,%rax
  804211f2f3:	00 00 00 
  804211f2f6:	ff d0                	call   *%rax
}
  804211f2f8:	5b                   	pop    %rbx
  804211f2f9:	41 5c                	pop    %r12
  804211f2fb:	41 5d                	pop    %r13
  804211f2fd:	41 5e                	pop    %r14
  804211f2ff:	5d                   	pop    %rbp
  804211f300:	c3                   	ret

000000804211f301 <LZ4_compress_limitedOutput_continue>:
int LZ4_compress_limitedOutput_continue (LZ4_stream_t* LZ4_stream, const char* src, char* dst, int srcSize, int dstCapacity)
{
  804211f301:	f3 0f 1e fa          	endbr64
  804211f305:	55                   	push   %rbp
  804211f306:	48 89 e5             	mov    %rsp,%rbp
    return LZ4_compress_fast_continue(LZ4_stream, src, dst, srcSize, dstCapacity, 1);
  804211f309:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  804211f30f:	48 b8 8f 78 11 42 80 	movabs $0x804211788f,%rax
  804211f316:	00 00 00 
  804211f319:	ff d0                	call   *%rax
}
  804211f31b:	5d                   	pop    %rbp
  804211f31c:	c3                   	ret

000000804211f31d <LZ4_compress_continue>:
int LZ4_compress_continue (LZ4_stream_t* LZ4_stream, const char* source, char* dest, int inputSize)
{
  804211f31d:	f3 0f 1e fa          	endbr64
  804211f321:	55                   	push   %rbp
  804211f322:	48 89 e5             	mov    %rsp,%rbp
  804211f325:	41 56                	push   %r14
  804211f327:	41 55                	push   %r13
  804211f329:	41 54                	push   %r12
  804211f32b:	53                   	push   %rbx
  804211f32c:	49 89 fc             	mov    %rdi,%r12
  804211f32f:	49 89 f5             	mov    %rsi,%r13
  804211f332:	49 89 d6             	mov    %rdx,%r14
  804211f335:	89 cb                	mov    %ecx,%ebx
    return LZ4_compress_fast_continue(LZ4_stream, source, dest, inputSize, LZ4_compressBound(inputSize), 1);
  804211f337:	89 cf                	mov    %ecx,%edi
  804211f339:	48 b8 10 29 11 42 80 	movabs $0x8042112910,%rax
  804211f340:	00 00 00 
  804211f343:	ff d0                	call   *%rax
  804211f345:	41 89 c0             	mov    %eax,%r8d
  804211f348:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  804211f34e:	89 d9                	mov    %ebx,%ecx
  804211f350:	4c 89 f2             	mov    %r14,%rdx
  804211f353:	4c 89 ee             	mov    %r13,%rsi
  804211f356:	4c 89 e7             	mov    %r12,%rdi
  804211f359:	48 b8 8f 78 11 42 80 	movabs $0x804211788f,%rax
  804211f360:	00 00 00 
  804211f363:	ff d0                	call   *%rax
}
  804211f365:	5b                   	pop    %rbx
  804211f366:	41 5c                	pop    %r12
  804211f368:	41 5d                	pop    %r13
  804211f36a:	41 5e                	pop    %r14
  804211f36c:	5d                   	pop    %rbp
  804211f36d:	c3                   	ret

000000804211f36e <LZ4_uncompress>:
They are only provided here for compatibility with older user programs.
- LZ4_uncompress is totally equivalent to LZ4_decompress_fast
- LZ4_uncompress_unknownOutputSize is totally equivalent to LZ4_decompress_safe
*/
int LZ4_uncompress (const char* source, char* dest, int outputSize)
{
  804211f36e:	f3 0f 1e fa          	endbr64
  804211f372:	55                   	push   %rbp
  804211f373:	48 89 e5             	mov    %rsp,%rbp
    return LZ4_decompress_fast(source, dest, outputSize);
  804211f376:	48 b8 bf c8 11 42 80 	movabs $0x804211c8bf,%rax
  804211f37d:	00 00 00 
  804211f380:	ff d0                	call   *%rax
}
  804211f382:	5d                   	pop    %rbp
  804211f383:	c3                   	ret

000000804211f384 <LZ4_uncompress_unknownOutputSize>:
int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize)
{
  804211f384:	f3 0f 1e fa          	endbr64
  804211f388:	55                   	push   %rbp
  804211f389:	48 89 e5             	mov    %rsp,%rbp
    return LZ4_decompress_safe(source, dest, isize, maxOutputSize);
  804211f38c:	48 b8 82 ba 11 42 80 	movabs $0x804211ba82,%rax
  804211f393:	00 00 00 
  804211f396:	ff d0                	call   *%rax
}
  804211f398:	5d                   	pop    %rbp
  804211f399:	c3                   	ret

000000804211f39a <LZ4_sizeofStreamState>:

/* Obsolete Streaming functions */

int LZ4_sizeofStreamState() { return LZ4_STREAMSIZE; }
  804211f39a:	f3 0f 1e fa          	endbr64
  804211f39e:	b8 20 40 00 00       	mov    $0x4020,%eax
  804211f3a3:	c3                   	ret

000000804211f3a4 <LZ4_resetStreamState>:

int LZ4_resetStreamState(void* state, char* inputBuffer)
{
  804211f3a4:	f3 0f 1e fa          	endbr64
  804211f3a8:	55                   	push   %rbp
  804211f3a9:	48 89 e5             	mov    %rsp,%rbp
    (void)inputBuffer;
    LZ4_resetStream((LZ4_stream_t*)state);
  804211f3ac:	48 b8 8d 76 11 42 80 	movabs $0x804211768d,%rax
  804211f3b3:	00 00 00 
  804211f3b6:	ff d0                	call   *%rax
    return 0;
}
  804211f3b8:	b8 00 00 00 00       	mov    $0x0,%eax
  804211f3bd:	5d                   	pop    %rbp
  804211f3be:	c3                   	ret

000000804211f3bf <LZ4_slideInputBuffer>:


char* LZ4_slideInputBuffer (void* state)
{
  804211f3bf:	f3 0f 1e fa          	endbr64
    /* avoid const char * -> char * conversion warning */
    return (char *)(uptrval)((LZ4_stream_t*)state)->internal_donotuse.dictionary;
  804211f3c3:	48 8b 87 08 40 00 00 	mov    0x4008(%rdi),%rax
}
  804211f3ca:	c3                   	ret
  804211f3cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000804211f3d0 <__rodata_start>:
  804211f3d0:	49 6e                	rex.WB outsb %ds:(%rsi),(%dx)
  804211f3d2:	69 74 69 61 6c 69 7a 	imul   $0x657a696c,0x61(%rcx,%rbp,2),%esi
  804211f3d9:	65 
  804211f3da:	64 20 74 69 6d       	and    %dh,%fs:0x6d(%rcx,%rbp,2)
  804211f3df:	65 72 20             	gs jb  804211f402 <__rodata_start+0x32>
  804211f3e2:	25 73 0a 00 6b       	and    $0x6b000a73,%eax
  804211f3e7:	65 72 6e             	gs jb  804211f458 <__rodata_start+0x88>
  804211f3ea:	65 6c                	gs insb (%dx),%es:(%rdi)
  804211f3ec:	20 70 61             	and    %dh,0x61(%rax)
  804211f3ef:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f3f0:	69 63 20 61 74 20 25 	imul   $0x25207461,0x20(%rbx),%esp
  804211f3f7:	73 3a                	jae    804211f433 <__rodata_start+0x63>
  804211f3f9:	25 64 3a 20 00       	and    $0x203a64,%eax
  804211f3fe:	6b 65 72 6e          	imul   $0x6e,0x72(%rbp),%esp
  804211f402:	2f                   	(bad)
  804211f403:	69 6e 69 74 2e 63 00 	imul   $0x632e74,0x69(%rsi),%ebp
  804211f40a:	54                   	push   %rsp
  804211f40b:	69 6d 65 72 20 25 73 	imul   $0x73252072,0x65(%rbp),%ebp
  804211f412:	20 64 6f 65          	and    %ah,0x65(%rdi,%rbp,2)
  804211f416:	73 20                	jae    804211f438 <__rodata_start+0x68>
  804211f418:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f419:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f41a:	74 20                	je     804211f43c <__rodata_start+0x6c>
  804211f41c:	65 78 69             	gs js  804211f488 <__rodata_start+0xb8>
  804211f41f:	73 74                	jae    804211f495 <__rodata_start+0xc5>
  804211f421:	0a 00                	or     (%rax),%al
  804211f423:	36 38 32             	ss cmp %dh,(%rdx)
  804211f426:	38 20                	cmp    %ah,(%rax)
  804211f428:	64 65 63 69 6d       	fs movsxd %gs:0x6d(%rcx),%ebp
  804211f42d:	61                   	(bad)
  804211f42e:	6c                   	insb   (%dx),%es:(%rdi)
  804211f42f:	20 69 73             	and    %ch,0x73(%rcx)
  804211f432:	20 25 6f 20 6f 63    	and    %ah,0x636f206f(%rip)        # 80a58114a7 <__bss_end+0x628094a7>
  804211f438:	74 61                	je     804211f49b <__rodata_start+0xcb>
  804211f43a:	6c                   	insb   (%dx),%es:(%rdi)
  804211f43b:	21 0a                	and    %ecx,(%rdx)
  804211f43d:	00 45 4e             	add    %al,0x4e(%rbp)
  804211f440:	44 3a 20             	cmp    (%rax),%r12b
  804211f443:	25 70 0a 00 46       	and    $0x46000a70,%eax
  804211f448:	72 61                	jb     804211f4ab <__rodata_start+0xdb>
  804211f44a:	6d                   	insl   (%dx),%es:(%rdi)
  804211f44b:	65 62 75 66 66 65    	(bad)
  804211f451:	72 20                	jb     804211f473 <__rodata_start+0xa3>
  804211f453:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
  804211f45a:	69 73 65 64 0a 00 68 	imul   $0x68000a64,0x65(%rbx),%esi
  804211f461:	70 65                	jo     804211f4c8 <__rodata_start+0xf8>
  804211f463:	74 30                	je     804211f495 <__rodata_start+0xc5>
  804211f465:	00 6b 65             	add    %ch,0x65(%rbx)
  804211f468:	72 6e                	jb     804211f4d8 <__rodata_start+0x108>
  804211f46a:	65 6c                	gs insb (%dx),%es:(%rdi)
  804211f46c:	20 77 61             	and    %dh,0x61(%rdi)
  804211f46f:	72 6e                	jb     804211f4df <__rodata_start+0x10f>
  804211f471:	69 6e 67 20 61 74 20 	imul   $0x20746120,0x67(%rsi),%ebp
  804211f478:	25 73 3a 25 64       	and    $0x64253a73,%eax
  804211f47d:	3a 20                	cmp    (%rax),%ah
  804211f47f:	00 52 65             	add    %dl,0x65(%rdx)
  804211f482:	62 6f 6f 74 69       	(bad)
  804211f487:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f488:	67 21 0a             	and    %ecx,(%edx)
  804211f48b:	00 53 65             	add    %dl,0x65(%rbx)
  804211f48e:	72 69                	jb     804211f4f9 <__rodata_start+0x129>
  804211f490:	61                   	(bad)
  804211f491:	6c                   	insb   (%dx),%es:(%rdi)
  804211f492:	20 70 6f             	and    %dh,0x6f(%rax)
  804211f495:	72 74                	jb     804211f50b <__rodata_start+0x13b>
  804211f497:	20 64 6f 65          	and    %ah,0x65(%rdi,%rbp,2)
  804211f49b:	73 20                	jae    804211f4bd <__rodata_start+0xed>
  804211f49d:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f49e:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f49f:	74 20                	je     804211f4c1 <__rodata_start+0xf1>
  804211f4a1:	65 78 69             	gs js  804211f50d <__rodata_start+0x13d>
  804211f4a4:	73 74                	jae    804211f51a <__rodata_start+0x14a>
  804211f4a6:	21 0a                	and    %ecx,(%rdx)
  804211f4a8:	00 55 6e             	add    %dl,0x6e(%rbp)
  804211f4ab:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
  804211f4af:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f4b0:	20 44 57 41          	and    %al,0x41(%rdi,%rdx,2)
  804211f4b4:	52                   	push   %rdx
  804211f4b5:	46 20 65 78          	rex.RX and %r12b,0x78(%rbp)
  804211f4b9:	74 65                	je     804211f520 <__rodata_start+0x150>
  804211f4bb:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f4bc:	73 69                	jae    804211f527 <__rodata_start+0x157>
  804211f4be:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f4bf:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f4c0:	0a 00                	or     (%rax),%al
  804211f4c2:	76 65                	jbe    804211f529 <__rodata_start+0x159>
  804211f4c4:	72 73                	jb     804211f539 <__rodata_start+0x169>
  804211f4c6:	69 6f 6e 20 3d 3d 20 	imul   $0x203d3d20,0x6e(%rdi),%ebp
  804211f4cd:	34 20                	xor    $0x20,%al
  804211f4cf:	7c 7c                	jl     804211f54d <__rodata_start+0x17d>
  804211f4d1:	20 76 65             	and    %dh,0x65(%rsi)
  804211f4d4:	72 73                	jb     804211f549 <__rodata_start+0x179>
  804211f4d6:	69 6f 6e 20 3d 3d 20 	imul   $0x203d3d20,0x6e(%rdi),%ebp
  804211f4dd:	32 00                	xor    (%rax),%al
  804211f4df:	61                   	(bad)
  804211f4e0:	73 73                	jae    804211f555 <__rodata_start+0x185>
  804211f4e2:	65 72 74             	gs jb  804211f559 <__rodata_start+0x189>
  804211f4e5:	69 6f 6e 20 66 61 69 	imul   $0x69616620,0x6e(%rdi),%ebp
  804211f4ec:	6c                   	insb   (%dx),%es:(%rdi)
  804211f4ed:	65 64 3a 20          	gs cmp %fs:(%rax),%ah
  804211f4f1:	25 73 00 6b 65       	and    $0x656b0073,%eax
  804211f4f6:	72 6e                	jb     804211f566 <__rodata_start+0x196>
  804211f4f8:	2f                   	(bad)
  804211f4f9:	64 77 61             	fs ja  804211f55d <__rodata_start+0x18d>
  804211f4fc:	72 66                	jb     804211f564 <__rodata_start+0x194>
  804211f4fe:	2e 63 00             	cs movsxd (%rax),%eax
  804211f501:	61                   	(bad)
  804211f502:	62 62 72 65 76       	(bad)
  804211f507:	5f                   	pop    %rdi
  804211f508:	63 6f 64             	movsxd 0x64(%rdi),%ebp
  804211f50b:	65 00 74 61 67       	add    %dh,%gs:0x67(%rcx,%riz,2)
  804211f510:	20 3d 3d 20 44 57    	and    %bh,0x5744203d(%rip)        # 8099561553 <__bss_end+0x56559553>
  804211f516:	5f                   	pop    %rdi
  804211f517:	54                   	push   %rsp
  804211f518:	41                   	rex.B
  804211f519:	47 5f                	rex.RXB pop %r15
  804211f51b:	63 6f 6d             	movsxd 0x6d(%rdi),%ebp
  804211f51e:	70 69                	jo     804211f589 <__rodata_start+0x1b9>
  804211f520:	6c                   	insb   (%dx),%es:(%rdi)
  804211f521:	65 5f                	gs pop %rdi
  804211f523:	75 6e                	jne    804211f593 <__rodata_start+0x1c3>
  804211f525:	69 74 00 6b 65 72 6e 	imul   $0x2f6e7265,0x6b(%rax,%rax,1),%esi
  804211f52c:	2f 
  804211f52d:	64 77 61             	fs ja  804211f591 <__rodata_start+0x1c1>
  804211f530:	72 66                	jb     804211f598 <__rodata_start+0x1c8>
  804211f532:	5f                   	pop    %rdi
  804211f533:	6c                   	insb   (%dx),%es:(%rdi)
  804211f534:	69 6e 65 73 2e 63 00 	imul   $0x632e73,0x65(%rsi),%ebp
  804211f53b:	55                   	push   %rbp
  804211f53c:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f53d:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
  804211f541:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f542:	20 6f 70             	and    %ch,0x70(%rdi)
  804211f545:	63 6f 64             	movsxd 0x64(%rdi),%ebp
  804211f548:	65 3a 20             	cmp    %gs:(%rax),%ah
  804211f54b:	25 78 00 70 72       	and    $0x72700078,%eax
  804211f550:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f551:	67 72 61             	addr32 jb 804211f5b5 <__rodata_start+0x1e5>
  804211f554:	6d                   	insl   (%dx),%es:(%rdi)
  804211f555:	5f                   	pop    %rdi
  804211f556:	61                   	(bad)
  804211f557:	64 64 72 20          	fs fs jb 804211f57b <__rodata_start+0x1ab>
  804211f55b:	3d 3d 20 6f 70       	cmp    $0x706f203d,%eax
  804211f560:	63 6f 64             	movsxd 0x64(%rdi),%ebp
  804211f563:	65 5f                	gs pop %rdi
  804211f565:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211f567:	64 00 25 73 20 2d 20 	add    %ah,%fs:0x202d2073(%rip)        # 80623f15e1 <__bss_end+0x1f3e95e1>
  804211f56e:	25 73 0a 00 53       	and    $0x53000a73,%eax
  804211f573:	70 65                	jo     804211f5da <__rodata_start+0x20a>
  804211f575:	63 69 61             	movsxd 0x61(%rcx),%ebp
  804211f578:	6c                   	insb   (%dx),%es:(%rdi)
  804211f579:	20 6b 65             	and    %ch,0x65(%rbx)
  804211f57c:	72 6e                	jb     804211f5ec <__rodata_start+0x21c>
  804211f57e:	65 6c                	gs insb (%dx),%es:(%rdi)
  804211f580:	20 73 79             	and    %dh,0x79(%rbx)
  804211f583:	6d                   	insl   (%dx),%es:(%rdi)
  804211f584:	62 6f 6c 73 3a       	(bad)
  804211f589:	0a 00                	or     (%rax),%al
  804211f58b:	53                   	push   %rbx
  804211f58c:	74 61                	je     804211f5ef <__rodata_start+0x21f>
  804211f58e:	63 6b 20             	movsxd 0x20(%rbx),%ebp
  804211f591:	62 61 63 6b 74       	(bad)
  804211f596:	72 61                	jb     804211f5f9 <__rodata_start+0x229>
  804211f598:	63 65 3a             	movsxd 0x3a(%rbp),%esp
  804211f59b:	0a 00                	or     (%rax),%al
  804211f59d:	20 20                	and    %ah,(%rax)
  804211f59f:	72 62                	jb     804211f603 <__rodata_start+0x233>
  804211f5a1:	70 20                	jo     804211f5c3 <__rodata_start+0x1f3>
  804211f5a3:	25 30 31 36 6c       	and    $0x6c363130,%eax
  804211f5a8:	78 20                	js     804211f5ca <__rodata_start+0x1fa>
  804211f5aa:	20 72 69             	and    %dh,0x69(%rdx)
  804211f5ad:	70 20                	jo     804211f5cf <__rodata_start+0x1ff>
  804211f5af:	25 30 31 36 6c       	and    $0x6c363130,%eax
  804211f5b4:	78 0a                	js     804211f5c0 <__rodata_start+0x1f0>
  804211f5b6:	00 20                	add    %ah,(%rax)
  804211f5b8:	20 20                	and    %ah,(%rax)
  804211f5ba:	20 25 73 3a 25 64    	and    %ah,0x64253a73(%rip)        # 80a6373033 <__bss_end+0x6336b033>
  804211f5c0:	3a 20                	cmp    (%rax),%ah
  804211f5c2:	25 2e 2a 73 2b       	and    $0x2b732a2e,%eax
  804211f5c7:	25 6c 78 0a 00       	and    $0xa786c,%eax
  804211f5cc:	30 30                	xor    %dh,(%rax)
  804211f5ce:	3a 20                	cmp    (%rax),%ah
  804211f5d0:	00 0a                	add    %cl,(%rdx)
  804211f5d2:	25 30 32 58 3a       	and    $0x3a583230,%eax
  804211f5d7:	20 00                	and    %al,(%rax)
  804211f5d9:	25 30 32 58 20       	and    $0x20583230,%eax
  804211f5de:	00 4b 3e             	add    %cl,0x3e(%rbx)
  804211f5e1:	20 00                	and    %al,(%rax)
  804211f5e3:	09 0d 0a 20 00 54    	or     %ecx,0x5400200a(%rip)        # 80961215f3 <__bss_end+0x531195f3>
  804211f5e9:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f5ea:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f5eb:	20 6d 61             	and    %ch,0x61(%rbp)
  804211f5ee:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f5ef:	79 20                	jns    804211f611 <__rodata_start+0x241>
  804211f5f1:	61                   	(bad)
  804211f5f2:	72 67                	jb     804211f65b <__rodata_start+0x28b>
  804211f5f4:	75 6d                	jne    804211f663 <__rodata_start+0x293>
  804211f5f6:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211f5f8:	74 73                	je     804211f66d <__rodata_start+0x29d>
  804211f5fa:	20 28                	and    %ch,(%rax)
  804211f5fc:	6d                   	insl   (%dx),%es:(%rdi)
  804211f5fd:	61                   	(bad)
  804211f5fe:	78 20                	js     804211f620 <__rodata_start+0x250>
  804211f600:	25 64 29 0a 00       	and    $0xa2964,%eax
  804211f605:	55                   	push   %rbp
  804211f606:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f607:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
  804211f60b:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f60c:	20 63 6f             	and    %ah,0x6f(%rbx)
  804211f60f:	6d                   	insl   (%dx),%es:(%rdi)
  804211f610:	6d                   	insl   (%dx),%es:(%rdi)
  804211f611:	61                   	(bad)
  804211f612:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f613:	64 20 27             	and    %ah,%fs:(%rdi)
  804211f616:	25 73 27 0a 00       	and    $0xa2773,%eax
  804211f61b:	68 65 6c 70 00       	push   $0x706c65
  804211f620:	44 69 73 70 6c 61 79 	imul   $0x2079616c,0x70(%rbx),%r14d
  804211f627:	20 
  804211f628:	74 68                	je     804211f692 <__rodata_start+0x2c2>
  804211f62a:	69 73 20 6c 69 73 74 	imul   $0x7473696c,0x20(%rbx),%esi
  804211f631:	20 6f 66             	and    %ch,0x66(%rdi)
  804211f634:	20 63 6f             	and    %ah,0x6f(%rbx)
  804211f637:	6d                   	insl   (%dx),%es:(%rdi)
  804211f638:	6d                   	insl   (%dx),%es:(%rdi)
  804211f639:	61                   	(bad)
  804211f63a:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f63b:	64 73 00             	fs jae 804211f63e <__rodata_start+0x26e>
  804211f63e:	6b 65 72 6e          	imul   $0x6e,0x72(%rbp),%esp
  804211f642:	69 6e 66 6f 00 50 72 	imul   $0x7250006f,0x66(%rsi),%ebp
  804211f649:	69 6e 74 20 73 74 61 	imul   $0x61747320,0x74(%rsi),%ebp
  804211f650:	63 6b 20             	movsxd 0x20(%rbx),%ebp
  804211f653:	62 61 63 6b 74       	(bad)
  804211f658:	72 61                	jb     804211f6bb <__rodata_start+0x2eb>
  804211f65a:	63 65 00             	movsxd 0x0(%rbp),%esp
  804211f65d:	64 75 6d             	fs jne 804211f6cd <__rodata_start+0x2fd>
  804211f660:	70 63                	jo     804211f6c5 <__rodata_start+0x2f5>
  804211f662:	6d                   	insl   (%dx),%es:(%rdi)
  804211f663:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f664:	73 00                	jae    804211f666 <__rodata_start+0x296>
  804211f666:	44 69 73 70 6c 61 79 	imul   $0x2079616c,0x70(%rbx),%r14d
  804211f66d:	20 
  804211f66e:	43                   	rex.XB
  804211f66f:	4d                   	rex.WRB
  804211f670:	4f 53                	rex.WRXB push %r11
  804211f672:	20 63 6f             	and    %ah,0x6f(%rbx)
  804211f675:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f676:	74 65                	je     804211f6dd <__rodata_start+0x30d>
  804211f678:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f679:	74 73                	je     804211f6ee <__rodata_start+0x31e>
  804211f67b:	00 74 69 6d          	add    %dh,0x6d(%rcx,%rbp,2)
  804211f67f:	65 72 5f             	gs jb  804211f6e1 <__rodata_start+0x311>
  804211f682:	73 74                	jae    804211f6f8 <__rodata_start+0x328>
  804211f684:	61                   	(bad)
  804211f685:	72 74                	jb     804211f6fb <__rodata_start+0x32b>
  804211f687:	00 53 74             	add    %dl,0x74(%rbx)
  804211f68a:	61                   	(bad)
  804211f68b:	72 74                	jb     804211f701 <__rodata_start+0x331>
  804211f68d:	20 74 69 6d          	and    %dh,0x6d(%rcx,%rbp,2)
  804211f691:	65 72 00             	gs jb  804211f694 <__rodata_start+0x2c4>
  804211f694:	74 69                	je     804211f6ff <__rodata_start+0x32f>
  804211f696:	6d                   	insl   (%dx),%es:(%rdi)
  804211f697:	65 72 5f             	gs jb  804211f6f9 <__rodata_start+0x329>
  804211f69a:	73 74                	jae    804211f710 <__rodata_start+0x340>
  804211f69c:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f69d:	70 00                	jo     804211f69f <__rodata_start+0x2cf>
  804211f69f:	53                   	push   %rbx
  804211f6a0:	74 6f                	je     804211f711 <__rodata_start+0x341>
  804211f6a2:	70 20                	jo     804211f6c4 <__rodata_start+0x2f4>
  804211f6a4:	74 69                	je     804211f70f <__rodata_start+0x33f>
  804211f6a6:	6d                   	insl   (%dx),%es:(%rdi)
  804211f6a7:	65 72 00             	gs jb  804211f6aa <__rodata_start+0x2da>
  804211f6aa:	74 69                	je     804211f715 <__rodata_start+0x345>
  804211f6ac:	6d                   	insl   (%dx),%es:(%rdi)
  804211f6ad:	65 72 5f             	gs jb  804211f70f <__rodata_start+0x33f>
  804211f6b0:	66 72 65             	data16 jb 804211f718 <__rodata_start+0x348>
  804211f6b3:	71 00                	jno    804211f6b5 <__rodata_start+0x2e5>
  804211f6b5:	47                   	rex.RXB
  804211f6b6:	65 74 20             	gs je  804211f6d9 <__rodata_start+0x309>
  804211f6b9:	74 69                	je     804211f724 <__rodata_start+0x354>
  804211f6bb:	6d                   	insl   (%dx),%es:(%rdi)
  804211f6bc:	65 72 20             	gs jb  804211f6df <__rodata_start+0x30f>
  804211f6bf:	66 72 65             	data16 jb 804211f727 <__rodata_start+0x357>
  804211f6c2:	71 75                	jno    804211f739 <__rodata_start+0x369>
  804211f6c4:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211f6c6:	63 79 00             	movsxd 0x0(%rcx),%edi
  804211f6c9:	70 61                	jo     804211f72c <__rodata_start+0x35c>
  804211f6cb:	67 65 74 61          	addr32 gs je 804211f730 <__rodata_start+0x360>
  804211f6cf:	62 6c 65             	(bad)
  804211f6d2:	00 44 69 73          	add    %al,0x73(%rcx,%rbp,2)
  804211f6d6:	70 6c                	jo     804211f744 <__rodata_start+0x374>
  804211f6d8:	61                   	(bad)
  804211f6d9:	79 20                	jns    804211f6fb <__rodata_start+0x32b>
  804211f6db:	63 75 72             	movsxd 0x72(%rbp),%esi
  804211f6de:	72 65                	jb     804211f745 <__rodata_start+0x375>
  804211f6e0:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f6e1:	74 20                	je     804211f703 <__rodata_start+0x333>
  804211f6e3:	70 61                	jo     804211f746 <__rodata_start+0x376>
  804211f6e5:	67 65 20 74 61 62    	and    %dh,%gs:0x62(%ecx,%eiz,2)
  804211f6eb:	6c                   	insb   (%dx),%es:(%rdi)
  804211f6ec:	65 00 76 69          	add    %dh,%gs:0x69(%rsi)
  804211f6f0:	72 74                	jb     804211f766 <__rodata_start+0x396>
  804211f6f2:	00 44 69 73          	add    %al,0x73(%rcx,%rbp,2)
  804211f6f6:	70 6c                	jo     804211f764 <__rodata_start+0x394>
  804211f6f8:	61                   	(bad)
  804211f6f9:	79 20                	jns    804211f71b <__rodata_start+0x34b>
  804211f6fb:	76 69                	jbe    804211f766 <__rodata_start+0x396>
  804211f6fd:	72 74                	jb     804211f773 <__rodata_start+0x3a3>
  804211f6ff:	75 61                	jne    804211f762 <__rodata_start+0x392>
  804211f701:	6c                   	insb   (%dx),%es:(%rdi)
  804211f702:	20 6d 65             	and    %ch,0x65(%rbp)
  804211f705:	6d                   	insl   (%dx),%es:(%rdi)
  804211f706:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f707:	72 79                	jb     804211f782 <__rodata_start+0x3b2>
  804211f709:	20 74 72 65          	and    %dh,0x65(%rdx,%rsi,2)
  804211f70d:	65 00 21             	add    %ah,%gs:(%rcx)
  804211f710:	70 2d                	jo     804211f73f <__rodata_start+0x36f>
  804211f712:	3e 72 65             	jb,pt  804211f77a <__rodata_start+0x3aa>
  804211f715:	66 63 00             	movsxd (%rax),%ax
  804211f718:	6b 65 72 6e          	imul   $0x6e,0x72(%rbp),%esp
  804211f71c:	2f                   	(bad)
  804211f71d:	70 6d                	jo     804211f78c <__rodata_start+0x3bc>
  804211f71f:	61                   	(bad)
  804211f720:	70 2e                	jo     804211f750 <__rodata_start+0x380>
  804211f722:	63 00                	movsxd (%rax),%eax
  804211f724:	21 6e 6f             	and    %ebp,0x6f(%rsi)
  804211f727:	64 65 2d 3e 6c 65 66 	fs gs sub $0x66656c3e,%eax
  804211f72e:	74 20                	je     804211f750 <__rodata_start+0x380>
  804211f730:	26 26 20 21          	es es and %ah,(%rcx)
  804211f734:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f735:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f736:	64 65 2d 3e 72 69 67 	fs gs sub $0x6769723e,%eax
  804211f73d:	68 74 00 70 61       	push   $0x61700074
  804211f742:	67 65 2d 3e 63 6c 61 	addr32 gs sub $0x616c633e,%eax
  804211f749:	73 73                	jae    804211f7be <__rodata_start+0x3ee>
  804211f74b:	20 3d 3d 20 4d 41    	and    %bh,0x414d203d(%rip)        # 80835f178e <__bss_end+0x405e978e>
  804211f751:	58                   	pop    %rax
  804211f752:	5f                   	pop    %rdi
  804211f753:	43                   	rex.XB
  804211f754:	4c                   	rex.WR
  804211f755:	41 53                	push   %r11
  804211f757:	53                   	push   %rbx
  804211f758:	00 70 61             	add    %dh,0x61(%rax)
  804211f75b:	67 65 20 3d 3d 20 26 	and    %bh,%gs:0x7226203d(%eip)        # 80b43817a0 <__bss_end+0x713797a0>
  804211f762:	72 
  804211f763:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f764:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f765:	74 00                	je     804211f767 <__rodata_start+0x397>
  804211f767:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f768:	20 21                	and    %ah,(%rcx)
  804211f76a:	3d 20 26 70 61       	cmp    $0x61702620,%eax
  804211f76f:	67 65 2d 3e 68 65 61 	addr32 gs sub $0x6165683e,%eax
  804211f776:	64 00 76 2d          	add    %dh,%fs:0x2d(%rsi)
  804211f77a:	3e 70 68             	jo,pt  804211f7e5 <__rodata_start+0x415>
  804211f77d:	79 20                	jns    804211f79f <__rodata_start+0x3cf>
  804211f77f:	3d 3d 20 70 61       	cmp    $0x6170203d,%eax
  804211f784:	67 65 00 70 61       	add    %dh,%gs:0x61(%eax)
  804211f789:	67 65 2d 3e 6c 65 66 	addr32 gs sub $0x66656c3e,%eax
  804211f790:	74 2d                	je     804211f7bf <__rodata_start+0x3ef>
  804211f792:	3e 70 61             	jo,pt  804211f7f6 <__rodata_start+0x426>
  804211f795:	72 65                	jb     804211f7fc <__rodata_start+0x42c>
  804211f797:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f798:	74 20                	je     804211f7ba <__rodata_start+0x3ea>
  804211f79a:	3d 3d 20 70 61       	cmp    $0x6170203d,%eax
  804211f79f:	67 65 00 70 61       	add    %dh,%gs:0x61(%eax)
  804211f7a4:	67 65 2d 3e 72 69 67 	addr32 gs sub $0x6769723e,%eax
  804211f7ab:	68 74 2d 3e 70       	push   $0x703e2d74
  804211f7b0:	61                   	(bad)
  804211f7b1:	72 65                	jb     804211f818 <__rodata_start+0x448>
  804211f7b3:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f7b4:	74 20                	je     804211f7d6 <__rodata_start+0x406>
  804211f7b6:	3d 3d 20 70 61       	cmp    $0x6170203d,%eax
  804211f7bb:	67 65 00 63 6c       	add    %ah,%gs:0x6c(%ebx)
  804211f7c0:	61                   	(bad)
  804211f7c1:	73 73                	jae    804211f836 <__rodata_start+0x466>
  804211f7c3:	20 3e                	and    %bh,(%rsi)
  804211f7c5:	3d 20 30 00 21       	cmp    $0x21003020,%eax
  804211f7ca:	70 61                	jo     804211f82d <__rodata_start+0x45d>
  804211f7cc:	67 65 2d 3e 6c 65 66 	addr32 gs sub $0x66656c3e,%eax
  804211f7d3:	74 20                	je     804211f7f5 <__rodata_start+0x425>
  804211f7d5:	26 26 20 21          	es es and %ah,(%rcx)
  804211f7d9:	70 61                	jo     804211f83c <__rodata_start+0x46c>
  804211f7db:	67 65 2d 3e 72 69 67 	addr32 gs sub $0x6769723e,%eax
  804211f7e2:	68 74 00 25 64       	push   $0x64250074
  804211f7e7:	20 25 64 0a 00 70    	and    %ah,0x70000a64(%rip)        # 80b2120251 <__bss_end+0x6f118251>
  804211f7ed:	61                   	(bad)
  804211f7ee:	67 65 2d 3e 70 68 79 	addr32 gs sub $0x7968703e,%eax
  804211f7f5:	2d 3e 63 6c 61       	sub    $0x616c633e,%eax
  804211f7fa:	73 73                	jae    804211f86f <__rodata_start+0x49f>
  804211f7fc:	20 3d 3d 20 63 6c    	and    %bh,0x6c63203d(%rip)        # 80ae75183f <__bss_end+0x6b74983f>
  804211f802:	61                   	(bad)
  804211f803:	73 73                	jae    804211f878 <__rodata_start+0x4a8>
  804211f805:	00 21                	add    %ah,(%rcx)
  804211f807:	70 61                	jo     804211f86a <__rodata_start+0x49a>
  804211f809:	67 65 2d 3e 70 68 79 	addr32 gs sub $0x7968703e,%eax
  804211f810:	00 50 61             	add    %dl,0x61(%rax)
  804211f813:	67 65 20 74 61 62    	and    %dh,%gs:0x62(%ecx,%eiz,2)
  804211f819:	6c                   	insb   (%dx),%es:(%rdi)
  804211f81a:	65 3a 0a             	cmp    %gs:(%rdx),%cl
  804211f81d:	00 20                	add    %ah,(%rax)
  804211f81f:	3e 20 20             	ds and %ah,(%rax)
  804211f822:	20 20                	and    %ah,(%rax)
  804211f824:	3e 20 20             	ds and %ah,(%rax)
  804211f827:	20 20                	and    %ah,(%rax)
  804211f829:	3e 20 20             	ds and %ah,(%rax)
  804211f82c:	20 20                	and    %ah,(%rax)
  804211f82e:	3e 00 57 4f          	ds add %dl,0x4f(%rdi)
  804211f832:	52                   	push   %rdx
  804211f833:	4b                   	rex.WXB
  804211f834:	4f 55                	rex.WRXB push %r13
  804211f836:	54                   	push   %rsp
  804211f837:	0a 00                	or     (%rax),%al
  804211f839:	44                   	rex.R
  804211f83a:	45                   	rex.RB
  804211f83b:	42 55                	rex.X push %rbp
  804211f83d:	47 20 73 69          	rex.RXB and %r14b,0x69(%r11)
  804211f841:	7a 65                	jp     804211f8a8 <__rodata_start+0x4d8>
  804211f843:	20 25 64 0a 00 21    	and    %ah,0x21000a64(%rip)        # 80631202ad <__bss_end+0x201182ad>
  804211f849:	61                   	(bad)
  804211f84a:	6c                   	insb   (%dx),%es:(%rdi)
  804211f84b:	6c                   	insb   (%dx),%es:(%rdi)
  804211f84c:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f84d:	63 61 74             	movsxd 0x74(%rcx),%esp
  804211f850:	69 6e 67 5f 70 6f 6f 	imul   $0x6f6f705f,0x67(%rsi),%ebp
  804211f857:	6c                   	insb   (%dx),%es:(%rdi)
  804211f858:	00 21                	add    %ah,(%rcx)
  804211f85a:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f85b:	65 77 2d             	gs ja  804211f88b <__rodata_start+0x4bb>
  804211f85e:	3e 72 65             	jb,pt  804211f8c6 <__rodata_start+0x4f6>
  804211f861:	66 63 00             	movsxd (%rax),%ax
  804211f864:	4f 75 74             	rex.WRXB jne 804211f8db <__rodata_start+0x50b>
  804211f867:	20 6f 66             	and    %ch,0x66(%rdi)
  804211f86a:	20 6d 65             	and    %ch,0x65(%rbp)
  804211f86d:	6d                   	insl   (%dx),%es:(%rdi)
  804211f86e:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f86f:	72 79                	jb     804211f8ea <__rodata_start+0x51a>
  804211f871:	0a 00                	or     (%rax),%al
  804211f873:	66 72 65             	data16 jb 804211f8db <__rodata_start+0x50b>
  804211f876:	65 5f                	gs pop %rdi
  804211f878:	64 65 73 63          	fs gs jae 804211f8df <__rodata_start+0x50f>
  804211f87c:	5f                   	pop    %rdi
  804211f87d:	63 6f 75             	movsxd 0x75(%rdi),%ebp
  804211f880:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f881:	74 20                	je     804211f8a3 <__rodata_start+0x4d3>
  804211f883:	3e 3d 20 63 6f 75    	ds cmp $0x756f6320,%eax
  804211f889:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f88a:	74 00                	je     804211f88c <__rodata_start+0x4bc>
  804211f88c:	21 28                	and    %ebp,(%rax)
  804211f88e:	61                   	(bad)
  804211f88f:	64 64 72 20          	fs fs jb 804211f8b3 <__rodata_start+0x4e3>
  804211f893:	26 20 43 4c          	es and %al,0x4c(%rbx)
  804211f897:	41 53                	push   %r11
  804211f899:	53                   	push   %rbx
  804211f89a:	5f                   	pop    %rdi
  804211f89b:	4d                   	rex.WRB
  804211f89c:	41 53                	push   %r11
  804211f89e:	4b 28 63 6c          	rex.WXB sub %spl,0x6c(%r11)
  804211f8a2:	61                   	(bad)
  804211f8a3:	73 73                	jae    804211f918 <__rodata_start+0x548>
  804211f8a5:	29 29                	sub    %ebp,(%rcx)
  804211f8a7:	00 6e 6f             	add    %ch,0x6f(%rsi)
  804211f8aa:	64 65 00 21          	fs add %ah,%gs:(%rcx)
  804211f8ae:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f8af:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f8b0:	64 65 2d 3e 72 65 66 	fs gs sub $0x6665723e,%eax
  804211f8b7:	63 00                	movsxd (%rax),%eax
  804211f8b9:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f8ba:	63 6c 61 73          	movsxd 0x73(%rcx,%riz,2),%ebp
  804211f8be:	73 20                	jae    804211f8e0 <__rodata_start+0x510>
  804211f8c0:	3d 3d 20 6e 6f       	cmp    $0x6f6e203d,%eax
  804211f8c5:	64 65 2d 3e 70 68 79 	fs gs sub $0x7968703e,%eax
  804211f8cc:	2d 3e 63 6c 61       	sub    $0x616c633e,%eax
  804211f8d1:	73 73                	jae    804211f946 <__rodata_start+0x576>
  804211f8d3:	00 2a                	add    %ch,(%rdx)
  804211f8d5:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f8d6:	65 78 74             	gs js  804211f94d <__rodata_start+0x57d>
  804211f8d9:	00 69 30             	add    %ch,0x30(%rcx)
  804211f8dc:	20 3c 20             	and    %bh,(%rax,%riz,1)
  804211f8df:	69 31 00 69 31 20    	imul   $0x20316900,(%rcx),%esi
  804211f8e5:	3c 3d                	cmp    $0x3d,%al
  804211f8e7:	20 35 31 32 00 21    	and    %dh,0x21003231(%rip)        # 8063122b1e <__bss_end+0x2011ab1e>
  804211f8ed:	70 61                	jo     804211f950 <__rodata_start+0x580>
  804211f8ef:	67 65 2d 3e 72 65 66 	addr32 gs sub $0x6665723e,%eax
  804211f8f6:	63 00                	movsxd (%rax),%eax
  804211f8f8:	25 30 38 6c 58       	and    $0x586c3830,%eax
  804211f8fd:	20 25 30 38 6c 58    	and    %ah,0x586c3830(%rip)        # 809a7e3133 <__bss_end+0x577db133>
  804211f903:	0a 00                	or     (%rax),%al
  804211f905:	21 72 65             	and    %esi,0x65(%rdx)
  804211f908:	73 00                	jae    804211f90a <__rodata_start+0x53a>
  804211f90a:	70 61                	jo     804211f96d <__rodata_start+0x59d>
  804211f90c:	67 65 20 26          	and    %ah,%gs:(%esi)
  804211f910:	26 20 73 70          	es and %dh,0x70(%rbx)
  804211f914:	63 00                	movsxd (%rax),%eax
  804211f916:	21 28                	and    %ebp,(%rax)
  804211f918:	73 70                	jae    804211f98a <__rodata_start+0x5ba>
  804211f91a:	63 2d 3e 70 6d 6c    	movsxd 0x6c6d703e(%rip),%ebp        # 80ae7f695e <__bss_end+0x6b7ee95e>
  804211f920:	34 5b                	xor    $0x5b,%al
  804211f922:	70 6d                	jo     804211f991 <__rodata_start+0x5c1>
  804211f924:	6c                   	insb   (%dx),%es:(%rdi)
  804211f925:	34 69                	xor    $0x69,%al
  804211f927:	30 5d 20             	xor    %bl,0x20(%rbp)
  804211f92a:	26 20 50 54          	es and %dl,0x54(%rax)
  804211f92e:	45 5f                	rex.RB pop %r15
  804211f930:	50                   	push   %rax
  804211f931:	53                   	push   %rbx
  804211f932:	29 00                	sub    %eax,(%rax)
  804211f934:	63 75 72             	movsxd 0x72(%rbp),%esi
  804211f937:	72 65                	jb     804211f99e <__rodata_start+0x5ce>
  804211f939:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211f93a:	74 5f                	je     804211f99b <__rodata_start+0x5cb>
  804211f93c:	73 70                	jae    804211f9ae <__rodata_start+0x5de>
  804211f93e:	61                   	(bad)
  804211f93f:	63 65 20             	movsxd 0x20(%rbp),%esp
  804211f942:	3d 3d 20 26 6b       	cmp    $0x6b26203d,%eax
  804211f947:	73 70                	jae    804211f9b9 <__rodata_start+0x5e9>
  804211f949:	61                   	(bad)
  804211f94a:	63 65 00             	movsxd 0x0(%rbp),%esp
  804211f94d:	43 50                	rex.XB push %r8
  804211f94f:	55                   	push   %rbp
  804211f950:	49                   	rex.WB
  804211f951:	44 3a 20             	cmp    (%rax),%r12b
  804211f954:	31 47 42             	xor    %eax,0x42(%rdi)
  804211f957:	20 70 61             	and    %dh,0x61(%rax)
  804211f95a:	67 65 73 3a          	addr32 gs jae 804211f998 <__rodata_start+0x5c8>
  804211f95e:	20 25 64 2c 20 4e    	and    %ah,0x4e202c64(%rip)        # 80903225c8 <__bss_end+0x4d31a5c8>
  804211f964:	58                   	pop    %rax
  804211f965:	3a 20                	cmp    (%rax),%ah
  804211f967:	25 64 0a 00 7a       	and    $0x7a000a64,%eax
  804211f96c:	65 72 6f             	gs jb  804211f9de <__rodata_start+0x60e>
  804211f96f:	5f                   	pop    %rdi
  804211f970:	70 61                	jo     804211f9d3 <__rodata_start+0x603>
  804211f972:	67 65 20 26          	and    %ah,%gs:(%esi)
  804211f976:	26 20 6f 6e          	es and %ch,0x6e(%rdi)
  804211f97a:	65 5f                	gs pop %rdi
  804211f97c:	70 61                	jo     804211f9df <__rodata_start+0x60f>
  804211f97e:	67 65 00 21          	add    %ah,%gs:(%ecx)
  804211f982:	7a 65                	jp     804211f9e9 <__rodata_start+0x619>
  804211f984:	72 6f                	jb     804211f9f5 <__rodata_start+0x625>
  804211f986:	5f                   	pop    %rdi
  804211f987:	70 61                	jo     804211f9ea <__rodata_start+0x61a>
  804211f989:	67 65 5f             	addr32 gs pop %rdi
  804211f98c:	72 61                	jb     804211f9ef <__rodata_start+0x61f>
  804211f98e:	77 5b                	ja     804211f9eb <__rodata_start+0x61b>
  804211f990:	69 5d 00 63 75 72 72 	imul   $0x72727563,0x0(%rbp),%ebx
  804211f997:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211f999:	74 5f                	je     804211f9fa <__rodata_start+0x62a>
  804211f99b:	73 70                	jae    804211fa0d <__rodata_start+0x63d>
  804211f99d:	61                   	(bad)
  804211f99e:	63 65 00             	movsxd 0x0(%rbp),%esp
  804211f9a1:	21 72 65             	and    %esi,0x65(%rdx)
  804211f9a4:	73 20                	jae    804211f9c6 <__rodata_start+0x5f6>
  804211f9a6:	7c 7c                	jl     804211fa24 <__rodata_start+0x654>
  804211f9a8:	20 72 65             	and    %dh,0x65(%rdx)
  804211f9ab:	73 20                	jae    804211f9cd <__rodata_start+0x5fd>
  804211f9ad:	3d 3d 20 2d 45       	cmp    $0x452d203d,%eax
  804211f9b2:	5f                   	pop    %rdi
  804211f9b3:	46                   	rex.RX
  804211f9b4:	41 55                	push   %r13
  804211f9b6:	4c 54                	rex.WR push %rsp
  804211f9b8:	00 6e 65             	add    %ch,0x65(%rsi)
  804211f9bb:	77 76                	ja     804211fa33 <__rodata_start+0x663>
  804211f9bd:	20 26                	and    %ah,(%rsi)
  804211f9bf:	26 20 6e 65          	es and %ch,0x65(%rsi)
  804211f9c3:	77 76                	ja     804211fa3b <__rodata_start+0x66b>
  804211f9c5:	2d 3e 70 68 79       	sub    $0x7968703e,%eax
  804211f9ca:	00 64 73 70          	add    %ah,0x70(%rbx,%rsi,2)
  804211f9ce:	61                   	(bad)
  804211f9cf:	63 65 00             	movsxd 0x0(%rbp),%esp
  804211f9d2:	70 61                	jo     804211fa35 <__rodata_start+0x665>
  804211f9d4:	67 65 31 00          	xor    %eax,%gs:(%eax)
  804211f9d8:	4b                   	rex.WXB
  804211f9d9:	65 72 6e             	gs jb  804211fa4a <__rodata_start+0x67a>
  804211f9dc:	65 6c                	gs insb (%dx),%es:(%rdi)
  804211f9de:	20 68 65             	and    %ch,0x65(%rax)
  804211f9e1:	61                   	(bad)
  804211f9e2:	70 20                	jo     804211fa04 <__rodata_start+0x634>
  804211f9e4:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f9e5:	76 65                	jbe    804211fa4c <__rodata_start+0x67c>
  804211f9e7:	72 66                	jb     804211fa4f <__rodata_start+0x67f>
  804211f9e9:	6c                   	insb   (%dx),%es:(%rdi)
  804211f9ea:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f9eb:	77 0a                	ja     804211f9f7 <__rodata_start+0x627>
  804211f9ed:	00 6b 7a             	add    %ch,0x7a(%rbx)
  804211f9f0:	61                   	(bad)
  804211f9f1:	6c                   	insb   (%dx),%es:(%rdi)
  804211f9f2:	6c                   	insb   (%dx),%es:(%rdi)
  804211f9f3:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211f9f4:	63 5f 72             	movsxd 0x72(%rdi),%ebx
  804211f9f7:	65 67 69 6f 6e 3a 20 	imul   $0x6925203a,%gs:0x6e(%edi),%ebp
  804211f9fe:	25 69 
  804211fa00:	0a 00                	or     (%rax),%al
  804211fa02:	73 77                	jae    804211fa7b <__rodata_start+0x6ab>
  804211fa04:	61                   	(bad)
  804211fa05:	70 5f                	jo     804211fa66 <__rodata_start+0x696>
  804211fa07:	70 75                	jo     804211fa7e <__rodata_start+0x6ae>
  804211fa09:	73 68                	jae    804211fa73 <__rodata_start+0x6a3>
  804211fa0b:	3a 20                	cmp    (%rax),%ah
  804211fa0d:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fa0e:	75 6c                	jne    804211fa7c <__rodata_start+0x6ac>
  804211fa10:	6c                   	insb   (%dx),%es:(%rdi)
  804211fa11:	20 70 61             	and    %dh,0x61(%rax)
  804211fa14:	67 65 0a 00          	or     %gs:(%eax),%al
  804211fa18:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211fa1a:	76 5f                	jbe    804211fa7b <__rodata_start+0x6ab>
  804211fa1c:	63 72 65             	movsxd 0x65(%rdx),%esi
  804211fa1f:	61                   	(bad)
  804211fa20:	74 65                	je     804211fa87 <__rodata_start+0x6b7>
  804211fa22:	3a 20                	cmp    (%rax),%ah
  804211fa24:	25 69 00 6b 65       	and    $0x656b0069,%eax
  804211fa29:	72 6e                	jb     804211fa99 <__rodata_start+0x6c9>
  804211fa2b:	2f                   	(bad)
  804211fa2c:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211fa2e:	76 2e                	jbe    804211fa5e <__rodata_start+0x68e>
  804211fa30:	63 00                	movsxd (%rax),%eax
  804211fa32:	6c                   	insb   (%dx),%es:(%rdi)
  804211fa33:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fa34:	61                   	(bad)
  804211fa35:	64 5f                	fs pop %rdi
  804211fa37:	69 63 6f 64 65 3a 20 	imul   $0x203a6564,0x6f(%rbx),%esp
  804211fa3e:	25 69 00 52 65       	and    $0x65520069,%eax
  804211fa43:	61                   	(bad)
  804211fa44:	63 68 65             	movsxd 0x65(%rax),%ebp
  804211fa47:	64 20 75 6e          	and    %dh,%fs:0x6e(%rbp)
  804211fa4b:	72 65                	jb     804211fab2 <__rodata_start+0x6e2>
  804211fa4d:	63 68 65             	movsxd 0x65(%rax),%ebp
  804211fa50:	62 6c 65             	(bad)  {%k2}
  804211fa53:	0a 00                	or     (%rax),%al
  804211fa55:	72 74                	jb     804211facb <__rodata_start+0x6fb>
  804211fa57:	63 00                	movsxd (%rax),%eax
  804211fa59:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211fa5b:	61                   	(bad)
  804211fa5c:	62 6c 65             	(bad)  {%k4}
  804211fa5f:	64 20 69 6e          	and    %ch,%fs:0x6e(%rcx)
  804211fa63:	74 65                	je     804211faca <__rodata_start+0x6fa>
  804211fa65:	72 72                	jb     804211fad9 <__rodata_start+0x709>
  804211fa67:	75 70                	jne    804211fad9 <__rodata_start+0x709>
  804211fa69:	74 73                	je     804211fade <__rodata_start+0x70e>
  804211fa6b:	3a 00                	cmp    (%rax),%al
  804211fa6d:	20 20                	and    %ah,(%rax)
  804211fa6f:	72 31                	jb     804211faa2 <__rodata_start+0x6d2>
  804211fa71:	35 20 20 30 78       	xor    $0x78302020,%eax
  804211fa76:	25 30 38 6c 78       	and    $0x786c3830,%eax
  804211fa7b:	0a 00                	or     (%rax),%al
  804211fa7d:	20 20                	and    %ah,(%rax)
  804211fa7f:	72 31                	jb     804211fab2 <__rodata_start+0x6e2>
  804211fa81:	34 20                	xor    $0x20,%al
  804211fa83:	20 30                	and    %dh,(%rax)
  804211fa85:	78 25                	js     804211faac <__rodata_start+0x6dc>
  804211fa87:	30 38                	xor    %bh,(%rax)
  804211fa89:	6c                   	insb   (%dx),%es:(%rdi)
  804211fa8a:	78 0a                	js     804211fa96 <__rodata_start+0x6c6>
  804211fa8c:	00 20                	add    %ah,(%rax)
  804211fa8e:	20 72 31             	and    %dh,0x31(%rdx)
  804211fa91:	33 20                	xor    (%rax),%esp
  804211fa93:	20 30                	and    %dh,(%rax)
  804211fa95:	78 25                	js     804211fabc <__rodata_start+0x6ec>
  804211fa97:	30 38                	xor    %bh,(%rax)
  804211fa99:	6c                   	insb   (%dx),%es:(%rdi)
  804211fa9a:	78 0a                	js     804211faa6 <__rodata_start+0x6d6>
  804211fa9c:	00 20                	add    %ah,(%rax)
  804211fa9e:	20 72 31             	and    %dh,0x31(%rdx)
  804211faa1:	32 20                	xor    (%rax),%ah
  804211faa3:	20 30                	and    %dh,(%rax)
  804211faa5:	78 25                	js     804211facc <__rodata_start+0x6fc>
  804211faa7:	30 38                	xor    %bh,(%rax)
  804211faa9:	6c                   	insb   (%dx),%es:(%rdi)
  804211faaa:	78 0a                	js     804211fab6 <__rodata_start+0x6e6>
  804211faac:	00 20                	add    %ah,(%rax)
  804211faae:	20 72 31             	and    %dh,0x31(%rdx)
  804211fab1:	31 20                	xor    %esp,(%rax)
  804211fab3:	20 30                	and    %dh,(%rax)
  804211fab5:	78 25                	js     804211fadc <__rodata_start+0x70c>
  804211fab7:	30 38                	xor    %bh,(%rax)
  804211fab9:	6c                   	insb   (%dx),%es:(%rdi)
  804211faba:	78 0a                	js     804211fac6 <__rodata_start+0x6f6>
  804211fabc:	00 20                	add    %ah,(%rax)
  804211fabe:	20 72 31             	and    %dh,0x31(%rdx)
  804211fac1:	30 20                	xor    %ah,(%rax)
  804211fac3:	20 30                	and    %dh,(%rax)
  804211fac5:	78 25                	js     804211faec <__rodata_start+0x71c>
  804211fac7:	30 38                	xor    %bh,(%rax)
  804211fac9:	6c                   	insb   (%dx),%es:(%rdi)
  804211faca:	78 0a                	js     804211fad6 <__rodata_start+0x706>
  804211facc:	00 20                	add    %ah,(%rax)
  804211face:	20 72 39             	and    %dh,0x39(%rdx)
  804211fad1:	20 20                	and    %ah,(%rax)
  804211fad3:	20 30                	and    %dh,(%rax)
  804211fad5:	78 25                	js     804211fafc <__rodata_start+0x72c>
  804211fad7:	30 38                	xor    %bh,(%rax)
  804211fad9:	6c                   	insb   (%dx),%es:(%rdi)
  804211fada:	78 0a                	js     804211fae6 <__rodata_start+0x716>
  804211fadc:	00 20                	add    %ah,(%rax)
  804211fade:	20 72 38             	and    %dh,0x38(%rdx)
  804211fae1:	20 20                	and    %ah,(%rax)
  804211fae3:	20 30                	and    %dh,(%rax)
  804211fae5:	78 25                	js     804211fb0c <__rodata_start+0x73c>
  804211fae7:	30 38                	xor    %bh,(%rax)
  804211fae9:	6c                   	insb   (%dx),%es:(%rdi)
  804211faea:	78 0a                	js     804211faf6 <__rodata_start+0x726>
  804211faec:	00 20                	add    %ah,(%rax)
  804211faee:	20 72 64             	and    %dh,0x64(%rdx)
  804211faf1:	69 20 20 30 78 25    	imul   $0x25783020,(%rax),%esp
  804211faf7:	30 38                	xor    %bh,(%rax)
  804211faf9:	6c                   	insb   (%dx),%es:(%rdi)
  804211fafa:	78 0a                	js     804211fb06 <__rodata_start+0x736>
  804211fafc:	00 20                	add    %ah,(%rax)
  804211fafe:	20 72 73             	and    %dh,0x73(%rdx)
  804211fb01:	69 20 20 30 78 25    	imul   $0x25783020,(%rax),%esp
  804211fb07:	30 38                	xor    %bh,(%rax)
  804211fb09:	6c                   	insb   (%dx),%es:(%rdi)
  804211fb0a:	78 0a                	js     804211fb16 <__rodata_start+0x746>
  804211fb0c:	00 20                	add    %ah,(%rax)
  804211fb0e:	20 72 62             	and    %dh,0x62(%rdx)
  804211fb11:	70 20                	jo     804211fb33 <__rodata_start+0x763>
  804211fb13:	20 30                	and    %dh,(%rax)
  804211fb15:	78 25                	js     804211fb3c <__rodata_start+0x76c>
  804211fb17:	30 38                	xor    %bh,(%rax)
  804211fb19:	6c                   	insb   (%dx),%es:(%rdi)
  804211fb1a:	78 0a                	js     804211fb26 <__rodata_start+0x756>
  804211fb1c:	00 20                	add    %ah,(%rax)
  804211fb1e:	20 72 62             	and    %dh,0x62(%rdx)
  804211fb21:	78 20                	js     804211fb43 <__rodata_start+0x773>
  804211fb23:	20 30                	and    %dh,(%rax)
  804211fb25:	78 25                	js     804211fb4c <__rodata_start+0x77c>
  804211fb27:	30 38                	xor    %bh,(%rax)
  804211fb29:	6c                   	insb   (%dx),%es:(%rdi)
  804211fb2a:	78 0a                	js     804211fb36 <__rodata_start+0x766>
  804211fb2c:	00 20                	add    %ah,(%rax)
  804211fb2e:	20 72 64             	and    %dh,0x64(%rdx)
  804211fb31:	78 20                	js     804211fb53 <__rodata_start+0x783>
  804211fb33:	20 30                	and    %dh,(%rax)
  804211fb35:	78 25                	js     804211fb5c <__rodata_start+0x78c>
  804211fb37:	30 38                	xor    %bh,(%rax)
  804211fb39:	6c                   	insb   (%dx),%es:(%rdi)
  804211fb3a:	78 0a                	js     804211fb46 <__rodata_start+0x776>
  804211fb3c:	00 20                	add    %ah,(%rax)
  804211fb3e:	20 72 63             	and    %dh,0x63(%rdx)
  804211fb41:	78 20                	js     804211fb63 <__rodata_start+0x793>
  804211fb43:	20 30                	and    %dh,(%rax)
  804211fb45:	78 25                	js     804211fb6c <__rodata_start+0x79c>
  804211fb47:	30 38                	xor    %bh,(%rax)
  804211fb49:	6c                   	insb   (%dx),%es:(%rdi)
  804211fb4a:	78 0a                	js     804211fb56 <__rodata_start+0x786>
  804211fb4c:	00 20                	add    %ah,(%rax)
  804211fb4e:	20 72 61             	and    %dh,0x61(%rdx)
  804211fb51:	78 20                	js     804211fb73 <__rodata_start+0x7a3>
  804211fb53:	20 30                	and    %dh,(%rax)
  804211fb55:	78 25                	js     804211fb7c <__rodata_start+0x7ac>
  804211fb57:	30 38                	xor    %bh,(%rax)
  804211fb59:	6c                   	insb   (%dx),%es:(%rdi)
  804211fb5a:	78 0a                	js     804211fb66 <__rodata_start+0x796>
  804211fb5c:	00 53 79             	add    %dl,0x79(%rbx)
  804211fb5f:	73 74                	jae    804211fbd5 <__rodata_start+0x805>
  804211fb61:	65 6d                	gs insl (%dx),%es:(%rdi)
  804211fb63:	20 63 61             	and    %ah,0x61(%rbx)
  804211fb66:	6c                   	insb   (%dx),%es:(%rdi)
  804211fb67:	6c                   	insb   (%dx),%es:(%rdi)
  804211fb68:	00 28                	add    %ch,(%rax)
  804211fb6a:	75 6e                	jne    804211fbda <__rodata_start+0x80a>
  804211fb6c:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
  804211fb70:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fb71:	20 74 72 61          	and    %dh,0x61(%rdx,%rsi,2)
  804211fb75:	70 29                	jo     804211fba0 <__rodata_start+0x7d0>
  804211fb77:	00 48 61             	add    %cl,0x61(%rax)
  804211fb7a:	72 64                	jb     804211fbe0 <__rodata_start+0x810>
  804211fb7c:	77 61                	ja     804211fbdf <__rodata_start+0x80f>
  804211fb7e:	72 65                	jb     804211fbe5 <__rodata_start+0x815>
  804211fb80:	20 49 6e             	and    %cl,0x6e(%rcx)
  804211fb83:	74 65                	je     804211fbea <__rodata_start+0x81a>
  804211fb85:	72 72                	jb     804211fbf9 <__rodata_start+0x829>
  804211fb87:	75 70                	jne    804211fbf9 <__rodata_start+0x829>
  804211fb89:	74 00                	je     804211fb8b <__rodata_start+0x7bb>
  804211fb8b:	70 72                	jo     804211fbff <__rodata_start+0x82f>
  804211fb8d:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fb8e:	74 65                	je     804211fbf5 <__rodata_start+0x825>
  804211fb90:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
  804211fb94:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fb95:	00 6e 6f             	add    %ch,0x6f(%rsi)
  804211fb98:	74 2d                	je     804211fbc7 <__rodata_start+0x7f7>
  804211fb9a:	70 72                	jo     804211fc0e <__rodata_start+0x83e>
  804211fb9c:	65 73 65             	gs jae 804211fc04 <__rodata_start+0x834>
  804211fb9f:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fba0:	74 00                	je     804211fba2 <__rodata_start+0x7d2>
  804211fba2:	72 65                	jb     804211fc09 <__rodata_start+0x839>
  804211fba4:	61                   	(bad)
  804211fba5:	64 00 77 72          	add    %dh,%fs:0x72(%rdi)
  804211fba9:	69 74 65 00 65 78 65 	imul   $0x63657865,0x0(%rbp,%riz,2),%esi
  804211fbb0:	63 
  804211fbb1:	75 74                	jne    804211fc27 <__rodata_start+0x857>
  804211fbb3:	65 00 75 73          	add    %dh,%gs:0x73(%rbp)
  804211fbb7:	65 72 00             	gs jb  804211fbba <__rodata_start+0x7ea>
  804211fbba:	54                   	push   %rsp
  804211fbbb:	52                   	push   %rdx
  804211fbbc:	41 50                	push   %r8
  804211fbbe:	20 66 72             	and    %ah,0x72(%rsi)
  804211fbc1:	61                   	(bad)
  804211fbc2:	6d                   	insl   (%dx),%es:(%rdi)
  804211fbc3:	65 20 61 74          	and    %ah,%gs:0x74(%rcx)
  804211fbc7:	20 25 70 0a 00 20    	and    %ah,0x20000a70(%rip)        # 806212063d <__bss_end+0x1f11863d>
  804211fbcd:	20 65 73             	and    %ah,0x73(%rbp)
  804211fbd0:	20 20                	and    %ah,(%rax)
  804211fbd2:	20 30                	and    %dh,(%rax)
  804211fbd4:	78 2d                	js     804211fc03 <__rodata_start+0x833>
  804211fbd6:	2d 2d 2d 25 30       	sub    $0x30252d2d,%eax
  804211fbdb:	34 78                	xor    $0x78,%al
  804211fbdd:	0a 00                	or     (%rax),%al
  804211fbdf:	20 20                	and    %ah,(%rax)
  804211fbe1:	64 73 20             	fs jae 804211fc04 <__rodata_start+0x834>
  804211fbe4:	20 20                	and    %ah,(%rax)
  804211fbe6:	30 78 2d             	xor    %bh,0x2d(%rax)
  804211fbe9:	2d 2d 2d 25 30       	sub    $0x30252d2d,%eax
  804211fbee:	34 78                	xor    $0x78,%al
  804211fbf0:	0a 00                	or     (%rax),%al
  804211fbf2:	20 20                	and    %ah,(%rax)
  804211fbf4:	74 72                	je     804211fc68 <__rodata_start+0x898>
  804211fbf6:	61                   	(bad)
  804211fbf7:	70 20                	jo     804211fc19 <__rodata_start+0x849>
  804211fbf9:	30 78 25             	xor    %bh,0x25(%rax)
  804211fbfc:	30 38                	xor    %bh,(%rax)
  804211fbfe:	6c                   	insb   (%dx),%es:(%rdi)
  804211fbff:	78 20                	js     804211fc21 <__rodata_start+0x851>
  804211fc01:	25 73 0a 00 20       	and    $0x20000a73,%eax
  804211fc06:	20 63 72             	and    %ah,0x72(%rbx)
  804211fc09:	32 20                	xor    (%rax),%ah
  804211fc0b:	20 30                	and    %dh,(%rax)
  804211fc0d:	78 25                	js     804211fc34 <__rodata_start+0x864>
  804211fc0f:	30 38                	xor    %bh,(%rax)
  804211fc11:	6c                   	insb   (%dx),%es:(%rdi)
  804211fc12:	78 0a                	js     804211fc1e <__rodata_start+0x84e>
  804211fc14:	00 20                	add    %ah,(%rax)
  804211fc16:	20 65 72             	and    %ah,0x72(%rbp)
  804211fc19:	72 20                	jb     804211fc3b <__rodata_start+0x86b>
  804211fc1b:	20 30                	and    %dh,(%rax)
  804211fc1d:	78 25                	js     804211fc44 <__rodata_start+0x874>
  804211fc1f:	30 38                	xor    %bh,(%rax)
  804211fc21:	6c                   	insb   (%dx),%es:(%rdi)
  804211fc22:	78 00                	js     804211fc24 <__rodata_start+0x854>
  804211fc24:	20 5b 25             	and    %bl,0x25(%rbx)
  804211fc27:	73 2c                	jae    804211fc55 <__rodata_start+0x885>
  804211fc29:	20 25 73 2c 20 25    	and    %ah,0x25202c73(%rip)        # 80673228a2 <__bss_end+0x2431a8a2>
  804211fc2f:	73 5d                	jae    804211fc8e <__rodata_start+0x8be>
  804211fc31:	0a 00                	or     (%rax),%al
  804211fc33:	20 20                	and    %ah,(%rax)
  804211fc35:	72 69                	jb     804211fca0 <__rodata_start+0x8d0>
  804211fc37:	70 20                	jo     804211fc59 <__rodata_start+0x889>
  804211fc39:	20 30                	and    %dh,(%rax)
  804211fc3b:	78 25                	js     804211fc62 <__rodata_start+0x892>
  804211fc3d:	30 38                	xor    %bh,(%rax)
  804211fc3f:	6c                   	insb   (%dx),%es:(%rdi)
  804211fc40:	78 0a                	js     804211fc4c <__rodata_start+0x87c>
  804211fc42:	00 20                	add    %ah,(%rax)
  804211fc44:	20 63 73             	and    %ah,0x73(%rbx)
  804211fc47:	20 20                	and    %ah,(%rax)
  804211fc49:	20 30                	and    %dh,(%rax)
  804211fc4b:	78 2d                	js     804211fc7a <__rodata_start+0x8aa>
  804211fc4d:	2d 2d 2d 25 30       	sub    $0x30252d2d,%eax
  804211fc52:	34 78                	xor    $0x78,%al
  804211fc54:	0a 00                	or     (%rax),%al
  804211fc56:	20 20                	and    %ah,(%rax)
  804211fc58:	66 6c                	data16 insb (%dx),%es:(%rdi)
  804211fc5a:	61                   	(bad)
  804211fc5b:	67 20 30             	and    %dh,(%eax)
  804211fc5e:	78 25                	js     804211fc85 <__rodata_start+0x8b5>
  804211fc60:	30 38                	xor    %bh,(%rax)
  804211fc62:	6c                   	insb   (%dx),%es:(%rdi)
  804211fc63:	78 0a                	js     804211fc6f <__rodata_start+0x89f>
  804211fc65:	00 20                	add    %ah,(%rax)
  804211fc67:	20 72 73             	and    %dh,0x73(%rdx)
  804211fc6a:	70 20                	jo     804211fc8c <__rodata_start+0x8bc>
  804211fc6c:	20 30                	and    %dh,(%rax)
  804211fc6e:	78 25                	js     804211fc95 <__rodata_start+0x8c5>
  804211fc70:	30 38                	xor    %bh,(%rax)
  804211fc72:	6c                   	insb   (%dx),%es:(%rdi)
  804211fc73:	78 0a                	js     804211fc7f <__rodata_start+0x8af>
  804211fc75:	00 20                	add    %ah,(%rax)
  804211fc77:	20 73 73             	and    %dh,0x73(%rbx)
  804211fc7a:	20 20                	and    %ah,(%rax)
  804211fc7c:	20 30                	and    %dh,(%rax)
  804211fc7e:	78 2d                	js     804211fcad <__rodata_start+0x8dd>
  804211fc80:	2d 2d 2d 25 30       	sub    $0x30252d2d,%eax
  804211fc85:	34 78                	xor    $0x78,%al
  804211fc87:	0a 00                	or     (%rax),%al
  804211fc89:	21 28                	and    %ebp,(%rax)
  804211fc8b:	72 65                	jb     804211fcf2 <__rodata_start+0x922>
  804211fc8d:	61                   	(bad)
  804211fc8e:	64 5f                	fs pop %rdi
  804211fc90:	72 66                	jb     804211fcf8 <__rodata_start+0x928>
  804211fc92:	6c                   	insb   (%dx),%es:(%rdi)
  804211fc93:	61                   	(bad)
  804211fc94:	67 73 28             	addr32 jae 804211fcbf <__rodata_start+0x8ef>
  804211fc97:	29 20                	sub    %esp,(%rax)
  804211fc99:	26 20 46 4c          	es and %al,0x4c(%rsi)
  804211fc9d:	5f                   	pop    %rdi
  804211fc9e:	49                   	rex.WB
  804211fc9f:	46 29 00             	rex.RX sub %r8d,(%rax)
  804211fca2:	6b 65 72 6e          	imul   $0x6e,0x72(%rbp),%esp
  804211fca6:	2f                   	(bad)
  804211fca7:	74 72                	je     804211fd1b <__rodata_start+0x94b>
  804211fca9:	61                   	(bad)
  804211fcaa:	70 2e                	jo     804211fcda <__rodata_start+0x90a>
  804211fcac:	63 00                	movsxd (%rax),%eax
  804211fcae:	21 69 6e             	and    %ebp,0x6e(%rcx)
  804211fcb1:	5f                   	pop    %rdi
  804211fcb2:	70 61                	jo     804211fd15 <__rodata_start+0x945>
  804211fcb4:	67 65 5f             	addr32 gs pop %rdi
  804211fcb7:	66 61                	data16 (bad)
  804211fcb9:	75 6c                	jne    804211fd27 <__rodata_start+0x957>
  804211fcbb:	74 00                	je     804211fcbd <__rodata_start+0x8ed>
  804211fcbd:	63 75 72             	movsxd 0x72(%rbp),%esi
  804211fcc0:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211fcc2:	76 00                	jbe    804211fcc4 <__rodata_start+0x8f4>
  804211fcc4:	4b                   	rex.WXB
  804211fcc5:	65 72 6e             	gs jb  804211fd36 <__rodata_start+0x966>
  804211fcc8:	65 6c                	gs insb (%dx),%es:(%rdi)
  804211fcca:	20 70 61             	and    %dh,0x61(%rax)
  804211fccd:	67 65 66 61          	addr32 gs data16 (bad)
  804211fcd1:	75 6c                	jne    804211fd3f <__rodata_start+0x96f>
  804211fcd3:	74 0a                	je     804211fcdf <__rodata_start+0x90f>
  804211fcd5:	00 55 6e             	add    %dl,0x6e(%rbp)
  804211fcd8:	68 61 6e 64 6c       	push   $0x6c646e61
  804211fcdd:	65 64 20 74 72 61    	gs and %dh,%fs:0x61(%rdx,%rsi,2)
  804211fce3:	70 20                	jo     804211fd05 <__rodata_start+0x935>
  804211fce5:	69 6e 20 6b 65 72 6e 	imul   $0x6e72656b,0x20(%rsi),%ebp
  804211fcec:	65 6c                	gs insb (%dx),%es:(%rdi)
  804211fcee:	00 44 69 76          	add    %al,0x76(%rcx,%rbp,2)
  804211fcf2:	69 64 65 20 65 72 72 	imul   $0x6f727265,0x20(%rbp,%riz,2),%esp
  804211fcf9:	6f 
  804211fcfa:	72 00                	jb     804211fcfc <__rodata_start+0x92c>
  804211fcfc:	44                   	rex.R
  804211fcfd:	65 62 75 67 00 4e    	(bad)
  804211fd03:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fd04:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fd05:	2d 4d 61 73 6b       	sub    $0x6b73614d,%eax
  804211fd0a:	61                   	(bad)
  804211fd0b:	62 6c 65             	(bad)
  804211fd0e:	20 49 6e             	and    %cl,0x6e(%rcx)
  804211fd11:	74 65                	je     804211fd78 <__rodata_start+0x9a8>
  804211fd13:	72 72                	jb     804211fd87 <__rodata_start+0x9b7>
  804211fd15:	75 70                	jne    804211fd87 <__rodata_start+0x9b7>
  804211fd17:	74 00                	je     804211fd19 <__rodata_start+0x949>
  804211fd19:	42 72 65             	rex.X jb 804211fd81 <__rodata_start+0x9b1>
  804211fd1c:	61                   	(bad)
  804211fd1d:	6b 70 6f 69          	imul   $0x69,0x6f(%rax),%esi
  804211fd21:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fd22:	74 00                	je     804211fd24 <__rodata_start+0x954>
  804211fd24:	4f 76 65             	rex.WRXB jbe 804211fd8c <__rodata_start+0x9bc>
  804211fd27:	72 66                	jb     804211fd8f <__rodata_start+0x9bf>
  804211fd29:	6c                   	insb   (%dx),%es:(%rdi)
  804211fd2a:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fd2b:	77 00                	ja     804211fd2d <__rodata_start+0x95d>
  804211fd2d:	42                   	rex.X
  804211fd2e:	4f 55                	rex.WRXB push %r13
  804211fd30:	4e                   	rex.WRX
  804211fd31:	44 20 52 61          	and    %r10b,0x61(%rdx)
  804211fd35:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fd36:	67 65 20 45 78       	and    %al,%gs:0x78(%ebp)
  804211fd3b:	63 65 65             	movsxd 0x65(%rbp),%esp
  804211fd3e:	64 65 64 00 49 6e    	fs gs add %cl,%fs:0x6e(%rcx)
  804211fd44:	76 61                	jbe    804211fda7 <__rodata_start+0x9d7>
  804211fd46:	6c                   	insb   (%dx),%es:(%rdi)
  804211fd47:	69 64 20 4f 70 63 6f 	imul   $0x646f6370,0x4f(%rax,%riz,1),%esp
  804211fd4e:	64 
  804211fd4f:	65 00 44 65 76       	add    %al,%gs:0x76(%rbp,%riz,2)
  804211fd54:	69 63 65 20 4e 6f 74 	imul   $0x746f4e20,0x65(%rbx),%esp
  804211fd5b:	20 41 76             	and    %al,0x76(%rcx)
  804211fd5e:	61                   	(bad)
  804211fd5f:	69 6c 61 62 6c 65 00 	imul   $0x4400656c,0x62(%rcx,%riz,2),%ebp
  804211fd66:	44 
  804211fd67:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fd68:	75 62                	jne    804211fdcc <__rodata_start+0x9fc>
  804211fd6a:	6c                   	insb   (%dx),%es:(%rdi)
  804211fd6b:	65 20 46 61          	and    %al,%gs:0x61(%rsi)
  804211fd6f:	75 6c                	jne    804211fddd <__rodata_start+0xa0d>
  804211fd71:	74 00                	je     804211fd73 <__rodata_start+0x9a3>
  804211fd73:	43 6f                	rex.XB outsl %ds:(%rsi),(%dx)
  804211fd75:	70 72                	jo     804211fde9 <__rodata_start+0xa19>
  804211fd77:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fd78:	63 65 73             	movsxd 0x73(%rbp),%esp
  804211fd7b:	73 6f                	jae    804211fdec <__rodata_start+0xa1c>
  804211fd7d:	72 20                	jb     804211fd9f <__rodata_start+0x9cf>
  804211fd7f:	53                   	push   %rbx
  804211fd80:	65 67 6d             	gs insl (%dx),%es:(%edi)
  804211fd83:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211fd85:	74 20                	je     804211fda7 <__rodata_start+0x9d7>
  804211fd87:	4f 76 65             	rex.WRXB jbe 804211fdef <__rodata_start+0xa1f>
  804211fd8a:	72 72                	jb     804211fdfe <__rodata_start+0xa2e>
  804211fd8c:	75 6e                	jne    804211fdfc <__rodata_start+0xa2c>
  804211fd8e:	00 49 6e             	add    %cl,0x6e(%rcx)
  804211fd91:	76 61                	jbe    804211fdf4 <__rodata_start+0xa24>
  804211fd93:	6c                   	insb   (%dx),%es:(%rdi)
  804211fd94:	69 64 20 54 53 53 00 	imul   $0x53005353,0x54(%rax,%riz,1),%esp
  804211fd9b:	53 
  804211fd9c:	65 67 6d             	gs insl (%dx),%es:(%edi)
  804211fd9f:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211fda1:	74 20                	je     804211fdc3 <__rodata_start+0x9f3>
  804211fda3:	4e 6f                	rex.WRX outsl %ds:(%rsi),(%dx)
  804211fda5:	74 20                	je     804211fdc7 <__rodata_start+0x9f7>
  804211fda7:	50                   	push   %rax
  804211fda8:	72 65                	jb     804211fe0f <__rodata_start+0xa3f>
  804211fdaa:	73 65                	jae    804211fe11 <__rodata_start+0xa41>
  804211fdac:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fdad:	74 00                	je     804211fdaf <__rodata_start+0x9df>
  804211fdaf:	53                   	push   %rbx
  804211fdb0:	74 61                	je     804211fe13 <__rodata_start+0xa43>
  804211fdb2:	63 6b 20             	movsxd 0x20(%rbx),%ebp
  804211fdb5:	46 61                	rex.RX (bad)
  804211fdb7:	75 6c                	jne    804211fe25 <__rodata_start+0xa55>
  804211fdb9:	74 00                	je     804211fdbb <__rodata_start+0x9eb>
  804211fdbb:	47                   	rex.RXB
  804211fdbc:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211fdbe:	65 72 61             	gs jb  804211fe22 <__rodata_start+0xa52>
  804211fdc1:	6c                   	insb   (%dx),%es:(%rdi)
  804211fdc2:	20 50 72             	and    %dl,0x72(%rax)
  804211fdc5:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fdc6:	74 65                	je     804211fe2d <__rodata_start+0xa5d>
  804211fdc8:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
  804211fdcc:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fdcd:	00 50 61             	add    %dl,0x61(%rax)
  804211fdd0:	67 65 20 46 61       	and    %al,%gs:0x61(%esi)
  804211fdd5:	75 6c                	jne    804211fe43 <__rodata_start+0xa73>
  804211fdd7:	74 00                	je     804211fdd9 <__rodata_start+0xa09>
  804211fdd9:	78 38                	js     804211fe13 <__rodata_start+0xa43>
  804211fddb:	37                   	(bad)
  804211fddc:	20 46 50             	and    %al,0x50(%rsi)
  804211fddf:	55                   	push   %rbp
  804211fde0:	20 46 6c             	and    %al,0x6c(%rsi)
  804211fde3:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fde4:	61                   	(bad)
  804211fde5:	74 69                	je     804211fe50 <__rodata_start+0xa80>
  804211fde7:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fde8:	67 2d 50 6f 69 6e    	addr32 sub $0x6e696f50,%eax
  804211fdee:	74 20                	je     804211fe10 <__rodata_start+0xa40>
  804211fdf0:	45 72 72             	rex.RB jb 804211fe65 <__rodata_start+0xa95>
  804211fdf3:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fdf4:	72 00                	jb     804211fdf6 <__rodata_start+0xa26>
  804211fdf6:	41 6c                	rex.B insb (%dx),%es:(%rdi)
  804211fdf8:	69 67 6e 6d 65 6e 74 	imul   $0x746e656d,0x6e(%rdi),%esp
  804211fdff:	20 43 68             	and    %al,0x68(%rbx)
  804211fe02:	65 63 6b 00          	movsxd %gs:0x0(%rbx),%ebp
  804211fe06:	4d 61                	rex.WRB (bad)
  804211fe08:	63 68 69             	movsxd 0x69(%rax),%ebp
  804211fe0b:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fe0c:	65 2d 43 68 65 63    	gs sub $0x63656843,%eax
  804211fe12:	6b 00 53             	imul   $0x53,(%rax),%eax
  804211fe15:	49                   	rex.WB
  804211fe16:	4d                   	rex.WRB
  804211fe17:	44 20 46 6c          	and    %r8b,0x6c(%rsi)
  804211fe1b:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211fe1c:	61                   	(bad)
  804211fe1d:	74 69                	je     804211fe88 <__rodata_start+0xab8>
  804211fe1f:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fe20:	67 2d 50 6f 69 6e    	addr32 sub $0x6e696f50,%eax
  804211fe26:	74 20                	je     804211fe48 <__rodata_start+0xa78>
  804211fe28:	45 78 63             	rex.RB js 804211fe8e <__rodata_start+0xabe>
  804211fe2b:	65 70 74             	gs jo  804211fea2 <__rodata_start+0xad2>
  804211fe2e:	69 6f 6e 00 4e 6f 20 	imul   $0x206f4e00,0x6e(%rdi),%ebp
  804211fe35:	72 73                	jb     804211feaa <__rodata_start+0xada>
  804211fe37:	64 70 0a             	fs jo  804211fe44 <__rodata_start+0xa74>
  804211fe3a:	00 6b 65             	add    %ch,0x65(%rbx)
  804211fe3d:	72 6e                	jb     804211fead <__rodata_start+0xadd>
  804211fe3f:	2f                   	(bad)
  804211fe40:	74 69                	je     804211feab <__rodata_start+0xadb>
  804211fe42:	6d                   	insl   (%dx),%es:(%rdi)
  804211fe43:	65 72 2e             	gs jb  804211fe74 <__rodata_start+0xaa4>
  804211fe46:	63 00                	movsxd (%rax),%eax
  804211fe48:	49 6e                	rex.WB outsb %ds:(%rsi),(%dx)
  804211fe4a:	76 61                	jbe    804211fead <__rodata_start+0xadd>
  804211fe4c:	6c                   	insb   (%dx),%es:(%rdi)
  804211fe4d:	69 64 20 52 53 44 50 	imul   $0xa504453,0x52(%rax,%riz,1),%esp
  804211fe54:	0a 
  804211fe55:	00 52 53             	add    %dl,0x53(%rdx)
  804211fe58:	44 54                	rex.R push %rsp
  804211fe5a:	00 49 6e             	add    %cl,0x6e(%rcx)
  804211fe5d:	76 61                	jbe    804211fec0 <__rodata_start+0xaf0>
  804211fe5f:	6c                   	insb   (%dx),%es:(%rdi)
  804211fe60:	69 64 20 52 53 44 54 	imul   $0xa544453,0x52(%rax,%riz,1),%esp
  804211fe67:	0a 
  804211fe68:	00 58 53             	add    %bl,0x53(%rax)
  804211fe6b:	44 54                	rex.R push %rsp
  804211fe6d:	00 49 6e             	add    %cl,0x6e(%rcx)
  804211fe70:	76 61                	jbe    804211fed3 <__rodata_start+0xb03>
  804211fe72:	6c                   	insb   (%dx),%es:(%rdi)
  804211fe73:	69 64 20 41 43 50 49 	imul   $0x20495043,0x41(%rax,%riz,1),%esp
  804211fe7a:	20 
  804211fe7b:	74 61                	je     804211fede <__rodata_start+0xb0e>
  804211fe7d:	62 6c 65             	(bad)
  804211fe80:	20 27                	and    %ah,(%rdi)
  804211fe82:	25 2e 34 73 27       	and    $0x2773342e,%eax
  804211fe87:	00 4d 43             	add    %cl,0x43(%rbp)
  804211fe8a:	46                   	rex.RX
  804211fe8b:	47 00 4d 43          	rex.RXB add %r9b,0x43(%r13)
  804211fe8f:	46                   	rex.RX
  804211fe90:	47 20 74 61 62       	and    %r14b,0x62(%r9,%r12,2)
  804211fe95:	6c                   	insb   (%dx),%es:(%rdi)
  804211fe96:	65 20 69 73          	and    %ch,%gs:0x73(%rcx)
  804211fe9a:	20 61 62             	and    %ah,0x62(%rcx)
  804211fe9d:	73 65                	jae    804211ff04 <__rodata_start+0xb34>
  804211fe9f:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fea0:	74 21                	je     804211fec3 <__rodata_start+0xaf3>
  804211fea2:	00 66 73             	add    %ah,0x73(%rsi)
  804211fea5:	00 65 63             	add    %ah,0x63(%rbp)
  804211fea8:	61                   	(bad)
  804211fea9:	6d                   	insl   (%dx),%es:(%rdi)
  804211feaa:	3d 25 6c 6c 78       	cmp    $0x786c6c25,%eax
  804211feaf:	3a 25 30 34 78 3a    	cmp    0x3a783430(%rip),%ah        # 807c8a32e5 <__bss_end+0x3989b2e5>
  804211feb5:	25 30 32 78 3a       	and    $0x3a783230,%eax
  804211feba:	25 30 32 78 00       	and    $0x783230,%eax
  804211febf:	74 73                	je     804211ff34 <__rodata_start+0xb64>
  804211fec1:	63 66 72             	movsxd 0x72(%rsi),%esp
  804211fec4:	65 71 3d             	gs jno 804211ff04 <__rodata_start+0xb34>
  804211fec7:	25 6c 6c 78 00       	and    $0x786c6c,%eax
  804211fecc:	46                   	rex.RX
  804211fecd:	41                   	rex.B
  804211fece:	43 50                	rex.XB push %r8
  804211fed0:	00 48 50             	add    %cl,0x50(%rax)
  804211fed3:	45 54                	rex.RB push %r12
  804211fed5:	00 68 70             	add    %ch,0x70(%rax)
  804211fed8:	65 74 20             	gs je  804211fefb <__rodata_start+0xb2b>
  804211fedb:	69 73 20 75 6e 61 76 	imul   $0x76616e75,0x20(%rbx),%esi
  804211fee2:	61                   	(bad)
  804211fee3:	69 6c 61 62 6c 65 0a 	imul   $0xa656c,0x62(%rcx,%riz,2),%ebp
  804211feea:	00 
  804211feeb:	68 70 65 74 20       	push   $0x20746570
  804211fef0:	21 3d 20 4e 55 4c    	and    %edi,0x4c554e20(%rip)        # 808e674d16 <__bss_end+0x4b66cd16>
  804211fef6:	4c 00 73 69          	rex.WR add %r14b,0x69(%rbx)
  804211fefa:	67 6e                	outsb  %ds:(%esi),(%dx)
  804211fefc:	61                   	(bad)
  804211fefd:	74 75                	je     804211ff74 <__rodata_start+0xba4>
  804211feff:	72 65                	jb     804211ff66 <__rodata_start+0xb96>
  804211ff01:	20 3d 20 25 73 0a    	and    %bh,0xa732520(%rip)        # 804c852427 <__bss_end+0x984a427>
  804211ff07:	00 6c 65 6e          	add    %ch,0x6e(%rbp,%riz,2)
  804211ff0b:	67 74 68             	addr32 je 804211ff76 <__rodata_start+0xba6>
  804211ff0e:	20 3d 20 25 30 38    	and    %bh,0x38302520(%rip)        # 807a422434 <__bss_end+0x3741a434>
  804211ff14:	78 0a                	js     804211ff20 <__rodata_start+0xb50>
  804211ff16:	00 63 68             	add    %ah,0x68(%rbx)
  804211ff19:	65 63 6b 73          	movsxd %gs:0x73(%rbx),%ebp
  804211ff1d:	75 6d                	jne    804211ff8c <__rodata_start+0xbbc>
  804211ff1f:	20 3d 20 25 30 38    	and    %bh,0x38302520(%rip)        # 807a422445 <__bss_end+0x3741a445>
  804211ff25:	78 0a                	js     804211ff31 <__rodata_start+0xb61>
  804211ff27:	00 6f 65             	add    %ch,0x65(%rdi)
  804211ff2a:	6d                   	insl   (%dx),%es:(%rdi)
  804211ff2b:	5f                   	pop    %rdi
  804211ff2c:	72 65                	jb     804211ff93 <__rodata_start+0xbc3>
  804211ff2e:	76 69                	jbe    804211ff99 <__rodata_start+0xbc9>
  804211ff30:	73 69                	jae    804211ff9b <__rodata_start+0xbcb>
  804211ff32:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211ff33:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211ff34:	20 3d 20 25 30 38    	and    %bh,0x38302520(%rip)        # 807a42245a <__bss_end+0x3741a45a>
  804211ff3a:	78 0a                	js     804211ff46 <__rodata_start+0xb76>
  804211ff3c:	00 63 72             	add    %ah,0x72(%rbx)
  804211ff3f:	65 61                	gs (bad)
  804211ff41:	74 6f                	je     804211ffb2 <__rodata_start+0xbe2>
  804211ff43:	72 5f                	jb     804211ffa4 <__rodata_start+0xbd4>
  804211ff45:	69 64 20 3d 20 25 30 	imul   $0x38302520,0x3d(%rax,%riz,1),%esp
  804211ff4c:	38 
  804211ff4d:	78 0a                	js     804211ff59 <__rodata_start+0xb89>
  804211ff4f:	00 63 72             	add    %ah,0x72(%rbx)
  804211ff52:	65 61                	gs (bad)
  804211ff54:	74 6f                	je     804211ffc5 <__rodata_start+0xbf5>
  804211ff56:	72 5f                	jb     804211ffb7 <__rodata_start+0xbe7>
  804211ff58:	72 65                	jb     804211ffbf <__rodata_start+0xbef>
  804211ff5a:	76 69                	jbe    804211ffc5 <__rodata_start+0xbf5>
  804211ff5c:	73 69                	jae    804211ffc7 <__rodata_start+0xbf7>
  804211ff5e:	6f                   	outsl  %ds:(%rsi),(%dx)
  804211ff5f:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211ff60:	20 3d 20 25 30 38    	and    %bh,0x38302520(%rip)        # 807a422486 <__bss_end+0x3741a486>
  804211ff66:	78 0a                	js     804211ff72 <__rodata_start+0xba2>
  804211ff68:	00 68 61             	add    %ch,0x61(%rax)
  804211ff6b:	72 64                	jb     804211ffd1 <__rodata_start+0xc01>
  804211ff6d:	77 61                	ja     804211ffd0 <__rodata_start+0xc00>
  804211ff6f:	72 65                	jb     804211ffd6 <__rodata_start+0xc06>
  804211ff71:	5f                   	pop    %rdi
  804211ff72:	72 65                	jb     804211ffd9 <__rodata_start+0xc09>
  804211ff74:	76 5f                	jbe    804211ffd5 <__rodata_start+0xc05>
  804211ff76:	69 64 20 3d 20 25 30 	imul   $0x38302520,0x3d(%rax,%riz,1),%esp
  804211ff7d:	38 
  804211ff7e:	78 0a                	js     804211ff8a <__rodata_start+0xbba>
  804211ff80:	00 63 6f             	add    %ah,0x6f(%rbx)
  804211ff83:	6d                   	insl   (%dx),%es:(%rdi)
  804211ff84:	70 61                	jo     804211ffe7 <__rodata_start+0xc17>
  804211ff86:	72 61                	jb     804211ffe9 <__rodata_start+0xc19>
  804211ff88:	74 6f                	je     804211fff9 <__rodata_start+0xc29>
  804211ff8a:	72 5f                	jb     804211ffeb <__rodata_start+0xc1b>
  804211ff8c:	63 6f 75             	movsxd 0x75(%rdi),%ebp
  804211ff8f:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211ff90:	74 20                	je     804211ffb2 <__rodata_start+0xbe2>
  804211ff92:	3d 20 25 30 38       	cmp    $0x38302520,%eax
  804211ff97:	78 0a                	js     804211ffa3 <__rodata_start+0xbd3>
  804211ff99:	00 63 6f             	add    %ah,0x6f(%rbx)
  804211ff9c:	75 6e                	jne    804212000c <__rodata_start+0xc3c>
  804211ff9e:	74 65                	je     8042120005 <__rodata_start+0xc35>
  804211ffa0:	72 5f                	jb     8042120001 <__rodata_start+0xc31>
  804211ffa2:	73 69                	jae    804212000d <__rodata_start+0xc3d>
  804211ffa4:	7a 65                	jp     804212000b <__rodata_start+0xc3b>
  804211ffa6:	20 3d 20 25 30 38    	and    %bh,0x38302520(%rip)        # 807a4224cc <__bss_end+0x3741a4cc>
  804211ffac:	78 0a                	js     804211ffb8 <__rodata_start+0xbe8>
  804211ffae:	00 72 65             	add    %dh,0x65(%rdx)
  804211ffb1:	73 65                	jae    8042120018 <__rodata_start+0xc48>
  804211ffb3:	72 76                	jb     804212002b <__rodata_start+0xc5b>
  804211ffb5:	65 64 20 3d 20 25 30 	gs and %bh,%fs:0x38302520(%rip)        # 807a4224dd <__bss_end+0x3741a4dd>
  804211ffbc:	38 
  804211ffbd:	78 0a                	js     804211ffc9 <__rodata_start+0xbf9>
  804211ffbf:	00 6c 65 67          	add    %ch,0x67(%rbp,%riz,2)
  804211ffc3:	61                   	(bad)
  804211ffc4:	63 79 5f             	movsxd 0x5f(%rcx),%edi
  804211ffc7:	72 65                	jb     804212002e <__rodata_start+0xc5e>
  804211ffc9:	70 6c                	jo     8042120037 <__rodata_start+0xc67>
  804211ffcb:	61                   	(bad)
  804211ffcc:	63 65 6d             	movsxd 0x6d(%rbp),%esp
  804211ffcf:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804211ffd1:	74 20                	je     804211fff3 <__rodata_start+0xc23>
  804211ffd3:	3d 20 25 30 38       	cmp    $0x38302520,%eax
  804211ffd8:	78 0a                	js     804211ffe4 <__rodata_start+0xc14>
  804211ffda:	00 70 63             	add    %dh,0x63(%rax)
  804211ffdd:	69 5f 76 65 6e 64 6f 	imul   $0x6f646e65,0x76(%rdi),%ebx
  804211ffe4:	72 5f                	jb     8042120045 <__rodata_start+0xc75>
  804211ffe6:	69 64 20 3d 20 25 30 	imul   $0x38302520,0x3d(%rax,%riz,1),%esp
  804211ffed:	38 
  804211ffee:	78 0a                	js     804211fffa <__rodata_start+0xc2a>
  804211fff0:	00 68 70             	add    %ch,0x70(%rax)
  804211fff3:	65 74 5f             	gs je  8042120055 <__rodata_start+0xc85>
  804211fff6:	6e                   	outsb  %ds:(%rsi),(%dx)
  804211fff7:	75 6d                	jne    8042120066 <__rodata_start+0xc96>
  804211fff9:	62 65 72 20 3d       	(bad)
  804211fffe:	20 25 30 38 78 0a    	and    %ah,0xa783830(%rip)        # 804c8a3834 <__bss_end+0x989b834>
  8042120004:	00 6d 69             	add    %ch,0x69(%rbp)
  8042120007:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120008:	69 6d 75 6d 5f 74 69 	imul   $0x69745f6d,0x75(%rbp),%ebp
  804212000f:	63 6b 20             	movsxd 0x20(%rbx),%ebp
  8042120012:	3d 20 25 30 38       	cmp    $0x38302520,%eax
  8042120017:	78 0a                	js     8042120023 <__rodata_start+0xc53>
  8042120019:	00 61 64             	add    %ah,0x64(%rcx)
  804212001c:	64 72 65             	fs jb  8042120084 <__rodata_start+0xcb4>
  804212001f:	73 73                	jae    8042120094 <__rodata_start+0xcc4>
  8042120021:	5f                   	pop    %rdi
  8042120022:	73 74                	jae    8042120098 <__rodata_start+0xcc8>
  8042120024:	72 75                	jb     804212009b <__rodata_start+0xccb>
  8042120026:	63 74 75 72          	movsxd 0x72(%rbp,%rsi,2),%esi
  804212002a:	65 3a 0a             	cmp    %gs:(%rdx),%cl
  804212002d:	00 61 64             	add    %ah,0x64(%rcx)
  8042120030:	64 72 65             	fs jb  8042120098 <__rodata_start+0xcc8>
  8042120033:	73 73                	jae    80421200a8 <__rodata_start+0xcd8>
  8042120035:	5f                   	pop    %rdi
  8042120036:	73 70                	jae    80421200a8 <__rodata_start+0xcd8>
  8042120038:	61                   	(bad)
  8042120039:	63 65 5f             	movsxd 0x5f(%rbp),%esp
  804212003c:	69 64 20 3d 20 25 30 	imul   $0x38302520,0x3d(%rax,%riz,1),%esp
  8042120043:	38 
  8042120044:	78 0a                	js     8042120050 <__rodata_start+0xc80>
  8042120046:	00 72 65             	add    %dh,0x65(%rdx)
  8042120049:	67 69 73 74 65 72 5f 	imul   $0x625f7265,0x74(%ebx),%esi
  8042120050:	62 
  8042120051:	69 74 5f 77 69 64 74 	imul   $0x68746469,0x77(%rdi,%rbx,2),%esi
  8042120058:	68 
  8042120059:	20 3d 20 25 30 38    	and    %bh,0x38302520(%rip)        # 807a42257f <__bss_end+0x3741a57f>
  804212005f:	78 0a                	js     804212006b <__rodata_start+0xc9b>
  8042120061:	00 72 65             	add    %dh,0x65(%rdx)
  8042120064:	67 69 73 74 65 72 5f 	imul   $0x625f7265,0x74(%ebx),%esi
  804212006b:	62 
  804212006c:	69 74 5f 6f 66 66 73 	imul   $0x65736666,0x6f(%rdi,%rbx,2),%esi
  8042120073:	65 
  8042120074:	74 20                	je     8042120096 <__rodata_start+0xcc6>
  8042120076:	3d 20 25 30 38       	cmp    $0x38302520,%eax
  804212007b:	78 0a                	js     8042120087 <__rodata_start+0xcb7>
  804212007d:	00 61 64             	add    %ah,0x64(%rcx)
  8042120080:	64 72 65             	fs jb  80421200e8 <__rodata_start+0xd18>
  8042120083:	73 73                	jae    80421200f8 <__rodata_start+0xd28>
  8042120085:	20 3d 20 25 30 38    	and    %bh,0x38302520(%rip)        # 807a4225ab <__bss_end+0x3741a5ab>
  804212008b:	6c                   	insb   (%dx),%es:(%rdi)
  804212008c:	78 0a                	js     8042120098 <__rodata_start+0xcc8>
  804212008e:	00 47 43             	add    %al,0x43(%rdi)
  8042120091:	41 50                	push   %r8
  8042120093:	5f                   	pop    %rdi
  8042120094:	49                   	rex.WB
  8042120095:	44 20 3d 20 25 30 31 	and    %r15b,0x31302520(%rip)        # 80734225bc <__bss_end+0x3041a5bc>
  804212009c:	36 6c                	ss insb (%dx),%es:(%rdi)
  804212009e:	78 0a                	js     80421200aa <__rodata_start+0xcda>
  80421200a0:	00 47 45             	add    %al,0x45(%rdi)
  80421200a3:	4e 5f                	rex.WRX pop %rdi
  80421200a5:	43                   	rex.XB
  80421200a6:	4f                   	rex.WRXB
  80421200a7:	4e                   	rex.WRX
  80421200a8:	46 20 3d 20 25 30 31 	rex.RX and %r15b,0x31302520(%rip)        # 80734225cf <__bss_end+0x3041a5cf>
  80421200af:	36 6c                	ss insb (%dx),%es:(%rdi)
  80421200b1:	78 0a                	js     80421200bd <__rodata_start+0xced>
  80421200b3:	00 47 49             	add    %al,0x49(%rdi)
  80421200b6:	4e 54                	rex.WRX push %rsp
  80421200b8:	52                   	push   %rdx
  80421200b9:	5f                   	pop    %rdi
  80421200ba:	53                   	push   %rbx
  80421200bb:	54                   	push   %rsp
  80421200bc:	41 20 3d 20 25 30 31 	and    %dil,0x31302520(%rip)        # 80734225e3 <__bss_end+0x3041a5e3>
  80421200c3:	36 6c                	ss insb (%dx),%es:(%rdi)
  80421200c5:	78 0a                	js     80421200d1 <__rodata_start+0xd01>
  80421200c7:	00 4d 41             	add    %cl,0x41(%rbp)
  80421200ca:	49                   	rex.WB
  80421200cb:	4e 5f                	rex.WRX pop %rdi
  80421200cd:	43                   	rex.XB
  80421200ce:	4e 54                	rex.WRX push %rsp
  80421200d0:	20 3d 20 25 30 31    	and    %bh,0x31302520(%rip)        # 80734225f6 <__bss_end+0x3041a5f6>
  80421200d6:	36 6c                	ss insb (%dx),%es:(%rdi)
  80421200d8:	78 0a                	js     80421200e4 <__rodata_start+0xd14>
  80421200da:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  80421200de:	30 5f 43             	xor    %bl,0x43(%rdi)
  80421200e1:	4f                   	rex.WRXB
  80421200e2:	4e                   	rex.WRX
  80421200e3:	46 20 3d 20 25 30 31 	rex.RX and %r15b,0x31302520(%rip)        # 807342260a <__bss_end+0x3041a60a>
  80421200ea:	36 6c                	ss insb (%dx),%es:(%rdi)
  80421200ec:	78 0a                	js     80421200f8 <__rodata_start+0xd28>
  80421200ee:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  80421200f2:	30 5f 43             	xor    %bl,0x43(%rdi)
  80421200f5:	4f                   	rex.WRXB
  80421200f6:	4d 50                	rex.WRB push %r8
  80421200f8:	20 3d 20 25 30 31    	and    %bh,0x31302520(%rip)        # 807342261e <__bss_end+0x3041a61e>
  80421200fe:	36 6c                	ss insb (%dx),%es:(%rdi)
  8042120100:	78 0a                	js     804212010c <__rodata_start+0xd3c>
  8042120102:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  8042120106:	30 5f 46             	xor    %bl,0x46(%rdi)
  8042120109:	53                   	push   %rbx
  804212010a:	42 20 3d 20 25 30 31 	rex.X and %dil,0x31302520(%rip)        # 8073422631 <__bss_end+0x3041a631>
  8042120111:	36 6c                	ss insb (%dx),%es:(%rdi)
  8042120113:	78 0a                	js     804212011f <__rodata_start+0xd4f>
  8042120115:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  8042120119:	31 5f 43             	xor    %ebx,0x43(%rdi)
  804212011c:	4f                   	rex.WRXB
  804212011d:	4e                   	rex.WRX
  804212011e:	46 20 3d 20 25 30 31 	rex.RX and %r15b,0x31302520(%rip)        # 8073422645 <__bss_end+0x3041a645>
  8042120125:	36 6c                	ss insb (%dx),%es:(%rdi)
  8042120127:	78 0a                	js     8042120133 <__rodata_start+0xd63>
  8042120129:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  804212012d:	31 5f 43             	xor    %ebx,0x43(%rdi)
  8042120130:	4f                   	rex.WRXB
  8042120131:	4d 50                	rex.WRB push %r8
  8042120133:	20 3d 20 25 30 31    	and    %bh,0x31302520(%rip)        # 8073422659 <__bss_end+0x3041a659>
  8042120139:	36 6c                	ss insb (%dx),%es:(%rdi)
  804212013b:	78 0a                	js     8042120147 <__rodata_start+0xd77>
  804212013d:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  8042120141:	31 5f 46             	xor    %ebx,0x46(%rdi)
  8042120144:	53                   	push   %rbx
  8042120145:	42 20 3d 20 25 30 31 	rex.X and %dil,0x31302520(%rip)        # 807342266c <__bss_end+0x3041a66c>
  804212014c:	36 6c                	ss insb (%dx),%es:(%rdi)
  804212014e:	78 0a                	js     804212015a <__rodata_start+0xd8a>
  8042120150:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  8042120154:	32 5f 43             	xor    0x43(%rdi),%bl
  8042120157:	4f                   	rex.WRXB
  8042120158:	4e                   	rex.WRX
  8042120159:	46 20 3d 20 25 30 31 	rex.RX and %r15b,0x31302520(%rip)        # 8073422680 <__bss_end+0x3041a680>
  8042120160:	36 6c                	ss insb (%dx),%es:(%rdi)
  8042120162:	78 0a                	js     804212016e <__rodata_start+0xd9e>
  8042120164:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  8042120168:	32 5f 43             	xor    0x43(%rdi),%bl
  804212016b:	4f                   	rex.WRXB
  804212016c:	4d 50                	rex.WRB push %r8
  804212016e:	20 3d 20 25 30 31    	and    %bh,0x31302520(%rip)        # 8073422694 <__bss_end+0x3041a694>
  8042120174:	36 6c                	ss insb (%dx),%es:(%rdi)
  8042120176:	78 0a                	js     8042120182 <__rodata_start+0xdb2>
  8042120178:	00 54 49 4d          	add    %dl,0x4d(%rcx,%rcx,2)
  804212017c:	32 5f 46             	xor    0x46(%rdi),%bl
  804212017f:	53                   	push   %rbx
  8042120180:	42 20 3d 20 25 30 31 	rex.X and %dil,0x31302520(%rip)        # 80734226a7 <__bss_end+0x3041a6a7>
  8042120187:	36 6c                	ss insb (%dx),%es:(%rdi)
  8042120189:	78 0a                	js     8042120195 <__rodata_start+0xdc5>
  804212018b:	00 70 6d             	add    %dh,0x6d(%rax)
  804212018e:	00 68 70             	add    %ch,0x70(%rax)
  8042120191:	65 74 31             	gs je  80421201c5 <__rodata_start+0xdf5>
  8042120194:	00 48 61             	add    %cl,0x61(%rax)
  8042120197:	6c                   	insb   (%dx),%es:(%rdi)
  8042120198:	74 0a                	je     80421201a4 <__rodata_start+0xdd4>
  804212019a:	00 25 2e 2a 73 00    	add    %ah,0x732a2e(%rip)        # 8042852bce <_binary_obj_user_testpiperace2_end+0x1137e>
  80421201a0:	6b 65 72 6e          	imul   $0x6e,0x72(%rbp),%esp
  80421201a4:	2f                   	(bad)
  80421201a5:	6b 64 65 62 75       	imul   $0x75,0x62(%rbp,%riz,2),%esp
  80421201aa:	67 2e 63 00          	cs movsxd (%eax),%eax
  80421201ae:	63 75 72             	movsxd 0x72(%rbp),%esi
  80421201b1:	65 6e                	outsb  %gs:(%rsi),(%dx)
  80421201b3:	76 2d                	jbe    80421201e2 <__rodata_start+0xe12>
  80421201b5:	3e 62 69 6e 61 72    	(bad)
  80421201bb:	79 00                	jns    80421201bd <__rodata_start+0xded>
  80421201bd:	2e 64 65 62 75 67 5f 	(bad)
  80421201c4:	61 
  80421201c5:	72 61                	jb     8042120228 <__rodata_start+0xe58>
  80421201c7:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421201c8:	67 65 73 00          	addr32 gs jae 80421201cc <__rodata_start+0xdfc>
  80421201cc:	2e 64 65 62 75 67 5f 	(bad)
  80421201d3:	61 
  80421201d4:	62 62 72 65 76       	(bad)
  80421201d9:	00 2e                	add    %ch,(%rsi)
  80421201db:	64 65 62 75 67 5f 69 	(bad)
  80421201e2:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421201e3:	66 6f                	outsw  %ds:(%rsi),(%dx)
  80421201e5:	00 2e                	add    %ch,(%rsi)
  80421201e7:	64 65 62 75 67 5f 6c 	(bad)
  80421201ee:	69 6e 65 00 2e 64 65 	imul   $0x65642e00,0x65(%rsi),%ebp
  80421201f5:	62 75 67 5f 73       	(bad)
  80421201fa:	74 72                	je     804212026e <__rodata_start+0xe9e>
  80421201fc:	00 2e                	add    %ch,(%rsi)
  80421201fe:	64 65 62 75 67 5f 70 	(bad)
  8042120205:	75 62                	jne    8042120269 <__rodata_start+0xe99>
  8042120207:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120208:	61                   	(bad)
  8042120209:	6d                   	insl   (%dx),%es:(%rdi)
  804212020a:	65 73 00             	gs jae 804212020d <__rodata_start+0xe3d>
  804212020d:	2e 64 65 62 75 67 5f 	(bad)
  8042120214:	70 
  8042120215:	75 62                	jne    8042120279 <__rodata_start+0xea9>
  8042120217:	74 79                	je     8042120292 <__rodata_start+0xec2>
  8042120219:	70 65                	jo     8042120280 <__rodata_start+0xeb0>
  804212021b:	73 00                	jae    804212021d <__rodata_start+0xe4d>
  804212021d:	65 6c                	gs insb (%dx),%es:(%rdi)
  804212021f:	66 2d 3e 65          	sub    $0x653e,%ax
  8042120223:	5f                   	pop    %rdi
  8042120224:	6d                   	insl   (%dx),%es:(%rdi)
  8042120225:	61                   	(bad)
  8042120226:	67 69 63 20 21 3d 20 	imul   $0x45203d21,0x20(%ebx),%esp
  804212022d:	45 
  804212022e:	4c                   	rex.WR
  804212022f:	46 5f                	rex.RX pop %rdi
  8042120231:	4d                   	rex.WRB
  8042120232:	41                   	rex.B
  8042120233:	47                   	rex.RXB
  8042120234:	49                   	rex.WB
  8042120235:	43 00 3c 75 6e 6b 6e 	add    %dil,0x6f6e6b6e(,%r14,2)
  804212023c:	6f 
  804212023d:	77 6e                	ja     80421202ad <__rodata_start+0xedd>
  804212023f:	3e 00 73 79          	ds add %dh,0x79(%rbx)
  8042120243:	73 5f                	jae    80421202a4 <__rodata_start+0xed4>
  8042120245:	65 78 69             	gs js  80421202b1 <__rodata_start+0xee1>
  8042120248:	74 00                	je     804212024a <__rodata_start+0xe7a>
  804212024a:	73 79                	jae    80421202c5 <__rodata_start+0xef5>
  804212024c:	73 5f                	jae    80421202ad <__rodata_start+0xedd>
  804212024e:	79 69                	jns    80421202b9 <__rodata_start+0xee9>
  8042120250:	65 6c                	gs insb (%dx),%es:(%rdi)
  8042120252:	64 00 30             	add    %dh,%fs:(%rax)
  8042120255:	31 32                	xor    %esi,(%rdx)
  8042120257:	33 34 35 36 37 38 39 	xor    0x39383736(,%rsi,1),%esi
  804212025e:	41                   	rex.B
  804212025f:	42                   	rex.X
  8042120260:	43                   	rex.XB
  8042120261:	44                   	rex.R
  8042120262:	45                   	rex.RB
  8042120263:	46 00 30             	rex.RX add %r14b,(%rax)
  8042120266:	31 32                	xor    %esi,(%rdx)
  8042120268:	33 34 35 36 37 38 39 	xor    0x39383736(,%rsi,1),%esi
  804212026f:	61                   	(bad)
  8042120270:	62 63 64 65 66       	(bad)
  8042120275:	00 28                	add    %ch,(%rax)
  8042120277:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120278:	75 6c                	jne    80421202e6 <__rodata_start+0xf16>
  804212027a:	6c                   	insb   (%dx),%es:(%rdi)
  804212027b:	29 00                	sub    %eax,(%rax)
  804212027d:	65 72 72             	gs jb  80421202f2 <__rodata_start+0xf22>
  8042120280:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120281:	72 20                	jb     80421202a3 <__rodata_start+0xed3>
  8042120283:	25 64 00 75 6e       	and    $0x6e750064,%eax
  8042120288:	73 70                	jae    80421202fa <__rodata_start+0xf2a>
  804212028a:	65 63 69 66          	movsxd %gs:0x66(%rcx),%ebp
  804212028e:	69 65 64 20 65 72 72 	imul   $0x72726520,0x64(%rbp),%esp
  8042120295:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120296:	72 00                	jb     8042120298 <__rodata_start+0xec8>
  8042120298:	62 61 64 20 65       	(bad)
  804212029d:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212029e:	76 69                	jbe    8042120309 <__rodata_start+0xf39>
  80421202a0:	72 6f                	jb     8042120311 <__rodata_start+0xf41>
  80421202a2:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421202a3:	6d                   	insl   (%dx),%es:(%rdi)
  80421202a4:	65 6e                	outsb  %gs:(%rsi),(%dx)
  80421202a6:	74 00                	je     80421202a8 <__rodata_start+0xed8>
  80421202a8:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
  80421202af:	20 70 61             	and    %dh,0x61(%rax)
  80421202b2:	72 61                	jb     8042120315 <__rodata_start+0xf45>
  80421202b4:	6d                   	insl   (%dx),%es:(%rdi)
  80421202b5:	65 74 65             	gs je  804212031d <__rodata_start+0xf4d>
  80421202b8:	72 00                	jb     80421202ba <__rodata_start+0xeea>
  80421202ba:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421202bb:	75 74                	jne    8042120331 <__rodata_start+0xf61>
  80421202bd:	20 6f 66             	and    %ch,0x66(%rdi)
  80421202c0:	20 6d 65             	and    %ch,0x65(%rbp)
  80421202c3:	6d                   	insl   (%dx),%es:(%rdi)
  80421202c4:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421202c5:	72 79                	jb     8042120340 <__rodata_start+0xf70>
  80421202c7:	00 6f 75             	add    %ch,0x75(%rdi)
  80421202ca:	74 20                	je     80421202ec <__rodata_start+0xf1c>
  80421202cc:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421202cd:	66 20 65 6e          	data16 and %ah,0x6e(%rbp)
  80421202d1:	76 69                	jbe    804212033c <__rodata_start+0xf6c>
  80421202d3:	72 6f                	jb     8042120344 <__rodata_start+0xf74>
  80421202d5:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421202d6:	6d                   	insl   (%dx),%es:(%rdi)
  80421202d7:	65 6e                	outsb  %gs:(%rsi),(%dx)
  80421202d9:	74 73                	je     804212034e <__rodata_start+0xf7e>
  80421202db:	00 63 6f             	add    %ah,0x6f(%rbx)
  80421202de:	72 72                	jb     8042120352 <__rodata_start+0xf82>
  80421202e0:	75 70                	jne    8042120352 <__rodata_start+0xf82>
  80421202e2:	74 65                	je     8042120349 <__rodata_start+0xf79>
  80421202e4:	64 20 64 65 62       	and    %ah,%fs:0x62(%rbp,%riz,2)
  80421202e9:	75 67                	jne    8042120352 <__rodata_start+0xf82>
  80421202eb:	20 69 6e             	and    %ch,0x6e(%rcx)
  80421202ee:	66 6f                	outsw  %ds:(%rsi),(%dx)
  80421202f0:	00 73 65             	add    %dh,0x65(%rbx)
  80421202f3:	67 6d                	insl   (%dx),%es:(%edi)
  80421202f5:	65 6e                	outsb  %gs:(%rsi),(%dx)
  80421202f7:	74 61                	je     804212035a <__rodata_start+0xf8a>
  80421202f9:	74 69                	je     8042120364 <__rodata_start+0xf94>
  80421202fb:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421202fc:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421202fd:	20 66 61             	and    %ah,0x61(%rsi)
  8042120300:	75 6c                	jne    804212036e <__rodata_start+0xf9e>
  8042120302:	74 00                	je     8042120304 <__rodata_start+0xf34>
  8042120304:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
  804212030b:	20 45 4c             	and    %al,0x4c(%rbp)
  804212030e:	46 20 69 6d          	rex.RX and %r13b,0x6d(%rcx)
  8042120312:	61                   	(bad)
  8042120313:	67 65 00 6e 6f       	add    %ch,%gs:0x6f(%esi)
  8042120318:	20 73 75             	and    %dh,0x75(%rbx)
  804212031b:	63 68 20             	movsxd 0x20(%rax),%ebp
  804212031e:	73 79                	jae    8042120399 <__rodata_start+0xfc9>
  8042120320:	73 74                	jae    8042120396 <__rodata_start+0xfc6>
  8042120322:	65 6d                	gs insl (%dx),%es:(%rdi)
  8042120324:	20 63 61             	and    %ah,0x61(%rbx)
  8042120327:	6c                   	insb   (%dx),%es:(%rdi)
  8042120328:	6c                   	insb   (%dx),%es:(%rdi)
  8042120329:	00 65 6e             	add    %ah,0x6e(%rbp)
  804212032c:	74 72                	je     80421203a0 <__rodata_start+0xfd0>
  804212032e:	79 20                	jns    8042120350 <__rodata_start+0xf80>
  8042120330:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120331:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120332:	74 20                	je     8042120354 <__rodata_start+0xf84>
  8042120334:	66 6f                	outsw  %ds:(%rsi),(%dx)
  8042120336:	75 6e                	jne    80421203a6 <__rodata_start+0xfd6>
  8042120338:	64 00 65 6e          	add    %ah,%fs:0x6e(%rbp)
  804212033c:	76 20                	jbe    804212035e <__rodata_start+0xf8e>
  804212033e:	69 73 20 6e 6f 74 20 	imul   $0x20746f6e,0x20(%rbx),%esi
  8042120345:	72 65                	jb     80421203ac <__rodata_start+0xfdc>
  8042120347:	63 76 69             	movsxd 0x69(%rsi),%esi
  804212034a:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212034b:	67 00 75 6e          	add    %dh,0x6e(%ebp)
  804212034f:	65 78 70             	gs js  80421203c2 <__rodata_start+0xff2>
  8042120352:	65 63 74 65 64       	movsxd %gs:0x64(%rbp,%riz,2),%esi
  8042120357:	20 65 6e             	and    %ah,0x6e(%rbp)
  804212035a:	64 20 6f 66          	and    %ch,%fs:0x66(%rdi)
  804212035e:	20 66 69             	and    %ah,0x69(%rsi)
  8042120361:	6c                   	insb   (%dx),%es:(%rdi)
  8042120362:	65 00 6e 6f          	add    %ch,%gs:0x6f(%rsi)
  8042120366:	20 66 72             	and    %ah,0x72(%rsi)
  8042120369:	65 65 20 73 70       	gs and %dh,%gs:0x70(%rbx)
  804212036e:	61                   	(bad)
  804212036f:	63 65 20             	movsxd 0x20(%rbp),%esp
  8042120372:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120373:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120374:	20 64 69 73          	and    %ah,0x73(%rcx,%rbp,2)
  8042120378:	6b 00 74             	imul   $0x74,(%rax),%eax
  804212037b:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212037c:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212037d:	20 6d 61             	and    %ch,0x61(%rbp)
  8042120380:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120381:	79 20                	jns    80421203a3 <__rodata_start+0xfd3>
  8042120383:	66 69 6c 65 73 20 61 	imul   $0x6120,0x73(%rbp,%riz,2),%bp
  804212038a:	72 65                	jb     80421203f1 <__rodata_start+0x1021>
  804212038c:	20 6f 70             	and    %ch,0x70(%rdi)
  804212038f:	65 6e                	outsb  %gs:(%rsi),(%dx)
  8042120391:	00 66 69             	add    %ah,0x69(%rsi)
  8042120394:	6c                   	insb   (%dx),%es:(%rdi)
  8042120395:	65 20 6f 72          	and    %ch,%gs:0x72(%rdi)
  8042120399:	20 62 6c             	and    %ah,0x6c(%rdx)
  804212039c:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212039d:	63 6b 20             	movsxd 0x20(%rbx),%ebp
  80421203a0:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421203a1:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421203a2:	74 20                	je     80421203c4 <__rodata_start+0xff4>
  80421203a4:	66 6f                	outsw  %ds:(%rsi),(%dx)
  80421203a6:	75 6e                	jne    8042120416 <__rodata_start+0x1046>
  80421203a8:	64 00 69 6e          	add    %ch,%fs:0x6e(%rcx)
  80421203ac:	76 61                	jbe    804212040f <__rodata_start+0x103f>
  80421203ae:	6c                   	insb   (%dx),%es:(%rdi)
  80421203af:	69 64 20 70 61 74 68 	imul   $0x687461,0x70(%rax,%riz,1),%esp
  80421203b6:	00 
  80421203b7:	66 69 6c 65 20 61 6c 	imul   $0x6c61,0x20(%rbp,%riz,2),%bp
  80421203be:	72 65                	jb     8042120425 <__rodata_start+0x1055>
  80421203c0:	61                   	(bad)
  80421203c1:	64 79 20             	fs jns 80421203e4 <__rodata_start+0x1014>
  80421203c4:	65 78 69             	gs js  8042120430 <__rodata_start+0x1060>
  80421203c7:	73 74                	jae    804212043d <__rodata_start+0x106d>
  80421203c9:	73 00                	jae    80421203cb <__rodata_start+0xffb>
  80421203cb:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421203cc:	70 65                	jo     8042120433 <__rodata_start+0x1063>
  80421203ce:	72 61                	jb     8042120431 <__rodata_start+0x1061>
  80421203d0:	74 69                	je     804212043b <__rodata_start+0x106b>
  80421203d2:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421203d3:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421203d4:	20 6e 6f             	and    %ch,0x6f(%rsi)
  80421203d7:	74 20                	je     80421203f9 <__rodata_start+0x1029>
  80421203d9:	73 75                	jae    8042120450 <__rodata_start+0x1080>
  80421203db:	70 70                	jo     804212044d <__rodata_start+0x107d>
  80421203dd:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421203de:	72 74                	jb     8042120454 <__rodata_start+0x1084>
  80421203e0:	65 64 00 72 65       	gs add %dh,%fs:0x65(%rdx)
  80421203e5:	61                   	(bad)
  80421203e6:	64 20 65 72          	and    %ah,%fs:0x72(%rbp)
  80421203ea:	72 6f                	jb     804212045b <__rodata_start+0x108b>
  80421203ec:	72 3a                	jb     8042120428 <__rodata_start+0x1058>
  80421203ee:	20 25 69 0a 00 25    	and    %ah,0x25000a69(%rip)        # 8067120e5d <__bss_end+0x24118e5d>
  80421203f4:	75 0a                	jne    8042120400 <__rodata_start+0x1030>
  80421203f6:	00 54 69 6d          	add    %dl,0x6d(%rcx,%rbp,2)
  80421203fa:	65 72 20             	gs jb  804212041d <__rodata_start+0x104d>
  80421203fd:	45 72 72             	rex.RB jb 8042120472 <__rodata_start+0x10a2>
  8042120400:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120401:	72 0a                	jb     804212040d <__rodata_start+0x103d>
  8042120403:	00 25 6c 75 0a 00    	add    %ah,0xa756c(%rip)        # 80421c7975 <_binary_obj_user_buggyhello2_end+0x62fd>
  8042120409:	70 69                	jo     8042120474 <__rodata_start+0x10a4>
  804212040b:	74 00                	je     804212040d <__rodata_start+0x103d>
  804212040d:	25 6c 64 0a 00       	and    $0xa646c,%eax
  8042120412:	70 61                	jo     8042120475 <__rodata_start+0x10a5>
  8042120414:	67 65 20 4e 55       	and    %cl,%gs:0x55(%esi)
  8042120419:	4c                   	rex.WR
  804212041a:	4c 00 6b 65          	rex.WR add %r13b,0x65(%rbx)
  804212041e:	72 6e                	jb     804212048e <__rodata_start+0x10be>
  8042120420:	2f                   	(bad)
  8042120421:	73 77                	jae    804212049a <__rodata_start+0x10ca>
  8042120423:	61                   	(bad)
  8042120424:	70 2e                	jo     8042120454 <__rodata_start+0x1084>
  8042120426:	63 00                	movsxd (%rax),%eax
  8042120428:	31 2e                	xor    %ebp,(%rsi)
  804212042a:	39 2e                	cmp    %ebp,(%rsi)
  804212042c:	32 00                	xor    (%rax),%al
  804212042e:	66 90                	xchg   %ax,%ax
  8042120430:	54                   	push   %rsp
  8042120431:	69 6d 65 72 20 25 73 	imul   $0x73252072,0x65(%rbp),%ebp
  8042120438:	20 64 6f 65          	and    %ah,0x65(%rdi,%rbp,2)
  804212043c:	73 20                	jae    804212045e <__rodata_start+0x108e>
  804212043e:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212043f:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120440:	74 20                	je     8042120462 <__rodata_start+0x1092>
  8042120442:	73 75                	jae    80421204b9 <__rodata_start+0x10e9>
  8042120444:	70 70                	jo     80421204b6 <__rodata_start+0x10e6>
  8042120446:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120447:	72 74                	jb     80421204bd <__rodata_start+0x10ed>
  8042120449:	20 69 6e             	and    %ch,0x6e(%rcx)
  804212044c:	74 65                	je     80421204b3 <__rodata_start+0x10e3>
  804212044e:	72 72                	jb     80421204c2 <__rodata_start+0x10f2>
  8042120450:	75 70                	jne    80421204c2 <__rodata_start+0x10f2>
  8042120452:	74 73                	je     80421204c7 <__rodata_start+0x10f7>
  8042120454:	0a 00                	or     (%rax),%al
  8042120456:	00 00                	add    %al,(%rax)
  8042120458:	61                   	(bad)
  8042120459:	64 64 72 65          	fs fs jb 80421204c2 <__rodata_start+0x10f2>
  804212045d:	73 73                	jae    80421204d2 <__rodata_start+0x1102>
  804212045f:	5f                   	pop    %rdi
  8042120460:	73 69                	jae    80421204cb <__rodata_start+0x10fb>
  8042120462:	7a 65                	jp     80421204c9 <__rodata_start+0x10f9>
  8042120464:	20 3d 3d 20 73 69    	and    %bh,0x6973203d(%rip)        # 80ab8524a7 <__bss_end+0x6884a4a7>
  804212046a:	7a 65                	jp     80421204d1 <__rodata_start+0x1101>
  804212046c:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212046d:	66 28 75 69          	data16 sub %dh,0x69(%rbp)
  8042120471:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120472:	74 70                	je     80421204e4 <__rodata_start+0x1114>
  8042120474:	74 72                	je     80421204e8 <__rodata_start+0x1118>
  8042120476:	5f                   	pop    %rdi
  8042120477:	74 29                	je     80421204a2 <__rodata_start+0x10d2>
  8042120479:	00 00                	add    %al,(%rax)
  804212047b:	00 00                	add    %al,(%rax)
  804212047d:	00 00                	add    %al,(%rax)
  804212047f:	00 74 61 62          	add    %dh,0x62(%rcx,%riz,2)
  8042120483:	6c                   	insb   (%dx),%es:(%rdi)
  8042120484:	65 5f                	gs pop %rdi
  8042120486:	61                   	(bad)
  8042120487:	62 62 72 65 76       	(bad)
  804212048c:	5f                   	pop    %rdi
  804212048d:	63 6f 64             	movsxd 0x64(%rdi),%ebp
  8042120490:	65 20 3d 3d 20 61 62 	and    %bh,%gs:0x6261203d(%rip)        # 80a47324d4 <__bss_end+0x6172a4d4>
  8042120497:	62 72 65 76 5f       	(bad)
  804212049c:	63 6f 64             	movsxd 0x64(%rdi),%ebp
  804212049f:	65 00 00             	add    %al,%gs:(%rax)
  80421204a2:	00 00                	add    %al,(%rax)
  80421204a4:	00 00                	add    %al,(%rax)
  80421204a6:	00 00                	add    %al,(%rax)
  80421204a8:	76 65                	jbe    804212050f <__rodata_start+0x113f>
  80421204aa:	72 73                	jb     804212051f <__rodata_start+0x114f>
  80421204ac:	69 6f 6e 20 3d 3d 20 	imul   $0x203d3d20,0x6e(%rdi),%ebp
  80421204b3:	34 20                	xor    $0x20,%al
  80421204b5:	7c 7c                	jl     8042120533 <__rodata_start+0x1163>
  80421204b7:	20 76 65             	and    %dh,0x65(%rsi)
  80421204ba:	72 73                	jb     804212052f <__rodata_start+0x115f>
  80421204bc:	69 6f 6e 20 3d 3d 20 	imul   $0x203d3d20,0x6e(%rdi),%ebp
  80421204c3:	33 20                	xor    (%rax),%esp
  80421204c5:	7c 7c                	jl     8042120543 <__rodata_start+0x1173>
  80421204c7:	20 76 65             	and    %dh,0x65(%rsi)
  80421204ca:	72 73                	jb     804212053f <__rodata_start+0x116f>
  80421204cc:	69 6f 6e 20 3d 3d 20 	imul   $0x203d3d20,0x6e(%rdi),%ebp
  80421204d3:	32 00                	xor    (%rax),%al
  80421204d5:	00 00                	add    %al,(%rax)
  80421204d7:	00 6d 69             	add    %ch,0x69(%rbp)
  80421204da:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421204db:	69 6d 75 6d 5f 69 6e 	imul   $0x6e695f6d,0x75(%rbp),%ebp
  80421204e2:	73 74                	jae    8042120558 <__rodata_start+0x1188>
  80421204e4:	72 75                	jb     804212055b <__rodata_start+0x118b>
  80421204e6:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
  80421204ea:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421204eb:	5f                   	pop    %rdi
  80421204ec:	6c                   	insb   (%dx),%es:(%rdi)
  80421204ed:	65 6e                	outsb  %gs:(%rsi),(%dx)
  80421204ef:	67 74 68             	addr32 je 804212055a <__rodata_start+0x118a>
  80421204f2:	20 3d 3d 20 31 00    	and    %bh,0x31203d(%rip)        # 8042432535 <_binary_obj_user_faultwritekernel_end+0xa1ed>
  80421204f8:	6d                   	insl   (%dx),%es:(%rdi)
  80421204f9:	61                   	(bad)
  80421204fa:	78 69                	js     8042120565 <__rodata_start+0x1195>
  80421204fc:	6d                   	insl   (%dx),%es:(%rdi)
  80421204fd:	75 6d                	jne    804212056c <__rodata_start+0x119c>
  80421204ff:	5f                   	pop    %rdi
  8042120500:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120501:	70 65                	jo     8042120568 <__rodata_start+0x1198>
  8042120503:	72 61                	jb     8042120566 <__rodata_start+0x1196>
  8042120505:	74 69                	je     8042120570 <__rodata_start+0x11a0>
  8042120507:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120508:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120509:	73 5f                	jae    804212056a <__rodata_start+0x119a>
  804212050b:	70 65                	jo     8042120572 <__rodata_start+0x11a2>
  804212050d:	72 5f                	jb     804212056e <__rodata_start+0x119e>
  804212050f:	69 6e 73 74 72 75 63 	imul   $0x63757274,0x73(%rsi),%ebp
  8042120516:	74 69                	je     8042120581 <__rodata_start+0x11b1>
  8042120518:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120519:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212051a:	20 3d 3d 20 31 00    	and    %bh,0x31203d(%rip)        # 804243255d <_binary_obj_user_faultwritekernel_end+0xa215>
  8042120520:	20 20                	and    %ah,(%rax)
  8042120522:	5f                   	pop    %rdi
  8042120523:	68 65 61 64 36       	push   $0x36646165
  8042120528:	34 20                	xor    $0x20,%al
  804212052a:	25 31 36 6c 78       	and    $0x786c3631,%eax
  804212052f:	20 28                	and    %ch,(%rax)
  8042120531:	76 69                	jbe    804212059c <__rodata_start+0x11cc>
  8042120533:	72 74                	jb     80421205a9 <__rodata_start+0x11d9>
  8042120535:	29 20                	sub    %esp,(%rax)
  8042120537:	20 25 31 36 6c 78    	and    %ah,0x786c3631(%rip)        # 80ba7e3b6e <__bss_end+0x777dbb6e>
  804212053d:	20 28                	and    %ch,(%rax)
  804212053f:	70 68                	jo     80421205a9 <__rodata_start+0x11d9>
  8042120541:	79 73                	jns    80421205b6 <__rodata_start+0x11e6>
  8042120543:	29 0a                	sub    %ecx,(%rdx)
  8042120545:	00 00                	add    %al,(%rax)
  8042120547:	00 20                	add    %ah,(%rax)
  8042120549:	20 65 6e             	and    %ah,0x6e(%rbp)
  804212054c:	74 72                	je     80421205c0 <__rodata_start+0x11f0>
  804212054e:	79 20                	jns    8042120570 <__rodata_start+0x11a0>
  8042120550:	20 20                	and    %ah,(%rax)
  8042120552:	25 31 36 6c 78       	and    $0x786c3631,%eax
  8042120557:	20 28                	and    %ch,(%rax)
  8042120559:	76 69                	jbe    80421205c4 <__rodata_start+0x11f4>
  804212055b:	72 74                	jb     80421205d1 <__rodata_start+0x1201>
  804212055d:	29 20                	sub    %esp,(%rax)
  804212055f:	20 25 31 36 6c 78    	and    %ah,0x786c3631(%rip)        # 80ba7e3b96 <__bss_end+0x777dbb96>
  8042120565:	20 28                	and    %ch,(%rax)
  8042120567:	70 68                	jo     80421205d1 <__rodata_start+0x1201>
  8042120569:	79 73                	jns    80421205de <__rodata_start+0x120e>
  804212056b:	29 0a                	sub    %ecx,(%rdx)
  804212056d:	00 00                	add    %al,(%rax)
  804212056f:	00 20                	add    %ah,(%rax)
  8042120571:	20 65 74             	and    %ah,0x74(%rbp)
  8042120574:	65 78 74             	gs js  80421205eb <__rodata_start+0x121b>
  8042120577:	20 20                	and    %ah,(%rax)
  8042120579:	20 25 31 36 6c 78    	and    %ah,0x786c3631(%rip)        # 80ba7e3bb0 <__bss_end+0x777dbbb0>
  804212057f:	20 28                	and    %ch,(%rax)
  8042120581:	76 69                	jbe    80421205ec <__rodata_start+0x121c>
  8042120583:	72 74                	jb     80421205f9 <__rodata_start+0x1229>
  8042120585:	29 20                	sub    %esp,(%rax)
  8042120587:	20 25 31 36 6c 78    	and    %ah,0x786c3631(%rip)        # 80ba7e3bbe <__bss_end+0x777dbbbe>
  804212058d:	20 28                	and    %ch,(%rax)
  804212058f:	70 68                	jo     80421205f9 <__rodata_start+0x1229>
  8042120591:	79 73                	jns    8042120606 <__rodata_start+0x1236>
  8042120593:	29 0a                	sub    %ecx,(%rdx)
  8042120595:	00 00                	add    %al,(%rax)
  8042120597:	00 20                	add    %ah,(%rax)
  8042120599:	20 65 64             	and    %ah,0x64(%rbp)
  804212059c:	61                   	(bad)
  804212059d:	74 61                	je     8042120600 <__rodata_start+0x1230>
  804212059f:	20 20                	and    %ah,(%rax)
  80421205a1:	20 25 31 36 6c 78    	and    %ah,0x786c3631(%rip)        # 80ba7e3bd8 <__bss_end+0x777dbbd8>
  80421205a7:	20 28                	and    %ch,(%rax)
  80421205a9:	76 69                	jbe    8042120614 <__rodata_start+0x1244>
  80421205ab:	72 74                	jb     8042120621 <__rodata_start+0x1251>
  80421205ad:	29 20                	sub    %esp,(%rax)
  80421205af:	20 25 31 36 6c 78    	and    %ah,0x786c3631(%rip)        # 80ba7e3be6 <__bss_end+0x777dbbe6>
  80421205b5:	20 28                	and    %ch,(%rax)
  80421205b7:	70 68                	jo     8042120621 <__rodata_start+0x1251>
  80421205b9:	79 73                	jns    804212062e <__rodata_start+0x125e>
  80421205bb:	29 0a                	sub    %ecx,(%rdx)
  80421205bd:	00 00                	add    %al,(%rax)
  80421205bf:	00 20                	add    %ah,(%rax)
  80421205c1:	20 65 6e             	and    %ah,0x6e(%rbp)
  80421205c4:	64 20 20             	and    %ah,%fs:(%rax)
  80421205c7:	20 20                	and    %ah,(%rax)
  80421205c9:	20 25 31 36 6c 78    	and    %ah,0x786c3631(%rip)        # 80ba7e3c00 <__bss_end+0x777dbc00>
  80421205cf:	20 28                	and    %ch,(%rax)
  80421205d1:	76 69                	jbe    804212063c <__rodata_start+0x126c>
  80421205d3:	72 74                	jb     8042120649 <__rodata_start+0x1279>
  80421205d5:	29 20                	sub    %esp,(%rax)
  80421205d7:	20 25 31 36 6c 78    	and    %ah,0x786c3631(%rip)        # 80ba7e3c0e <__bss_end+0x777dbc0e>
  80421205dd:	20 28                	and    %ch,(%rax)
  80421205df:	70 68                	jo     8042120649 <__rodata_start+0x1279>
  80421205e1:	79 73                	jns    8042120656 <__rodata_start+0x1286>
  80421205e3:	29 0a                	sub    %ecx,(%rdx)
  80421205e5:	00 00                	add    %al,(%rax)
  80421205e7:	00 4b 65             	add    %cl,0x65(%rbx)
  80421205ea:	72 6e                	jb     804212065a <__rodata_start+0x128a>
  80421205ec:	65 6c                	gs insb (%dx),%es:(%rdi)
  80421205ee:	20 65 78             	and    %ah,0x78(%rbp)
  80421205f1:	65 63 75 74          	movsxd %gs:0x74(%rbp),%esi
  80421205f5:	61                   	(bad)
  80421205f6:	62 6c 65             	(bad)
  80421205f9:	20 6d 65             	and    %ch,0x65(%rbp)
  80421205fc:	6d                   	insl   (%dx),%es:(%rdi)
  80421205fd:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421205fe:	72 79                	jb     8042120679 <__rodata_start+0x12a9>
  8042120600:	20 66 6f             	and    %ah,0x6f(%rsi)
  8042120603:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120604:	74 70                	je     8042120676 <__rodata_start+0x12a6>
  8042120606:	72 69                	jb     8042120671 <__rodata_start+0x12a1>
  8042120608:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120609:	74 3a                	je     8042120645 <__rodata_start+0x1275>
  804212060b:	20 25 6c 75 4b 42    	and    %ah,0x424b756c(%rip)        # 80845d7b7d <__bss_end+0x415cfb7d>
  8042120611:	0a 00                	or     (%rax),%al
  8042120613:	00 00                	add    %al,(%rax)
  8042120615:	00 00                	add    %al,(%rax)
  8042120617:	00 57 65             	add    %dl,0x65(%rdi)
  804212061a:	6c                   	insb   (%dx),%es:(%rdi)
  804212061b:	63 6f 6d             	movsxd 0x6d(%rdi),%ebp
  804212061e:	65 20 74 6f 20       	and    %dh,%gs:0x20(%rdi,%rbp,2)
  8042120623:	74 68                	je     804212068d <__rodata_start+0x12bd>
  8042120625:	65 20 4a 4f          	and    %cl,%gs:0x4f(%rdx)
  8042120629:	53                   	push   %rbx
  804212062a:	20 6b 65             	and    %ch,0x65(%rbx)
  804212062d:	72 6e                	jb     804212069d <__rodata_start+0x12cd>
  804212062f:	65 6c                	gs insb (%dx),%es:(%rdi)
  8042120631:	20 6d 6f             	and    %ch,0x6f(%rbp)
  8042120634:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120635:	69 74 6f 72 21 0a 00 	imul   $0xa21,0x72(%rdi,%rbp,2),%esi
  804212063c:	00 
  804212063d:	00 00                	add    %al,(%rax)
  804212063f:	00 54 79 70          	add    %dl,0x70(%rcx,%rdi,2)
  8042120643:	65 20 27             	and    %ah,%gs:(%rdi)
  8042120646:	68 65 6c 70 27       	push   $0x27706c65
  804212064b:	20 66 6f             	and    %ah,0x6f(%rsi)
  804212064e:	72 20                	jb     8042120670 <__rodata_start+0x12a0>
  8042120650:	61                   	(bad)
  8042120651:	20 6c 69 73          	and    %ch,0x73(%rcx,%rbp,2)
  8042120655:	74 20                	je     8042120677 <__rodata_start+0x12a7>
  8042120657:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120658:	66 20 63 6f          	data16 and %ah,0x6f(%rbx)
  804212065c:	6d                   	insl   (%dx),%es:(%rdi)
  804212065d:	6d                   	insl   (%dx),%es:(%rdi)
  804212065e:	61                   	(bad)
  804212065f:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120660:	64 73 2e             	fs jae 8042120691 <__rodata_start+0x12c1>
  8042120663:	0a 00                	or     (%rax),%al
  8042120665:	00 00                	add    %al,(%rax)
  8042120667:	00 44 69 73          	add    %al,0x73(%rcx,%rbp,2)
  804212066b:	70 6c                	jo     80421206d9 <__rodata_start+0x1309>
  804212066d:	61                   	(bad)
  804212066e:	79 20                	jns    8042120690 <__rodata_start+0x12c0>
  8042120670:	69 6e 66 6f 72 6d 61 	imul   $0x616d726f,0x66(%rsi),%ebp
  8042120677:	74 69                	je     80421206e2 <__rodata_start+0x1312>
  8042120679:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212067a:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212067b:	20 61 62             	and    %ah,0x62(%rcx)
  804212067e:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212067f:	75 74                	jne    80421206f5 <__rodata_start+0x1325>
  8042120681:	20 74 68 65          	and    %dh,0x65(%rax,%rbp,2)
  8042120685:	20 6b 65             	and    %ch,0x65(%rbx)
  8042120688:	72 6e                	jb     80421206f8 <__rodata_start+0x1328>
  804212068a:	65 6c                	gs insb (%dx),%es:(%rdi)
  804212068c:	00 00                	add    %al,(%rax)
  804212068e:	00 00                	add    %al,(%rax)
  8042120690:	44 69 73 70 6c 61 79 	imul   $0x2079616c,0x70(%rbx),%r14d
  8042120697:	20 
  8042120698:	61                   	(bad)
  8042120699:	6c                   	insb   (%dx),%es:(%rdi)
  804212069a:	6c                   	insb   (%dx),%es:(%rdi)
  804212069b:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212069c:	63 61 74             	movsxd 0x74(%rcx),%esp
  804212069f:	65 64 20 6d 65       	gs and %ch,%fs:0x65(%rbp)
  80421206a4:	6d                   	insl   (%dx),%es:(%rdi)
  80421206a5:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421206a6:	72 79                	jb     8042120721 <__rodata_start+0x1351>
  80421206a8:	20 70 61             	and    %dh,0x61(%rax)
  80421206ab:	67 65 73 00          	addr32 gs jae 80421206af <__rodata_start+0x12df>
  80421206af:	00 28                	add    %ch,(%rax)
  80421206b1:	28 70 61             	sub    %dh,0x61(%rax)
  80421206b4:	67 65 29 2d 3e 73 74 	sub    %ebp,%gs:0x6174733e(%eip)        # 80a38679fa <__bss_end+0x6085f9fa>
  80421206bb:	61 
  80421206bc:	74 65                	je     8042120723 <__rodata_start+0x1353>
  80421206be:	20 26                	and    %ah,(%rsi)
  80421206c0:	20 4e 4f             	and    %cl,0x4f(%rsi)
  80421206c3:	44                   	rex.R
  80421206c4:	45 5f                	rex.RB pop %r15
  80421206c6:	54                   	push   %rsp
  80421206c7:	59                   	pop    %rcx
  80421206c8:	50                   	push   %rax
  80421206c9:	45 5f                	rex.RB pop %r15
  80421206cb:	4d                   	rex.WRB
  80421206cc:	41 53                	push   %r11
  80421206ce:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  80421206d1:	3e 3d 20 50 41 52    	ds cmp $0x52415020,%eax
  80421206d7:	54                   	push   %rsp
  80421206d8:	49                   	rex.WB
  80421206d9:	41                   	rex.B
  80421206da:	4c 5f                	rex.WR pop %rdi
  80421206dc:	4e                   	rex.WRX
  80421206dd:	4f                   	rex.WRXB
  80421206de:	44                   	rex.R
  80421206df:	45 00 00             	add    %r8b,(%r8)
  80421206e2:	00 00                	add    %al,(%rax)
  80421206e4:	00 00                	add    %al,(%rax)
  80421206e6:	00 00                	add    %al,(%rax)
  80421206e8:	28 28                	sub    %ch,(%rax)
  80421206ea:	70 61                	jo     804212074d <__rodata_start+0x137d>
  80421206ec:	72 29                	jb     8042120717 <__rodata_start+0x1347>
  80421206ee:	2d 3e 73 74 61       	sub    $0x6174733e,%eax
  80421206f3:	74 65                	je     804212075a <__rodata_start+0x138a>
  80421206f5:	20 26                	and    %ah,(%rsi)
  80421206f7:	20 4e 4f             	and    %cl,0x4f(%rsi)
  80421206fa:	44                   	rex.R
  80421206fb:	45 5f                	rex.RB pop %r15
  80421206fd:	54                   	push   %rsp
  80421206fe:	59                   	pop    %rcx
  80421206ff:	50                   	push   %rax
  8042120700:	45 5f                	rex.RB pop %r15
  8042120702:	4d                   	rex.WRB
  8042120703:	41 53                	push   %r11
  8042120705:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  8042120708:	3e 3d 20 50 41 52    	ds cmp $0x52415020,%eax
  804212070e:	54                   	push   %rsp
  804212070f:	49                   	rex.WB
  8042120710:	41                   	rex.B
  8042120711:	4c 5f                	rex.WR pop %rdi
  8042120713:	4e                   	rex.WRX
  8042120714:	4f                   	rex.WRXB
  8042120715:	44                   	rex.R
  8042120716:	45 00 6c 69 73       	add    %r13b,0x73(%r9,%rbp,2)
  804212071b:	74 5f                	je     804212077c <__rodata_start+0x13ac>
  804212071d:	65 6d                	gs insl (%dx),%es:(%rdi)
  804212071f:	70 74                	jo     8042120795 <__rodata_start+0x13c5>
  8042120721:	79 28                	jns    804212074b <__rodata_start+0x137b>
  8042120723:	28 73 74             	sub    %dh,0x74(%rbx)
  8042120726:	72 75                	jb     804212079d <__rodata_start+0x13cd>
  8042120728:	63 74 20 4c          	movsxd 0x4c(%rax,%riz,1),%esi
  804212072c:	69 73 74 20 2a 29 70 	imul   $0x70292a20,0x74(%rbx),%esi
  8042120733:	61                   	(bad)
  8042120734:	72 29                	jb     804212075f <__rodata_start+0x138f>
  8042120736:	00 00                	add    %al,(%rax)
  8042120738:	28 28                	sub    %ch,(%rax)
  804212073a:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212073b:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212073c:	64 65 29 2d 3e 73 74 	fs sub %ebp,%gs:0x6174733e(%rip)        # 80a3867a82 <__bss_end+0x6085fa82>
  8042120743:	61 
  8042120744:	74 65                	je     80421207ab <__rodata_start+0x13db>
  8042120746:	20 26                	and    %ah,(%rsi)
  8042120748:	20 4e 4f             	and    %cl,0x4f(%rsi)
  804212074b:	44                   	rex.R
  804212074c:	45 5f                	rex.RB pop %r15
  804212074e:	54                   	push   %rsp
  804212074f:	59                   	pop    %rcx
  8042120750:	50                   	push   %rax
  8042120751:	45 5f                	rex.RB pop %r15
  8042120753:	4d                   	rex.WRB
  8042120754:	41 53                	push   %r11
  8042120756:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  8042120759:	3c 20                	cmp    $0x20,%al
  804212075b:	50                   	push   %rax
  804212075c:	41 52                	push   %r10
  804212075e:	54                   	push   %rsp
  804212075f:	49                   	rex.WB
  8042120760:	41                   	rex.B
  8042120761:	4c 5f                	rex.WR pop %rdi
  8042120763:	4e                   	rex.WRX
  8042120764:	4f                   	rex.WRXB
  8042120765:	44                   	rex.R
  8042120766:	45 00 28             	add    %r13b,(%r8)
  8042120769:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212076a:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212076b:	64 65 2d 3e 73 74 61 	fs gs sub $0x6174733e,%eax
  8042120772:	74 65                	je     80421207d9 <__rodata_start+0x1409>
  8042120774:	20 26                	and    %ah,(%rsi)
  8042120776:	20 4e 4f             	and    %cl,0x4f(%rsi)
  8042120779:	44                   	rex.R
  804212077a:	45 5f                	rex.RB pop %r15
  804212077c:	54                   	push   %rsp
  804212077d:	59                   	pop    %rcx
  804212077e:	50                   	push   %rax
  804212077f:	45 5f                	rex.RB pop %r15
  8042120781:	4d                   	rex.WRB
  8042120782:	41 53                	push   %r11
  8042120784:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  8042120787:	3d 3d 20 4d 41       	cmp    $0x414d203d,%eax
  804212078c:	50                   	push   %rax
  804212078d:	50                   	push   %rax
  804212078e:	49                   	rex.WB
  804212078f:	4e                   	rex.WRX
  8042120790:	47 5f                	rex.RXB pop %r15
  8042120792:	4e                   	rex.WRX
  8042120793:	4f                   	rex.WRXB
  8042120794:	44                   	rex.R
  8042120795:	45 00 00             	add    %r8b,(%r8)
  8042120798:	28 6e 6f             	sub    %ch,0x6f(%rsi)
  804212079b:	64 65 2d 3e 73 74 61 	fs gs sub $0x6174733e,%eax
  80421207a2:	74 65                	je     8042120809 <__rodata_start+0x1439>
  80421207a4:	20 26                	and    %ah,(%rsi)
  80421207a6:	20 4e 4f             	and    %cl,0x4f(%rsi)
  80421207a9:	44                   	rex.R
  80421207aa:	45 5f                	rex.RB pop %r15
  80421207ac:	54                   	push   %rsp
  80421207ad:	59                   	pop    %rcx
  80421207ae:	50                   	push   %rax
  80421207af:	45 5f                	rex.RB pop %r15
  80421207b1:	4d                   	rex.WRB
  80421207b2:	41 53                	push   %r11
  80421207b4:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  80421207b7:	3d 3d 20 49 4e       	cmp    $0x4e49203d,%eax
  80421207bc:	54                   	push   %rsp
  80421207bd:	45 52                	rex.RB push %r10
  80421207bf:	4d                   	rex.WRB
  80421207c0:	45                   	rex.RB
  80421207c1:	44                   	rex.R
  80421207c2:	49                   	rex.WB
  80421207c3:	41 54                	push   %r12
  80421207c5:	45 5f                	rex.RB pop %r15
  80421207c7:	4e                   	rex.WRX
  80421207c8:	4f                   	rex.WRXB
  80421207c9:	44                   	rex.R
  80421207ca:	45 00 00             	add    %r8b,(%r8)
  80421207cd:	00 00                	add    %al,(%rax)
  80421207cf:	00 21                	add    %ah,(%rcx)
  80421207d1:	28 70 61             	sub    %dh,0x61(%rax)
  80421207d4:	67 65 32 70 61       	xor    %gs:0x61(%eax),%dh
  80421207d9:	28 70 61             	sub    %dh,0x61(%rax)
  80421207dc:	67 65 29 20          	sub    %esp,%gs:(%eax)
  80421207e0:	26 20 43 4c          	es and %al,0x4c(%rbx)
  80421207e4:	41 53                	push   %r11
  80421207e6:	53                   	push   %rbx
  80421207e7:	5f                   	pop    %rdi
  80421207e8:	4d                   	rex.WRB
  80421207e9:	41 53                	push   %r11
  80421207eb:	4b 28 70 61          	rex.WXB sub %sil,0x61(%r8)
  80421207ef:	67 65 2d 3e 63 6c 61 	addr32 gs sub $0x616c633e,%eax
  80421207f6:	73 73                	jae    804212086b <__rodata_start+0x149b>
  80421207f8:	29 29                	sub    %ebp,(%rcx)
  80421207fa:	00 00                	add    %al,(%rax)
  80421207fc:	00 00                	add    %al,(%rax)
  80421207fe:	00 00                	add    %al,(%rax)
  8042120800:	70 61                	jo     8042120863 <__rodata_start+0x1493>
  8042120802:	67 65 2d 3e 6c 65 66 	addr32 gs sub $0x66656c3e,%eax
  8042120809:	74 2d                	je     8042120838 <__rodata_start+0x1468>
  804212080b:	3e 73 74             	jae,pt 8042120882 <__rodata_start+0x14b2>
  804212080e:	61                   	(bad)
  804212080f:	74 65                	je     8042120876 <__rodata_start+0x14a6>
  8042120811:	20 3d 3d 20 70 61    	and    %bh,0x6170203d(%rip)        # 80a3822854 <__bss_end+0x6081a854>
  8042120817:	67 65 2d 3e 73 74 61 	addr32 gs sub $0x6174733e,%eax
  804212081e:	74 65                	je     8042120885 <__rodata_start+0x14b5>
	...
  8042120828:	70 61                	jo     804212088b <__rodata_start+0x14bb>
  804212082a:	67 65 2d 3e 72 69 67 	addr32 gs sub $0x6769723e,%eax
  8042120831:	68 74 2d 3e 73       	push   $0x733e2d74
  8042120836:	74 61                	je     8042120899 <__rodata_start+0x14c9>
  8042120838:	74 65                	je     804212089f <__rodata_start+0x14cf>
  804212083a:	20 3d 3d 20 70 61    	and    %bh,0x6170203d(%rip)        # 80a382287d <__bss_end+0x6081a87d>
  8042120840:	67 65 2d 3e 73 74 61 	addr32 gs sub $0x6174733e,%eax
  8042120847:	74 65                	je     80421208ae <__rodata_start+0x14de>
  8042120849:	00 00                	add    %al,(%rax)
  804212084b:	00 00                	add    %al,(%rax)
  804212084d:	00 00                	add    %al,(%rax)
  804212084f:	00 70 61             	add    %dh,0x61(%rax)
  8042120852:	67 65 2d 3e 6c 65 66 	addr32 gs sub $0x66656c3e,%eax
  8042120859:	74 2d                	je     8042120888 <__rodata_start+0x14b8>
  804212085b:	3e 63 6c 61 73       	ds movsxd 0x73(%rcx,%riz,2),%ebp
  8042120860:	73 20                	jae    8042120882 <__rodata_start+0x14b2>
  8042120862:	2b 20                	sub    (%rax),%esp
  8042120864:	31 20                	xor    %esp,(%rax)
  8042120866:	3d 3d 20 70 61       	cmp    $0x6170203d,%eax
  804212086b:	67 65 2d 3e 63 6c 61 	addr32 gs sub $0x616c633e,%eax
  8042120872:	73 73                	jae    80421208e7 <__rodata_start+0x1517>
  8042120874:	00 00                	add    %al,(%rax)
  8042120876:	00 00                	add    %al,(%rax)
  8042120878:	70 61                	jo     80421208db <__rodata_start+0x150b>
  804212087a:	67 65 32 70 61       	xor    %gs:0x61(%eax),%dh
  804212087f:	28 70 61             	sub    %dh,0x61(%rax)
  8042120882:	67 65 29 20          	sub    %esp,%gs:(%eax)
  8042120886:	3d 3d 20 70 61       	cmp    $0x6170203d,%eax
  804212088b:	67 65 32 70 61       	xor    %gs:0x61(%eax),%dh
  8042120890:	28 70 61             	sub    %dh,0x61(%rax)
  8042120893:	67 65 2d 3e 6c 65 66 	addr32 gs sub $0x66656c3e,%eax
  804212089a:	74 29                	je     80421208c5 <__rodata_start+0x14f5>
  804212089c:	00 00                	add    %al,(%rax)
  804212089e:	00 00                	add    %al,(%rax)
  80421208a0:	70 61                	jo     8042120903 <__rodata_start+0x1533>
  80421208a2:	67 65 2d 3e 72 69 67 	addr32 gs sub $0x6769723e,%eax
  80421208a9:	68 74 2d 3e 63       	push   $0x633e2d74
  80421208ae:	6c                   	insb   (%dx),%es:(%rdi)
  80421208af:	61                   	(bad)
  80421208b0:	73 73                	jae    8042120925 <__rodata_start+0x1555>
  80421208b2:	20 2b                	and    %ch,(%rbx)
  80421208b4:	20 31                	and    %dh,(%rcx)
  80421208b6:	20 3d 3d 20 70 61    	and    %bh,0x6170203d(%rip)        # 80a38228f9 <__bss_end+0x6081a8f9>
  80421208bc:	67 65 2d 3e 63 6c 61 	addr32 gs sub $0x616c633e,%eax
  80421208c3:	73 73                	jae    8042120938 <__rodata_start+0x1568>
  80421208c5:	00 00                	add    %al,(%rax)
  80421208c7:	00 70 61             	add    %dh,0x61(%rax)
  80421208ca:	67 65 2d 3e 61 64 64 	addr32 gs sub $0x6464613e,%eax
  80421208d1:	72 20                	jb     80421208f3 <__rodata_start+0x1523>
  80421208d3:	2b 20                	sub    (%rax),%esp
  80421208d5:	28 31                	sub    %dh,(%rcx)
  80421208d7:	55                   	push   %rbp
  80421208d8:	4c                   	rex.WR
  80421208d9:	4c 20 3c 3c          	rex.WR and %r15b,(%rsp,%rdi,1)
  80421208dd:	20 28                	and    %ch,(%rax)
  80421208df:	70 61                	jo     8042120942 <__rodata_start+0x1572>
  80421208e1:	67 65 2d 3e 63 6c 61 	addr32 gs sub $0x616c633e,%eax
  80421208e8:	73 73                	jae    804212095d <__rodata_start+0x158d>
  80421208ea:	20 2d 20 31 29 29    	and    %ch,0x29293120(%rip)        # 806b3b3a10 <__bss_end+0x283aba10>
  80421208f0:	20 3d 3d 20 70 61    	and    %bh,0x6170203d(%rip)        # 80a3822933 <__bss_end+0x6081a933>
  80421208f6:	67 65 2d 3e 72 69 67 	addr32 gs sub $0x6769723e,%eax
  80421208fd:	68 74 2d 3e 61       	push   $0x613e2d74
  8042120902:	64 64 72 00          	fs fs jb 8042120906 <__rodata_start+0x1536>
  8042120906:	00 00                	add    %al,(%rax)
  8042120908:	70 61                	jo     804212096b <__rodata_start+0x159b>
  804212090a:	67 65 2d 3e 70 61 72 	addr32 gs sub $0x7261703e,%eax
  8042120911:	65 6e                	outsb  %gs:(%rsi),(%dx)
  8042120913:	74 2d                	je     8042120942 <__rodata_start+0x1572>
  8042120915:	3e 63 6c 61 73       	ds movsxd 0x73(%rcx,%riz,2),%ebp
  804212091a:	73 20                	jae    804212093c <__rodata_start+0x156c>
  804212091c:	2d 20 31 20 3d       	sub    $0x3d203120,%eax
  8042120921:	3d 20 70 61 67       	cmp    $0x67617020,%eax
  8042120926:	65 2d 3e 63 6c 61    	gs sub $0x616c633e,%eax
  804212092c:	73 73                	jae    80421209a1 <__rodata_start+0x15d1>
  804212092e:	00 00                	add    %al,(%rax)
  8042120930:	28 70 61             	sub    %dh,0x61(%rax)
  8042120933:	67 65 2d 3e 70 61 72 	addr32 gs sub $0x7261703e,%eax
  804212093a:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804212093c:	74 2d                	je     804212096b <__rodata_start+0x159b>
  804212093e:	3e 6c                	ds insb (%dx),%es:(%rdi)
  8042120940:	65 66 74 20          	gs data16 je 8042120964 <__rodata_start+0x1594>
  8042120944:	3d 3d 20 70 61       	cmp    $0x6170203d,%eax
  8042120949:	67 65 29 20          	sub    %esp,%gs:(%eax)
  804212094d:	5e                   	pop    %rsi
  804212094e:	20 28                	and    %ch,(%rax)
  8042120950:	70 61                	jo     80421209b3 <__rodata_start+0x15e3>
  8042120952:	67 65 2d 3e 70 61 72 	addr32 gs sub $0x7261703e,%eax
  8042120959:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804212095b:	74 2d                	je     804212098a <__rodata_start+0x15ba>
  804212095d:	3e 72 69             	jb,pt  80421209c9 <__rodata_start+0x15f9>
  8042120960:	67 68 74 20 3d 3d    	addr32 push $0x3d3d2074
  8042120966:	20 70 61             	and    %dh,0x61(%rax)
  8042120969:	67 65 29 00          	sub    %eax,%gs:(%eax)
  804212096d:	00 00                	add    %al,(%rax)
  804212096f:	00 70 61             	add    %dh,0x61(%rax)
  8042120972:	67 65 2d 3e 68 65 61 	addr32 gs sub $0x6165683e,%eax
  8042120979:	64 2e 6e             	fs outsb %fs:(%rsi),(%dx)
  804212097c:	65 78 74             	gs js  80421209f3 <__rodata_start+0x1623>
  804212097f:	20 26                	and    %ah,(%rsi)
  8042120981:	26 20 70 61          	es and %dh,0x61(%rax)
  8042120985:	67 65 2d 3e 68 65 61 	addr32 gs sub $0x6165683e,%eax
  804212098c:	64 2e 70 72          	fs jo,pn 8042120a02 <__rodata_start+0x1632>
  8042120990:	65 76 00             	gs jbe 8042120993 <__rodata_start+0x15c3>
  8042120993:	00 00                	add    %al,(%rax)
  8042120995:	00 00                	add    %al,(%rax)
  8042120997:	00 28                	add    %ch,(%rax)
  8042120999:	28 76 29             	sub    %dh,0x29(%rsi)
  804212099c:	2d 3e 73 74 61       	sub    $0x6174733e,%eax
  80421209a1:	74 65                	je     8042120a08 <__rodata_start+0x1638>
  80421209a3:	20 26                	and    %ah,(%rsi)
  80421209a5:	20 4e 4f             	and    %cl,0x4f(%rsi)
  80421209a8:	44                   	rex.R
  80421209a9:	45 5f                	rex.RB pop %r15
  80421209ab:	54                   	push   %rsp
  80421209ac:	59                   	pop    %rcx
  80421209ad:	50                   	push   %rax
  80421209ae:	45 5f                	rex.RB pop %r15
  80421209b0:	4d                   	rex.WRB
  80421209b1:	41 53                	push   %r11
  80421209b3:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  80421209b6:	3c 20                	cmp    $0x20,%al
  80421209b8:	50                   	push   %rax
  80421209b9:	41 52                	push   %r10
  80421209bb:	54                   	push   %rsp
  80421209bc:	49                   	rex.WB
  80421209bd:	41                   	rex.B
  80421209be:	4c 5f                	rex.WR pop %rdi
  80421209c0:	4e                   	rex.WRX
  80421209c1:	4f                   	rex.WRXB
  80421209c2:	44                   	rex.R
  80421209c3:	45 00 00             	add    %r8b,(%r8)
  80421209c6:	00 00                	add    %al,(%rax)
  80421209c8:	28 28                	sub    %ch,(%rax)
  80421209ca:	70 61                	jo     8042120a2d <__rodata_start+0x165d>
  80421209cc:	67 65 29 2d 3e 73 74 	sub    %ebp,%gs:0x6174733e(%eip)        # 80a3867d12 <__bss_end+0x6085fd12>
  80421209d3:	61 
  80421209d4:	74 65                	je     8042120a3b <__rodata_start+0x166b>
  80421209d6:	20 26                	and    %ah,(%rsi)
  80421209d8:	20 4e 4f             	and    %cl,0x4f(%rsi)
  80421209db:	44                   	rex.R
  80421209dc:	45 5f                	rex.RB pop %r15
  80421209de:	54                   	push   %rsp
  80421209df:	59                   	pop    %rcx
  80421209e0:	50                   	push   %rax
  80421209e1:	45 5f                	rex.RB pop %r15
  80421209e3:	4d                   	rex.WRB
  80421209e4:	41 53                	push   %r11
  80421209e6:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  80421209e9:	3c 20                	cmp    $0x20,%al
  80421209eb:	50                   	push   %rax
  80421209ec:	41 52                	push   %r10
  80421209ee:	54                   	push   %rsp
  80421209ef:	49                   	rex.WB
  80421209f0:	41                   	rex.B
  80421209f1:	4c 5f                	rex.WR pop %rdi
  80421209f3:	4e                   	rex.WRX
  80421209f4:	4f                   	rex.WRXB
  80421209f5:	44                   	rex.R
  80421209f6:	45 00 21             	add    %r12b,(%r9)
  80421209f9:	28 70 61             	sub    %dh,0x61(%rax)
  80421209fc:	67 65 2d 3e 73 74 61 	addr32 gs sub $0x6174733e,%eax
  8042120a03:	74 65                	je     8042120a6a <__rodata_start+0x169a>
  8042120a05:	20 26                	and    %ah,(%rsi)
  8042120a07:	20 50 52             	and    %dl,0x52(%rax)
  8042120a0a:	4f 54                	rex.WRXB push %r12
  8042120a0c:	5f                   	pop    %rdi
  8042120a0d:	4c                   	rex.WR
  8042120a0e:	41 5a                	pop    %r10
  8042120a10:	59                   	pop    %rcx
  8042120a11:	29 20                	sub    %esp,(%rax)
  8042120a13:	7c 7c                	jl     8042120a91 <__rodata_start+0x16c1>
  8042120a15:	20 21                	and    %ah,(%rcx)
  8042120a17:	28 70 61             	sub    %dh,0x61(%rax)
  8042120a1a:	67 65 2d 3e 73 74 61 	addr32 gs sub $0x6174733e,%eax
  8042120a21:	74 65                	je     8042120a88 <__rodata_start+0x16b8>
  8042120a23:	20 26                	and    %ah,(%rsi)
  8042120a25:	20 50 52             	and    %dl,0x52(%rax)
  8042120a28:	4f 54                	rex.WRXB push %r12
  8042120a2a:	5f                   	pop    %rdi
  8042120a2b:	53                   	push   %rbx
  8042120a2c:	48                   	rex.W
  8042120a2d:	41 52                	push   %r10
  8042120a2f:	45 29 00             	sub    %r8d,(%r8)
  8042120a32:	00 00                	add    %al,(%rax)
  8042120a34:	00 00                	add    %al,(%rax)
  8042120a36:	00 00                	add    %al,(%rax)
  8042120a38:	70 61                	jo     8042120a9b <__rodata_start+0x16cb>
  8042120a3a:	67 65 2d 3e 73 74 61 	addr32 gs sub $0x6174733e,%eax
  8042120a41:	74 65                	je     8042120aa8 <__rodata_start+0x16d8>
  8042120a43:	20 3d 3d 20 49 4e    	and    %bh,0x4e49203d(%rip)        # 80905b2a86 <__bss_end+0x4d5aaa86>
  8042120a49:	54                   	push   %rsp
  8042120a4a:	45 52                	rex.RB push %r10
  8042120a4c:	4d                   	rex.WRB
  8042120a4d:	45                   	rex.RB
  8042120a4e:	44                   	rex.R
  8042120a4f:	49                   	rex.WB
  8042120a50:	41 54                	push   %r12
  8042120a52:	45 5f                	rex.RB pop %r15
  8042120a54:	4e                   	rex.WRX
  8042120a55:	4f                   	rex.WRXB
  8042120a56:	44                   	rex.R
  8042120a57:	45 00 00             	add    %r8b,(%r8)
  8042120a5a:	00 00                	add    %al,(%rax)
  8042120a5c:	00 00                	add    %al,(%rax)
  8042120a5e:	00 00                	add    %al,(%rax)
  8042120a60:	4d                   	rex.WRB
  8042120a61:	41 50                	push   %r8
  8042120a63:	50                   	push   %rax
  8042120a64:	49                   	rex.WB
  8042120a65:	4e                   	rex.WRX
  8042120a66:	47 5f                	rex.RXB pop %r15
  8042120a68:	4e                   	rex.WRX
  8042120a69:	4f                   	rex.WRXB
  8042120a6a:	44                   	rex.R
  8042120a6b:	45 3a 20             	cmp    (%r8),%r12b
  8042120a6e:	70 68                	jo     8042120ad8 <__rodata_start+0x1708>
  8042120a70:	79 3a                	jns    8042120aac <__rodata_start+0x16dc>
  8042120a72:	20 25 70 2c 20 63    	and    %ah,0x63202c70(%rip)        # 80a53236e8 <__bss_end+0x6231b6e8>
  8042120a78:	6c                   	insb   (%dx),%es:(%rdi)
  8042120a79:	61                   	(bad)
  8042120a7a:	73 73                	jae    8042120aef <__rodata_start+0x171f>
  8042120a7c:	3a 20                	cmp    (%rax),%ah
  8042120a7e:	25 64 0a 00 00       	and    $0xa64,%eax
  8042120a83:	00 00                	add    %al,(%rax)
  8042120a85:	00 00                	add    %al,(%rax)
  8042120a87:	00 4b 41             	add    %cl,0x41(%rbx)
  8042120a8a:	44                   	rex.R
  8042120a8b:	44 52                	rex.R push %rdx
  8042120a8d:	20 63 61             	and    %ah,0x61(%rbx)
  8042120a90:	6c                   	insb   (%dx),%es:(%rdi)
  8042120a91:	6c                   	insb   (%dx),%es:(%rdi)
  8042120a92:	65 64 20 77 69       	gs and %dh,%fs:0x69(%rdi)
  8042120a97:	74 68                	je     8042120b01 <__rodata_start+0x1731>
  8042120a99:	20 69 6e             	and    %ch,0x6e(%rcx)
  8042120a9c:	76 61                	jbe    8042120aff <__rodata_start+0x172f>
  8042120a9e:	6c                   	insb   (%dx),%es:(%rdi)
  8042120a9f:	69 64 20 70 61 20 25 	imul   $0x70252061,0x70(%rax,%riz,1),%esp
  8042120aa6:	70 
  8042120aa7:	20 77 69             	and    %dh,0x69(%rdi)
  8042120aaa:	74 68                	je     8042120b14 <__rodata_start+0x1744>
  8042120aac:	20 6d 61             	and    %ch,0x61(%rbp)
  8042120aaf:	78 5f                	js     8042120b10 <__rodata_start+0x1740>
  8042120ab1:	6d                   	insl   (%dx),%es:(%rdi)
  8042120ab2:	65 6d                	gs insl (%dx),%es:(%rdi)
  8042120ab4:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120ab5:	72 79                	jb     8042120b30 <__rodata_start+0x1760>
  8042120ab7:	5f                   	pop    %rdi
  8042120ab8:	6d                   	insl   (%dx),%es:(%rdi)
  8042120ab9:	61                   	(bad)
  8042120aba:	70 5f                	jo     8042120b1b <__rodata_start+0x174b>
  8042120abc:	61                   	(bad)
  8042120abd:	64 64 72 3d          	fs fs jb 8042120afe <__rodata_start+0x172e>
  8042120ac1:	25 70 00 00 00       	and    $0x70,%eax
  8042120ac6:	00 00                	add    %al,(%rax)
  8042120ac8:	25 73 5b 25 30       	and    $0x30255b73,%eax
  8042120acd:	38 6c 6c 58          	cmp    %ch,0x58(%rsp,%rbp,2)
  8042120ad1:	2c 20                	sub    $0x20,%al
  8042120ad3:	25 30 38 6c 6c       	and    $0x6c6c3830,%eax
  8042120ad8:	58                   	pop    %rax
  8042120ad9:	5d                   	pop    %rbp
  8042120ada:	20 25 63 25 63 25    	and    %ah,0x25632563(%rip)        # 8067753043 <__bss_end+0x2474b043>
  8042120ae0:	63 25 63 25 63 20    	movsxd 0x20632563(%rip),%esp        # 8062753049 <__bss_end+0x1f74b049>
  8042120ae6:	2d 2d 20 73 74       	sub    $0x7473202d,%eax
  8042120aeb:	65 70 3d             	gs jo  8042120b2b <__rodata_start+0x175b>
  8042120aee:	25 7a 78 0a 00       	and    $0xa787a,%eax
  8042120af3:	00 00                	add    %al,(%rax)
  8042120af5:	00 00                	add    %al,(%rax)
  8042120af7:	00 70 65             	add    %dh,0x65(%rax)
  8042120afa:	65 72 2d             	gs jb  8042120b2a <__rodata_start+0x175a>
  8042120afd:	3e 73 74             	jae,pt 8042120b74 <__rodata_start+0x17a4>
  8042120b00:	61                   	(bad)
  8042120b01:	74 65                	je     8042120b68 <__rodata_start+0x1798>
  8042120b03:	20 3d 3d 20 41 4c    	and    %bh,0x4c41203d(%rip)        # 808e532b46 <__bss_end+0x4b52ab46>
  8042120b09:	4c                   	rex.WR
  8042120b0a:	4f                   	rex.WRXB
  8042120b0b:	43                   	rex.XB
  8042120b0c:	41 54                	push   %r12
  8042120b0e:	41                   	rex.B
  8042120b0f:	42                   	rex.X
  8042120b10:	4c                   	rex.WR
  8042120b11:	45 5f                	rex.RB pop %r15
  8042120b13:	4e                   	rex.WRX
  8042120b14:	4f                   	rex.WRXB
  8042120b15:	44                   	rex.R
  8042120b16:	45 00 4b 41          	add    %r9b,0x41(%r11)
  8042120b1a:	44                   	rex.R
  8042120b1b:	44 52                	rex.R push %rdx
  8042120b1d:	28 70 61             	sub    %dh,0x61(%rax)
  8042120b20:	67 65 32 70 61       	xor    %gs:0x61(%eax),%dh
  8042120b25:	28 6e 65             	sub    %ch,0x65(%rsi)
  8042120b28:	77 29                	ja     8042120b53 <__rodata_start+0x1783>
  8042120b2a:	29 20                	sub    %esp,(%rax)
  8042120b2c:	3d 3d 20 66 69       	cmp    $0x6966203d,%eax
  8042120b31:	72 73                	jb     8042120ba6 <__rodata_start+0x17d6>
  8042120b33:	74 5f                	je     8042120b94 <__rodata_start+0x17c4>
  8042120b35:	70 6f                	jo     8042120ba6 <__rodata_start+0x17d6>
  8042120b37:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120b38:	6c                   	insb   (%dx),%es:(%rdi)
  8042120b39:	00 00                	add    %al,(%rax)
  8042120b3b:	00 00                	add    %al,(%rax)
  8042120b3d:	00 00                	add    %al,(%rax)
  8042120b3f:	00 50 41             	add    %dl,0x41(%rax)
  8042120b42:	44                   	rex.R
  8042120b43:	44 52                	rex.R push %rdx
  8042120b45:	20 63 61             	and    %ah,0x61(%rbx)
  8042120b48:	6c                   	insb   (%dx),%es:(%rdi)
  8042120b49:	6c                   	insb   (%dx),%es:(%rdi)
  8042120b4a:	65 64 20 77 69       	gs and %dh,%fs:0x69(%rdi)
  8042120b4f:	74 68                	je     8042120bb9 <__rodata_start+0x17e9>
  8042120b51:	20 69 6e             	and    %ch,0x6e(%rcx)
  8042120b54:	76 61                	jbe    8042120bb7 <__rodata_start+0x17e7>
  8042120b56:	6c                   	insb   (%dx),%es:(%rdi)
  8042120b57:	69 64 20 6b 76 61 20 	imul   $0x25206176,0x6b(%rax,%riz,1),%esp
  8042120b5e:	25 
  8042120b5f:	70 00                	jo     8042120b61 <__rodata_start+0x1791>
  8042120b61:	00 00                	add    %al,(%rax)
  8042120b63:	00 00                	add    %al,(%rax)
  8042120b65:	00 00                	add    %al,(%rax)
  8042120b67:	00 70 61             	add    %dh,0x61(%rax)
  8042120b6a:	67 65 32 70 61       	xor    %gs:0x61(%eax),%dh
  8042120b6f:	28 6e 65             	sub    %ch,0x65(%rsi)
  8042120b72:	77 29                	ja     8042120b9d <__rodata_start+0x17cd>
  8042120b74:	20 3e                	and    %bh,(%rsi)
  8042120b76:	3d 20 50 41 44       	cmp    $0x44415020,%eax
  8042120b7b:	44 52                	rex.R push %rdx
  8042120b7d:	28 65 6e             	sub    %ah,0x6e(%rbp)
  8042120b80:	64 29 20             	sub    %esp,%fs:(%rax)
  8042120b83:	7c 7c                	jl     8042120c01 <__rodata_start+0x1831>
  8042120b85:	20 70 61             	and    %dh,0x61(%rax)
  8042120b88:	67 65 32 70 61       	xor    %gs:0x61(%eax),%dh
  8042120b8d:	28 6e 65             	sub    %ch,0x65(%rsi)
  8042120b90:	77 29                	ja     8042120bbb <__rodata_start+0x17eb>
  8042120b92:	20 2b                	and    %ch,(%rbx)
  8042120b94:	20 43 4c             	and    %al,0x4c(%rbx)
  8042120b97:	41 53                	push   %r11
  8042120b99:	53                   	push   %rbx
  8042120b9a:	5f                   	pop    %rdi
  8042120b9b:	4d                   	rex.WRB
  8042120b9c:	41 53                	push   %r11
  8042120b9e:	4b 28 6e 65          	rex.WXB sub %bpl,0x65(%r14)
  8042120ba2:	77 2d                	ja     8042120bd1 <__rodata_start+0x1801>
  8042120ba4:	3e 63 6c 61 73       	ds movsxd 0x73(%rcx,%riz,2),%ebp
  8042120ba9:	73 29                	jae    8042120bd4 <__rodata_start+0x1804>
  8042120bab:	20 3c 20             	and    %bh,(%rax,%riz,1)
  8042120bae:	49                   	rex.WB
  8042120baf:	4f 50                	rex.WRXB push %r8
  8042120bb1:	48 59                	rex.W pop %rcx
  8042120bb3:	53                   	push   %rbx
  8042120bb4:	4d                   	rex.WRB
  8042120bb5:	45                   	rex.RB
  8042120bb6:	4d 00 21             	rex.WRB add %r12b,(%r9)
  8042120bb9:	6c                   	insb   (%dx),%es:(%rdi)
  8042120bba:	69 73 74 5f 65 6d 70 	imul   $0x706d655f,0x74(%rbx),%esi
  8042120bc1:	74 79                	je     8042120c3c <__rodata_start+0x186c>
  8042120bc3:	28 26                	sub    %ah,(%rsi)
  8042120bc5:	66 72 65             	data16 jb 8042120c2d <__rodata_start+0x185d>
  8042120bc8:	65 5f                	gs pop %rdi
  8042120bca:	64 65 73 63          	fs gs jae 8042120c31 <__rodata_start+0x1861>
  8042120bce:	72 69                	jb     8042120c39 <__rodata_start+0x1869>
  8042120bd0:	70 74                	jo     8042120c46 <__rodata_start+0x1876>
  8042120bd2:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120bd3:	72 73                	jb     8042120c48 <__rodata_start+0x1878>
  8042120bd5:	29 00                	sub    %eax,(%rax)
  8042120bd7:	00 28                	add    %ch,(%rax)
  8042120bd9:	28 70 61             	sub    %dh,0x61(%rax)
  8042120bdc:	72 65                	jb     8042120c43 <__rodata_start+0x1873>
  8042120bde:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120bdf:	74 29                	je     8042120c0a <__rodata_start+0x183a>
  8042120be1:	2d 3e 73 74 61       	sub    $0x6174733e,%eax
  8042120be6:	74 65                	je     8042120c4d <__rodata_start+0x187d>
  8042120be8:	20 26                	and    %ah,(%rsi)
  8042120bea:	20 4e 4f             	and    %cl,0x4f(%rsi)
  8042120bed:	44                   	rex.R
  8042120bee:	45 5f                	rex.RB pop %r15
  8042120bf0:	54                   	push   %rsp
  8042120bf1:	59                   	pop    %rcx
  8042120bf2:	50                   	push   %rax
  8042120bf3:	45 5f                	rex.RB pop %r15
  8042120bf5:	4d                   	rex.WRB
  8042120bf6:	41 53                	push   %r11
  8042120bf8:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  8042120bfb:	3c 20                	cmp    $0x20,%al
  8042120bfd:	50                   	push   %rax
  8042120bfe:	41 52                	push   %r10
  8042120c00:	54                   	push   %rsp
  8042120c01:	49                   	rex.WB
  8042120c02:	41                   	rex.B
  8042120c03:	4c 5f                	rex.WR pop %rdi
  8042120c05:	4e                   	rex.WRX
  8042120c06:	4f                   	rex.WRXB
  8042120c07:	44                   	rex.R
  8042120c08:	45 00 00             	add    %r8b,(%r8)
  8042120c0b:	00 00                	add    %al,(%rax)
  8042120c0d:	00 00                	add    %al,(%rax)
  8042120c0f:	00 70 61             	add    %dh,0x61(%rax)
  8042120c12:	72 65                	jb     8042120c79 <__rodata_start+0x18a9>
  8042120c14:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120c15:	74 2d                	je     8042120c44 <__rodata_start+0x1874>
  8042120c17:	3e 70 68             	jo,pt  8042120c82 <__rodata_start+0x18b2>
  8042120c1a:	79 20                	jns    8042120c3c <__rodata_start+0x186c>
  8042120c1c:	26 26 20 70 61       	es es and %dh,0x61(%rax)
  8042120c21:	72 65                	jb     8042120c88 <__rodata_start+0x18b8>
  8042120c23:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120c24:	74 2d                	je     8042120c53 <__rodata_start+0x1883>
  8042120c26:	3e 70 68             	jo,pt  8042120c91 <__rodata_start+0x18c1>
  8042120c29:	79 2d                	jns    8042120c58 <__rodata_start+0x1888>
  8042120c2b:	3e 6c                	ds insb (%dx),%es:(%rdi)
  8042120c2d:	65 66 74 20          	gs data16 je 8042120c51 <__rodata_start+0x1881>
  8042120c31:	26 26 20 70 61       	es es and %dh,0x61(%rax)
  8042120c36:	72 65                	jb     8042120c9d <__rodata_start+0x18cd>
  8042120c38:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120c39:	74 2d                	je     8042120c68 <__rodata_start+0x1898>
  8042120c3b:	3e 70 68             	jo,pt  8042120ca6 <__rodata_start+0x18d6>
  8042120c3e:	79 2d                	jns    8042120c6d <__rodata_start+0x189d>
  8042120c40:	3e 72 69             	jb,pt  8042120cac <__rodata_start+0x18dc>
  8042120c43:	67 68 74 00 00 28    	addr32 push $0x28000074
  8042120c49:	28 70 61             	sub    %dh,0x61(%rax)
  8042120c4c:	72 65                	jb     8042120cb3 <__rodata_start+0x18e3>
  8042120c4e:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120c4f:	74 29                	je     8042120c7a <__rodata_start+0x18aa>
  8042120c51:	2d 3e 73 74 61       	sub    $0x6174733e,%eax
  8042120c56:	74 65                	je     8042120cbd <__rodata_start+0x18ed>
  8042120c58:	20 26                	and    %ah,(%rsi)
  8042120c5a:	20 4e 4f             	and    %cl,0x4f(%rsi)
  8042120c5d:	44                   	rex.R
  8042120c5e:	45 5f                	rex.RB pop %r15
  8042120c60:	54                   	push   %rsp
  8042120c61:	59                   	pop    %rcx
  8042120c62:	50                   	push   %rax
  8042120c63:	45 5f                	rex.RB pop %r15
  8042120c65:	4d                   	rex.WRB
  8042120c66:	41 53                	push   %r11
  8042120c68:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  8042120c6b:	3e 3d 20 50 41 52    	ds cmp $0x52415020,%eax
  8042120c71:	54                   	push   %rsp
  8042120c72:	49                   	rex.WB
  8042120c73:	41                   	rex.B
  8042120c74:	4c 5f                	rex.WR pop %rdi
  8042120c76:	4e                   	rex.WRX
  8042120c77:	4f                   	rex.WRXB
  8042120c78:	44                   	rex.R
  8042120c79:	45 00 00             	add    %r8b,(%r8)
  8042120c7c:	00 00                	add    %al,(%rax)
  8042120c7e:	00 00                	add    %al,(%rax)
  8042120c80:	28 28                	sub    %ch,(%rax)
  8042120c82:	68 69 6e 74 29       	push   $0x29746e69
  8042120c87:	2d 3e 73 74 61       	sub    $0x6174733e,%eax
  8042120c8c:	74 65                	je     8042120cf3 <__rodata_start+0x1923>
  8042120c8e:	20 26                	and    %ah,(%rsi)
  8042120c90:	20 4e 4f             	and    %cl,0x4f(%rsi)
  8042120c93:	44                   	rex.R
  8042120c94:	45 5f                	rex.RB pop %r15
  8042120c96:	54                   	push   %rsp
  8042120c97:	59                   	pop    %rcx
  8042120c98:	50                   	push   %rax
  8042120c99:	45 5f                	rex.RB pop %r15
  8042120c9b:	4d                   	rex.WRB
  8042120c9c:	41 53                	push   %r11
  8042120c9e:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  8042120ca1:	3e 3d 20 50 41 52    	ds cmp $0x52415020,%eax
  8042120ca7:	54                   	push   %rsp
  8042120ca8:	49                   	rex.WB
  8042120ca9:	41                   	rex.B
  8042120caa:	4c 5f                	rex.WR pop %rdi
  8042120cac:	4e                   	rex.WRX
  8042120cad:	4f                   	rex.WRXB
  8042120cae:	44                   	rex.R
  8042120caf:	45 00 00             	add    %r8b,(%r8)
  8042120cb2:	00 00                	add    %al,(%rax)
  8042120cb4:	00 00                	add    %al,(%rax)
  8042120cb6:	00 00                	add    %al,(%rax)
  8042120cb8:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120cb9:	74 68                	je     8042120d23 <__rodata_start+0x1953>
  8042120cbb:	65 72 2d             	gs jb  8042120ceb <__rodata_start+0x191b>
  8042120cbe:	3e 73 74             	jae,pt 8042120d35 <__rodata_start+0x1965>
  8042120cc1:	61                   	(bad)
  8042120cc2:	74 65                	je     8042120d29 <__rodata_start+0x1959>
  8042120cc4:	20 3d 3d 20 41 4c    	and    %bh,0x4c41203d(%rip)        # 808e532d07 <__bss_end+0x4b52ad07>
  8042120cca:	4c                   	rex.WR
  8042120ccb:	4f                   	rex.WRXB
  8042120ccc:	43                   	rex.XB
  8042120ccd:	41 54                	push   %r12
  8042120ccf:	41                   	rex.B
  8042120cd0:	42                   	rex.X
  8042120cd1:	4c                   	rex.WR
  8042120cd2:	45 5f                	rex.RB pop %r15
  8042120cd4:	4e                   	rex.WRX
  8042120cd5:	4f                   	rex.WRXB
  8042120cd6:	44                   	rex.R
  8042120cd7:	45 00 00             	add    %r8b,(%r8)
  8042120cda:	00 00                	add    %al,(%rax)
  8042120cdc:	00 00                	add    %al,(%rax)
  8042120cde:	00 00                	add    %al,(%rax)
  8042120ce0:	28 6e 6f             	sub    %ch,0x6f(%rsi)
  8042120ce3:	64 65 2d 3e 6c 65 66 	fs gs sub $0x66656c3e,%eax
  8042120cea:	74 20                	je     8042120d0c <__rodata_start+0x193c>
  8042120cec:	26 26 20 6e 6f       	es es and %ch,0x6f(%rsi)
  8042120cf1:	64 65 2d 3e 72 69 67 	fs gs sub $0x6769723e,%eax
  8042120cf8:	68 74 29 20 7c       	push   $0x7c202974
  8042120cfd:	7c 20                	jl     8042120d1f <__rodata_start+0x194f>
  8042120cff:	21 61 6c             	and    %esp,0x6c(%rcx)
  8042120d02:	6c                   	insb   (%dx),%es:(%rdi)
  8042120d03:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120d04:	63 00                	movsxd (%rax),%eax
  8042120d06:	00 00                	add    %al,(%rax)
  8042120d08:	21 28                	and    %ebp,(%rax)
  8042120d0a:	70 61                	jo     8042120d6d <__rodata_start+0x199d>
  8042120d0c:	67 65 32 70 61       	xor    %gs:0x61(%eax),%dh
  8042120d11:	28 6e 6f             	sub    %ch,0x6f(%rsi)
  8042120d14:	64 65 29 20          	fs sub %esp,%gs:(%rax)
  8042120d18:	26 20 43 4c          	es and %al,0x4c(%rbx)
  8042120d1c:	41 53                	push   %r11
  8042120d1e:	53                   	push   %rbx
  8042120d1f:	5f                   	pop    %rdi
  8042120d20:	4d                   	rex.WRB
  8042120d21:	41 53                	push   %r11
  8042120d23:	4b 28 6e 6f          	rex.WXB sub %bpl,0x6f(%r14)
  8042120d27:	64 65 2d 3e 63 6c 61 	fs gs sub $0x616c633e,%eax
  8042120d2e:	73 73                	jae    8042120da3 <__rodata_start+0x19d3>
  8042120d30:	29 29                	sub    %ebp,(%rcx)
  8042120d32:	00 00                	add    %al,(%rax)
  8042120d34:	00 00                	add    %al,(%rax)
  8042120d36:	00 00                	add    %al,(%rax)
  8042120d38:	43 6c                	rex.XB insb (%dx),%es:(%rdi)
  8042120d3a:	61                   	(bad)
  8042120d3b:	73 73                	jae    8042120db0 <__rodata_start+0x19e0>
  8042120d3d:	20 25 64 20 20 50    	and    %ah,0x50202064(%rip)        # 8092322da7 <__bss_end+0x4f31ada7>
  8042120d43:	61                   	(bad)
  8042120d44:	67 65 20 61 74       	and    %ah,%gs:0x74(%ecx)
  8042120d49:	20 61 64             	and    %ah,0x64(%rcx)
  8042120d4c:	64 72 65             	fs jb  8042120db4 <__rodata_start+0x19e4>
  8042120d4f:	73 73                	jae    8042120dc4 <__rodata_start+0x19f4>
  8042120d51:	3a 20                	cmp    (%rax),%ah
  8042120d53:	25 70 2c 20 73       	and    $0x73202c70,%eax
  8042120d58:	69 7a 65 3a 20 25 6c 	imul   $0x6c25203a,0x65(%rdx),%edi
  8042120d5f:	75 20                	jne    8042120d81 <__rodata_start+0x19b1>
  8042120d61:	62 79 74 65 73       	(bad)
  8042120d66:	0a 00                	or     (%rax),%al
  8042120d68:	70 68                	jo     8042120dd2 <__rodata_start+0x1a02>
  8042120d6a:	79 73                	jns    8042120ddf <__rodata_start+0x1a0f>
  8042120d6c:	69 63 61 6c 20 70 61 	imul   $0x6170206c,0x61(%rbx),%esp
  8042120d73:	67 65 20 61 64       	and    %ah,%gs:0x64(%ecx)
  8042120d78:	64 72 65             	fs jb  8042120de0 <__rodata_start+0x1a10>
  8042120d7b:	73 73                	jae    8042120df0 <__rodata_start+0x1a20>
  8042120d7d:	3a 20                	cmp    (%rax),%ah
  8042120d7f:	25 6c 78 20 2d       	and    $0x2d20786c,%eax
  8042120d84:	20 25 6c 78 0a 00    	and    %ah,0xa786c(%rip)        # 80421c85f6 <_binary_obj_user_buggyhello2_end+0x6f7e>
  8042120d8a:	00 00                	add    %al,(%rax)
  8042120d8c:	00 00                	add    %al,(%rax)
  8042120d8e:	00 00                	add    %al,(%rax)
  8042120d90:	73 74                	jae    8042120e06 <__rodata_start+0x1a36>
  8042120d92:	65 70 20             	gs jo  8042120db5 <__rodata_start+0x19e5>
  8042120d95:	3d 3d 20 31 20       	cmp    $0x2031203d,%eax
  8042120d9a:	2a 20                	sub    (%rax),%ah
  8042120d9c:	47                   	rex.RXB
  8042120d9d:	42 20 7c 7c 20       	and    %dil,0x20(%rsp,%r15,2)
  8042120da2:	73 74                	jae    8042120e18 <__rodata_start+0x1a48>
  8042120da4:	65 70 20             	gs jo  8042120dc7 <__rodata_start+0x19f7>
  8042120da7:	3d 3d 20 32 20       	cmp    $0x2032203d,%eax
  8042120dac:	2a 20                	sub    (%rax),%ah
  8042120dae:	4d                   	rex.WRB
  8042120daf:	42 20 7c 7c 20       	and    %dil,0x20(%rsp,%r15,2)
  8042120db4:	73 74                	jae    8042120e2a <__rodata_start+0x1a5a>
  8042120db6:	65 70 20             	gs jo  8042120dd9 <__rodata_start+0x1a09>
  8042120db9:	3d 3d 20 34 20       	cmp    $0x2034203d,%eax
  8042120dbe:	2a 20                	sub    (%rax),%ah
  8042120dc0:	4b                   	rex.WXB
  8042120dc1:	42 20 7c 7c 20       	and    %dil,0x20(%rsp,%r15,2)
  8042120dc6:	73 74                	jae    8042120e3c <__rodata_start+0x1a6c>
  8042120dc8:	65 70 20             	gs jo  8042120deb <__rodata_start+0x1a1b>
  8042120dcb:	3d 3d 20 35 31       	cmp    $0x3135203d,%eax
  8042120dd0:	32 20                	xor    (%rax),%ah
  8042120dd2:	2a 20                	sub    (%rax),%ah
  8042120dd4:	47                   	rex.RXB
  8042120dd5:	42 00 00             	rex.X add %al,(%rax)
  8042120dd8:	21 28                	and    %ebp,(%rax)
  8042120dda:	70 74                	jo     8042120e50 <__rodata_start+0x1a80>
  8042120ddc:	5b                   	pop    %rbx
  8042120ddd:	69 5d 20 26 20 50 54 	imul   $0x54502026,0x20(%rbp),%ebx
  8042120de4:	45 5f                	rex.RB pop %r15
  8042120de6:	50                   	push   %rax
  8042120de7:	53                   	push   %rbx
  8042120de8:	29 20                	sub    %esp,(%rax)
  8042120dea:	7c 7c                	jl     8042120e68 <__rodata_start+0x1a98>
  8042120dec:	20 28                	and    %ch,(%rax)
  8042120dee:	73 74                	jae    8042120e64 <__rodata_start+0x1a94>
  8042120df0:	65 70 20             	gs jo  8042120e13 <__rodata_start+0x1a43>
  8042120df3:	3d 3d 20 31 20       	cmp    $0x2031203d,%eax
  8042120df8:	2a 20                	sub    (%rax),%ah
  8042120dfa:	47                   	rex.RXB
  8042120dfb:	42 20 7c 7c 20       	and    %dil,0x20(%rsp,%r15,2)
  8042120e00:	73 74                	jae    8042120e76 <__rodata_start+0x1aa6>
  8042120e02:	65 70 20             	gs jo  8042120e25 <__rodata_start+0x1a55>
  8042120e05:	3d 3d 20 32 20       	cmp    $0x2032203d,%eax
  8042120e0a:	2a 20                	sub    (%rax),%ah
  8042120e0c:	4d                   	rex.WRB
  8042120e0d:	42 29 00             	rex.X sub %eax,(%rax)
  8042120e10:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120e11:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120e12:	64 65 2d 3e 70 68 79 	fs gs sub $0x7968703e,%eax
  8042120e19:	2d 3e 6c 65 66       	sub    $0x66656c3e,%eax
  8042120e1e:	74 20                	je     8042120e40 <__rodata_start+0x1a70>
  8042120e20:	26 26 20 6e 6f       	es es and %ch,0x6f(%rsi)
  8042120e25:	64 65 2d 3e 70 68 79 	fs gs sub $0x7968703e,%eax
  8042120e2c:	2d 3e 72 69 67       	sub    $0x6769723e,%eax
  8042120e31:	68 74 00 00 00       	push   $0x74
  8042120e36:	00 00                	add    %al,(%rax)
  8042120e38:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120e39:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120e3a:	64 65 2d 3e 73 74 61 	fs gs sub $0x6174733e,%eax
  8042120e41:	74 65                	je     8042120ea8 <__rodata_start+0x1ad8>
  8042120e43:	20 3d 3d 20 49 4e    	and    %bh,0x4e49203d(%rip)        # 80905b2e86 <__bss_end+0x4d5aae86>
  8042120e49:	54                   	push   %rsp
  8042120e4a:	45 52                	rex.RB push %r10
  8042120e4c:	4d                   	rex.WRB
  8042120e4d:	45                   	rex.RB
  8042120e4e:	44                   	rex.R
  8042120e4f:	49                   	rex.WB
  8042120e50:	41 54                	push   %r12
  8042120e52:	45 5f                	rex.RB pop %r15
  8042120e54:	4e                   	rex.WRX
  8042120e55:	4f                   	rex.WRXB
  8042120e56:	44                   	rex.R
  8042120e57:	45 00 00             	add    %r8b,(%r8)
  8042120e5a:	00 00                	add    %al,(%rax)
  8042120e5c:	00 00                	add    %al,(%rax)
  8042120e5e:	00 00                	add    %al,(%rax)
  8042120e60:	5b                   	pop    %rbx
  8042120e61:	25 30 38 78 5d       	and    $0x5d783830,%eax
  8042120e66:	20 75 73             	and    %dh,0x73(%rbp)
  8042120e69:	65 72 5f             	gs jb  8042120ecb <__rodata_start+0x1afb>
  8042120e6c:	6d                   	insl   (%dx),%es:(%rdi)
  8042120e6d:	65 6d                	gs insl (%dx),%es:(%rdi)
  8042120e6f:	5f                   	pop    %rdi
  8042120e70:	63 68 65             	movsxd 0x65(%rax),%ebp
  8042120e73:	63 6b 20             	movsxd 0x20(%rbx),%ebp
  8042120e76:	61                   	(bad)
  8042120e77:	73 73                	jae    8042120eec <__rodata_start+0x1b1c>
  8042120e79:	65 72 74             	gs jb  8042120ef0 <__rodata_start+0x1b20>
  8042120e7c:	69 6f 6e 20 66 61 69 	imul   $0x69616620,0x6e(%rdi),%ebp
  8042120e83:	6c                   	insb   (%dx),%es:(%rdi)
  8042120e84:	75 72                	jne    8042120ef8 <__rodata_start+0x1b28>
  8042120e86:	65 20 66 6f          	and    %ah,%gs:0x6f(%rsi)
  8042120e8a:	72 20                	jb     8042120eac <__rodata_start+0x1adc>
  8042120e8c:	76 61                	jbe    8042120eef <__rodata_start+0x1b1f>
  8042120e8e:	3d 25 30 31 36       	cmp    $0x36313025,%eax
  8042120e93:	7a 78                	jp     8042120f0d <__rodata_start+0x1b3d>
  8042120e95:	20 69 70             	and    %ch,0x70(%rcx)
  8042120e98:	3d 25 30 31 36       	cmp    $0x36313025,%eax
  8042120e9d:	7a 78                	jp     8042120f17 <__rodata_start+0x1b47>
  8042120e9f:	0a 00                	or     (%rax),%al
  8042120ea1:	00 00                	add    %al,(%rax)
  8042120ea3:	00 00                	add    %al,(%rax)
  8042120ea5:	00 00                	add    %al,(%rax)
  8042120ea7:	00 21                	add    %ah,(%rcx)
  8042120ea9:	28 50 54             	sub    %dl,0x54(%rax)
  8042120eac:	45 5f                	rex.RB pop %r15
  8042120eae:	41                   	rex.B
  8042120eaf:	44                   	rex.R
  8042120eb0:	44 52                	rex.R push %rdx
  8042120eb2:	28 62 61             	sub    %ah,0x61(%rdx)
  8042120eb5:	73 65                	jae    8042120f1c <__rodata_start+0x1b4c>
  8042120eb7:	29 20                	sub    %esp,(%rax)
  8042120eb9:	26 20 28             	es and %ch,(%rax)
  8042120ebc:	73 74                	jae    8042120f32 <__rodata_start+0x1b62>
  8042120ebe:	65 70 20             	gs jo  8042120ee1 <__rodata_start+0x1b11>
  8042120ec1:	2d 20 31 29 29       	sub    $0x29293120,%eax
  8042120ec6:	00 00                	add    %al,(%rax)
  8042120ec8:	21 28                	and    %ebp,(%rax)
  8042120eca:	66 6c                	data16 insb (%dx),%es:(%rdi)
  8042120ecc:	61                   	(bad)
  8042120ecd:	67 73 20             	addr32 jae 8042120ef0 <__rodata_start+0x1b20>
  8042120ed0:	26 20 50 52          	es and %dl,0x52(%rax)
  8042120ed4:	4f 54                	rex.WRXB push %r12
  8042120ed6:	5f                   	pop    %rdi
  8042120ed7:	4c                   	rex.WR
  8042120ed8:	41 5a                	pop    %r10
  8042120eda:	59                   	pop    %rcx
  8042120edb:	29 20                	sub    %esp,(%rax)
  8042120edd:	7c 20                	jl     8042120eff <__rodata_start+0x1b2f>
  8042120edf:	21 28                	and    %ebp,(%rax)
  8042120ee1:	66 6c                	data16 insb (%dx),%es:(%rdi)
  8042120ee3:	61                   	(bad)
  8042120ee4:	67 73 20             	addr32 jae 8042120f07 <__rodata_start+0x1b37>
  8042120ee7:	26 20 50 52          	es and %dl,0x52(%rax)
  8042120eeb:	4f 54                	rex.WRXB push %r12
  8042120eed:	5f                   	pop    %rdi
  8042120eee:	53                   	push   %rbx
  8042120eef:	48                   	rex.W
  8042120ef0:	41 52                	push   %r10
  8042120ef2:	45 29 00             	sub    %r8d,(%r8)
  8042120ef5:	00 00                	add    %al,(%rax)
  8042120ef7:	00 21                	add    %ah,(%rcx)
  8042120ef9:	28 61 64             	sub    %ah,0x64(%rcx)
  8042120efc:	64 72 20             	fs jb  8042120f1f <__rodata_start+0x1b4f>
  8042120eff:	26 20 43 4c          	es and %al,0x4c(%rbx)
  8042120f03:	41 53                	push   %r11
  8042120f05:	53                   	push   %rbx
  8042120f06:	5f                   	pop    %rdi
  8042120f07:	4d                   	rex.WRB
  8042120f08:	41 53                	push   %r11
  8042120f0a:	4b 28 70 61          	rex.WXB sub %sil,0x61(%r8)
  8042120f0e:	67 65 2d 3e 63 6c 61 	addr32 gs sub $0x616c633e,%eax
  8042120f15:	73 73                	jae    8042120f8a <__rodata_start+0x1bba>
  8042120f17:	29 29                	sub    %ebp,(%rcx)
  8042120f19:	00 00                	add    %al,(%rax)
  8042120f1b:	00 00                	add    %al,(%rax)
  8042120f1d:	00 00                	add    %al,(%rax)
  8042120f1f:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
  8042120f23:	61                   	(bad)
  8042120f24:	72 74                	jb     8042120f9a <__rodata_start+0x1bca>
  8042120f26:	20 3e                	and    %bh,(%rsi)
  8042120f28:	20 4d 41             	and    %cl,0x41(%rbp)
  8042120f2b:	58                   	pop    %rax
  8042120f2c:	5f                   	pop    %rdi
  8042120f2d:	55                   	push   %rbp
  8042120f2e:	53                   	push   %rbx
  8042120f2f:	45 52                	rex.RB push %r10
  8042120f31:	5f                   	pop    %rdi
  8042120f32:	41                   	rex.B
  8042120f33:	44                   	rex.R
  8042120f34:	44 52                	rex.R push %rdx
  8042120f36:	45 53                	rex.RB push %r11
  8042120f38:	53                   	push   %rbx
  8042120f39:	20 7c 7c 20          	and    %bh,0x20(%rsp,%rdi,2)
  8042120f3d:	64 73 74             	fs jae 8042120fb4 <__rodata_start+0x1be4>
  8042120f40:	20 3d 3d 20 26 6b    	and    %bh,0x6b26203d(%rip)        # 80ad382f83 <__bss_end+0x6a37af83>
  8042120f46:	73 70                	jae    8042120fb8 <__rodata_start+0x1be8>
  8042120f48:	61                   	(bad)
  8042120f49:	63 65 20             	movsxd 0x20(%rbp),%esp
  8042120f4c:	7c 7c                	jl     8042120fca <__rodata_start+0x1bfa>
  8042120f4e:	20 28                	and    %ch,(%rax)
  8042120f50:	66 6c                	data16 insb (%dx),%es:(%rdi)
  8042120f52:	61                   	(bad)
  8042120f53:	67 73 20             	addr32 jae 8042120f76 <__rodata_start+0x1ba6>
  8042120f56:	26 20 4d 41          	es and %cl,0x41(%rbp)
  8042120f5a:	50                   	push   %rax
  8042120f5b:	5f                   	pop    %rdi
  8042120f5c:	55                   	push   %rbp
  8042120f5d:	53                   	push   %rbx
  8042120f5e:	45 52                	rex.RB push %r10
  8042120f60:	5f                   	pop    %rdi
  8042120f61:	4d                   	rex.WRB
  8042120f62:	4d                   	rex.WRB
  8042120f63:	49                   	rex.WB
  8042120f64:	4f 20 26             	rex.WRXB and %r12b,(%r14)
  8042120f67:	26 20 64 73 74       	es and %ah,0x74(%rbx,%rsi,2)
  8042120f6c:	61                   	(bad)
  8042120f6d:	72 74                	jb     8042120fe3 <__rodata_start+0x1c13>
  8042120f6f:	20 3c 3d 20 4d 41 58 	and    %bh,0x58414d20(,%rdi,1)
  8042120f76:	5f                   	pop    %rdi
  8042120f77:	55                   	push   %rbp
  8042120f78:	53                   	push   %rbx
  8042120f79:	45 52                	rex.RB push %r10
  8042120f7b:	5f                   	pop    %rdi
  8042120f7c:	41                   	rex.B
  8042120f7d:	44                   	rex.R
  8042120f7e:	44 52                	rex.R push %rdx
  8042120f80:	45 53                	rex.RB push %r11
  8042120f82:	53                   	push   %rbx
  8042120f83:	20 26                	and    %ah,(%rsi)
  8042120f85:	26 20 64 73 74       	es and %ah,0x74(%rbx,%rsi,2)
  8042120f8a:	20 21                	and    %ah,(%rcx)
  8042120f8c:	3d 20 26 6b 73       	cmp    $0x736b2620,%eax
  8042120f91:	70 61                	jo     8042120ff4 <__rodata_start+0x1c24>
  8042120f93:	63 65 29             	movsxd 0x29(%rbp),%esp
  8042120f96:	00 00                	add    %al,(%rax)
  8042120f98:	21 28                	and    %ebp,(%rax)
  8042120f9a:	28 61 64             	sub    %ah,0x64(%rcx)
  8042120f9d:	64 72 31             	fs jb  8042120fd1 <__rodata_start+0x1c01>
  8042120fa0:	20 7c 20 61          	and    %bh,0x61(%rax,%riz,1)
  8042120fa4:	64 64 72 32          	fs fs jb 8042120fda <__rodata_start+0x1c0a>
  8042120fa8:	29 20                	sub    %esp,(%rax)
  8042120faa:	26 20 43 4c          	es and %al,0x4c(%rbx)
  8042120fae:	41 53                	push   %r11
  8042120fb0:	53                   	push   %rbx
  8042120fb1:	5f                   	pop    %rdi
  8042120fb2:	4d                   	rex.WRB
  8042120fb3:	41 53                	push   %r11
  8042120fb5:	4b 28 30             	rex.WXB sub %sil,(%r8)
  8042120fb8:	29 29                	sub    %ebp,(%rcx)
  8042120fba:	00 00                	add    %al,(%rax)
  8042120fbc:	00 00                	add    %al,(%rax)
  8042120fbe:	00 00                	add    %al,(%rax)
  8042120fc0:	28 28                	sub    %ch,(%rax)
  8042120fc2:	64 73 74             	fs jae 8042121039 <__rodata_start+0x1c69>
  8042120fc5:	2d 3e 72 6f 6f       	sub    $0x6f6f723e,%eax
  8042120fca:	74 29                	je     8042120ff5 <__rodata_start+0x1c25>
  8042120fcc:	2d 3e 73 74 61       	sub    $0x6174733e,%eax
  8042120fd1:	74 65                	je     8042121038 <__rodata_start+0x1c68>
  8042120fd3:	20 26                	and    %ah,(%rsi)
  8042120fd5:	20 4e 4f             	and    %cl,0x4f(%rsi)
  8042120fd8:	44                   	rex.R
  8042120fd9:	45 5f                	rex.RB pop %r15
  8042120fdb:	54                   	push   %rsp
  8042120fdc:	59                   	pop    %rcx
  8042120fdd:	50                   	push   %rax
  8042120fde:	45 5f                	rex.RB pop %r15
  8042120fe0:	4d                   	rex.WRB
  8042120fe1:	41 53                	push   %r11
  8042120fe3:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  8042120fe6:	3c 20                	cmp    $0x20,%al
  8042120fe8:	50                   	push   %rax
  8042120fe9:	41 52                	push   %r10
  8042120feb:	54                   	push   %rsp
  8042120fec:	49                   	rex.WB
  8042120fed:	41                   	rex.B
  8042120fee:	4c 5f                	rex.WR pop %rdi
  8042120ff0:	4e                   	rex.WRX
  8042120ff1:	4f                   	rex.WRXB
  8042120ff2:	44                   	rex.R
  8042120ff3:	45 00 00             	add    %r8b,(%r8)
  8042120ff6:	00 00                	add    %al,(%rax)
  8042120ff8:	43 61                	rex.XB (bad)
  8042120ffa:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120ffb:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042120ffc:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042120ffd:	74 20                	je     804212101f <__rodata_start+0x1c4f>
  8042120fff:	6d                   	insl   (%dx),%es:(%rdi)
  8042121000:	61                   	(bad)
  8042121001:	70 20                	jo     8042121023 <__rodata_start+0x1c53>
  8042121003:	70 68                	jo     804212106d <__rodata_start+0x1c9d>
  8042121005:	79 73                	jns    804212107a <__rodata_start+0x1caa>
  8042121007:	69 63 61 6c 20 72 65 	imul   $0x6572206c,0x61(%rbx),%esp
  804212100e:	67 69 6f 6e 20 61 74 	imul   $0x20746120,0x6e(%edi),%ebp
  8042121015:	20 
  8042121016:	25 70 20 6f 66       	and    $0x666f2070,%eax
  804212101b:	20 73 69             	and    %dh,0x69(%rbx)
  804212101e:	7a 65                	jp     8042121085 <__rodata_start+0x1cb5>
  8042121020:	20 25 7a 64 00 00    	and    %ah,0x647a(%rip)        # 80421274a0 <__rodata_end+0x44a0>
  8042121026:	00 00                	add    %al,(%rax)
  8042121028:	54                   	push   %rsp
  8042121029:	72 79                	jb     80421210a4 <__rodata_start+0x1cd4>
  804212102b:	69 6e 67 20 74 6f 20 	imul   $0x206f7420,0x67(%rsi),%ebp
  8042121032:	72 65                	jb     8042121099 <__rodata_start+0x1cc9>
  8042121034:	6d                   	insl   (%dx),%es:(%rdi)
  8042121035:	61                   	(bad)
  8042121036:	70 20                	jo     8042121058 <__rodata_start+0x1c88>
  8042121038:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042121039:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212103a:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212103b:	2d 6c 61 73 74       	sub    $0x7473616c,%eax
  8042121040:	20 4d 4d             	and    %cl,0x4d(%rbp)
  8042121043:	49                   	rex.WB
  8042121044:	4f 20 72 65          	rex.WRXB and %r14b,0x65(%r10)
  8042121048:	67 69 6f 6e 21 0a 00 	imul   $0xa21,0x6e(%edi),%ebp
  804212104f:	00 
  8042121050:	4d                   	rex.WRB
  8042121051:	65 6d                	gs insl (%dx),%es:(%rdi)
  8042121053:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042121054:	72 79                	jb     80421210cf <__rodata_start+0x1cff>
  8042121056:	20 61 6c             	and    %ah,0x6c(%rcx)
  8042121059:	6c                   	insb   (%dx),%es:(%rdi)
  804212105a:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212105b:	63 61 74             	movsxd 0x74(%rcx),%esp
  804212105e:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212105f:	72 20                	jb     8042121081 <__rodata_start+0x1cb1>
  8042121061:	69 73 20 69 6e 69 74 	imul   $0x74696e69,0x20(%rbx),%esi
  8042121068:	69 61 6c 69 7a 65 64 	imul   $0x64657a69,0x6c(%rcx),%esp
  804212106f:	0a 00                	or     (%rax),%al
  8042121071:	00 00                	add    %al,(%rax)
  8042121073:	00 00                	add    %al,(%rax)
  8042121075:	00 00                	add    %al,(%rax)
  8042121077:	00 50 68             	add    %dl,0x68(%rax)
  804212107a:	79 73                	jns    80421210ef <__rodata_start+0x1d1f>
  804212107c:	69 63 61 6c 20 6d 65 	imul   $0x656d206c,0x61(%rbx),%esp
  8042121083:	6d                   	insl   (%dx),%es:(%rdi)
  8042121084:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042121085:	72 79                	jb     8042121100 <__rodata_start+0x1d30>
  8042121087:	3a 20                	cmp    (%rax),%ah
  8042121089:	25 7a 75 4d 20       	and    $0x204d757a,%eax
  804212108e:	61                   	(bad)
  804212108f:	76 61                	jbe    80421210f2 <__rodata_start+0x1d22>
  8042121091:	69 6c 61 62 6c 65 2c 	imul   $0x202c656c,0x62(%rcx,%riz,2),%ebp
  8042121098:	20 
  8042121099:	62 61 73 65 20       	(bad)
  804212109e:	3d 20 25 7a 75       	cmp    $0x757a2520,%eax
  80421210a3:	4b 2c 20             	rex.WXB sub $0x20,%al
  80421210a6:	65 78 74             	gs js  804212111d <__rodata_start+0x1d4d>
  80421210a9:	65 6e                	outsb  %gs:(%rsi),(%dx)
  80421210ab:	64 65 64 20 3d 20 25 	fs gs and %bh,%fs:0x757a2520(%rip)        # 80b78c35d4 <__bss_end+0x748bb5d4>
  80421210b2:	7a 75 
  80421210b4:	4b 0a 00             	rex.WXB or (%r8),%al
  80421210b7:	00 50 68             	add    %dl,0x68(%rax)
  80421210ba:	79 73                	jns    804212112f <__rodata_start+0x1d5f>
  80421210bc:	69 63 61 6c 20 6d 65 	imul   $0x656d206c,0x61(%rbx),%esp
  80421210c3:	6d                   	insl   (%dx),%es:(%rdi)
  80421210c4:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421210c5:	72 79                	jb     8042121140 <__rodata_start+0x1d70>
  80421210c7:	20 74 72 65          	and    %dh,0x65(%rdx,%rsi,2)
  80421210cb:	65 20 69 73          	and    %ch,%gs:0x73(%rcx)
  80421210cf:	20 63 6f             	and    %ah,0x6f(%rbx)
  80421210d2:	72 72                	jb     8042121146 <__rodata_start+0x1d76>
  80421210d4:	65 63 74 0a 00       	movsxd %gs:0x0(%rdx,%rcx,1),%esi
  80421210d9:	00 00                	add    %al,(%rax)
  80421210db:	00 00                	add    %al,(%rax)
  80421210dd:	00 00                	add    %al,(%rax)
  80421210df:	00 21                	add    %ah,(%rcx)
  80421210e1:	28 28                	sub    %ch,(%rax)
  80421210e3:	75 69                	jne    804212114e <__rodata_start+0x1d7e>
  80421210e5:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421210e6:	74 70                	je     8042121158 <__rodata_start+0x1d88>
  80421210e8:	74 72                	je     804212115c <__rodata_start+0x1d8c>
  80421210ea:	5f                   	pop    %rdi
  80421210eb:	74 29                	je     8042121116 <__rodata_start+0x1d46>
  80421210ed:	5f                   	pop    %rdi
  80421210ee:	5f                   	pop    %rdi
  80421210ef:	74 65                	je     8042121156 <__rodata_start+0x1d86>
  80421210f1:	78 74                	js     8042121167 <__rodata_start+0x1d97>
  80421210f3:	5f                   	pop    %rdi
  80421210f4:	73 74                	jae    804212116a <__rodata_start+0x1d9a>
  80421210f6:	61                   	(bad)
  80421210f7:	72 74                	jb     804212116d <__rodata_start+0x1d9d>
  80421210f9:	20 26                	and    %ah,(%rsi)
  80421210fb:	20 43 4c             	and    %al,0x4c(%rbx)
  80421210fe:	41 53                	push   %r11
  8042121100:	53                   	push   %rbx
  8042121101:	5f                   	pop    %rdi
  8042121102:	4d                   	rex.WRB
  8042121103:	41 53                	push   %r11
  8042121105:	4b 28 30             	rex.WXB sub %sil,(%r8)
  8042121108:	29 29                	sub    %ebp,(%rcx)
  804212110a:	00 00                	add    %al,(%rax)
  804212110c:	00 00                	add    %al,(%rax)
  804212110e:	00 00                	add    %al,(%rax)
  8042121110:	5f                   	pop    %rdi
  8042121111:	5f                   	pop    %rdi
  8042121112:	74 65                	je     8042121179 <__rodata_start+0x1da9>
  8042121114:	78 74                	js     804212118a <__rodata_start+0x1dba>
  8042121116:	5f                   	pop    %rdi
  8042121117:	65 6e                	outsb  %gs:(%rsi),(%dx)
  8042121119:	64 20 2d 20 5f 5f 74 	and    %ch,%fs:0x745f5f20(%rip)        # 80b6717040 <__bss_end+0x7370f040>
  8042121120:	65 78 74             	gs js  8042121197 <__rodata_start+0x1dc7>
  8042121123:	5f                   	pop    %rdi
  8042121124:	73 74                	jae    804212119a <__rodata_start+0x1dca>
  8042121126:	61                   	(bad)
  8042121127:	72 74                	jb     804212119d <__rodata_start+0x1dcd>
  8042121129:	20 3c 20             	and    %bh,(%rax,%riz,1)
  804212112c:	4d                   	rex.WRB
  804212112d:	41 58                	pop    %r8
  804212112f:	5f                   	pop    %rdi
  8042121130:	4c                   	rex.WR
  8042121131:	4f 57                	rex.WRXB push %r15
  8042121133:	5f                   	pop    %rdi
  8042121134:	41                   	rex.B
  8042121135:	44                   	rex.R
  8042121136:	44 52                	rex.R push %rdx
  8042121138:	5f                   	pop    %rdi
  8042121139:	4b                   	rex.WXB
  804212113a:	45 52                	rex.RB push %r10
  804212113c:	4e 5f                	rex.WRX pop %rdi
  804212113e:	53                   	push   %rbx
  804212113f:	49 5a                	rex.WB pop %r10
  8042121141:	45 00 00             	add    %r8b,(%r8)
  8042121144:	00 00                	add    %al,(%rax)
  8042121146:	00 00                	add    %al,(%rax)
  8042121148:	28 75 69             	sub    %dh,0x69(%rbp)
  804212114b:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212114c:	74 70                	je     80421211be <__rodata_start+0x1dee>
  804212114e:	74 72                	je     80421211c2 <__rodata_start+0x1df2>
  8042121150:	5f                   	pop    %rdi
  8042121151:	74 29                	je     804212117c <__rodata_start+0x1dac>
  8042121153:	28 65 6e             	sub    %ah,0x6e(%rbp)
  8042121156:	64 20 2d 20 4b 45 52 	and    %ch,%fs:0x52454b20(%rip)        # 8094575c7d <__bss_end+0x5156dc7d>
  804212115d:	4e 5f                	rex.WRX pop %rdi
  804212115f:	42                   	rex.X
  8042121160:	41 53                	push   %r11
  8042121162:	45 5f                	rex.RB pop %r15
  8042121164:	41                   	rex.B
  8042121165:	44                   	rex.R
  8042121166:	44 52                	rex.R push %rdx
  8042121168:	29 20                	sub    %esp,(%rax)
  804212116a:	3c 20                	cmp    $0x20,%al
  804212116c:	4d                   	rex.WRB
  804212116d:	49                   	rex.WB
  804212116e:	4e 28 42 4f          	rex.WRX sub %r8b,0x4f(%rdx)
  8042121172:	4f 54                	rex.WRXB push %r12
  8042121174:	5f                   	pop    %rdi
  8042121175:	4d                   	rex.WRB
  8042121176:	45                   	rex.RB
  8042121177:	4d 5f                	rex.WRB pop %r15
  8042121179:	53                   	push   %rbx
  804212117a:	49 5a                	rex.WB pop %r10
  804212117c:	45 2c 20             	rex.RB sub $0x20,%al
  804212117f:	6d                   	insl   (%dx),%es:(%rdi)
  8042121180:	61                   	(bad)
  8042121181:	78 5f                	js     80421211e2 <__rodata_start+0x1e12>
  8042121183:	6d                   	insl   (%dx),%es:(%rdi)
  8042121184:	65 6d                	gs insl (%dx),%es:(%rdi)
  8042121186:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042121187:	72 79                	jb     8042121202 <__rodata_start+0x1e32>
  8042121189:	5f                   	pop    %rdi
  804212118a:	6d                   	insl   (%dx),%es:(%rdi)
  804212118b:	61                   	(bad)
  804212118c:	70 5f                	jo     80421211ed <__rodata_start+0x1e1d>
  804212118e:	61                   	(bad)
  804212118f:	64 64 72 29          	fs fs jb 80421211bc <__rodata_start+0x1dec>
  8042121193:	00 00                	add    %al,(%rax)
  8042121195:	00 00                	add    %al,(%rax)
  8042121197:	00 43 61             	add    %al,0x61(%rbx)
  804212119a:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212119b:	60                   	(bad)
  804212119c:	74 20                	je     80421211be <__rodata_start+0x1dee>
  804212119e:	6d                   	insl   (%dx),%es:(%rdi)
  804212119f:	61                   	(bad)
  80421211a0:	70 20                	jo     80421211c2 <__rodata_start+0x1df2>
  80421211a2:	70 68                	jo     804212120c <__rodata_start+0x1e3c>
  80421211a4:	79 73                	jns    8042121219 <__rodata_start+0x1e49>
  80421211a6:	69 63 61 6c 20 72 65 	imul   $0x6572206c,0x61(%rbx),%esp
  80421211ad:	67 69 6f 6e 20 61 74 	imul   $0x20746120,0x6e(%edi),%ebp
  80421211b4:	20 
  80421211b5:	25 70 20 6f 66       	and    $0x666f2070,%eax
  80421211ba:	20 73 69             	and    %dh,0x69(%rbx)
  80421211bd:	7a 65                	jp     8042121224 <__rodata_start+0x1e54>
  80421211bf:	20 25 6c 6c 64 00    	and    %ah,0x646c6c(%rip)        # 8042767e31 <_binary_obj_user_stresssched_end+0x170d1>
  80421211c5:	00 00                	add    %al,(%rax)
  80421211c7:	00 43 61             	add    %al,0x61(%rbx)
  80421211ca:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421211cb:	60                   	(bad)
  80421211cc:	74 20                	je     80421211ee <__rodata_start+0x1e1e>
  80421211ce:	6d                   	insl   (%dx),%es:(%rdi)
  80421211cf:	61                   	(bad)
  80421211d0:	70 20                	jo     80421211f2 <__rodata_start+0x1e22>
  80421211d2:	70 68                	jo     804212123c <__rodata_start+0x1e6c>
  80421211d4:	79 73                	jns    8042121249 <__rodata_start+0x1e79>
  80421211d6:	69 63 61 6c 20 72 65 	imul   $0x6572206c,0x61(%rbx),%esp
  80421211dd:	67 69 6f 6e 20 61 74 	imul   $0x20746120,0x6e(%edi),%ebp
  80421211e4:	20 
  80421211e5:	25 70 20 6f 66       	and    $0x666f2070,%eax
  80421211ea:	20 73 69             	and    %dh,0x69(%rbx)
  80421211ed:	7a 65                	jp     8042121254 <__rodata_start+0x1e84>
  80421211ef:	20 25 6c 6c 75 00    	and    %ah,0x756c6c(%rip)        # 8042877e61 <_binary_obj_user_testpiperace_end+0x12879>
  80421211f5:	00 00                	add    %al,(%rax)
  80421211f7:	00 2a                	add    %ch,(%rdx)
  80421211f9:	28 76 6f             	sub    %dh,0x6f(%rsi)
  80421211fc:	6c                   	insb   (%dx),%es:(%rdi)
  80421211fd:	61                   	(bad)
  80421211fe:	74 69                	je     8042121269 <__rodata_start+0x1e99>
  8042121200:	6c                   	insb   (%dx),%es:(%rdi)
  8042121201:	65 20 69 6e          	and    %ch,%gs:0x6e(%rcx)
  8042121205:	74 20                	je     8042121227 <__rodata_start+0x1e57>
  8042121207:	2a 29                	sub    (%rcx),%ch
  8042121209:	6d                   	insl   (%dx),%es:(%rdi)
  804212120a:	73 74                	jae    8042121280 <__rodata_start+0x1eb0>
  804212120c:	61                   	(bad)
  804212120d:	72 74                	jb     8042121283 <__rodata_start+0x1eb3>
  804212120f:	2d 3e 56 69 72       	sub    $0x7269563e,%eax
  8042121214:	74 75                	je     804212128b <__rodata_start+0x1ebb>
  8042121216:	61                   	(bad)
  8042121217:	6c                   	insb   (%dx),%es:(%rdi)
  8042121218:	53                   	push   %rbx
  8042121219:	74 61                	je     804212127c <__rodata_start+0x1eac>
  804212121b:	72 74                	jb     8042121291 <__rodata_start+0x1ec1>
  804212121d:	20 3d 3d 20 65 78    	and    %bh,0x7865203d(%rip)        # 80ba773260 <__bss_end+0x7776b260>
  8042121223:	70 65                	jo     804212128a <__rodata_start+0x1eba>
  8042121225:	63 74 65 64          	movsxd 0x64(%rbp,%riz,2),%esi
  8042121229:	00 00                	add    %al,(%rax)
  804212122b:	00 00                	add    %al,(%rax)
  804212122d:	00 00                	add    %al,(%rax)
  804212122f:	00 43 61             	add    %al,0x61(%rbx)
  8042121232:	6e                   	outsb  %ds:(%rsi),(%dx)
  8042121233:	60                   	(bad)
  8042121234:	74 20                	je     8042121256 <__rodata_start+0x1e86>
  8042121236:	6d                   	insl   (%dx),%es:(%rdi)
  8042121237:	61                   	(bad)
  8042121238:	70 20                	jo     804212125a <__rodata_start+0x1e8a>
  804212123a:	70 68                	jo     80421212a4 <__rodata_start+0x1ed4>
  804212123c:	79 73                	jns    80421212b1 <__rodata_start+0x1ee1>
  804212123e:	69 63 61 6c 20 72 65 	imul   $0x6572206c,0x61(%rbx),%esp
  8042121245:	67 69 6f 6e 20 61 74 	imul   $0x20746120,0x6e(%edi),%ebp
  804212124c:	20 
  804212124d:	25 70 20 6f 66       	and    $0x666f2070,%eax
  8042121252:	20 73 69             	and    %dh,0x69(%rbx)
  8042121255:	7a 65                	jp     80421212bc <__rodata_start+0x1eec>
  8042121257:	20 25 7a 64 00 00    	and    %ah,0x647a(%rip)        # 80421276d7 <__rodata_end+0x46d7>
  804212125d:	00 00                	add    %al,(%rax)
  804212125f:	00 50 68             	add    %dl,0x68(%rax)
  8042121262:	79 73                	jns    80421212d7 <__rodata_start+0x1f07>
  8042121264:	69 63 61 6c 20 6d 65 	imul   $0x656d206c,0x61(%rbx),%esp
  804212126b:	6d                   	insl   (%dx),%es:(%rdi)
  804212126c:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212126d:	72 79                	jb     80421212e8 <__rodata_start+0x1f18>
  804212126f:	20 74 72 65          	and    %dh,0x65(%rdx,%rsi,2)
  8042121273:	65 20 69 73          	and    %ch,%gs:0x73(%rcx)
  8042121277:	20 73 74             	and    %dh,0x74(%rbx)
  804212127a:	69 6c 6c 20 63 6f 72 	imul   $0x72726f63,0x20(%rsp,%rbp,2),%ebp
  8042121281:	72 
  8042121282:	65 63 74 0a 00       	movsxd %gs:0x0(%rdx,%rcx,1),%esi
  8042121287:	00 4b 65             	add    %cl,0x65(%rbx)
  804212128a:	72 6e                	jb     80421212fa <__rodata_start+0x1f2a>
  804212128c:	65 6c                	gs insb (%dx),%es:(%rdi)
  804212128e:	20 76 69             	and    %dh,0x69(%rsi)
  8042121291:	72 74                	jb     8042121307 <__rodata_start+0x1f37>
  8042121293:	75 61                	jne    80421212f6 <__rodata_start+0x1f26>
  8042121295:	6c                   	insb   (%dx),%es:(%rdi)
  8042121296:	20 6d 65             	and    %ch,0x65(%rbp)
  8042121299:	6d                   	insl   (%dx),%es:(%rdi)
  804212129a:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212129b:	72 79                	jb     8042121316 <__rodata_start+0x1f46>
  804212129d:	20 74 72 65          	and    %dh,0x65(%rdx,%rsi,2)
  80421212a1:	65 20 69 73          	and    %ch,%gs:0x73(%rcx)
  80421212a5:	20 63 6f             	and    %ah,0x6f(%rbx)
  80421212a8:	72 72                	jb     804212131c <__rodata_start+0x1f4c>
  80421212aa:	65 63 74 0a 00       	movsxd %gs:0x0(%rdx,%rcx,1),%esi
  80421212af:	00 21                	add    %ah,(%rcx)
  80421212b1:	28 6f 6c             	sub    %ch,0x6c(%rdi)
  80421212b4:	64 66 6c             	fs data16 insb (%dx),%es:(%rdi)
  80421212b7:	61                   	(bad)
  80421212b8:	67 73 20             	addr32 jae 80421212db <__rodata_start+0x1f0b>
  80421212bb:	26 20 50 52          	es and %dl,0x52(%rax)
  80421212bf:	4f 54                	rex.WRXB push %r12
  80421212c1:	5f                   	pop    %rdi
  80421212c2:	4c                   	rex.WR
  80421212c3:	41 5a                	pop    %r10
  80421212c5:	59                   	pop    %rcx
  80421212c6:	29 20                	sub    %esp,(%rax)
  80421212c8:	7c 20                	jl     80421212ea <__rodata_start+0x1f1a>
  80421212ca:	21 28                	and    %ebp,(%rax)
  80421212cc:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421212cd:	6c                   	insb   (%dx),%es:(%rdi)
  80421212ce:	64 66 6c             	fs data16 insb (%dx),%es:(%rdi)
  80421212d1:	61                   	(bad)
  80421212d2:	67 73 20             	addr32 jae 80421212f5 <__rodata_start+0x1f25>
  80421212d5:	26 20 50 52          	es and %dl,0x52(%rax)
  80421212d9:	4f 54                	rex.WRXB push %r12
  80421212db:	5f                   	pop    %rdi
  80421212dc:	53                   	push   %rbx
  80421212dd:	48                   	rex.W
  80421212de:	41 52                	push   %r10
  80421212e0:	45 29 00             	sub    %r8d,(%r8)
  80421212e3:	00 00                	add    %al,(%rax)
  80421212e5:	00 00                	add    %al,(%rax)
  80421212e7:	00 28                	add    %ch,(%rax)
  80421212e9:	76 70                	jbe    804212135b <__rodata_start+0x1f8b>
  80421212eb:	61                   	(bad)
  80421212ec:	67 65 2d 3e 73 74 61 	addr32 gs sub $0x6174733e,%eax
  80421212f3:	74 65                	je     804212135a <__rodata_start+0x1f8a>
  80421212f5:	20 26                	and    %ah,(%rsi)
  80421212f7:	20 4e 4f             	and    %cl,0x4f(%rsi)
  80421212fa:	44                   	rex.R
  80421212fb:	45 5f                	rex.RB pop %r15
  80421212fd:	54                   	push   %rsp
  80421212fe:	59                   	pop    %rcx
  80421212ff:	50                   	push   %rax
  8042121300:	45 5f                	rex.RB pop %r15
  8042121302:	4d                   	rex.WRB
  8042121303:	41 53                	push   %r11
  8042121305:	4b 29 20             	rex.WXB sub %rsp,(%r8)
  8042121308:	3d 3d 20 4d 41       	cmp    $0x414d203d,%eax
  804212130d:	50                   	push   %rax
  804212130e:	50                   	push   %rax
  804212130f:	49                   	rex.WB
  8042121310:	4e                   	rex.WRX
  8042121311:	47 5f                	rex.RXB pop %r15
  8042121313:	4e                   	rex.WRX
  8042121314:	4f                   	rex.WRXB
  8042121315:	44                   	rex.R
  8042121316:	45 00 76 70          	add    %r14b,0x70(%r14)
  804212131a:	61                   	(bad)
  804212131b:	67 65 2d 3e 73 74 61 	addr32 gs sub $0x6174733e,%eax
  8042121322:	74 65                	je     8042121389 <__rodata_start+0x1fb9>
  8042121324:	20 3d 3d 20 49 4e    	and    %bh,0x4e49203d(%rip)        # 80905b3367 <__bss_end+0x4d5ab367>
  804212132a:	54                   	push   %rsp
  804212132b:	45 52                	rex.RB push %r10
  804212132d:	4d                   	rex.WRB
  804212132e:	45                   	rex.RB
  804212132f:	44                   	rex.R
  8042121330:	49                   	rex.WB
  8042121331:	41 54                	push   %r12
  8042121333:	45 5f                	rex.RB pop %r15
  8042121335:	4e                   	rex.WRX
  8042121336:	4f                   	rex.WRXB
  8042121337:	44                   	rex.R
  8042121338:	45 00 00             	add    %r8b,(%r8)
  804212133b:	00 00                	add    %al,(%rax)
  804212133d:	00 00                	add    %al,(%rax)
  804212133f:	00 41 42             	add    %al,0x42(%rcx)
  8042121342:	53                   	push   %rbx
  8042121343:	44                   	rex.R
  8042121344:	49                   	rex.WB
  8042121345:	46                   	rex.RX
  8042121346:	46 28 64 73 74       	sub    %r12b,0x74(%rbx,%r14,2)
  804212134b:	2c 20                	sub    $0x20,%al
  804212134d:	73 72                	jae    80421213c1 <__rodata_start+0x1ff1>
  804212134f:	63 29                	movsxd (%rcx),%ebp
  8042121351:	20 3e                	and    %bh,(%rsi)
  8042121353:	3d 20 43 4c 41       	cmp    $0x414c4320,%eax
  8042121358:	53                   	push   %rbx
  8042121359:	53                   	push   %rbx
  804212135a:	5f                   	pop    %rdi
  804212135b:	53                   	push   %rbx
  804212135c:	49 5a                	rex.WB pop %r10
  804212135e:	45 28 63 6c          	sub    %r12b,0x6c(%r11)
  8042121362:	61                   	(bad)
  8042121363:	73 73                	jae    80421213d8 <__rodata_start+0x2008>
  8042121365:	29 00                	sub    %eax,(%rax)
  8042121367:	00 43 4c             	add    %al,0x4c(%rbx)
  804212136a:	41 53                	push   %r11
  804212136c:	53                   	push   %rbx
  804212136d:	5f                   	pop    %rdi
  804212136e:	53                   	push   %rbx
  804212136f:	49 5a                	rex.WB pop %r10
  8042121371:	45 28 63 70          	sub    %r12b,0x70(%r11)
  8042121375:	61                   	(bad)
  8042121376:	67 65 2d 3e 63 6c 61 	addr32 gs sub $0x616c633e,%eax
  804212137d:	73 73                	jae    80421213f2 <__rodata_start+0x2022>
  804212137f:	29 20                	sub    %esp,(%rax)
  8042121381:	3d 3d 20 73 69       	cmp    $0x6973203d,%eax
  8042121386:	7a 65                	jp     80421213ed <__rodata_start+0x201d>
  8042121388:	5f                   	pop    %rdi
  8042121389:	69 6e 63 00 00 00 00 	imul   $0x0,0x63(%rsi),%ebp
  8042121390:	73 73                	jae    8042121405 <__rodata_start+0x2035>
  8042121392:	70 61                	jo     80421213f5 <__rodata_start+0x2025>
  8042121394:	63 65 20             	movsxd 0x20(%rbp),%esp
  8042121397:	21 3d 20 64 73 70    	and    %edi,0x70736420(%rip)        # 80b28577bd <__bss_end+0x6f84f7bd>
  804212139d:	61                   	(bad)
  804212139e:	63 65 20             	movsxd 0x20(%rbp),%esp
  80421213a1:	7c 7c                	jl     804212141f <__rodata_start+0x204f>
  80421213a3:	20 64 73 74          	and    %ah,0x74(%rbx,%rsi,2)
  80421213a7:	20 3c 3d 20 73 72 63 	and    %bh,0x63727320(,%rdi,1)
  80421213ae:	20 7c 7c 20          	and    %bh,0x20(%rsp,%rdi,2)
  80421213b2:	41                   	rex.B
  80421213b3:	42 53                	rex.X push %rbx
  80421213b5:	44                   	rex.R
  80421213b6:	49                   	rex.WB
  80421213b7:	46                   	rex.RX
  80421213b8:	46 28 73 72          	rex.RX sub %r14b,0x72(%rbx)
  80421213bc:	63 2c 20             	movsxd (%rax,%riz,1),%ebp
  80421213bf:	64 73 74             	fs jae 8042121436 <__rodata_start+0x2066>
  80421213c2:	29 20                	sub    %esp,(%rax)
  80421213c4:	3e 3d 20 73 69 7a    	ds cmp $0x7a697320,%eax
  80421213ca:	65 00 00             	add    %al,%gs:(%rax)
  80421213cd:	00 00                	add    %al,(%rax)
  80421213cf:	00 50 61             	add    %dl,0x61(%rax)
  80421213d2:	67 65 20 61 6c       	and    %ah,%gs:0x6c(%ecx)
  80421213d7:	6c                   	insb   (%dx),%es:(%rdi)
  80421213d8:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421213d9:	63 61 74             	movsxd 0x74(%rcx),%esp
  80421213dc:	69 6f 6e 20 66 61 69 	imul   $0x69616620,0x6e(%rdi),%ebp
  80421213e3:	6c                   	insb   (%dx),%es:(%rdi)
  80421213e4:	65 64 20 69 6e       	gs and %ch,%fs:0x6e(%rcx)
  80421213e9:	20 70 61             	and    %dh,0x61(%rax)
  80421213ec:	67 65 5f             	addr32 gs pop %rdi
  80421213ef:	66 61                	data16 (bad)
  80421213f1:	75 6c                	jne    804212145f <__rodata_start+0x208f>
  80421213f3:	74 5f                	je     8042121454 <__rodata_start+0x2084>
  80421213f5:	68 61 6e 64 6c       	push   $0x6c646e61
  80421213fa:	65 72 0a             	gs jb  8042121407 <__rodata_start+0x2037>
  80421213fd:	00 00                	add    %al,(%rax)
  80421213ff:	00 46 61             	add    %al,0x61(%rsi)
  8042121402:	69 6c 65 64 20 74 6f 	imul   $0x206f7420,0x64(%rbp,%riz,2),%ebp
  8042121409:	20 
  804212140a:	6d                   	insl   (%dx),%es:(%rdi)
  804212140b:	61                   	(bad)
  804212140c:	70 20                	jo     804212142e <__rodata_start+0x205e>
  804212140e:	70 61                	jo     8042121471 <__rodata_start+0x20a1>
  8042121410:	67 65 20 69 6e       	and    %ch,%gs:0x6e(%ecx)
  8042121415:	20 70 61             	and    %dh,0x61(%rax)
  8042121418:	67 65 5f             	addr32 gs pop %rdi
  804212141b:	66 61                	data16 (bad)
  804212141d:	75 6c                	jne    804212148b <__rodata_start+0x20bb>
  804212141f:	74 5f                	je     8042121480 <__rodata_start+0x20b0>
  8042121421:	68 61 6e 64 6c       	push   $0x6c646e61
  8042121426:	65 72 0a             	gs jb  8042121433 <__rodata_start+0x2063>
  8042121429:	00 00                	add    %al,(%rax)
  804212142b:	00 00                	add    %al,(%rax)
  804212142d:	00 00                	add    %al,(%rax)
  804212142f:	00 48 50             	add    %cl,0x50(%rax)
  8042121432:	45 54                	rex.RB push %r12
  8042121434:	20 68 61             	and    %ch,0x61(%rax)
  8042121437:	73 20                	jae    8042121459 <__rodata_start+0x2089>
  8042121439:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212143a:	6f                   	outsl  %ds:(%rsi),(%dx)
  804212143b:	20 4c 65 67          	and    %cl,0x67(%rbp,%riz,2)
  804212143f:	61                   	(bad)
  8042121440:	63 79 52             	movsxd 0x52(%rcx),%edi
  8042121443:	65 70 6c             	gs jo  80421214b2 <__rodata_start+0x20e2>
  8042121446:	61                   	(bad)
  8042121447:	63 65 6d             	movsxd 0x6d(%rbp),%esp
  804212144a:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804212144c:	74 20                	je     804212146e <__rodata_start+0x209e>
  804212144e:	6d                   	insl   (%dx),%es:(%rdi)
  804212144f:	6f                   	outsl  %ds:(%rsi),(%dx)
  8042121450:	64 65 00 00          	fs add %al,%gs:(%rax)
  8042121454:	00 00                	add    %al,(%rax)
  8042121456:	00 00                	add    %al,(%rax)
  8042121458:	4e 6f                	rex.WRX outsl %ds:(%rsi),(%dx)
  804212145a:	20 72 75             	and    %dh,0x75(%rdx)
  804212145d:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212145e:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212145f:	61                   	(bad)
  8042121460:	62 6c 65             	(bad)
  8042121463:	20 65 6e             	and    %ah,0x6e(%rbp)
  8042121466:	76 69                	jbe    80421214d1 <__rodata_start+0x2101>
  8042121468:	72 6f                	jb     80421214d9 <__rodata_start+0x2109>
  804212146a:	6e                   	outsb  %ds:(%rsi),(%dx)
  804212146b:	6d                   	insl   (%dx),%es:(%rdi)
  804212146c:	65 6e                	outsb  %gs:(%rsi),(%dx)
  804212146e:	74 73                	je     80421214e3 <__rodata_start+0x2113>
  8042121470:	20 69 6e             	and    %ch,0x6e(%rcx)
  8042121473:	20 74 68 65          	and    %dh,0x65(%rax,%rbp,2)
  8042121477:	20 73 79             	and    %dh,0x79(%rbx)
  804212147a:	73 74                	jae    80421214f0 <__rodata_start+0x2120>
  804212147c:	65 6d                	gs insl (%dx),%es:(%rdi)
  804212147e:	21 0a                	and    %ecx,(%rdx)
	...
  8042121488:	65 6c                	gs insb (%dx),%es:(%rdi)
  804212148a:	66 2d 3e 65          	sub    $0x653e,%ax
  804212148e:	5f                   	pop    %rdi
  804212148f:	73 68                	jae    80421214f9 <__rodata_start+0x2129>
  8042121491:	65 6e                	outsb  %gs:(%rsi),(%dx)
  8042121493:	74 73                	je     8042121508 <__rodata_start+0x2138>
  8042121495:	69 7a 65 20 21 3d 20 	imul   $0x203d2120,0x65(%rdx),%edi
  804212149c:	73 69                	jae    8042121507 <__rodata_start+0x2137>
  804212149e:	7a 65                	jp     8042121505 <__rodata_start+0x2135>
  80421214a0:	6f                   	outsl  %ds:(%rsi),(%dx)
  80421214a1:	66 28 2a             	data16 sub %ch,(%rdx)
  80421214a4:	73 65                	jae    804212150b <__rodata_start+0x213b>
  80421214a6:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
  80421214aa:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421214ab:	5f                   	pop    %rdi
  80421214ac:	68 65 61 64 65       	push   $0x65646165
  80421214b1:	72 73                	jb     8042121526 <__rodata_start+0x2156>
  80421214b3:	29 00                	sub    %eax,(%rax)
  80421214b5:	00 00                	add    %al,(%rax)
  80421214b7:	00 66 69             	add    %ah,0x69(%rsi)
  80421214ba:	6c                   	insb   (%dx),%es:(%rdi)
  80421214bb:	65 20 69 73          	and    %ch,%gs:0x73(%rcx)
  80421214bf:	20 6e 6f             	and    %ch,0x6f(%rsi)
  80421214c2:	74 20                	je     80421214e4 <__rodata_start+0x2114>
  80421214c4:	61                   	(bad)
  80421214c5:	20 76 61             	and    %dh,0x61(%rsi)
  80421214c8:	6c                   	insb   (%dx),%es:(%rdi)
  80421214c9:	69 64 20 65 78 65 63 	imul   $0x75636578,0x65(%rax,%riz,1),%esp
  80421214d0:	75 
  80421214d1:	74 61                	je     8042121534 <__rodata_start+0x2164>
  80421214d3:	62 6c 65             	(bad)
  80421214d6:	00 00                	add    %al,(%rax)
  80421214d8:	43 61                	rex.XB (bad)
  80421214da:	6e                   	outsb  %ds:(%rsi),(%dx)
  80421214db:	27                   	(bad)
  80421214dc:	74 20                	je     80421214fe <__rodata_start+0x212e>
  80421214de:	63 61 6c             	movsxd 0x6c(%rcx),%esp
  80421214e1:	69 62 72 61 74 65 20 	imul   $0x20657461,0x72(%rdx),%esp
  80421214e8:	70 69                	jo     8042121553 <__rodata_start+0x2183>
  80421214ea:	74 20                	je     804212150c <__rodata_start+0x213c>
  80421214ec:	74 69                	je     8042121557 <__rodata_start+0x2187>
  80421214ee:	6d                   	insl   (%dx),%es:(%rdi)
  80421214ef:	65 72 2e             	gs jb  8042121520 <__rodata_start+0x2150>
  80421214f2:	20 55 73             	and    %dl,0x73(%rbp)
  80421214f5:	69 6e 67 20 64 65 66 	imul   $0x66656420,0x67(%rsi),%ebp
  80421214fc:	61                   	(bad)
  80421214fd:	75 6c                	jne    804212156b <__rodata_start+0x219b>
  80421214ff:	74 20                	je     8042121521 <__rodata_start+0x2151>
  8042121501:	66 72 65             	data16 jb 8042121569 <__rodata_start+0x2199>
  8042121504:	71 75                	jno    804212157b <__rodata_start+0x21ab>
  8042121506:	65 6e                	outsb  %gs:(%rsi),(%dx)
  8042121508:	63 79 0a             	movsxd 0xa(%rcx),%edi
  804212150b:	00 00                	add    %al,(%rax)
  804212150d:	00 00                	add    %al,(%rax)
  804212150f:	00 d0                	add    %dl,%al
  8042121511:	92                   	xchg   %eax,%edx
  8042121512:	d0 b5 d1 82 d0 b5    	shlb   $1,-0x4a2f7d2f(%rbp)
  8042121518:	d1 80 20 d0 b2 20    	roll   $1,0x20b2d020(%rax)
  804212151e:	d0 bf d0 be d0 bb    	sarb   $1,-0x442f4130(%rdi)
  8042121524:	d0 b5 20 d0 b7 d0    	shlb   $1,-0x2f482fe0(%rbp)
  804212152a:	b0 d0                	mov    $0xd0,%al
  804212152c:	ba d1 80 d1 83       	mov    $0x83d180d1,%edx
  8042121531:	d0 b6 d0 b8 d0 bb    	shlb   $1,-0x442f4730(%rsi)
  8042121537:	0a d0                	or     %al,%dl
  8042121539:	92                   	xchg   %eax,%edx
  804212153a:	d0 b5 d1 82 d0 b5    	shlb   $1,-0x4a2f7d2f(%rbp)
  8042121540:	d1 80 20 d0 b2 20    	roll   $1,0x20b2d020(%rax)
  8042121546:	d0 bf d0 be d0 bb    	sarb   $1,-0x442f4130(%rdi)
  804212154c:	d0 b5 20 d0 b7 d0    	shlb   $1,-0x2f482fe0(%rbp)
  8042121552:	b0 d0                	mov    $0xd0,%al
  8042121554:	ba d1 80 d1 83       	mov    $0x83d180d1,%edx
  8042121559:	d0 b6 d0 b8 d0 bb    	shlb   $1,-0x442f4730(%rsi)
  804212155f:	0a d0                	or     %al,%dl
  8042121561:	92                   	xchg   %eax,%edx
  8042121562:	d0 b5 d1 82 d0 b5    	shlb   $1,-0x4a2f7d2f(%rbp)
  8042121568:	d1 80 20 d0 b2 20    	roll   $1,0x20b2d020(%rax)
  804212156e:	d0 bf d0 be d0 bb    	sarb   $1,-0x442f4130(%rdi)
  8042121574:	d0 b5 20 d0 b7 d0    	shlb   $1,-0x2f482fe0(%rbp)
  804212157a:	b0 d0                	mov    $0xd0,%al
  804212157c:	ba d1 80 d1 83       	mov    $0x83d180d1,%edx
  8042121581:	d0 b6 d0 b8 d0 bb    	shlb   $1,-0x442f4730(%rsi)
  8042121587:	0a d0                	or     %al,%dl
  8042121589:	92                   	xchg   %eax,%edx
  804212158a:	d0 b5 d1 82 d0 b5    	shlb   $1,-0x4a2f7d2f(%rbp)
  8042121590:	d1 80 20 d0 b2 20    	roll   $1,0x20b2d020(%rax)
  8042121596:	d0 bf d0 be d0 bb    	sarb   $1,-0x442f4130(%rdi)
  804212159c:	d0 b5 20 d0 b7 d0    	shlb   $1,-0x2f482fe0(%rbp)
  80421215a2:	b0 d0                	mov    $0xd0,%al
  80421215a4:	ba d1 80 d1 83       	mov    $0x83d180d1,%edx
  80421215a9:	d0 b6 d0 b8 d0 bb    	shlb   $1,-0x442f4730(%rsi)
  80421215af:	0a 0a                	or     (%rdx),%cl
  80421215b1:	20 20                	and    %ah,(%rax)
  80421215b3:	20 20                	and    %ah,(%rax)
  80421215b5:	20 d0                	and    %dl,%al
  80421215b7:	9b                   	fwait
  80421215b8:	d0 be d0 b1 d0 be    	sarb   $1,-0x412f4e30(%rsi)
  80421215be:	d1 82 d0 be d0 bc    	roll   $1,-0x432f4130(%rdx)
  80421215c4:	d0 b8 d1 8f 20 0a    	sarb   $1,0xa208fd1(%rax)
  80421215ca:	0a d0                	or     %al,%dl
  80421215cc:	9f                   	lahf
  80421215cd:	d0 be d0 b7 d0 b4    	sarb   $1,-0x4b2f4830(%rsi)
  80421215d3:	d0 bd d0 b8 d0 b9    	sarb   $1,-0x462f4730(%rbp)
  80421215d9:	20 d0                	and    %dl,%al
  80421215db:	b4 d0                	mov    $0xd0,%ah
  80421215dd:	be d0 b6 d0 b4       	mov    $0xb4d0b6d0,%esi
  80421215e2:	d0 b8 d0 ba 20 d0    	sarb   $1,-0x2fdf4530(%rax)
  80421215e8:	bd d0 b0 d0 bf       	mov    $0xbfd0b0d0,%ebp
  80421215ed:	d1 83 d0 b3 d0 b0    	roll   $1,-0x4f2f4c30(%rbx)
  80421215f3:	d0 bb 0a d0 9f d0    	sarb   $1,-0x2f602ff6(%rbx)
  80421215f9:	be d0 b7 d0 b4       	mov    $0xb4d0b7d0,%esi
  80421215fe:	d0 bd d0 b8 d0 b9    	sarb   $1,-0x462f4730(%rbp)
  8042121604:	20 d0                	and    %dl,%al
  8042121606:	b4 d0                	mov    $0xd0,%ah
  8042121608:	be d0 b6 d0 b4       	mov    $0xb4d0b6d0,%esi
  804212160d:	d0 b8 d0 ba 20 d0    	sarb   $1,-0x2fdf4530(%rax)
  8042121613:	bd d0 b0 d0 bf       	mov    $0xbfd0b0d0,%ebp
  8042121618:	d1 83 d0 b3 d0 b0    	roll   $1,-0x4f2f4c30(%rbx)
  804212161e:	d0 bb 0a d0 9f d0    	sarb   $1,-0x2f602ff6(%rbx)
  8042121624:	be d0 b7 d0 b4       	mov    $0xb4d0b7d0,%esi
  8042121629:	d0 bd d0 b8 d0 b9    	sarb   $1,-0x462f4730(%rbp)
  804212162f:	20 d0                	and    %dl,%al
  8042121631:	b4 d0                	mov    $0xd0,%ah
  8042121633:	be d0 b6 d0 b4       	mov    $0xb4d0b6d0,%esi
  8042121638:	d0 b8 d0 ba 20 d0    	sarb   $1,-0x2fdf4530(%rax)
  804212163e:	bd d0 b0 d0 bf       	mov    $0xbfd0b0d0,%ebp
  8042121643:	d1 83 d0 b3 d0 b0    	roll   $1,-0x4f2f4c30(%rbx)
  8042121649:	d0 bb 0a d0 9f d0    	sarb   $1,-0x2f602ff6(%rbx)
  804212164f:	be d0 b7 d0 b4       	mov    $0xb4d0b7d0,%esi
  8042121654:	d0 bd d0 b8 d0 b9    	sarb   $1,-0x462f4730(%rbp)
  804212165a:	20 d0                	and    %dl,%al
  804212165c:	b4 d0                	mov    $0xd0,%ah
  804212165e:	be d0 b6 d0 b4       	mov    $0xb4d0b6d0,%esi
  8042121663:	d0 b8 d0 ba 20 d0    	sarb   $1,-0x2fdf4530(%rax)
  8042121669:	bd d0 b0 d0 bf       	mov    $0xbfd0b0d0,%ebp
  804212166e:	d1 83 d0 b3 d0 b0    	roll   $1,-0x4f2f4c30(%rbx)
  8042121674:	d0 bb 0a 0a 20 20    	sarb   $1,0x20200a0a(%rbx)
  804212167a:	20 20                	and    %ah,(%rax)
  804212167c:	20 d0                	and    %dl,%al
  804212167e:	9b                   	fwait
  804212167f:	d0 be d0 b1 d0 be    	sarb   $1,-0x412f4e30(%rsi)
  8042121685:	d1 82 d0 be d0 bc    	roll   $1,-0x432f4130(%rdx)
  804212168b:	d0 b8 d1 8f 0a 0a    	sarb   $1,0xa0a8fd1(%rax)
  8042121691:	d0 97 d0 b0 d1 86    	rclb   $1,-0x792e4f30(%rdi)
  8042121697:	d0 b2 d0 b5 d0 bb    	shlb   $1,-0x442f4a30(%rdx)
  804212169d:	d0 b0 20 d0 b2 20    	shlb   $1,0x20b2d020(%rax)
  80421216a3:	d1 81 d0 b0 d0 b4    	roll   $1,-0x4b2f4f30(%rcx)
  80421216a9:	d1 83 20 d1 81 d0    	roll   $1,-0x2f7e2ee0(%rbx)
  80421216af:	b8 d1 80 d0 b5       	mov    $0xb5d080d1,%eax
  80421216b4:	d0 bd d1 8c 0a d0    	sarb   $1,-0x2ff5732f(%rbp)
  80421216ba:	97                   	xchg   %eax,%edi
  80421216bb:	d0 b0 d1 86 d0 b2    	shlb   $1,-0x4d2f792f(%rax)
  80421216c1:	d0 b5 d0 bb d0 b0    	shlb   $1,-0x4f2f4430(%rbp)
  80421216c7:	20 d0                	and    %dl,%al
  80421216c9:	b2 20                	mov    $0x20,%dl
  80421216cb:	d1 81 d0 b0 d0 b4    	roll   $1,-0x4b2f4f30(%rcx)
  80421216d1:	d1 83 20 d1 81 d0    	roll   $1,-0x2f7e2ee0(%rbx)
  80421216d7:	b8 d1 80 d0 b5       	mov    $0xb5d080d1,%eax
  80421216dc:	d0 bd d1 8c 0a d0    	sarb   $1,-0x2ff5732f(%rbp)
  80421216e2:	97                   	xchg   %eax,%edi
  80421216e3:	d0 b0 d1 86 d0 b2    	shlb   $1,-0x4d2f792f(%rax)
  80421216e9:	d0 b5 d0 bb d0 b0    	shlb   $1,-0x4f2f4430(%rbp)
  80421216ef:	20 d0                	and    %dl,%al
  80421216f1:	b2 20                	mov    $0x20,%dl
  80421216f3:	d1 81 d0 b0 d0 b4    	roll   $1,-0x4b2f4f30(%rcx)
  80421216f9:	d1 83 20 d1 81 d0    	roll   $1,-0x2f7e2ee0(%rbx)
  80421216ff:	b8 d1 80 d0 b5       	mov    $0xb5d080d1,%eax
  8042121704:	d0 bd d1 8c 0a d0    	sarb   $1,-0x2ff5732f(%rbp)
  804212170a:	97                   	xchg   %eax,%edi
  804212170b:	d0 b0 d1 86 d0 b2    	shlb   $1,-0x4d2f792f(%rax)
  8042121711:	d0 b5 d0 bb d0 b0    	shlb   $1,-0x4f2f4430(%rbp)
  8042121717:	20 d0                	and    %dl,%al
  8042121719:	b2 20                	mov    $0x20,%dl
  804212171b:	d1 81 d0 b0 d0 b4    	roll   $1,-0x4b2f4f30(%rcx)
  8042121721:	d1 83 20 d1 81 d0    	roll   $1,-0x2f7e2ee0(%rbx)
  8042121727:	b8 d1 80 d0 b5       	mov    $0xb5d080d1,%eax
  804212172c:	d0 bd d1 8c 0a 0a    	sarb   $1,0xa0a8cd1(%rbp)
  8042121732:	20 20                	and    %ah,(%rax)
  8042121734:	20 20                	and    %ah,(%rax)
  8042121736:	20 d0                	and    %dl,%al
  8042121738:	9b                   	fwait
  8042121739:	d0 be d0 b1 d0 be    	sarb   $1,-0x412f4e30(%rsi)
  804212173f:	d1 82 d0 be d0 bc    	roll   $1,-0x432f4130(%rdx)
  8042121745:	d0 b8 d1 8f 0a 0a    	sarb   $1,0xa0a8fd1(%rax)
  804212174b:	00 66 2e             	add    %ah,0x2e(%rsi)
  804212174e:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  8042121755:	00 
  8042121756:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
  804212175d:	00 00 00 

0000008042121760 <charcode>:
  8042121760:	20 32 14 42 80 00 00 00 20 31 14 42 80 00 00 00      2.B.... 1.B....
  8042121770:	20 30 14 42 80 00 00 00 20 30 14 42 80 00 00 00      0.B.... 0.B....

0000008042121780 <togglecode>:
	...
  80421217b8:	00 00 08 00 00 00 00 00 00 00 00 00 00 10 20 00     .............. .
	...

0000008042121880 <shiftcode>:
	...
  804212189c:	00 02 00 00 00 00 00 00 00 00 00 00 00 00 01 00     ................
	...
  80421218b4:	00 00 01 00 04 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  804212191c:	00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  8042121938:	04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  8042121980:	f7 17 10 42 80 00 00 00 b3 0d 10 42 80 00 00 00     ...B.......B....
  8042121990:	f7 17 10 42 80 00 00 00 0a 0e 10 42 80 00 00 00     ...B.......B....
  80421219a0:	65 0e 10 42 80 00 00 00 b9 0e 10 42 80 00 00 00     e..B.......B....
  80421219b0:	0e 0f 10 42 80 00 00 00 63 0f 10 42 80 00 00 00     ...B....c..B....
  80421219c0:	b8 0f 10 42 80 00 00 00 f4 0f 10 42 80 00 00 00     ...B.......B....
  80421219d0:	85 10 10 42 80 00 00 00 da 10 10 42 80 00 00 00     ...B.......B....
  80421219e0:	17 11 10 42 80 00 00 00 57 11 10 42 80 00 00 00     ...B....W..B....
  80421219f0:	fe 11 10 42 80 00 00 00 bc 12 10 42 80 00 00 00     ...B.......B....
  8042121a00:	4b 13 10 42 80 00 00 00 09 14 10 42 80 00 00 00     K..B.......B....
  8042121a10:	46 14 10 42 80 00 00 00 9b 14 10 42 80 00 00 00     F..B.......B....
  8042121a20:	f0 14 10 42 80 00 00 00 45 15 10 42 80 00 00 00     ...B....E..B....
  8042121a30:	d4 15 10 42 80 00 00 00 55 16 10 42 80 00 00 00     ...B....U..B....
  8042121a40:	13 17 10 42 80 00 00 00 99 17 10 42 80 00 00 00     ...B.......B....
  8042121a50:	f7 17 10 42 80 00 00 00 f7 17 10 42 80 00 00 00     ...B.......B....
  8042121a60:	f7 17 10 42 80 00 00 00 f7 17 10 42 80 00 00 00     ...B.......B....
  8042121a70:	f7 17 10 42 80 00 00 00 f7 17 10 42 80 00 00 00     ...B.......B....
  8042121a80:	a8 17 10 42 80 00 00 00 e1 3f 10 42 80 00 00 00     ...B.....?.B....
  8042121a90:	c4 3d 10 42 80 00 00 00 f0 3d 10 42 80 00 00 00     .=.B.....=.B....
  8042121aa0:	53 3e 10 42 80 00 00 00 cf 3e 10 42 80 00 00 00     S>.B.....>.B....
  8042121ab0:	1b 3f 10 42 80 00 00 00 93 40 10 42 80 00 00 00     .?.B.....@.B....
  8042121ac0:	93 40 10 42 80 00 00 00 67 3f 10 42 80 00 00 00     .@.B....g?.B....
  8042121ad0:	7c 3f 10 42 80 00 00 00 93 40 10 42 80 00 00 00     |?.B.....@.B....
  8042121ae0:	93 40 10 42 80 00 00 00 98 3f 10 42 80 00 00 00     .@.B.....?.B....
  8042121af0:	66 2e 0f 1f 84 00 00 00 00 00 66 0f 1f 44 00 00     f.........f..D..

0000008042121b00 <commands>:
  8042121b00:	1b f6 11 42 80 00 00 00 20 f6 11 42 80 00 00 00     ...B.... ..B....
  8042121b10:	5d 42 10 42 80 00 00 00 3e f6 11 42 80 00 00 00     ]B.B....>..B....
  8042121b20:	68 06 12 42 80 00 00 00 ba 42 10 42 80 00 00 00     h..B.....B.B....
  8042121b30:	53 f6 11 42 80 00 00 00 47 f6 11 42 80 00 00 00     S..B....G..B....
  8042121b40:	d4 43 10 42 80 00 00 00 5d f6 11 42 80 00 00 00     .C.B....]..B....
  8042121b50:	66 f6 11 42 80 00 00 00 89 45 10 42 80 00 00 00     f..B.....E.B....
  8042121b60:	7c f6 11 42 80 00 00 00 88 f6 11 42 80 00 00 00     |..B.......B....
  8042121b70:	a4 44 10 42 80 00 00 00 94 f6 11 42 80 00 00 00     .D.B.......B....
  8042121b80:	9f f6 11 42 80 00 00 00 ce 44 10 42 80 00 00 00     ...B.....D.B....
  8042121b90:	aa f6 11 42 80 00 00 00 b5 f6 11 42 80 00 00 00     ...B.......B....
  8042121ba0:	e9 44 10 42 80 00 00 00 c1 02 12 42 80 00 00 00     .D.B.......B....
  8042121bb0:	90 06 12 42 80 00 00 00 13 45 10 42 80 00 00 00     ...B.....E.B....
  8042121bc0:	c9 f6 11 42 80 00 00 00 d3 f6 11 42 80 00 00 00     ...B.......B....
  8042121bd0:	2e 45 10 42 80 00 00 00 ee f6 11 42 80 00 00 00     .E.B.......B....
  8042121be0:	f3 f6 11 42 80 00 00 00 56 45 10 42 80 00 00 00     ...B....VE.B....
  8042121bf0:	66 2e 0f 1f 84 00 00 00 00 00 66 0f 1f 44 00 00     f.........f..D..
  8042121c00:	a0 e0 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     ...B....'..B....
  8042121c10:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121c20:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121c30:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121c40:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121c50:	27 e1 10 42 80 00 00 00 01 df 10 42 80 00 00 00     '..B.......B....
  8042121c60:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121c70:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121c80:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121c90:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121ca0:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121cb0:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121cc0:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121cd0:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121ce0:	27 e1 10 42 80 00 00 00 b4 e0 10 42 80 00 00 00     '..B.......B....
  8042121cf0:	05 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     ...B....'..B....
  8042121d00:	27 e1 10 42 80 00 00 00 16 e1 10 42 80 00 00 00     '..B.......B....
  8042121d10:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121d20:	d9 de 10 42 80 00 00 00 b4 e0 10 42 80 00 00 00     ...B.......B....
  8042121d30:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121d40:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121d50:	27 e1 10 42 80 00 00 00 27 e1 10 42 80 00 00 00     '..B....'..B....
  8042121d60:	27 e1 10 42 80 00 00 00 9d de 10 42 80 00 00 00     '..B.......B....
	...

0000008042121d80 <excnames.0>:
  8042121d80:	ef fc 11 42 80 00 00 00 fc fc 11 42 80 00 00 00     ...B.......B....
  8042121d90:	02 fd 11 42 80 00 00 00 19 fd 11 42 80 00 00 00     ...B.......B....
  8042121da0:	24 fd 11 42 80 00 00 00 2d fd 11 42 80 00 00 00     $..B....-..B....
  8042121db0:	42 fd 11 42 80 00 00 00 51 fd 11 42 80 00 00 00     B..B....Q..B....
  8042121dc0:	66 fd 11 42 80 00 00 00 73 fd 11 42 80 00 00 00     f..B....s..B....
  8042121dd0:	8f fd 11 42 80 00 00 00 9b fd 11 42 80 00 00 00     ...B.......B....
  8042121de0:	af fd 11 42 80 00 00 00 bb fd 11 42 80 00 00 00     ...B.......B....
  8042121df0:	ce fd 11 42 80 00 00 00 69 fb 11 42 80 00 00 00     ...B....i..B....
  8042121e00:	d9 fd 11 42 80 00 00 00 f6 fd 11 42 80 00 00 00     ...B.......B....
  8042121e10:	06 fe 11 42 80 00 00 00 14 fe 11 42 80 00 00 00     ...B.......B....
  8042121e20:	db f2 10 42 80 00 00 00 66 f3 10 42 80 00 00 00     ...B....f..B....
  8042121e30:	87 f3 10 42 80 00 00 00 9a f3 10 42 80 00 00 00     ...B.......B....
  8042121e40:	d0 f3 10 42 80 00 00 00 7a f4 10 42 80 00 00 00     ...B....z..B....
  8042121e50:	b1 f5 10 42 80 00 00 00 4a f5 10 42 80 00 00 00     ...B....J..B....
  8042121e60:	59 f6 10 42 80 00 00 00 ac f6 10 42 80 00 00 00     Y..B.......B....
  8042121e70:	11 f7 10 42 80 00 00 00 57 f7 10 42 80 00 00 00     ...B....W..B....
  8042121e80:	f3 f7 10 42 80 00 00 00 27 f8 10 42 80 00 00 00     ...B....'..B....
  8042121e90:	33 f8 10 42 80 00 00 00 86 f9 10 42 80 00 00 00     3..B.......B....
  8042121ea0:	ea f9 10 42 80 00 00 00 66 2e 0f 1f 84 00 00 00     ...B....f.......
  8042121eb0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00     ..f...........@.
  8042121ec0:	4c 02 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     L..B.......B....
  8042121ed0:	7d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     }..B.......B....
  8042121ee0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121ef0:	8d 08 11 42 80 00 00 00 6b 02 11 42 80 00 00 00     ...B....k..B....
  8042121f00:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121f10:	5f 02 11 42 80 00 00 00 d9 02 11 42 80 00 00 00     _..B.......B....
  8042121f20:	8d 08 11 42 80 00 00 00 5f 02 11 42 80 00 00 00     ...B...._..B....
  8042121f30:	a5 02 11 42 80 00 00 00 a5 02 11 42 80 00 00 00     ...B.......B....
  8042121f40:	a5 02 11 42 80 00 00 00 a5 02 11 42 80 00 00 00     ...B.......B....
  8042121f50:	a5 02 11 42 80 00 00 00 a5 02 11 42 80 00 00 00     ...B.......B....
  8042121f60:	a5 02 11 42 80 00 00 00 a5 02 11 42 80 00 00 00     ...B.......B....
  8042121f70:	a5 02 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121f80:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121f90:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121fa0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121fb0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121fc0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121fd0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121fe0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042121ff0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122000:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122010:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122020:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122030:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122040:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122050:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122060:	8d 08 11 42 80 00 00 00 b0 07 11 42 80 00 00 00     ...B.......B....
  8042122070:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122080:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122090:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  80421220a0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  80421220b0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  80421220c0:	fc 02 11 42 80 00 00 00 cb 04 11 42 80 00 00 00     ...B.......B....
  80421220d0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  80421220e0:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  80421220f0:	2b 03 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     +..B.......B....
  8042122100:	8d 08 11 42 80 00 00 00 f1 02 11 42 80 00 00 00     ...B.......B....
  8042122110:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122120:	73 06 11 42 80 00 00 00 3d 07 11 42 80 00 00 00     s..B....=..B....
  8042122130:	8d 08 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122140:	c2 03 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122150:	9f 05 11 42 80 00 00 00 8d 08 11 42 80 00 00 00     ...B.......B....
  8042122160:	8d 08 11 42 80 00 00 00 b0 07 11 42 80 00 00 00     ...B.......B....
  8042122170:	8d 08 11 42 80 00 00 00 55 02 11 42 80 00 00 00     ...B....U..B....

0000008042122180 <error_string>:
	...
  8042122188:	86 02 12 42 80 00 00 00 98 02 12 42 80 00 00 00     ...B.......B....
  8042122198:	a8 02 12 42 80 00 00 00 ba 02 12 42 80 00 00 00     ...B.......B....
  80421221a8:	c8 02 12 42 80 00 00 00 dc 02 12 42 80 00 00 00     ...B.......B....
  80421221b8:	f1 02 12 42 80 00 00 00 04 03 12 42 80 00 00 00     ...B.......B....
  80421221c8:	16 03 12 42 80 00 00 00 2a 03 12 42 80 00 00 00     ...B....*..B....
  80421221d8:	3a 03 12 42 80 00 00 00 4d 03 12 42 80 00 00 00     :..B....M..B....
  80421221e8:	64 03 12 42 80 00 00 00 7a 03 12 42 80 00 00 00     d..B....z..B....
  80421221f8:	92 03 12 42 80 00 00 00 aa 03 12 42 80 00 00 00     ...B.......B....
  8042122208:	b7 03 12 42 80 00 00 00 b8 14 12 42 80 00 00 00     ...B.......B....
  8042122218:	cb 03 12 42 80 00 00 00                             ...B....

0000008042122220 <dec64table>:
	...
  804212222c:	ff ff ff ff fc ff ff ff 01 00 00 00 02 00 00 00     ................
  804212223c:	03 00 00 00                                         ....

0000008042122240 <inc32table>:
  8042122240:	00 00 00 00 01 00 00 00 02 00 00 00 01 00 00 00     ................
  8042122250:	00 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00     ................
  8042122260:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122270:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122280:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122290:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421222a0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421222b0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421222c0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421222d0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421222e0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421222f0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122300:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122310:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122320:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122330:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122340:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122350:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122360:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122370:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122380:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122390:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421223a0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421223b0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421223c0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421223d0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421223e0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421223f0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122400:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122410:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122420:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122430:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122440:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122450:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122460:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122470:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122480:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122490:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421224a0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421224b0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421224c0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421224d0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421224e0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421224f0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122500:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122510:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122520:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122530:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122540:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122550:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122560:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122570:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122580:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122590:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421225a0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421225b0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421225c0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421225d0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421225e0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421225f0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122600:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122610:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122620:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122630:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122640:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122650:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122660:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122670:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122680:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122690:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421226a0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421226b0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421226c0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421226d0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421226e0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421226f0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122700:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122710:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122720:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122730:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122740:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122750:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122760:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122770:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122780:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122790:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421227a0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421227b0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421227c0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421227d0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421227e0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421227f0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122800:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122810:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122820:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122830:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122840:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122850:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122860:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122870:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122880:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122890:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421228a0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421228b0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421228c0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421228d0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421228e0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421228f0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122900:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122910:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122920:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122930:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122940:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122950:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122960:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122970:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122980:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122990:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421229a0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  80421229b0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  80421229c0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  80421229d0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  80421229e0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  80421229f0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122a00:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122a10:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122a20:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122a30:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122a40:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122a50:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122a60:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122a70:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122a80:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122a90:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122aa0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122ab0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122ac0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122ad0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122ae0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122af0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122b00:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122b10:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122b20:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122b30:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122b40:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122b50:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122b60:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122b70:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122b80:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122b90:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122ba0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122bb0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122bc0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122bd0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122be0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122bf0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122c00:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122c10:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122c20:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122c30:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122c40:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122c50:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122c60:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122c70:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122c80:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122c90:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122ca0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122cb0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122cc0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122cd0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122ce0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122cf0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122d00:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122d10:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122d20:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122d30:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122d40:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122d50:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122d60:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122d70:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122d80:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122d90:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122da0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122db0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122dc0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122dd0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122de0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122df0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122e00:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122e10:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122e20:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122e30:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122e40:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122e50:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122e60:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122e70:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122e80:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122e90:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122ea0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122eb0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122ec0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122ed0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122ee0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122ef0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122f00:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122f10:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122f20:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122f30:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122f40:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122f50:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122f60:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122f70:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122f80:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122f90:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122fa0:	0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00     ........f.......
  8042122fb0:	00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f     ..f.........f...
  8042122fc0:	84 00 00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00     ......f.........
  8042122fd0:	66 2e 0f 1f 84 00 00 00 00 00 66 2e 0f 1f 84 00     f.........f.....
  8042122fe0:	00 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 2e     ....f.........f.
  8042122ff0:	0f 1f 84 00 00 00 00 00 0f 1f 84 00 00 00 00 00     ................
